/** Generated with https://github.com/Gr3q/GIR2TS - If possible do not modify. */
declare namespace imports.gi.Gio {
	/** This construct is only for enabling class multi-inheritance,
	 * use {@link AppInfoMonitor} instead.
	 */
	interface IAppInfoMonitor {

		/**
		 * Signal emitted when the app info database for changes (ie: newly installed
		 * or removed applications).
		 * @param signal 
		 * @param callback Callback function
		 *  - owner: owner of the emitted event 
		 * 
		 * @returns Callback ID
		 */
		connect(signal: "changed", callback: (owner: this) => void): number;

	}

	type AppInfoMonitorInitOptionsMixin = GObject.ObjectInitOptions
	export interface AppInfoMonitorInitOptions extends AppInfoMonitorInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link AppInfoMonitor} instead.
	 */
	type AppInfoMonitorMixin = IAppInfoMonitor & GObject.Object;

	/**
	 * #GAppInfoMonitor is a very simple object used for monitoring the app
	 * info database for changes (ie: newly installed or removed
	 * applications).
	 * 
	 * Call {@link G.app_info_monitor_get} to get a #GAppInfoMonitor and connect
	 * to the "changed" signal.
	 * 
	 * In the usual case, applications should try to make note of the change
	 * (doing things like invalidating caches) but not act on it.  In
	 * particular, applications should avoid making calls to #GAppInfo APIs
	 * in response to the change signal, deferring these until the time that
	 * the data is actually required.  The exception to this case is when
	 * application information is actually being displayed on the screen
	 * (eg: during a search or when the list of all applications is shown).
	 * The reason for this is that changes to the list of installed
	 * applications often come in groups (like during system updates) and
	 * rescanning the list on every change is pointless and expensive.
	 */
	interface AppInfoMonitor extends AppInfoMonitorMixin {}

	class AppInfoMonitor {
		public constructor(options?: Partial<AppInfoMonitorInitOptions>);
		/**
		 * Gets the #GAppInfoMonitor for the current thread-default main
		 * context.
		 * 
		 * The #GAppInfoMonitor will emit a "changed" signal in the
		 * thread-default main context whenever the list of installed
		 * applications (as reported by {@link G.app_info_get_all}) may have changed.
		 * 
		 * You must only call g_object_unref() on the return value from under
		 * the same main context as you created it.
		 * @returns a reference to a #GAppInfoMonitor
		 */
		public static get(): AppInfoMonitor;
	}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link AppLaunchContext} instead.
	 */
	interface IAppLaunchContext {
		/**
		 * Gets the display string for the #context. This is used to ensure new
		 * applications are started on the same display as the launching
		 * application, by setting the `DISPLAY` environment variable.
		 * @param info a #GAppInfo
		 * @param files a #GList of #GFile objects
		 * @returns a display string for the display.
		 */
		get_display(info: AppInfo, files: File[]): string | null;
		/**
		 * Gets the complete environment variable list to be passed to
		 * the child process when #context is used to launch an application.
		 * This is a %NULL-terminated array of strings, where each string has
		 * the form `KEY=VALUE`.
		 * @returns 
		 *     the child's environment
		 */
		get_environment(): string[];
		/**
		 * Initiates startup notification for the application and returns the
		 * `DESKTOP_STARTUP_ID` for the launched operation, if supported.
		 * 
		 * Startup notification IDs are defined in the
		 * [FreeDesktop.Org Startup Notifications standard](http://standards.freedesktop.org/startup-notification-spec/startup-notification-latest.txt).
		 * @param info a #GAppInfo
		 * @param files a #GList of of #GFile objects
		 * @returns a startup notification ID for the application, or %NULL if
		 *     not supported.
		 */
		get_startup_notify_id(info: AppInfo, files: File[]): string | null;
		/**
		 * Called when an application has failed to launch, so that it can cancel
		 * the application startup notification started in {@link G.app_launch_context_get_startup_notify_id}.
		 * @param startup_notify_id the startup notification id that was returned by {@link G.app_launch_context_get_startup_notify_id}.
		 */
		launch_failed(startup_notify_id: string): void;
		/**
		 * Arranges for #variable to be set to #value in the child's
		 * environment when #context is used to launch an application.
		 * @param variable the environment variable to set
		 * @param value the value for to set the variable to.
		 */
		setenv(variable: string, value: string): void;
		/**
		 * Arranges for #variable to be unset in the child's environment
		 * when #context is used to launch an application.
		 * @param variable the environment variable to remove
		 */
		unsetenv(variable: string): void;
		/**
		 * The ::launch-failed signal is emitted when a #GAppInfo launch
		 * fails. The startup notification id is provided, so that the launcher
		 * can cancel the startup notification.
		 * @param signal 
		 * @param callback Callback function
		 *  - owner: owner of the emitted event 
		 *  - startup_notify_id: the startup notification id for the failed launch 
		 * 
		 * @returns Callback ID
		 */
		connect(signal: "launch-failed", callback: (owner: this, startup_notify_id: string) => void): number;
		/**
		 * The ::launched signal is emitted when a #GAppInfo is successfully
		 * launched. The #platform_data is an GVariant dictionary mapping
		 * strings to variants (ie a{sv}), which contains additional,
		 * platform-specific data about this launch. On UNIX, at least the
		 * "pid" and "startup-notification-id" keys will be present.
		 * @param signal 
		 * @param callback Callback function
		 *  - owner: owner of the emitted event 
		 *  - info: the #GAppInfo that was just launched 
		 *  - platform_data: additional platform-specific data for this launch 
		 * 
		 * @returns Callback ID
		 */
		connect(signal: "launched", callback: (owner: this, info: AppInfo, platform_data: GLib.Variant) => void): number;

	}

	type AppLaunchContextInitOptionsMixin = GObject.ObjectInitOptions
	export interface AppLaunchContextInitOptions extends AppLaunchContextInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link AppLaunchContext} instead.
	 */
	type AppLaunchContextMixin = IAppLaunchContext & GObject.Object;

	/**
	 * Integrating the launch with the launching application. This is used to
	 * handle for instance startup notification and launching the new application
	 * on the same screen as the launching window.
	 */
	interface AppLaunchContext extends AppLaunchContextMixin {}

	class AppLaunchContext {
		public constructor(options?: Partial<AppLaunchContextInitOptions>);
		/**
		 * Creates a new application launch context. This is not normally used,
		 * instead you instantiate a subclass of this, such as #GdkAppLaunchContext.
		 * @returns a #GAppLaunchContext.
		 */
		public static new(): AppLaunchContext;
	}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link Application} instead.
	 */
	interface IApplication {
		application_id: string;
		flags: ApplicationFlags;
		inactivity_timeout: number;
		/**
		 * Whether the application is currently marked as busy through
		 * {@link G.application_mark_busy} or g_application_bind_busy_property().
		 */
		readonly is_busy: boolean;
		readonly is_registered: boolean;
		readonly is_remote: boolean;
		resource_base_path: string;
		/**
		 * Activates the application.
		 * 
		 * In essence, this results in the #GApplication::activate signal being
		 * emitted in the primary instance.
		 * 
		 * The application must be registered before calling this function.
		 */
		activate(): void;
		/**
		 * Add an option to be handled by #application.
		 * 
		 * Calling this function is the equivalent of calling
		 * {@link G.application_add_main_option_entries} with a single #GOptionEntry
		 * that has its arg_data member set to %NULL.
		 * 
		 * The parsed arguments will be packed into a #GVariantDict which
		 * is passed to #GApplication::handle-local-options. If
		 * %G_APPLICATION_HANDLES_COMMAND_LINE is set, then it will also
		 * be sent to the primary instance. See
		 * g_application_add_main_option_entries() for more details.
		 * 
		 * See #GOptionEntry for more documentation of the arguments.
		 * @param long_name the long name of an option used to specify it in a commandline
		 * @param short_name the short name of an option
		 * @param flags flags from #GOptionFlags
		 * @param arg the type of the option, as a #GOptionArg
		 * @param description the description for the option in `--help` output
		 * @param arg_description the placeholder to use for the extra argument
		 *    parsed by the option in `--help` output
		 */
		add_main_option(long_name: string, short_name: string, flags: GLib.OptionFlags, arg: GLib.OptionArg, description: string, arg_description?: string | null): void;
		/**
		 * Adds main option entries to be handled by #application.
		 * 
		 * This function is comparable to {@link G.option_context_add_main_entries}.
		 * 
		 * After the commandline arguments are parsed, the
		 * #GApplication::handle-local-options signal will be emitted.  At this
		 * point, the application can inspect the values pointed to by #arg_data
		 * in the given #GOptionEntrys.
		 * 
		 * Unlike #GOptionContext, #GApplication supports giving a %NULL
		 * #arg_data for a non-callback #GOptionEntry.  This results in the
		 * argument in question being packed into a #GVariantDict which is also
		 * passed to #GApplication::handle-local-options, where it can be
		 * inspected and modified.  If %G_APPLICATION_HANDLES_COMMAND_LINE is
		 * set, then the resulting dictionary is sent to the primary instance,
		 * where g_application_command_line_get_options_dict() will return it.
		 * This "packing" is done according to the type of the argument --
		 * booleans for normal flags, strings for strings, bytestrings for
		 * filenames, etc.  The packing only occurs if the flag is given (ie: we
		 * do not pack a "false" #GVariant in the case that a flag is missing).
		 * 
		 * In general, it is recommended that all commandline arguments are
		 * parsed locally.  The options dictionary should then be used to
		 * transmit the result of the parsing to the primary instance, where
		 * g_variant_dict_lookup() can be used.  For local options, it is
		 * possible to either use #arg_data in the usual way, or to consult (and
		 * potentially remove) the option from the options dictionary.
		 * 
		 * This function is new in GLib 2.40.  Before then, the only real choice
		 * was to send all of the commandline arguments (options and all) to the
		 * primary instance for handling.  #GApplication ignored them completely
		 * on the local side.  Calling this function "opts in" to the new
		 * behaviour, and in particular, means that unrecognised options will be
		 * treated as errors.  Unrecognised options have never been ignored when
		 * %G_APPLICATION_HANDLES_COMMAND_LINE is unset.
		 * 
		 * If #GApplication::handle-local-options needs to see the list of
		 * filenames, then the use of %G_OPTION_REMAINING is recommended.  If
		 * #arg_data is %NULL then %G_OPTION_REMAINING can be used as a key into
		 * the options dictionary.  If you do use %G_OPTION_REMAINING then you
		 * need to handle these arguments for yourself because once they are
		 * consumed, they will no longer be visible to the default handling
		 * (which treats them as filenames to be opened).
		 * 
		 * It is important to use the proper GVariant format when retrieving
		 * the options with g_variant_dict_lookup():
		 * - for %G_OPTION_ARG_NONE, use `b`
		 * - for %G_OPTION_ARG_STRING, use `&s`
		 * - for %G_OPTION_ARG_INT, use `i`
		 * - for %G_OPTION_ARG_INT64, use `x`
		 * - for %G_OPTION_ARG_DOUBLE, use `d`
		 * - for %G_OPTION_ARG_FILENAME, use `^&ay`
		 * - for %G_OPTION_ARG_STRING_ARRAY, use `^a&s`
		 * - for %G_OPTION_ARG_FILENAME_ARRAY, use `^a&ay`
		 * @param entries a
		 *           %NULL-terminated list of #GOptionEntrys
		 */
		add_main_option_entries(entries: GLib.OptionEntry[]): void;
		/**
		 * Adds a #GOptionGroup to the commandline handling of #application.
		 * 
		 * This function is comparable to {@link G.option_context_add_group}.
		 * 
		 * Unlike g_application_add_main_option_entries(), this function does
		 * not deal with %NULL #arg_data and never transmits options to the
		 * primary instance.
		 * 
		 * The reason for that is because, by the time the options arrive at the
		 * primary instance, it is typically too late to do anything with them.
		 * Taking the GTK option group as an example: GTK will already have been
		 * initialised by the time the #GApplication::command-line handler runs.
		 * In the case that this is not the first-running instance of the
		 * application, the existing instance may already have been running for
		 * a very long time.
		 * 
		 * This means that the options from #GOptionGroup are only really usable
		 * in the case that the instance of the application being run is the
		 * first instance.  Passing options like `--display=` or `--gdk-debug=`
		 * on future runs will have no effect on the existing primary instance.
		 * 
		 * Calling this function will cause the options in the supplied option
		 * group to be parsed, but it does not cause you to be "opted in" to the
		 * new functionality whereby unrecognised options are rejected even if
		 * %G_APPLICATION_HANDLES_COMMAND_LINE was given.
		 * @param group a #GOptionGroup
		 */
		add_option_group(group: GLib.OptionGroup): void;
		/**
		 * Marks #application as busy (see {@link G.application_mark_busy}) while
		 * #property on #object is %TRUE.
		 * 
		 * The binding holds a reference to #application while it is active, but
		 * not to #object. Instead, the binding is destroyed when #object is
		 * finalized.
		 * @param object a #GObject
		 * @param property the name of a boolean property of #object
		 */
		bind_busy_property(object: GObject.Object, property: string): void;
		/**
		 * Gets the unique identifier for #application.
		 * @returns the identifier for #application, owned by #application
		 */
		get_application_id(): string | null;
		/**
		 * Gets the #GDBusConnection being used by the application, or %NULL.
		 * 
		 * If #GApplication is using its D-Bus backend then this function will
		 * return the #GDBusConnection being used for uniqueness and
		 * communication with the desktop environment and other instances of the
		 * application.
		 * 
		 * If #GApplication is not using D-Bus then this function will return
		 * %NULL.  This includes the situation where the D-Bus backend would
		 * normally be in use but we were unable to connect to the bus.
		 * 
		 * This function must not be called before the application has been
		 * registered.  See {@link G.application_get_is_registered}.
		 * @returns a #GDBusConnection, or %NULL
		 */
		get_dbus_connection(): DBusConnection | null;
		/**
		 * Gets the D-Bus object path being used by the application, or %NULL.
		 * 
		 * If #GApplication is using its D-Bus backend then this function will
		 * return the D-Bus object path that #GApplication is using.  If the
		 * application is the primary instance then there is an object published
		 * at this path.  If the application is not the primary instance then
		 * the result of this function is undefined.
		 * 
		 * If #GApplication is not using D-Bus then this function will return
		 * %NULL.  This includes the situation where the D-Bus backend would
		 * normally be in use but we were unable to connect to the bus.
		 * 
		 * This function must not be called before the application has been
		 * registered.  See {@link G.application_get_is_registered}.
		 * @returns the object path, or %NULL
		 */
		get_dbus_object_path(): string | null;
		/**
		 * Gets the flags for #application.
		 * 
		 * See #GApplicationFlags.
		 * @returns the flags for #application
		 */
		get_flags(): ApplicationFlags;
		/**
		 * Gets the current inactivity timeout for the application.
		 * 
		 * This is the amount of time (in milliseconds) after the last call to
		 * {@link G.application_release} before the application stops running.
		 * @returns the timeout, in milliseconds
		 */
		get_inactivity_timeout(): number;
		/**
		 * Gets the application's current busy state, as set through
		 * {@link G.application_mark_busy} or g_application_bind_busy_property().
		 * @returns %TRUE if #application is currently marked as busy
		 */
		get_is_busy(): boolean;
		/**
		 * Checks if #application is registered.
		 * 
		 * An application is registered if {@link G.application_register} has been
		 * successfully called.
		 * @returns %TRUE if #application is registered
		 */
		get_is_registered(): boolean;
		/**
		 * Checks if #application is remote.
		 * 
		 * If #application is remote then it means that another instance of
		 * application already exists (the 'primary' instance).  Calls to
		 * perform actions on #application will result in the actions being
		 * performed by the primary instance.
		 * 
		 * The value of this property cannot be accessed before
		 * {@link G.application_register} has been called.  See
		 * g_application_get_is_registered().
		 * @returns %TRUE if #application is remote
		 */
		get_is_remote(): boolean;
		/**
		 * Gets the resource base path of #application.
		 * 
		 * See {@link G.application_set_resource_base_path} for more information.
		 * @returns the base resource path, if one is set
		 */
		get_resource_base_path(): string | null;
		/**
		 * Increases the use count of #application.
		 * 
		 * Use this function to indicate that the application has a reason to
		 * continue to run.  For example, {@link G.application_hold} is called by GTK+
		 * when a toplevel window is on the screen.
		 * 
		 * To cancel the hold, call g_application_release().
		 */
		hold(): void;
		/**
		 * Increases the busy count of #application.
		 * 
		 * Use this function to indicate that the application is busy, for instance
		 * while a long running operation is pending.
		 * 
		 * The busy state will be exposed to other processes, so a session shell will
		 * use that information to indicate the state to the user (e.g. with a
		 * spinner).
		 * 
		 * To cancel the busy indication, use {@link G.application_unmark_busy}.
		 * 
		 * The application must be registered before calling this function.
		 */
		mark_busy(): void;
		/**
		 * Opens the given files.
		 * 
		 * In essence, this results in the #GApplication::open signal being emitted
		 * in the primary instance.
		 * 
		 * #n_files must be greater than zero.
		 * 
		 * #hint is simply passed through to the ::open signal.  It is
		 * intended to be used by applications that have multiple modes for
		 * opening files (eg: "view" vs "edit", etc).  Unless you have a need
		 * for this functionality, you should use "".
		 * 
		 * The application must be registered before calling this function
		 * and it must have the %G_APPLICATION_HANDLES_OPEN flag set.
		 * @param files an array of #GFiles to open
		 * @param hint a hint (or ""), but never %NULL
		 */
		open(files: File[], hint: string): void;
		/**
		 * Immediately quits the application.
		 * 
		 * Upon return to the mainloop, {@link G.application_run} will return,
		 * calling only the 'shutdown' function before doing so.
		 * 
		 * The hold count is ignored.
		 * Take care if your code has called g_application_hold() on the application and
		 * is therefore still expecting it to exist.
		 * (Note that you may have called g_application_hold() indirectly, for example
		 * through gtk_application_add_window().)
		 * 
		 * The result of calling g_application_run() again after it returns is
		 * unspecified.
		 */
		quit(): void;
		/**
		 * Attempts registration of the application.
		 * 
		 * This is the point at which the application discovers if it is the
		 * primary instance or merely acting as a remote for an already-existing
		 * primary instance.  This is implemented by attempting to acquire the
		 * application identifier as a unique bus name on the session bus using
		 * GDBus.
		 * 
		 * If there is no application ID or if %G_APPLICATION_NON_UNIQUE was
		 * given, then this process will always become the primary instance.
		 * 
		 * Due to the internal architecture of GDBus, method calls can be
		 * dispatched at any time (even if a main loop is not running).  For
		 * this reason, you must ensure that any object paths that you wish to
		 * register are registered before calling this function.
		 * 
		 * If the application has already been registered then %TRUE is
		 * returned with no work performed.
		 * 
		 * The #GApplication::startup signal is emitted if registration succeeds
		 * and #application is the primary instance (including the non-unique
		 * case).
		 * 
		 * In the event of an error (such as #cancellable being cancelled, or a
		 * failure to connect to the session bus), %FALSE is returned and #error
		 * is set appropriately.
		 * 
		 * Note: the return value of this function is not an indicator that this
		 * instance is or is not the primary instance of the application.  See
		 * {@link G.application_get_is_remote} for that.
		 * @param cancellable a #GCancellable, or %NULL
		 * @returns %TRUE if registration succeeded
		 */
		register(cancellable?: Cancellable | null): boolean;
		/**
		 * Decrease the use count of #application.
		 * 
		 * When the use count reaches zero, the application will stop running.
		 * 
		 * Never call this function except to cancel the effect of a previous
		 * call to {@link G.application_hold}.
		 */
		release(): void;
		/**
		 * Runs the application.
		 * 
		 * This function is intended to be run from main() and its return value
		 * is intended to be returned by main(). Although you are expected to pass
		 * the #argc, #argv parameters from main() to this function, it is possible
		 * to pass %NULL if #argv is not available or commandline handling is not
		 * required.  Note that on Windows, #argc and #argv are ignored, and
		 * g_win32_get_command_line() is called internally (for proper support
		 * of Unicode commandline arguments).
		 * 
		 * #GApplication will attempt to parse the commandline arguments.  You
		 * can add commandline flags to the list of recognised options by way of
		 * g_application_add_main_option_entries().  After this, the
		 * #GApplication::handle-local-options signal is emitted, from which the
		 * application can inspect the values of its #GOptionEntrys.
		 * 
		 * #GApplication::handle-local-options is a good place to handle options
		 * such as `--version`, where an immediate reply from the local process is
		 * desired (instead of communicating with an already-running instance).
		 * A #GApplication::handle-local-options handler can stop further processing
		 * by returning a non-negative value, which then becomes the exit status of
		 * the process.
		 * 
		 * What happens next depends on the flags: if
		 * %G_APPLICATION_HANDLES_COMMAND_LINE was specified then the remaining
		 * commandline arguments are sent to the primary instance, where a
		 * #GApplication::command-line signal is emitted.  Otherwise, the
		 * remaining commandline arguments are assumed to be a list of files.
		 * If there are no files listed, the application is activated via the
		 * #GApplication::activate signal.  If there are one or more files, and
		 * %G_APPLICATION_HANDLES_OPEN was specified then the files are opened
		 * via the #GApplication::open signal.
		 * 
		 * If you are interested in doing more complicated local handling of the
		 * commandline then you should implement your own #GApplication subclass
		 * and override local_command_line(). In this case, you most likely want
		 * to return %TRUE from your local_command_line() implementation to
		 * suppress the default handling. See
		 * [gapplication-example-cmdline2.c][https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gapplication-example-cmdline2.c]
		 * for an example.
		 * 
		 * If, after the above is done, the use count of the application is zero
		 * then the exit status is returned immediately.  If the use count is
		 * non-zero then the default main context is iterated until the use count
		 * falls to zero, at which point 0 is returned.
		 * 
		 * If the %G_APPLICATION_IS_SERVICE flag is set, then the service will
		 * run for as much as 10 seconds with a use count of zero while waiting
		 * for the message that caused the activation to arrive.  After that,
		 * if the use count falls to zero the application will exit immediately,
		 * except in the case that g_application_set_inactivity_timeout() is in
		 * use.
		 * 
		 * This function sets the prgname (g_set_prgname()), if not already set,
		 * to the basename of argv[0].
		 * 
		 * Much like g_main_loop_run(), this function will acquire the main context
		 * for the duration that the application is running.
		 * 
		 * Since 2.40, applications that are not explicitly flagged as services
		 * or launchers (ie: neither %G_APPLICATION_IS_SERVICE or
		 * %G_APPLICATION_IS_LAUNCHER are given as flags) will check (from the
		 * default handler for local_command_line) if "--gapplication-service"
		 * was given in the command line.  If this flag is present then normal
		 * commandline processing is interrupted and the
		 * %G_APPLICATION_IS_SERVICE flag is set.  This provides a "compromise"
		 * solution whereby running an application directly from the commandline
		 * will invoke it in the normal way (which can be useful for debugging)
		 * while still allowing applications to be D-Bus activated in service
		 * mode.  The D-Bus service file should invoke the executable with
		 * "--gapplication-service" as the sole commandline argument.  This
		 * approach is suitable for use by most graphical applications but
		 * should not be used from applications like editors that need precise
		 * control over when processes invoked via the commandline will exit and
		 * what their exit status will be.
		 * @param argv 
		 *     the argv from main(), or %NULL
		 * @returns the exit status
		 */
		run(argv?: string[] | null): number;
		/**
		 * Sends a notification on behalf of #application to the desktop shell.
		 * There is no guarantee that the notification is displayed immediately,
		 * or even at all.
		 * 
		 * Notifications may persist after the application exits. It will be
		 * D-Bus-activated when the notification or one of its actions is
		 * activated.
		 * 
		 * Modifying #notification after this call has no effect. However, the
		 * object can be reused for a later call to this function.
		 * 
		 * #id may be any string that uniquely identifies the event for the
		 * application. It does not need to be in any special format. For
		 * example, "new-message" might be appropriate for a notification about
		 * new messages.
		 * 
		 * If a previous notification was sent with the same #id, it will be
		 * replaced with #notification and shown again as if it was a new
		 * notification. This works even for notifications sent from a previous
		 * execution of the application, as long as #id is the same string.
		 * 
		 * #id may be %NULL, but it is impossible to replace or withdraw
		 * notifications without an id.
		 * 
		 * If #notification is no longer relevant, it can be withdrawn with
		 * {@link G.application_withdraw_notification}.
		 * @param id id of the notification, or %NULL
		 * @param notification the #GNotification to send
		 */
		send_notification(id: string | null, notification: Notification): void;
		/**
		 * @deprecated
		 * Use the #GActionMap interface instead.  Never ever
		 * mix use of this API with use of #GActionMap on the same #application
		 * or things will go very badly wrong.  This function is known to
		 * introduce buggy behaviour (ie: signals not emitted on changes to the
		 * action group), so you should really use #GActionMap instead.
		 * 
		 * This used to be how actions were associated with a #GApplication.
		 * Now there is #GActionMap for that.
		 * @param action_group a #GActionGroup, or %NULL
		 */
		set_action_group(action_group?: ActionGroup | null): void;
		/**
		 * Sets the unique identifier for #application.
		 * 
		 * The application id can only be modified if #application has not yet
		 * been registered.
		 * 
		 * If non-%NULL, the application id must be valid.  See
		 * {@link G.application_id_is_valid}.
		 * @param application_id the identifier for #application
		 */
		set_application_id(application_id?: string | null): void;
		/**
		 * Sets or unsets the default application for the process, as returned
		 * by {@link G.application_get_default}.
		 * 
		 * This function does not take its own reference on #application.  If
		 * #application is destroyed then the default application will revert
		 * back to %NULL.
		 */
		set_default(): void;
		/**
		 * Sets the flags for #application.
		 * 
		 * The flags can only be modified if #application has not yet been
		 * registered.
		 * 
		 * See #GApplicationFlags.
		 * @param flags the flags for #application
		 */
		set_flags(flags: ApplicationFlags): void;
		/**
		 * Sets the current inactivity timeout for the application.
		 * 
		 * This is the amount of time (in milliseconds) after the last call to
		 * {@link G.application_release} before the application stops running.
		 * 
		 * This call has no side effects of its own.  The value set here is only
		 * used for next time g_application_release() drops the use count to
		 * zero.  Any timeouts currently in progress are not impacted.
		 * @param inactivity_timeout the timeout, in milliseconds
		 */
		set_inactivity_timeout(inactivity_timeout: number): void;
		/**
		 * Adds a description to the #application option context.
		 * 
		 * See {@link G.option_context_set_description} for more information.
		 * @param description a string to be shown in `--help` output
		 *  after the list of options, or %NULL
		 */
		set_option_context_description(description?: string | null): void;
		/**
		 * Sets the parameter string to be used by the commandline handling of #application.
		 * 
		 * This function registers the argument to be passed to {@link G.option_context_new}
		 * when the internal #GOptionContext of #application is created.
		 * 
		 * See g_option_context_new() for more information about #parameter_string.
		 * @param parameter_string a string which is displayed
		 *   in the first line of `--help` output, after the usage summary `programname [OPTION...]`.
		 */
		set_option_context_parameter_string(parameter_string?: string | null): void;
		/**
		 * Adds a summary to the #application option context.
		 * 
		 * See {@link G.option_context_set_summary} for more information.
		 * @param summary a string to be shown in `--help` output
		 *  before the list of options, or %NULL
		 */
		set_option_context_summary(summary?: string | null): void;
		/**
		 * Sets (or unsets) the base resource path of #application.
		 * 
		 * The path is used to automatically load various [application
		 * resources][gresource] such as menu layouts and action descriptions.
		 * The various types of resources will be found at fixed names relative
		 * to the given base path.
		 * 
		 * By default, the resource base path is determined from the application
		 * ID by prefixing '/' and replacing each '.' with '/'.  This is done at
		 * the time that the #GApplication object is constructed.  Changes to
		 * the application ID after that point will not have an impact on the
		 * resource base path.
		 * 
		 * As an example, if the application has an ID of "org.example.app" then
		 * the default resource base path will be "/org/example/app".  If this
		 * is a #GtkApplication (and you have not manually changed the path)
		 * then Gtk will then search for the menus of the application at
		 * "/org/example/app/gtk/menus.ui".
		 * 
		 * See #GResource for more information about adding resources to your
		 * application.
		 * 
		 * You can disable automatic resource loading functionality by setting
		 * the path to %NULL.
		 * 
		 * Changing the resource base path once the application is running is
		 * not recommended.  The point at which the resource path is consulted
		 * for forming paths for various purposes is unspecified.  When writing
		 * a sub-class of #GApplication you should either set the
		 * #GApplication:resource-base-path property at construction time, or call
		 * this function during the instance initialization. Alternatively, you
		 * can call this function in the #GApplicationClass.startup virtual function,
		 * before chaining up to the parent implementation.
		 * @param resource_path the resource path to use
		 */
		set_resource_base_path(resource_path?: string | null): void;
		/**
		 * Destroys a binding between #property and the busy state of
		 * #application that was previously created with
		 * {@link G.application_bind_busy_property}.
		 * @param object a #GObject
		 * @param property the name of a boolean property of #object
		 */
		unbind_busy_property(object: GObject.Object, property: string): void;
		/**
		 * Decreases the busy count of #application.
		 * 
		 * When the busy count reaches zero, the new state will be propagated
		 * to other processes.
		 * 
		 * This function must only be called to cancel the effect of a previous
		 * call to {@link G.application_mark_busy}.
		 */
		unmark_busy(): void;
		/**
		 * Withdraws a notification that was sent with
		 * {@link G.application_send_notification}.
		 * 
		 * This call does nothing if a notification with #id doesn't exist or
		 * the notification was never sent.
		 * 
		 * This function works even for notifications sent in previous
		 * executions of this application, as long #id is the same as it was for
		 * the sent notification.
		 * 
		 * Note that notifications are dismissed when the user clicks on one
		 * of the buttons in a notification or triggers its default action, so
		 * there is no need to explicitly withdraw the notification in that case.
		 * @param id id of a previously sent notification
		 */
		withdraw_notification(id: string): void;
		/**
		 * The ::activate signal is emitted on the primary instance when an
		 * activation occurs. See {@link G.application_activate}.
		 * @param signal 
		 * @param callback Callback function
		 *  - owner: owner of the emitted event 
		 * 
		 * @returns Callback ID
		 */
		connect(signal: "activate", callback: (owner: this) => void): number;
		/**
		 * The ::command-line signal is emitted on the primary instance when
		 * a commandline is not handled locally. See {@link G.application_run} and
		 * the #GApplicationCommandLine documentation for more information.
		 * @param signal 
		 * @param callback Callback function
		 *  - owner: owner of the emitted event 
		 *  - command_line: a #GApplicationCommandLine representing the
		 *     passed commandline 
		 *  - returns An integer that is set as the exit status for the calling
		 *   process. See {@link G.application_command_line_set_exit_status}. 
		 * 
		 * @returns Callback ID
		 */
		connect(signal: "command-line", callback: (owner: this, command_line: ApplicationCommandLine) => number): number;
		/**
		 * The ::handle-local-options signal is emitted on the local instance
		 * after the parsing of the commandline options has occurred.
		 * 
		 * You can add options to be recognised during commandline option
		 * parsing using {@link G.application_add_main_option_entries} and
		 * g_application_add_option_group().
		 * 
		 * Signal handlers can inspect #options (along with values pointed to
		 * from the #arg_data of an installed #GOptionEntrys) in order to
		 * decide to perform certain actions, including direct local handling
		 * (which may be useful for options like --version).
		 * 
		 * In the event that the application is marked
		 * %G_APPLICATION_HANDLES_COMMAND_LINE the "normal processing" will
		 * send the #options dictionary to the primary instance where it can be
		 * read with g_application_command_line_get_options_dict().  The signal
		 * handler can modify the dictionary before returning, and the
		 * modified dictionary will be sent.
		 * 
		 * In the event that %G_APPLICATION_HANDLES_COMMAND_LINE is not set,
		 * "normal processing" will treat the remaining uncollected command
		 * line arguments as filenames or URIs.  If there are no arguments,
		 * the application is activated by g_application_activate().  One or
		 * more arguments results in a call to g_application_open().
		 * 
		 * If you want to handle the local commandline arguments for yourself
		 * by converting them to calls to g_application_open() or
		 * g_action_group_activate_action() then you must be sure to register
		 * the application first.  You should probably not call
		 * g_application_activate() for yourself, however: just return -1 and
		 * allow the default handler to do it for you.  This will ensure that
		 * the `--gapplication-service` switch works properly (i.e. no activation
		 * in that case).
		 * 
		 * Note that this signal is emitted from the default implementation of
		 * local_command_line().  If you override that function and don't
		 * chain up then this signal will never be emitted.
		 * 
		 * You can override local_command_line() if you need more powerful
		 * capabilities than what is provided here, but this should not
		 * normally be required.
		 * @param signal 
		 * @param callback Callback function
		 *  - owner: owner of the emitted event 
		 *  - options: the options dictionary 
		 *  - returns an exit code. If you have handled your options and want
		 * to exit the process, return a non-negative option, 0 for success,
		 * and a positive value for failure. To continue, return -1 to let
		 * the default option processing continue. 
		 * 
		 * @returns Callback ID
		 */
		connect(signal: "handle-local-options", callback: (owner: this, options: GLib.VariantDict) => number): number;
		/**
		 * The ::name-lost signal is emitted only on the registered primary instance
		 * when a new instance has taken over. This can only happen if the application
		 * is using the %G_APPLICATION_ALLOW_REPLACEMENT flag.
		 * 
		 * The default handler for this signal calls {@link G.application_quit}.
		 * @param signal 
		 * @param callback Callback function
		 *  - owner: owner of the emitted event 
		 *  - returns %TRUE if the signal has been handled 
		 * 
		 * @returns Callback ID
		 */
		connect(signal: "name-lost", callback: (owner: this) => boolean): number;
		/**
		 * The ::open signal is emitted on the primary instance when there are
		 * files to open. See {@link G.application_open} for more information.
		 * @param signal 
		 * @param callback Callback function
		 *  - owner: owner of the emitted event 
		 *  - files: an array of #GFiles 
		 *  - hint: a hint provided by the calling instance 
		 * 
		 * @returns Callback ID
		 */
		connect(signal: "open", callback: (owner: this, files: File[], hint: string) => void): number;
		/**
		 * The ::shutdown signal is emitted only on the registered primary instance
		 * immediately after the main loop terminates.
		 * @param signal 
		 * @param callback Callback function
		 *  - owner: owner of the emitted event 
		 * 
		 * @returns Callback ID
		 */
		connect(signal: "shutdown", callback: (owner: this) => void): number;
		/**
		 * The ::startup signal is emitted on the primary instance immediately
		 * after registration. See {@link G.application_register}.
		 * @param signal 
		 * @param callback Callback function
		 *  - owner: owner of the emitted event 
		 * 
		 * @returns Callback ID
		 */
		connect(signal: "startup", callback: (owner: this) => void): number;

		connect(signal: "notify::application-id", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::flags", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::inactivity-timeout", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::is-busy", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::is-registered", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::is-remote", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::resource-base-path", callback: (owner: this, ...args: any) => void): number;

	}

	type ApplicationInitOptionsMixin = GObject.ObjectInitOptions & ActionGroupInitOptions & ActionMapInitOptions & 
	Pick<IApplication,
		"application_id" |
		"flags" |
		"inactivity_timeout" |
		"resource_base_path">;

	export interface ApplicationInitOptions extends ApplicationInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link Application} instead.
	 */
	type ApplicationMixin = IApplication & GObject.Object & ActionGroup & ActionMap;

	/**
	 * A #GApplication is the foundation of an application.  It wraps some
	 * low-level platform-specific services and is intended to act as the
	 * foundation for higher-level application classes such as
	 * #GtkApplication or #MxApplication.  In general, you should not use
	 * this class outside of a higher level framework.
	 * 
	 * GApplication provides convenient life cycle management by maintaining
	 * a "use count" for the primary application instance. The use count can
	 * be changed using {@link G.application_hold} and g_application_release(). If
	 * it drops to zero, the application exits. Higher-level classes such as
	 * #GtkApplication employ the use count to ensure that the application
	 * stays alive as long as it has any opened windows.
	 * 
	 * Another feature that GApplication (optionally) provides is process
	 * uniqueness. Applications can make use of this functionality by
	 * providing a unique application ID. If given, only one application
	 * with this ID can be running at a time per session. The session
	 * concept is platform-dependent, but corresponds roughly to a graphical
	 * desktop login. When your application is launched again, its
	 * arguments are passed through platform communication to the already
	 * running program. The already running instance of the program is
	 * called the "primary instance"; for non-unique applications this is
	 * always the current instance. On Linux, the D-Bus session bus
	 * is used for communication.
	 * 
	 * The use of #GApplication differs from some other commonly-used
	 * uniqueness libraries (such as libunique) in important ways. The
	 * application is not expected to manually register itself and check
	 * if it is the primary instance. Instead, the main() function of a
	 * #GApplication should do very little more than instantiating the
	 * application instance, possibly connecting signal handlers, then
	 * calling g_application_run(). All checks for uniqueness are done
	 * internally. If the application is the primary instance then the
	 * startup signal is emitted and the mainloop runs. If the application
	 * is not the primary instance then a signal is sent to the primary
	 * instance and g_application_run() promptly returns. See the code
	 * examples below.
	 * 
	 * If used, the expected form of an application identifier is the same as
	 * that of of a
	 * [D-Bus well-known bus name](https://dbus.freedesktop.org/doc/dbus-specification.html#message-protocol-names-bus).
	 * Examples include: `com.example.MyApp`, `org.example.internal_apps.Calculator`,
	 * `org._7_zip.Archiver`.
	 * For details on valid application identifiers, see g_application_id_is_valid().
	 * 
	 * On Linux, the application identifier is claimed as a well-known bus name
	 * on the user's session bus.  This means that the uniqueness of your
	 * application is scoped to the current session.  It also means that your
	 * application may provide additional services (through registration of other
	 * object paths) at that bus name.  The registration of these object paths
	 * should be done with the shared GDBus session bus.  Note that due to the
	 * internal architecture of GDBus, method calls can be dispatched at any time
	 * (even if a main loop is not running).  For this reason, you must ensure that
	 * any object paths that you wish to register are registered before #GApplication
	 * attempts to acquire the bus name of your application (which happens in
	 * g_application_register()).  Unfortunately, this means that you cannot use
	 * g_application_get_is_remote() to decide if you want to register object paths.
	 * 
	 * GApplication also implements the #GActionGroup and #GActionMap
	 * interfaces and lets you easily export actions by adding them with
	 * g_action_map_add_action(). When invoking an action by calling
	 * g_action_group_activate_action() on the application, it is always
	 * invoked in the primary instance. The actions are also exported on
	 * the session bus, and GIO provides the #GDBusActionGroup wrapper to
	 * conveniently access them remotely. GIO provides a #GDBusMenuModel wrapper
	 * for remote access to exported #GMenuModels.
	 * 
	 * There is a number of different entry points into a GApplication:
	 * 
	 * - via 'Activate' (i.e. just starting the application)
	 * 
	 * - via 'Open' (i.e. opening some files)
	 * 
	 * - by handling a command-line
	 * 
	 * - via activating an action
	 * 
	 * The #GApplication::startup signal lets you handle the application
	 * initialization for all of these in a single place.
	 * 
	 * Regardless of which of these entry points is used to start the
	 * application, GApplication passes some ‘platform data’ from the
	 * launching instance to the primary instance, in the form of a
	 * #GVariant dictionary mapping strings to variants. To use platform
	 * data, override the #before_emit or #after_emit virtual functions
	 * in your #GApplication subclass. When dealing with
	 * #GApplicationCommandLine objects, the platform data is
	 * directly available via g_application_command_line_get_cwd(),
	 * g_application_command_line_get_environ() and
	 * g_application_command_line_get_platform_data().
	 * 
	 * As the name indicates, the platform data may vary depending on the
	 * operating system, but it always includes the current directory (key
	 * "cwd"), and optionally the environment (ie the set of environment
	 * variables and their values) of the calling process (key "environ").
	 * The environment is only added to the platform data if the
	 * %G_APPLICATION_SEND_ENVIRONMENT flag is set. #GApplication subclasses
	 * can add their own platform data by overriding the #add_platform_data
	 * virtual function. For instance, #GtkApplication adds startup notification
	 * data in this way.
	 * 
	 * To parse commandline arguments you may handle the
	 * #GApplication::command-line signal or override the local_command_line()
	 * vfunc, to parse them in either the primary instance or the local instance,
	 * respectively.
	 * 
	 * For an example of opening files with a GApplication, see
	 * [gapplication-example-open.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gapplication-example-open.c).
	 * 
	 * For an example of using actions with GApplication, see
	 * [gapplication-example-actions.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gapplication-example-actions.c).
	 * 
	 * For an example of using extra D-Bus hooks with GApplication, see
	 * [gapplication-example-dbushooks.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gapplication-example-dbushooks.c).
	 */
	interface Application extends ApplicationMixin {}

	class Application {
		public constructor(options?: Partial<ApplicationInitOptions>);
		/**
		 * Creates a new #GApplication instance.
		 * 
		 * If non-%NULL, the application id must be valid.  See
		 * {@link G.application_id_is_valid}.
		 * 
		 * If no application ID is given then some features of #GApplication
		 * (most notably application uniqueness) will be disabled.
		 * @param application_id the application id
		 * @param flags the application flags
		 * @returns a new #GApplication instance
		 */
		public static new(application_id: string | null, flags: ApplicationFlags): Application;
		/**
		 * Returns the default #GApplication instance for this process.
		 * 
		 * Normally there is only one #GApplication per process and it becomes
		 * the default when it is created.  You can exercise more control over
		 * this by using {@link G.application_set_default}.
		 * 
		 * If there is no default application then %NULL is returned.
		 * @returns the default application for this process, or %NULL
		 */
		public static get_default(): Application | null;
		/**
		 * Checks if #application_id is a valid application identifier.
		 * 
		 * A valid ID is required for calls to {@link G.application_new} and
		 * g_application_set_application_id().
		 * 
		 * Application identifiers follow the same format as
		 * [D-Bus well-known bus names](https://dbus.freedesktop.org/doc/dbus-specification.html#message-protocol-names-bus).
		 * For convenience, the restrictions on application identifiers are
		 * reproduced here:
		 * 
		 * - Application identifiers are composed of 1 or more elements separated by a
		 *   period (`.`) character. All elements must contain at least one character.
		 * 
		 * - Each element must only contain the ASCII characters `[A-Z][a-z][0-9]_-`,
		 *   with `-` discouraged in new application identifiers. Each element must not
		 *   begin with a digit.
		 * 
		 * - Application identifiers must contain at least one `.` (period) character
		 *   (and thus at least two elements).
		 * 
		 * - Application identifiers must not begin with a `.` (period) character.
		 * 
		 * - Application identifiers must not exceed 255 characters.
		 * 
		 * Note that the hyphen (`-`) character is allowed in application identifiers,
		 * but is problematic or not allowed in various specifications and APIs that
		 * refer to D-Bus, such as
		 * [Flatpak application IDs](http://docs.flatpak.org/en/latest/introduction.html#identifiers),
		 * the
		 * [`DBusActivatable` interface in the Desktop Entry Specification](https://specifications.freedesktop.org/desktop-entry-spec/desktop-entry-spec-latest.html#dbus),
		 * and the convention that an application's "main" interface and object path
		 * resemble its application identifier and bus name. To avoid situations that
		 * require special-case handling, it is recommended that new application
		 * identifiers consistently replace hyphens with underscores.
		 * 
		 * Like D-Bus interface names, application identifiers should start with the
		 * reversed DNS domain name of the author of the interface (in lower-case), and
		 * it is conventional for the rest of the application identifier to consist of
		 * words run together, with initial capital letters.
		 * 
		 * As with D-Bus interface names, if the author's DNS domain name contains
		 * hyphen/minus characters they should be replaced by underscores, and if it
		 * contains leading digits they should be escaped by prepending an underscore.
		 * For example, if the owner of 7-zip.org used an application identifier for an
		 * archiving application, it might be named `org._7_zip.Archiver`.
		 * @param application_id a potential application identifier
		 * @returns %TRUE if #application_id is valid
		 */
		public static id_is_valid(application_id: string): boolean;
	}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link ApplicationCommandLine} instead.
	 */
	interface IApplicationCommandLine {
		readonly is_remote: boolean;
		/**
		 * Creates a #GFile corresponding to a filename that was given as part
		 * of the invocation of #cmdline.
		 * 
		 * This differs from {@link G.file_new_for_commandline_arg} in that it
		 * resolves relative pathnames using the current working directory of
		 * the invoking process rather than the local process.
		 * @param arg an argument from #cmdline
		 * @returns a new #GFile
		 */
		create_file_for_arg(arg: string): File;
		/**
		 * Gets the list of arguments that was passed on the command line.
		 * 
		 * The strings in the array may contain non-UTF-8 data on UNIX (such as
		 * filenames or arguments given in the system locale) but are always in
		 * UTF-8 on Windows.
		 * 
		 * If you wish to use the return value with #GOptionContext, you must
		 * use {@link G.option_context_parse_strv}.
		 * 
		 * The return value is %NULL-terminated and should be freed using
		 * g_strfreev().
		 * @returns 
		 *      the string array containing the arguments (the argv)
		 * 
		 * the length of the arguments array, or %NULL
		 */
		get_arguments(): [ string[], number | null ];
		/**
		 * Gets the working directory of the command line invocation.
		 * The string may contain non-utf8 data.
		 * 
		 * It is possible that the remote application did not send a working
		 * directory, so this may be %NULL.
		 * 
		 * The return value should not be modified or freed and is valid for as
		 * long as #cmdline exists.
		 * @returns the current directory, or %NULL
		 */
		get_cwd(): string | null;
		/**
		 * Gets the contents of the 'environ' variable of the command line
		 * invocation, as would be returned by {@link G.get_environ}, ie as a
		 * %NULL-terminated list of strings in the form 'NAME=VALUE'.
		 * The strings may contain non-utf8 data.
		 * 
		 * The remote application usually does not send an environment.  Use
		 * %G_APPLICATION_SEND_ENVIRONMENT to affect that.  Even with this flag
		 * set it is possible that the environment is still not available (due
		 * to invocation messages from other applications).
		 * 
		 * The return value should not be modified or freed and is valid for as
		 * long as #cmdline exists.
		 * 
		 * See g_application_command_line_getenv() if you are only interested
		 * in the value of a single environment variable.
		 * @returns 
		 *     the environment strings, or %NULL if they were not sent
		 */
		get_environ(): string[];
		/**
		 * Gets the exit status of #cmdline.  See
		 * {@link G.application_command_line_set_exit_status} for more information.
		 * @returns the exit status
		 */
		get_exit_status(): number;
		/**
		 * Determines if #cmdline represents a remote invocation.
		 * @returns %TRUE if the invocation was remote
		 */
		get_is_remote(): boolean;
		/**
		 * Gets the options there were passed to {@link G.application_command_line}.
		 * 
		 * If you did not override local_command_line() then these are the same
		 * options that were parsed according to the #GOptionEntrys added to the
		 * application with g_application_add_main_option_entries() and possibly
		 * modified from your GApplication::handle-local-options handler.
		 * 
		 * If no options were sent then an empty dictionary is returned so that
		 * you don't need to check for %NULL.
		 * @returns a #GVariantDict with the options
		 */
		get_options_dict(): GLib.VariantDict;
		/**
		 * Gets the platform data associated with the invocation of #cmdline.
		 * 
		 * This is a #GVariant dictionary containing information about the
		 * context in which the invocation occurred.  It typically contains
		 * information like the current working directory and the startup
		 * notification ID.
		 * 
		 * For local invocation, it will be %NULL.
		 * @returns the platform data, or %NULL
		 */
		get_platform_data(): GLib.Variant | null;
		/**
		 * Gets the stdin of the invoking process.
		 * 
		 * The #GInputStream can be used to read data passed to the standard
		 * input of the invoking process.
		 * This doesn't work on all platforms.  Presently, it is only available
		 * on UNIX when using a D-Bus daemon capable of passing file descriptors.
		 * If stdin is not available then %NULL will be returned.  In the
		 * future, support may be expanded to other platforms.
		 * 
		 * You must only call this function once per commandline invocation.
		 * @returns a #GInputStream for stdin
		 */
		get_stdin(): InputStream | null;
		/**
		 * Gets the value of a particular environment variable of the command
		 * line invocation, as would be returned by {@link G.getenv}.  The strings may
		 * contain non-utf8 data.
		 * 
		 * The remote application usually does not send an environment.  Use
		 * %G_APPLICATION_SEND_ENVIRONMENT to affect that.  Even with this flag
		 * set it is possible that the environment is still not available (due
		 * to invocation messages from other applications).
		 * 
		 * The return value should not be modified or freed and is valid for as
		 * long as #cmdline exists.
		 * @param name the environment variable to get
		 * @returns the value of the variable, or %NULL if unset or unsent
		 */
		getenv(name: string): string | null;
		/**
		 * Formats a message and prints it using the stdout print handler in the
		 * invoking process.
		 * 
		 * If #cmdline is a local invocation then this is exactly equivalent to
		 * {@link G.print}.  If #cmdline is remote then this is equivalent to calling
		 * g_print() in the invoking process.
		 * @param format a printf-style format string
		 */
		print(format: string): void;
		/**
		 * Formats a message and prints it using the stderr print handler in the
		 * invoking process.
		 * 
		 * If #cmdline is a local invocation then this is exactly equivalent to
		 * {@link G.printerr}.  If #cmdline is remote then this is equivalent to
		 * calling g_printerr() in the invoking process.
		 * @param format a printf-style format string
		 */
		printerr(format: string): void;
		/**
		 * Sets the exit status that will be used when the invoking process
		 * exits.
		 * 
		 * The return value of the #GApplication::command-line signal is
		 * passed to this function when the handler returns.  This is the usual
		 * way of setting the exit status.
		 * 
		 * In the event that you want the remote invocation to continue running
		 * and want to decide on the exit status in the future, you can use this
		 * call.  For the case of a remote invocation, the remote process will
		 * typically exit when the last reference is dropped on #cmdline.  The
		 * exit status of the remote process will be equal to the last value
		 * that was set with this function.
		 * 
		 * In the case that the commandline invocation is local, the situation
		 * is slightly more complicated.  If the commandline invocation results
		 * in the mainloop running (ie: because the use-count of the application
		 * increased to a non-zero value) then the application is considered to
		 * have been 'successful' in a certain sense, and the exit status is
		 * always zero.  If the application use count is zero, though, the exit
		 * status of the local #GApplicationCommandLine is used.
		 * @param exit_status the exit status
		 */
		set_exit_status(exit_status: number): void;
		connect(signal: "notify::is-remote", callback: (owner: this, ...args: any) => void): number;

	}

	type ApplicationCommandLineInitOptionsMixin = GObject.ObjectInitOptions
	export interface ApplicationCommandLineInitOptions extends ApplicationCommandLineInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link ApplicationCommandLine} instead.
	 */
	type ApplicationCommandLineMixin = IApplicationCommandLine & GObject.Object;

	/**
	 * #GApplicationCommandLine represents a command-line invocation of
	 * an application.  It is created by #GApplication and emitted
	 * in the #GApplication::command-line signal and virtual function.
	 * 
	 * The class contains the list of arguments that the program was invoked
	 * with.  It is also possible to query if the commandline invocation was
	 * local (ie: the current process is running in direct response to the
	 * invocation) or remote (ie: some other process forwarded the
	 * commandline to this process).
	 * 
	 * The GApplicationCommandLine object can provide the #argc and #argv
	 * parameters for use with the #GOptionContext command-line parsing API,
	 * with the {@link G.application_command_line_get_arguments} function. See
	 * [gapplication-example-cmdline3.c][gapplication-example-cmdline3]
	 * for an example.
	 * 
	 * The exit status of the originally-invoked process may be set and
	 * messages can be printed to stdout or stderr of that process.  The
	 * lifecycle of the originally-invoked process is tied to the lifecycle
	 * of this object (ie: the process exits when the last reference is
	 * dropped).
	 * 
	 * The main use for #GApplicationCommandLine (and the
	 * #GApplication::command-line signal) is 'Emacs server' like use cases:
	 * You can set the `EDITOR` environment variable to have e.g. git use
	 * your favourite editor to edit commit messages, and if you already
	 * have an instance of the editor running, the editing will happen
	 * in the running instance, instead of opening a new one. An important
	 * aspect of this use case is that the process that gets started by git
	 * does not return until the editing is done.
	 * 
	 * Normally, the commandline is completely handled in the
	 * #GApplication::command-line handler. The launching instance exits
	 * once the signal handler in the primary instance has returned, and
	 * the return value of the signal handler becomes the exit status
	 * of the launching instance.
	 * |[<!-- language="C" -->
	 * static int
	 * command_line (GApplication            *application,
	 *               GApplicationCommandLine *cmdline)
	 * {
	 *   gchar **argv;
	 *   gint argc;
	 *   gint i;
	 * 
	 *   argv = g_application_command_line_get_arguments (cmdline, &argc);
	 * 
	 *   g_application_command_line_print (cmdline,
	 *                                     "This text is written back\n"
	 *                                     "to stdout of the caller\n");
	 * 
	 *   for (i = 0; i < argc; i++)
	 *     g_print ("argument %d: %s\n", i, argv[i]);
	 * 
	 *   g_strfreev (argv);
	 * 
	 *   return 0;
	 * }
	 * ]|
	 * The complete example can be found here:
	 * [gapplication-example-cmdline.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gapplication-example-cmdline.c)
	 * 
	 * In more complicated cases, the handling of the comandline can be
	 * split between the launcher and the primary instance.
	 * |[<!-- language="C" -->
	 * static gboolean
	 *  test_local_cmdline (GApplication   *application,
	 *                      gchar        ***arguments,
	 *                      gint           *exit_status)
	 * {
	 *   gint i, j;
	 *   gchar **argv;
	 * 
	 *   argv = *arguments;
	 * 
	 *   i = 1;
	 *   while (argv[i])
	 *     {
	 *       if (g_str_has_prefix (argv[i], "--local-"))
	 *         {
	 *           g_print ("handling argument %s locally\n", argv[i]);
	 *           g_free (argv[i]);
	 *           for (j = i; argv[j]; j++)
	 *             argv[j] = argv[j + 1];
	 *         }
	 *       else
	 *         {
	 *           g_print ("not handling argument %s locally\n", argv[i]);
	 *           i++;
	 *         }
	 *     }
	 * 
	 *   *exit_status = 0;
	 * 
	 *   return FALSE;
	 * }
	 * 
	 * static void
	 * test_application_class_init (TestApplicationClass *class)
	 * {
	 *   G_APPLICATION_CLASS (class)->local_command_line = test_local_cmdline;
	 * 
	 *   ...
	 * }
	 * ]|
	 * In this example of split commandline handling, options that start
	 * with `--local-` are handled locally, all other options are passed
	 * to the #GApplication::command-line handler which runs in the primary
	 * instance.
	 * 
	 * The complete example can be found here:
	 * [gapplication-example-cmdline2.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gapplication-example-cmdline2.c)
	 * 
	 * If handling the commandline requires a lot of work, it may
	 * be better to defer it.
	 * |[<!-- language="C" -->
	 * static gboolean
	 * my_cmdline_handler (gpointer data)
	 * {
	 *   GApplicationCommandLine *cmdline = data;
	 * 
	 *   // do the heavy lifting in an idle
	 * 
	 *   g_application_command_line_set_exit_status (cmdline, 0);
	 *   g_object_unref (cmdline); // this releases the application
	 * 
	 *   return G_SOURCE_REMOVE;
	 * }
	 * 
	 * static int
	 * command_line (GApplication            *application,
	 *               GApplicationCommandLine *cmdline)
	 * {
	 *   // keep the application running until we are done with this commandline
	 *   g_application_hold (application);
	 * 
	 *   g_object_set_data_full (G_OBJECT (cmdline),
	 *                           "application", application,
	 *                           (GDestroyNotify)g_application_release);
	 * 
	 *   g_object_ref (cmdline);
	 *   g_idle_add (my_cmdline_handler, cmdline);
	 * 
	 *   return 0;
	 * }
	 * ]|
	 * In this example the commandline is not completely handled before
	 * the #GApplication::command-line handler returns. Instead, we keep
	 * a reference to the #GApplicationCommandLine object and handle it
	 * later (in this example, in an idle). Note that it is necessary to
	 * hold the application until you are done with the commandline.
	 * 
	 * The complete example can be found here:
	 * [gapplication-example-cmdline3.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gapplication-example-cmdline3.c)
	 */
	interface ApplicationCommandLine extends ApplicationCommandLineMixin {}

	class ApplicationCommandLine {
		public constructor(options?: Partial<ApplicationCommandLineInitOptions>);
	}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link BufferedInputStream} instead.
	 */
	interface IBufferedInputStream {
		buffer_size: number;
		/**
		 * Tries to read #count bytes from the stream into the buffer.
		 * Will block during this read.
		 * 
		 * If #count is zero, returns zero and does nothing. A value of #count
		 * larger than %G_MAXSSIZE will cause a %G_IO_ERROR_INVALID_ARGUMENT error.
		 * 
		 * On success, the number of bytes read into the buffer is returned.
		 * It is not an error if this is not the same as the requested size, as it
		 * can happen e.g. near the end of a file. Zero is returned on end of file
		 * (or if #count is zero),  but never otherwise.
		 * 
		 * If #count is -1 then the attempted read size is equal to the number of
		 * bytes that are required to fill the buffer.
		 * 
		 * If #cancellable is not %NULL, then the operation can be cancelled by
		 * triggering the cancellable object from another thread. If the operation
		 * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
		 * operation was partially finished when the operation was cancelled the
		 * partial result will be returned, without an error.
		 * 
		 * On error -1 is returned and #error is set accordingly.
		 * 
		 * For the asynchronous, non-blocking, version of this function, see
		 * {@link G.buffered_input_stream_fill_async}.
		 * @param count the number of bytes that will be read from the stream
		 * @param cancellable optional #GCancellable object, %NULL to ignore
		 * @returns the number of bytes read into #stream's buffer, up to #count,
		 *     or -1 on error.
		 */
		fill(count: number, cancellable?: Cancellable | null): number;
		/**
		 * Reads data into #stream's buffer asynchronously, up to #count size.
		 * #io_priority can be used to prioritize reads. For the synchronous
		 * version of this function, see {@link G.buffered_input_stream_fill}.
		 * 
		 * If #count is -1 then the attempted read size is equal to the number
		 * of bytes that are required to fill the buffer.
		 * @param count the number of bytes that will be read from the stream
		 * @param io_priority the [I/O priority][io-priority] of the request
		 * @param cancellable optional #GCancellable object
		 * @param callback a #GAsyncReadyCallback
		 */
		fill_async(count: number, io_priority: number, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;
		/**
		 * Finishes an asynchronous read.
		 * @param result a #GAsyncResult
		 * @returns a #gssize of the read stream, or `-1` on an error.
		 */
		fill_finish(result: AsyncResult): number;
		/**
		 * Gets the size of the available data within the stream.
		 * @returns size of the available stream.
		 */
		get_available(): number;
		/**
		 * Gets the size of the input buffer.
		 * @returns the current buffer size.
		 */
		get_buffer_size(): number;
		/**
		 * Peeks in the buffer, copying data of size #count into #buffer,
		 * offset #offset bytes.
		 * @param buffer a pointer to
		 *   an allocated chunk of memory
		 * @param offset a #gsize
		 * @returns a #gsize of the number of bytes peeked, or -1 on error.
		 */
		peek(buffer: number[], offset: number): number;
		/**
		 * Returns the buffer with the currently available bytes. The returned
		 * buffer must not be modified and will become invalid when reading from
		 * the stream or filling the buffer.
		 * @returns 
		 *          read-only buffer
		 * 
		 * a #gsize to get the number of bytes available in the buffer
		 */
		peek_buffer(): [ number[], number ];
		/**
		 * Tries to read a single byte from the stream or the buffer. Will block
		 * during this read.
		 * 
		 * On success, the byte read from the stream is returned. On end of stream
		 * -1 is returned but it's not an exceptional error and #error is not set.
		 * 
		 * If #cancellable is not %NULL, then the operation can be cancelled by
		 * triggering the cancellable object from another thread. If the operation
		 * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
		 * operation was partially finished when the operation was cancelled the
		 * partial result will be returned, without an error.
		 * 
		 * On error -1 is returned and #error is set accordingly.
		 * @param cancellable optional #GCancellable object, %NULL to ignore
		 * @returns the byte read from the #stream, or -1 on end of stream or error.
		 */
		read_byte(cancellable?: Cancellable | null): number;
		/**
		 * Sets the size of the internal buffer of #stream to #size, or to the
		 * size of the contents of the buffer. The buffer can never be resized
		 * smaller than its current contents.
		 * @param size a #gsize
		 */
		set_buffer_size(size: number): void;
		connect(signal: "notify::buffer-size", callback: (owner: this, ...args: any) => void): number;

	}

	type BufferedInputStreamInitOptionsMixin = FilterInputStreamInitOptions & SeekableInitOptions & 
	Pick<IBufferedInputStream,
		"buffer_size">;

	export interface BufferedInputStreamInitOptions extends BufferedInputStreamInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link BufferedInputStream} instead.
	 */
	type BufferedInputStreamMixin = IBufferedInputStream & FilterInputStream & Seekable;

	/**
	 * Buffered input stream implements #GFilterInputStream and provides
	 * for buffered reads.
	 * 
	 * By default, #GBufferedInputStream's buffer size is set at 4 kilobytes.
	 * 
	 * To create a buffered input stream, use {@link G.buffered_input_stream_new},
	 * or g_buffered_input_stream_new_sized() to specify the buffer's size at
	 * construction.
	 * 
	 * To get the size of a buffer within a buffered input stream, use
	 * g_buffered_input_stream_get_buffer_size(). To change the size of a
	 * buffered input stream's buffer, use
	 * g_buffered_input_stream_set_buffer_size(). Note that the buffer's size
	 * cannot be reduced below the size of the data within the buffer.
	 */
	interface BufferedInputStream extends BufferedInputStreamMixin {}

	class BufferedInputStream {
		public constructor(options?: Partial<BufferedInputStreamInitOptions>);
		/**
		 * Creates a new #GInputStream from the given #base_stream, with
		 * a buffer set to the default size (4 kilobytes).
		 * @param base_stream a #GInputStream
		 * @returns a #GInputStream for the given #base_stream.
		 */
		public static new(base_stream: InputStream): InputStream;
		/**
		 * Creates a new #GBufferedInputStream from the given #base_stream,
		 * with a buffer set to #size.
		 * @param base_stream a #GInputStream
		 * @param size a #gsize
		 * @returns a #GInputStream.
		 */
		public static new_sized(base_stream: InputStream, size: number): InputStream;
	}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link BufferedOutputStream} instead.
	 */
	interface IBufferedOutputStream {
		auto_grow: boolean;
		buffer_size: number;
		/**
		 * Checks if the buffer automatically grows as data is added.
		 * @returns %TRUE if the #stream's buffer automatically grows,
		 * %FALSE otherwise.
		 */
		get_auto_grow(): boolean;
		/**
		 * Gets the size of the buffer in the #stream.
		 * @returns the current size of the buffer.
		 */
		get_buffer_size(): number;
		/**
		 * Sets whether or not the #stream's buffer should automatically grow.
		 * If #auto_grow is true, then each write will just make the buffer
		 * larger, and you must manually flush the buffer to actually write out
		 * the data to the underlying stream.
		 * @param auto_grow a #gboolean.
		 */
		set_auto_grow(auto_grow: boolean): void;
		/**
		 * Sets the size of the internal buffer to #size.
		 * @param size a #gsize.
		 */
		set_buffer_size(size: number): void;
		connect(signal: "notify::auto-grow", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::buffer-size", callback: (owner: this, ...args: any) => void): number;

	}

	type BufferedOutputStreamInitOptionsMixin = FilterOutputStreamInitOptions & SeekableInitOptions & 
	Pick<IBufferedOutputStream,
		"auto_grow" |
		"buffer_size">;

	export interface BufferedOutputStreamInitOptions extends BufferedOutputStreamInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link BufferedOutputStream} instead.
	 */
	type BufferedOutputStreamMixin = IBufferedOutputStream & FilterOutputStream & Seekable;

	/**
	 * Buffered output stream implements #GFilterOutputStream and provides
	 * for buffered writes.
	 * 
	 * By default, #GBufferedOutputStream's buffer size is set at 4 kilobytes.
	 * 
	 * To create a buffered output stream, use {@link G.buffered_output_stream_new},
	 * or g_buffered_output_stream_new_sized() to specify the buffer's size
	 * at construction.
	 * 
	 * To get the size of a buffer within a buffered input stream, use
	 * g_buffered_output_stream_get_buffer_size(). To change the size of a
	 * buffered output stream's buffer, use
	 * g_buffered_output_stream_set_buffer_size(). Note that the buffer's
	 * size cannot be reduced below the size of the data within the buffer.
	 */
	interface BufferedOutputStream extends BufferedOutputStreamMixin {}

	class BufferedOutputStream {
		public constructor(options?: Partial<BufferedOutputStreamInitOptions>);
		/**
		 * Creates a new buffered output stream for a base stream.
		 * @param base_stream a #GOutputStream.
		 * @returns a #GOutputStream for the given #base_stream.
		 */
		public static new(base_stream: OutputStream): OutputStream;
		/**
		 * Creates a new buffered output stream with a given buffer size.
		 * @param base_stream a #GOutputStream.
		 * @param size a #gsize.
		 * @returns a #GOutputStream with an internal buffer set to #size.
		 */
		public static new_sized(base_stream: OutputStream, size: number): OutputStream;
	}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link BytesIcon} instead.
	 */
	interface IBytesIcon {
		/**
		 * The bytes containing the icon.
		 */
		bytes: GLib.Bytes;
		/**
		 * Gets the #GBytes associated with the given #icon.
		 * @returns a #GBytes.
		 */
		get_bytes(): GLib.Bytes;
		connect(signal: "notify::bytes", callback: (owner: this, ...args: any) => void): number;

	}

	type BytesIconInitOptionsMixin = GObject.ObjectInitOptions & IconInitOptions & LoadableIconInitOptions & 
	Pick<IBytesIcon,
		"bytes">;

	export interface BytesIconInitOptions extends BytesIconInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link BytesIcon} instead.
	 */
	type BytesIconMixin = IBytesIcon & GObject.Object & Icon & LoadableIcon;

	/**
	 * #GBytesIcon specifies an image held in memory in a common format (usually
	 * png) to be used as icon.
	 */
	interface BytesIcon extends BytesIconMixin {}

	class BytesIcon {
		public constructor(options?: Partial<BytesIconInitOptions>);
		/**
		 * Creates a new icon for a bytes.
		 * 
		 * This cannot fail, but loading and interpreting the bytes may fail later on
		 * (for example, if {@link G.loadable_icon_load} is called) if the image is invalid.
		 * @param bytes a #GBytes.
		 * @returns a #GIcon for the given
		 *   #bytes.
		 */
		public static new(bytes: GLib.Bytes): BytesIcon;
	}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link Cancellable} instead.
	 */
	interface ICancellable {
		/**
		 * Will set #cancellable to cancelled, and will emit the
		 * #GCancellable::cancelled signal. (However, see the warning about
		 * race conditions in the documentation for that signal if you are
		 * planning to connect to it.)
		 * 
		 * This function is thread-safe. In other words, you can safely call
		 * it from a thread other than the one running the operation that was
		 * passed the #cancellable.
		 * 
		 * If #cancellable is %NULL, this function returns immediately for convenience.
		 * 
		 * The convention within GIO is that cancelling an asynchronous
		 * operation causes it to complete asynchronously. That is, if you
		 * cancel the operation from the same thread in which it is running,
		 * then the operation's #GAsyncReadyCallback will not be invoked until
		 * the application returns to the main loop.
		 */
		cancel(): void;
		/**
		 * Convenience function to connect to the #GCancellable::cancelled
		 * signal. Also handles the race condition that may happen
		 * if the cancellable is cancelled right before connecting.
		 * 
		 * #callback is called at most once, either directly at the
		 * time of the connect if #cancellable is already cancelled,
		 * or when #cancellable is cancelled in some thread.
		 * 
		 * #data_destroy_func will be called when the handler is
		 * disconnected, or immediately if the cancellable is already
		 * cancelled.
		 * 
		 * See #GCancellable::cancelled for details on how to use this.
		 * 
		 * Since GLib 2.40, the lock protecting #cancellable is not held when
		 * #callback is invoked.  This lifts a restriction in place for
		 * earlier GLib versions which now makes it easier to write cleanup
		 * code that unconditionally invokes e.g. {@link G.cancellable_cancel}.
		 * @param callback The #GCallback to connect.
		 * @returns The id of the signal handler or 0 if #cancellable has already
		 *          been cancelled.
		 */
		connect(callback: GObject.Callback): number;
		/**
		 * Disconnects a handler from a cancellable instance similar to
		 * {@link G.signal_handler_disconnect}.  Additionally, in the event that a
		 * signal handler is currently running, this call will block until the
		 * handler has finished.  Calling this function from a
		 * #GCancellable::cancelled signal handler will therefore result in a
		 * deadlock.
		 * 
		 * This avoids a race condition where a thread cancels at the
		 * same time as the cancellable operation is finished and the
		 * signal handler is removed. See #GCancellable::cancelled for
		 * details on how to use this.
		 * 
		 * If #cancellable is %NULL or #handler_id is `0` this function does
		 * nothing.
		 * @param handler_id Handler id of the handler to be disconnected, or `0`.
		 */
		disconnect(handler_id: number): void;
		/**
		 * Gets the file descriptor for a cancellable job. This can be used to
		 * implement cancellable operations on Unix systems. The returned fd will
		 * turn readable when #cancellable is cancelled.
		 * 
		 * You are not supposed to read from the fd yourself, just check for
		 * readable status. Reading to unset the readable status is done
		 * with {@link G.cancellable_reset}.
		 * 
		 * After a successful return from this function, you should use
		 * g_cancellable_release_fd() to free up resources allocated for
		 * the returned file descriptor.
		 * 
		 * See also g_cancellable_make_pollfd().
		 * @returns A valid file descriptor. `-1` if the file descriptor
		 * is not supported, or on errors.
		 */
		get_fd(): number;
		/**
		 * Checks if a cancellable job has been cancelled.
		 * @returns %TRUE if #cancellable is cancelled,
		 * FALSE if called with %NULL or if item is not cancelled.
		 */
		is_cancelled(): boolean;
		/**
		 * Creates a #GPollFD corresponding to #cancellable; this can be passed
		 * to {@link G.poll} and used to poll for cancellation. This is useful both
		 * for unix systems without a native poll and for portability to
		 * windows.
		 * 
		 * When this function returns %TRUE, you should use
		 * g_cancellable_release_fd() to free up resources allocated for the
		 * #pollfd. After a %FALSE return, do not call g_cancellable_release_fd().
		 * 
		 * If this function returns %FALSE, either no #cancellable was given or
		 * resource limits prevent this function from allocating the necessary
		 * structures for polling. (On Linux, you will likely have reached
		 * the maximum number of file descriptors.) The suggested way to handle
		 * these cases is to ignore the #cancellable.
		 * 
		 * You are not supposed to read from the fd yourself, just check for
		 * readable status. Reading to unset the readable status is done
		 * with g_cancellable_reset().
		 * @param pollfd a pointer to a #GPollFD
		 * @returns %TRUE if #pollfd was successfully initialized, %FALSE on
		 *          failure to prepare the cancellable.
		 */
		make_pollfd(pollfd: GLib.PollFD): boolean;
		/**
		 * Pops #cancellable off the cancellable stack (verifying that #cancellable
		 * is on the top of the stack).
		 */
		pop_current(): void;
		/**
		 * Pushes #cancellable onto the cancellable stack. The current
		 * cancellable can then be received using {@link G.cancellable_get_current}.
		 * 
		 * This is useful when implementing cancellable operations in
		 * code that does not allow you to pass down the cancellable object.
		 * 
		 * This is typically called automatically by e.g. #GFile operations,
		 * so you rarely have to call this yourself.
		 */
		push_current(): void;
		/**
		 * Releases a resources previously allocated by {@link G.cancellable_get_fd}
		 * or g_cancellable_make_pollfd().
		 * 
		 * For compatibility reasons with older releases, calling this function
		 * is not strictly required, the resources will be automatically freed
		 * when the #cancellable is finalized. However, the #cancellable will
		 * block scarce file descriptors until it is finalized if this function
		 * is not called. This can cause the application to run out of file
		 * descriptors when many #GCancellables are used at the same time.
		 */
		release_fd(): void;
		/**
		 * Resets #cancellable to its uncancelled state.
		 * 
		 * If cancellable is currently in use by any cancellable operation
		 * then the behavior of this function is undefined.
		 * 
		 * Note that it is generally not a good idea to reuse an existing
		 * cancellable for more operations after it has been cancelled once,
		 * as this function might tempt you to do. The recommended practice
		 * is to drop the reference to a cancellable after cancelling it,
		 * and let it die with the outstanding async operations. You should
		 * create a fresh cancellable for further async operations.
		 */
		reset(): void;
		/**
		 * If the #cancellable is cancelled, sets the error to notify
		 * that the operation was cancelled.
		 * @returns %TRUE if #cancellable was cancelled, %FALSE if it was not
		 */
		set_error_if_cancelled(): boolean;
		/**
		 * Creates a source that triggers if #cancellable is cancelled and
		 * calls its callback of type #GCancellableSourceFunc. This is
		 * primarily useful for attaching to another (non-cancellable) source
		 * with {@link G.source_add_child_source} to add cancellability to it.
		 * 
		 * For convenience, you can call this with a %NULL #GCancellable,
		 * in which case the source will never trigger.
		 * 
		 * The new #GSource will hold a reference to the #GCancellable.
		 * @returns the new #GSource.
		 */
		source_new(): GLib.Source;
		/**
		 * Emitted when the operation has been cancelled.
		 * 
		 * Can be used by implementations of cancellable operations. If the
		 * operation is cancelled from another thread, the signal will be
		 * emitted in the thread that cancelled the operation, not the
		 * thread that is running the operation.
		 * 
		 * Note that disconnecting from this signal (or any signal) in a
		 * multi-threaded program is prone to race conditions. For instance
		 * it is possible that a signal handler may be invoked even after
		 * a call to {@link G.signal_handler_disconnect} for that handler has
		 * already returned.
		 * 
		 * There is also a problem when cancellation happens right before
		 * connecting to the signal. If this happens the signal will
		 * unexpectedly not be emitted, and checking before connecting to
		 * the signal leaves a race condition where this is still happening.
		 * 
		 * In order to make it safe and easy to connect handlers there
		 * are two helper functions: g_cancellable_connect() and
		 * g_cancellable_disconnect() which protect against problems
		 * like this.
		 * 
		 * An example of how to us this:
		 * |[<!-- language="C" -->
		 *     // Make sure we don't do unnecessary work if already cancelled
		 *     if (g_cancellable_set_error_if_cancelled (cancellable, error))
		 *       return;
		 * 
		 *     // Set up all the data needed to be able to handle cancellation
		 *     // of the operation
		 *     my_data = my_data_new (...);
		 * 
		 *     id = 0;
		 *     if (cancellable)
		 *       id = g_cancellable_connect (cancellable,
		 *     			      G_CALLBACK (cancelled_handler)
		 *     			      data, NULL);
		 * 
		 *     // cancellable operation here...
		 * 
		 *     g_cancellable_disconnect (cancellable, id);
		 * 
		 *     // cancelled_handler is never called after this, it is now safe
		 *     // to free the data
		 *     my_data_free (my_data);
		 * ]|
		 * 
		 * Note that the cancelled signal is emitted in the thread that
		 * the user cancelled from, which may be the main thread. So, the
		 * cancellable signal should not do something that can block.
		 * @param signal 
		 * @param callback Callback function
		 *  - owner: owner of the emitted event 
		 * 
		 * @returns Callback ID
		 */
		connect(signal: "cancelled", callback: (owner: this) => void): number;

	}

	type CancellableInitOptionsMixin = GObject.ObjectInitOptions
	export interface CancellableInitOptions extends CancellableInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link Cancellable} instead.
	 */
	type CancellableMixin = ICancellable & GObject.Object;

	/**
	 * GCancellable is a thread-safe operation cancellation stack used
	 * throughout GIO to allow for cancellation of synchronous and
	 * asynchronous operations.
	 */
	interface Cancellable extends CancellableMixin {}

	class Cancellable {
		public constructor(options?: Partial<CancellableInitOptions>);
		/**
		 * Creates a new #GCancellable object.
		 * 
		 * Applications that want to start one or more operations
		 * that should be cancellable should create a #GCancellable
		 * and pass it to the operations.
		 * 
		 * One #GCancellable can be used in multiple consecutive
		 * operations or in multiple concurrent operations.
		 * @returns a #GCancellable.
		 */
		public static new(): Cancellable;
		/**
		 * Gets the top cancellable from the stack.
		 * @returns a #GCancellable from the top
		 * of the stack, or %NULL if the stack is empty.
		 */
		public static get_current(): Cancellable | null;
	}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link CharsetConverter} instead.
	 */
	interface ICharsetConverter {
		from_charset: string;
		to_charset: string;
		use_fallback: boolean;
		/**
		 * Gets the number of fallbacks that #converter has applied so far.
		 * @returns the number of fallbacks that #converter has applied
		 */
		get_num_fallbacks(): number;
		/**
		 * Gets the #GCharsetConverter:use-fallback property.
		 * @returns %TRUE if fallbacks are used by #converter
		 */
		get_use_fallback(): boolean;
		/**
		 * Sets the #GCharsetConverter:use-fallback property.
		 * @param use_fallback %TRUE to use fallbacks
		 */
		set_use_fallback(use_fallback: boolean): void;
		connect(signal: "notify::from-charset", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::to-charset", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::use-fallback", callback: (owner: this, ...args: any) => void): number;

	}

	type CharsetConverterInitOptionsMixin = GObject.ObjectInitOptions & ConverterInitOptions & InitableInitOptions & 
	Pick<ICharsetConverter,
		"from_charset" |
		"to_charset" |
		"use_fallback">;

	export interface CharsetConverterInitOptions extends CharsetConverterInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link CharsetConverter} instead.
	 */
	type CharsetConverterMixin = ICharsetConverter & GObject.Object & Converter & Initable;

	/**
	 * #GCharsetConverter is an implementation of #GConverter based on
	 * GIConv.
	 */
	interface CharsetConverter extends CharsetConverterMixin {}

	class CharsetConverter {
		public constructor(options?: Partial<CharsetConverterInitOptions>);
		/**
		 * Creates a new #GCharsetConverter.
		 * @param to_charset destination charset
		 * @param from_charset source charset
		 * @returns a new #GCharsetConverter or %NULL on error.
		 */
		public static new(to_charset: string, from_charset: string): CharsetConverter;
	}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link ConverterInputStream} instead.
	 */
	interface IConverterInputStream {
		converter: Converter;
		/**
		 * Gets the #GConverter that is used by #converter_stream.
		 * @returns the converter of the converter input stream
		 */
		get_converter(): Converter;
		connect(signal: "notify::converter", callback: (owner: this, ...args: any) => void): number;

	}

	type ConverterInputStreamInitOptionsMixin = FilterInputStreamInitOptions & PollableInputStreamInitOptions & 
	Pick<IConverterInputStream,
		"converter">;

	export interface ConverterInputStreamInitOptions extends ConverterInputStreamInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link ConverterInputStream} instead.
	 */
	type ConverterInputStreamMixin = IConverterInputStream & FilterInputStream & PollableInputStream;

	/**
	 * Converter input stream implements #GInputStream and allows
	 * conversion of data of various types during reading.
	 * 
	 * As of GLib 2.34, #GConverterInputStream implements
	 * #GPollableInputStream.
	 */
	interface ConverterInputStream extends ConverterInputStreamMixin {}

	class ConverterInputStream {
		public constructor(options?: Partial<ConverterInputStreamInitOptions>);
		/**
		 * Creates a new converter input stream for the #base_stream.
		 * @param base_stream a #GInputStream
		 * @param converter a #GConverter
		 * @returns a new #GInputStream.
		 */
		public static new(base_stream: InputStream, converter: Converter): InputStream;
	}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link ConverterOutputStream} instead.
	 */
	interface IConverterOutputStream {
		converter: Converter;
		/**
		 * Gets the #GConverter that is used by #converter_stream.
		 * @returns the converter of the converter output stream
		 */
		get_converter(): Converter;
		connect(signal: "notify::converter", callback: (owner: this, ...args: any) => void): number;

	}

	type ConverterOutputStreamInitOptionsMixin = FilterOutputStreamInitOptions & PollableOutputStreamInitOptions & 
	Pick<IConverterOutputStream,
		"converter">;

	export interface ConverterOutputStreamInitOptions extends ConverterOutputStreamInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link ConverterOutputStream} instead.
	 */
	type ConverterOutputStreamMixin = IConverterOutputStream & FilterOutputStream & PollableOutputStream;

	/**
	 * Converter output stream implements #GOutputStream and allows
	 * conversion of data of various types during reading.
	 * 
	 * As of GLib 2.34, #GConverterOutputStream implements
	 * #GPollableOutputStream.
	 */
	interface ConverterOutputStream extends ConverterOutputStreamMixin {}

	class ConverterOutputStream {
		public constructor(options?: Partial<ConverterOutputStreamInitOptions>);
		/**
		 * Creates a new converter output stream for the #base_stream.
		 * @param base_stream a #GOutputStream
		 * @param converter a #GConverter
		 * @returns a new #GOutputStream.
		 */
		public static new(base_stream: OutputStream, converter: Converter): OutputStream;
	}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link Credentials} instead.
	 */
	interface ICredentials {
		/**
		 * Gets a pointer to native credentials of type #native_type from
		 * #credentials.
		 * 
		 * It is a programming error (which will cause a warning to be
		 * logged) to use this method if there is no #GCredentials support for
		 * the OS or if #native_type isn't supported by the OS.
		 * @param native_type The type of native credentials to get.
		 * @returns The pointer to native credentials or
		 *     %NULL if there is no #GCredentials support for the OS or if #native_type
		 *     isn't supported by the OS. Do not free the returned data, it is owned
		 *     by #credentials.
		 */
		get_native(native_type: CredentialsType): any | null;
		/**
		 * Tries to get the UNIX process identifier from #credentials. This
		 * method is only available on UNIX platforms.
		 * 
		 * This operation can fail if #GCredentials is not supported on the
		 * OS or if the native credentials type does not contain information
		 * about the UNIX process ID (for example this is the case for
		 * %G_CREDENTIALS_TYPE_APPLE_XUCRED).
		 * @returns The UNIX process ID, or `-1` if #error is set.
		 */
		get_unix_pid(): number;
		/**
		 * Tries to get the UNIX user identifier from #credentials. This
		 * method is only available on UNIX platforms.
		 * 
		 * This operation can fail if #GCredentials is not supported on the
		 * OS or if the native credentials type does not contain information
		 * about the UNIX user.
		 * @returns The UNIX user identifier or `-1` if #error is set.
		 */
		get_unix_user(): number;
		/**
		 * Checks if #credentials and #other_credentials is the same user.
		 * 
		 * This operation can fail if #GCredentials is not supported on the
		 * the OS.
		 * @param other_credentials A #GCredentials.
		 * @returns %TRUE if #credentials and #other_credentials has the same
		 * user, %FALSE otherwise or if #error is set.
		 */
		is_same_user(other_credentials: Credentials): boolean;
		/**
		 * Copies the native credentials of type #native_type from #native
		 * into #credentials.
		 * 
		 * It is a programming error (which will cause a warning to be
		 * logged) to use this method if there is no #GCredentials support for
		 * the OS or if #native_type isn't supported by the OS.
		 * @param native_type The type of native credentials to set.
		 * @param _native A pointer to native credentials.
		 */
		set_native(native_type: CredentialsType, _native: any): void;
		/**
		 * Tries to set the UNIX user identifier on #credentials. This method
		 * is only available on UNIX platforms.
		 * 
		 * This operation can fail if #GCredentials is not supported on the
		 * OS or if the native credentials type does not contain information
		 * about the UNIX user. It can also fail if the OS does not allow the
		 * use of "spoofed" credentials.
		 * @param uid The UNIX user identifier to set.
		 * @returns %TRUE if #uid was set, %FALSE if error is set.
		 */
		set_unix_user(uid: number): boolean;
		/**
		 * Creates a human-readable textual representation of #credentials
		 * that can be used in logging and debug messages. The format of the
		 * returned string may change in future GLib release.
		 * @returns A string that should be freed with {@link G.free}.
		 */
		to_string(): string;
	}

	type CredentialsInitOptionsMixin = GObject.ObjectInitOptions
	export interface CredentialsInitOptions extends CredentialsInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link Credentials} instead.
	 */
	type CredentialsMixin = ICredentials & GObject.Object;

	/**
	 * The #GCredentials type is a reference-counted wrapper for native
	 * credentials. This information is typically used for identifying,
	 * authenticating and authorizing other processes.
	 * 
	 * Some operating systems supports looking up the credentials of the
	 * remote peer of a communication endpoint - see e.g.
	 * {@link G.socket_get_credentials}.
	 * 
	 * Some operating systems supports securely sending and receiving
	 * credentials over a Unix Domain Socket, see
	 * #GUnixCredentialsMessage, g_unix_connection_send_credentials() and
	 * g_unix_connection_receive_credentials() for details.
	 * 
	 * On Linux, the native credential type is a `struct ucred` - see the
	 * unix(7) man page for details. This corresponds to
	 * %G_CREDENTIALS_TYPE_LINUX_UCRED.
	 * 
	 * On Apple operating systems (including iOS, tvOS, and macOS),
	 * the native credential type is a `struct xucred`.
	 * This corresponds to %G_CREDENTIALS_TYPE_APPLE_XUCRED.
	 * 
	 * On FreeBSD, Debian GNU/kFreeBSD, and GNU/Hurd, the native
	 * credential type is a `struct cmsgcred`. This corresponds
	 * to %G_CREDENTIALS_TYPE_FREEBSD_CMSGCRED.
	 * 
	 * On NetBSD, the native credential type is a `struct unpcbid`.
	 * This corresponds to %G_CREDENTIALS_TYPE_NETBSD_UNPCBID.
	 * 
	 * On OpenBSD, the native credential type is a `struct sockpeercred`.
	 * This corresponds to %G_CREDENTIALS_TYPE_OPENBSD_SOCKPEERCRED.
	 * 
	 * On Solaris (including OpenSolaris and its derivatives), the native
	 * credential type is a `ucred_t`. This corresponds to
	 * %G_CREDENTIALS_TYPE_SOLARIS_UCRED.
	 */
	interface Credentials extends CredentialsMixin {}

	class Credentials {
		public constructor(options?: Partial<CredentialsInitOptions>);
		/**
		 * Creates a new #GCredentials object with credentials matching the
		 * the current process.
		 * @returns A #GCredentials. Free with {@link GObject.unref}.
		 */
		public static new(): Credentials;
	}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link DBusActionGroup} instead.
	 */
	interface IDBusActionGroup {

	}

	type DBusActionGroupInitOptionsMixin = GObject.ObjectInitOptions & ActionGroupInitOptions & RemoteActionGroupInitOptions
	export interface DBusActionGroupInitOptions extends DBusActionGroupInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link DBusActionGroup} instead.
	 */
	type DBusActionGroupMixin = IDBusActionGroup & GObject.Object & ActionGroup & RemoteActionGroup;

	/**
	 * #GDBusActionGroup is an implementation of the #GActionGroup
	 * interface that can be used as a proxy for an action group
	 * that is exported over D-Bus with {@link G.dbus_connection_export_action_group}.
	 */
	interface DBusActionGroup extends DBusActionGroupMixin {}

	class DBusActionGroup {
		public constructor(options?: Partial<DBusActionGroupInitOptions>);
		/**
		 * Obtains a #GDBusActionGroup for the action group which is exported at
		 * the given #bus_name and #object_path.
		 * 
		 * The thread default main context is taken at the time of this call.
		 * All signals on the menu model (and any linked models) are reported
		 * with respect to this context.  All calls on the returned menu model
		 * (and linked models) must also originate from this same context, with
		 * the thread default main context unchanged.
		 * 
		 * This call is non-blocking.  The returned action group may or may not
		 * already be filled in.  The correct thing to do is connect the signals
		 * for the action group to monitor for changes and then to call
		 * {@link G.action_group_list_actions} to get the initial list.
		 * @param connection A #GDBusConnection
		 * @param bus_name the bus name which exports the action
		 *     group or %NULL if #connection is not a message bus connection
		 * @param object_path the object path at which the action group is exported
		 * @returns a #GDBusActionGroup
		 */
		public static get(connection: DBusConnection, bus_name: string | null, object_path: string): DBusActionGroup;
	}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link DBusAuthObserver} instead.
	 */
	interface IDBusAuthObserver {
		/**
		 * Emits the #GDBusAuthObserver::allow-mechanism signal on #observer.
		 * @param mechanism The name of the mechanism, e.g. `DBUS_COOKIE_SHA1`.
		 * @returns %TRUE if #mechanism can be used to authenticate the other peer, %FALSE if not.
		 */
		allow_mechanism(mechanism: string): boolean;
		/**
		 * Emits the #GDBusAuthObserver::authorize-authenticated-peer signal on #observer.
		 * @param stream A #GIOStream for the #GDBusConnection.
		 * @param credentials Credentials received from the peer or %NULL.
		 * @returns %TRUE if the peer is authorized, %FALSE if not.
		 */
		authorize_authenticated_peer(stream: IOStream, credentials?: Credentials | null): boolean;
		/**
		 * Emitted to check if #mechanism is allowed to be used.
		 * @param signal 
		 * @param callback Callback function
		 *  - owner: owner of the emitted event 
		 *  - mechanism: The name of the mechanism, e.g. `DBUS_COOKIE_SHA1`. 
		 *  - returns %TRUE if #mechanism can be used to authenticate the other peer, %FALSE if not. 
		 * 
		 * @returns Callback ID
		 */
		connect(signal: "allow-mechanism", callback: (owner: this, mechanism: string) => boolean): number;
		/**
		 * Emitted to check if a peer that is successfully authenticated
		 * is authorized.
		 * @param signal 
		 * @param callback Callback function
		 *  - owner: owner of the emitted event 
		 *  - stream: A #GIOStream for the #GDBusConnection. 
		 *  - credentials: Credentials received from the peer or %NULL. 
		 *  - returns %TRUE if the peer is authorized, %FALSE if not. 
		 * 
		 * @returns Callback ID
		 */
		connect(signal: "authorize-authenticated-peer", callback: (owner: this, stream: IOStream, credentials: Credentials | null) => boolean): number;

	}

	type DBusAuthObserverInitOptionsMixin = GObject.ObjectInitOptions
	export interface DBusAuthObserverInitOptions extends DBusAuthObserverInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link DBusAuthObserver} instead.
	 */
	type DBusAuthObserverMixin = IDBusAuthObserver & GObject.Object;

	/**
	 * The #GDBusAuthObserver type provides a mechanism for participating
	 * in how a #GDBusServer (or a #GDBusConnection) authenticates remote
	 * peers. Simply instantiate a #GDBusAuthObserver and connect to the
	 * signals you are interested in. Note that new signals may be added
	 * in the future
	 * 
	 * ## Controlling Authentication Mechanisms
	 * 
	 * By default, a #GDBusServer or server-side #GDBusConnection will allow
	 * any authentication mechanism to be used. If you only
	 * want to allow D-Bus connections with the `EXTERNAL` mechanism,
	 * which makes use of credentials passing and is the recommended
	 * mechanism for modern Unix platforms such as Linux and the BSD family,
	 * you would use a signal handler like this:
	 * 
	 * |[<!-- language="C" -->
	 * static gboolean
	 * on_allow_mechanism (GDBusAuthObserver *observer,
	 *                     const gchar       *mechanism,
	 *                     gpointer           user_data)
	 * {
	 *   if (g_strcmp0 (mechanism, "EXTERNAL") == 0)
	 *     {
	 *       return TRUE;
	 *     }
	 * 
	 *   return FALSE;
	 * }
	 * ]|
	 * 
	 * ## Controlling Authorization # {#auth-observer}
	 * 
	 * By default, a #GDBusServer or server-side #GDBusConnection will accept
	 * connections from any successfully authenticated user (but not from
	 * anonymous connections using the `ANONYMOUS` mechanism). If you only
	 * want to allow D-Bus connections from processes owned by the same uid
	 * as the server, since GLib 2.68, you should use the
	 * %G_DBUS_SERVER_FLAGS_AUTHENTICATION_REQUIRE_SAME_USER flag. It’s equivalent
	 * to the following signal handler:
	 * 
	 * |[<!-- language="C" -->
	 * static gboolean
	 * on_authorize_authenticated_peer (GDBusAuthObserver *observer,
	 *                                  GIOStream         *stream,
	 *                                  GCredentials      *credentials,
	 *                                  gpointer           user_data)
	 * {
	 *   gboolean authorized;
	 * 
	 *   authorized = FALSE;
	 *   if (credentials != NULL)
	 *     {
	 *       GCredentials *own_credentials;
	 *       own_credentials = g_credentials_new ();
	 *       if (g_credentials_is_same_user (credentials, own_credentials, NULL))
	 *         authorized = TRUE;
	 *       g_object_unref (own_credentials);
	 *     }
	 * 
	 *   return authorized;
	 * }
	 * ]|
	 */
	interface DBusAuthObserver extends DBusAuthObserverMixin {}

	class DBusAuthObserver {
		public constructor(options?: Partial<DBusAuthObserverInitOptions>);
		/**
		 * Creates a new #GDBusAuthObserver object.
		 * @returns A #GDBusAuthObserver. Free with {@link GObject.unref}.
		 */
		public static new(): DBusAuthObserver;
	}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link DBusConnection} instead.
	 */
	interface IDBusConnection {
		/**
		 * Flags from the #GDBusCapabilityFlags enumeration
		 * representing connection features negotiated with the other peer.
		 */
		readonly capabilities: DBusCapabilityFlags;
		/**
		 * A boolean specifying whether the connection has been closed.
		 */
		readonly closed: boolean;
		/**
		 * A boolean specifying whether the process will be terminated (by
		 * calling `raise(SIGTERM)`) if the connection is closed by the
		 * remote peer.
		 * 
		 * Note that #GDBusConnection objects returned by {@link G.bus_get_finish}
		 * and g_bus_get_sync() will (usually) have this property set to %TRUE.
		 */
		exit_on_close: boolean;
		/**
		 * Flags from the #GDBusConnectionFlags enumeration.
		 */
		flags: DBusConnectionFlags;
		/**
		 * The GUID of the peer performing the role of server when
		 * authenticating.
		 * 
		 * If you are constructing a #GDBusConnection and pass
		 * %G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER in the
		 * #GDBusConnection:flags property then you **must** also set this
		 * property to a valid guid.
		 * 
		 * If you are constructing a #GDBusConnection and pass
		 * %G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_CLIENT in the
		 * #GDBusConnection:flags property you will be able to read the GUID
		 * of the other peer here after the connection has been successfully
		 * initialized.
		 * 
		 * Note that the
		 * [D-Bus specification](https://dbus.freedesktop.org/doc/dbus-specification.html#addresses)
		 * uses the term ‘UUID’ to refer to this, whereas GLib consistently uses the
		 * term ‘GUID’ for historical reasons.
		 * 
		 * Despite its name, the format of #GDBusConnection:guid does not follow
		 * [RFC 4122](https://datatracker.ietf.org/doc/html/rfc4122) or the Microsoft
		 * GUID format.
		 */
		guid: string;
		/**
		 * The underlying #GIOStream used for I/O.
		 * 
		 * If this is passed on construction and is a #GSocketConnection,
		 * then the corresponding #GSocket will be put into non-blocking mode.
		 * 
		 * While the #GDBusConnection is active, it will interact with this
		 * stream from a worker thread, so it is not safe to interact with
		 * the stream directly.
		 */
		stream: IOStream;
		/**
		 * The unique name as assigned by the message bus or %NULL if the
		 * connection is not open or not a message bus connection.
		 */
		readonly unique_name: string;
		/**
		 * Adds a message filter. Filters are handlers that are run on all
		 * incoming and outgoing messages, prior to standard dispatch. Filters
		 * are run in the order that they were added.  The same handler can be
		 * added as a filter more than once, in which case it will be run more
		 * than once.  Filters added during a filter callback won't be run on
		 * the message being processed. Filter functions are allowed to modify
		 * and even drop messages.
		 * 
		 * Note that filters are run in a dedicated message handling thread so
		 * they can't block and, generally, can't do anything but signal a
		 * worker thread. Also note that filters are rarely needed - use API
		 * such as {@link G.dbus_connection_send_message_with_reply},
		 * g_dbus_connection_signal_subscribe() or g_dbus_connection_call() instead.
		 * 
		 * If a filter consumes an incoming message the message is not
		 * dispatched anywhere else - not even the standard dispatch machinery
		 * (that API such as g_dbus_connection_signal_subscribe() and
		 * g_dbus_connection_send_message_with_reply() relies on) will see the
		 * message. Similarly, if a filter consumes an outgoing message, the
		 * message will not be sent to the other peer.
		 * 
		 * If #user_data_free_func is non-%NULL, it will be called (in the
		 * thread-default main context of the thread you are calling this
		 * method from) at some point after #user_data is no longer
		 * needed. (It is not guaranteed to be called synchronously when the
		 * filter is removed, and may be called after #connection has been
		 * destroyed.)
		 * @param filter_function a filter function
		 * @returns a filter identifier that can be used with
		 *     {@link G.dbus_connection_remove_filter}
		 */
		add_filter(filter_function: DBusMessageFilterFunction): number;
		/**
		 * Asynchronously invokes the #method_name method on the
		 * #interface_name D-Bus interface on the remote object at
		 * #object_path owned by #bus_name.
		 * 
		 * If #connection is closed then the operation will fail with
		 * %G_IO_ERROR_CLOSED. If #cancellable is canceled, the operation will
		 * fail with %G_IO_ERROR_CANCELLED. If #parameters contains a value
		 * not compatible with the D-Bus protocol, the operation fails with
		 * %G_IO_ERROR_INVALID_ARGUMENT.
		 * 
		 * If #reply_type is non-%NULL then the reply will be checked for having this type and an
		 * error will be raised if it does not match.  Said another way, if you give a #reply_type
		 * then any non-%NULL return value will be of this type. Unless it’s
		 * %G_VARIANT_TYPE_UNIT, the #reply_type will be a tuple containing one or more
		 * values.
		 * 
		 * If the #parameters #GVariant is floating, it is consumed. This allows
		 * convenient 'inline' use of {@link G.variant_new}, e.g.:
		 * |[<!-- language="C" -->
		 *  g_dbus_connection_call (connection,
		 *                          "org.freedesktop.StringThings",
		 *                          "/org/freedesktop/StringThings",
		 *                          "org.freedesktop.StringThings",
		 *                          "TwoStrings",
		 *                          g_variant_new ("(ss)",
		 *                                         "Thing One",
		 *                                         "Thing Two"),
		 *                          NULL,
		 *                          G_DBUS_CALL_FLAGS_NONE,
		 *                          -1,
		 *                          NULL,
		 *                          (GAsyncReadyCallback) two_strings_done,
		 *                          NULL);
		 * ]|
		 * 
		 * This is an asynchronous method. When the operation is finished,
		 * #callback will be invoked in the
		 * [thread-default main context][g-main-context-push-thread-default]
		 * of the thread you are calling this method from. You can then call
		 * g_dbus_connection_call_finish() to get the result of the operation.
		 * See g_dbus_connection_call_sync() for the synchronous version of this
		 * function.
		 * 
		 * If #callback is %NULL then the D-Bus method call message will be sent with
		 * the %G_DBUS_MESSAGE_FLAGS_NO_REPLY_EXPECTED flag set.
		 * @param bus_name a unique or well-known bus name or %NULL if
		 *     #connection is not a message bus connection
		 * @param object_path path of remote object
		 * @param interface_name D-Bus interface to invoke method on
		 * @param method_name the name of the method to invoke
		 * @param parameters a #GVariant tuple with parameters for the method
		 *     or %NULL if not passing parameters
		 * @param reply_type the expected type of the reply (which will be a
		 *     tuple), or %NULL
		 * @param flags flags from the #GDBusCallFlags enumeration
		 * @param timeout_msec the timeout in milliseconds, -1 to use the default
		 *     timeout or %G_MAXINT for no timeout
		 * @param cancellable a #GCancellable or %NULL
		 * @param callback a #GAsyncReadyCallback to call when the request
		 *     is satisfied or %NULL if you don't care about the result of the
		 *     method invocation
		 */
		call(bus_name: string | null, object_path: string, interface_name: string, method_name: string, parameters: GLib.Variant | null, reply_type: GLib.VariantType | null, flags: DBusCallFlags, timeout_msec: number, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;
		/**
		 * Finishes an operation started with {@link G.dbus_connection_call}.
		 * @param res a #GAsyncResult obtained from the #GAsyncReadyCallback passed to {@link G.dbus_connection_call}
		 * @returns %NULL if #error is set. Otherwise a non-floating
		 *     #GVariant tuple with return values. Free with {@link G.variant_unref}.
		 */
		call_finish(res: AsyncResult): GLib.Variant;
		/**
		 * Synchronously invokes the #method_name method on the
		 * #interface_name D-Bus interface on the remote object at
		 * #object_path owned by #bus_name.
		 * 
		 * If #connection is closed then the operation will fail with
		 * %G_IO_ERROR_CLOSED. If #cancellable is canceled, the
		 * operation will fail with %G_IO_ERROR_CANCELLED. If #parameters
		 * contains a value not compatible with the D-Bus protocol, the operation
		 * fails with %G_IO_ERROR_INVALID_ARGUMENT.
		 * 
		 * If #reply_type is non-%NULL then the reply will be checked for having
		 * this type and an error will be raised if it does not match.  Said
		 * another way, if you give a #reply_type then any non-%NULL return
		 * value will be of this type.
		 * 
		 * If the #parameters #GVariant is floating, it is consumed.
		 * This allows convenient 'inline' use of {@link G.variant_new}, e.g.:
		 * |[<!-- language="C" -->
		 *  g_dbus_connection_call_sync (connection,
		 *                               "org.freedesktop.StringThings",
		 *                               "/org/freedesktop/StringThings",
		 *                               "org.freedesktop.StringThings",
		 *                               "TwoStrings",
		 *                               g_variant_new ("(ss)",
		 *                                              "Thing One",
		 *                                              "Thing Two"),
		 *                               NULL,
		 *                               G_DBUS_CALL_FLAGS_NONE,
		 *                               -1,
		 *                               NULL,
		 *                               &error);
		 * ]|
		 * 
		 * The calling thread is blocked until a reply is received. See
		 * g_dbus_connection_call() for the asynchronous version of
		 * this method.
		 * @param bus_name a unique or well-known bus name or %NULL if
		 *     #connection is not a message bus connection
		 * @param object_path path of remote object
		 * @param interface_name D-Bus interface to invoke method on
		 * @param method_name the name of the method to invoke
		 * @param parameters a #GVariant tuple with parameters for the method
		 *     or %NULL if not passing parameters
		 * @param reply_type the expected type of the reply, or %NULL
		 * @param flags flags from the #GDBusCallFlags enumeration
		 * @param timeout_msec the timeout in milliseconds, -1 to use the default
		 *     timeout or %G_MAXINT for no timeout
		 * @param cancellable a #GCancellable or %NULL
		 * @returns %NULL if #error is set. Otherwise a non-floating
		 *     #GVariant tuple with return values. Free with {@link G.variant_unref}.
		 */
		call_sync(bus_name: string | null, object_path: string, interface_name: string, method_name: string, parameters: GLib.Variant | null, reply_type: GLib.VariantType | null, flags: DBusCallFlags, timeout_msec: number, cancellable?: Cancellable | null): GLib.Variant;
		/**
		 * Like {@link G.dbus_connection_call} but also takes a #GUnixFDList object.
		 * 
		 * The file descriptors normally correspond to %G_VARIANT_TYPE_HANDLE
		 * values in the body of the message. For example, if a message contains
		 * two file descriptors, #fd_list would have length 2, and
		 * `g_variant_new_handle (0)` and `g_variant_new_handle (1)` would appear
		 * somewhere in the body of the message (not necessarily in that order!)
		 * to represent the file descriptors at indexes 0 and 1 respectively.
		 * 
		 * When designing D-Bus APIs that are intended to be interoperable,
		 * please note that non-GDBus implementations of D-Bus can usually only
		 * access file descriptors if they are referenced in this way by a
		 * value of type %G_VARIANT_TYPE_HANDLE in the body of the message.
		 * 
		 * This method is only available on UNIX.
		 * @param bus_name a unique or well-known bus name or %NULL if
		 *     #connection is not a message bus connection
		 * @param object_path path of remote object
		 * @param interface_name D-Bus interface to invoke method on
		 * @param method_name the name of the method to invoke
		 * @param parameters a #GVariant tuple with parameters for the method
		 *     or %NULL if not passing parameters
		 * @param reply_type the expected type of the reply, or %NULL
		 * @param flags flags from the #GDBusCallFlags enumeration
		 * @param timeout_msec the timeout in milliseconds, -1 to use the default
		 *     timeout or %G_MAXINT for no timeout
		 * @param fd_list a #GUnixFDList or %NULL
		 * @param cancellable a #GCancellable or %NULL
		 * @param callback a #GAsyncReadyCallback to call when the request is
		 *     satisfied or %NULL if you don't * care about the result of the
		 *     method invocation
		 */
		call_with_unix_fd_list(bus_name: string | null, object_path: string, interface_name: string, method_name: string, parameters: GLib.Variant | null, reply_type: GLib.VariantType | null, flags: DBusCallFlags, timeout_msec: number, fd_list?: UnixFDList | null, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;
		/**
		 * Finishes an operation started with {@link G.dbus_connection_call_with_unix_fd_list}.
		 * 
		 * The file descriptors normally correspond to %G_VARIANT_TYPE_HANDLE
		 * values in the body of the message. For example,
		 * if g_variant_get_handle() returns 5, that is intended to be a reference
		 * to the file descriptor that can be accessed by
		 * `g_unix_fd_list_get (*out_fd_list, 5, ...)`.
		 * 
		 * When designing D-Bus APIs that are intended to be interoperable,
		 * please note that non-GDBus implementations of D-Bus can usually only
		 * access file descriptors if they are referenced in this way by a
		 * value of type %G_VARIANT_TYPE_HANDLE in the body of the message.
		 * @param res a #GAsyncResult obtained from the #GAsyncReadyCallback passed to
		 *     {@link G.dbus_connection_call_with_unix_fd_list}
		 * @returns %NULL if #error is set. Otherwise a non-floating
		 *     #GVariant tuple with return values. Free with {@link G.variant_unref}.
		 * 
		 * return location for a #GUnixFDList or %NULL
		 */
		call_with_unix_fd_list_finish(res: AsyncResult): [ GLib.Variant, UnixFDList | null ];
		/**
		 * Like {@link G.dbus_connection_call_sync} but also takes and returns #GUnixFDList objects.
		 * See g_dbus_connection_call_with_unix_fd_list() and
		 * g_dbus_connection_call_with_unix_fd_list_finish() for more details.
		 * 
		 * This method is only available on UNIX.
		 * @param bus_name a unique or well-known bus name or %NULL
		 *     if #connection is not a message bus connection
		 * @param object_path path of remote object
		 * @param interface_name D-Bus interface to invoke method on
		 * @param method_name the name of the method to invoke
		 * @param parameters a #GVariant tuple with parameters for
		 *     the method or %NULL if not passing parameters
		 * @param reply_type the expected type of the reply, or %NULL
		 * @param flags flags from the #GDBusCallFlags enumeration
		 * @param timeout_msec the timeout in milliseconds, -1 to use the default
		 *     timeout or %G_MAXINT for no timeout
		 * @param fd_list a #GUnixFDList or %NULL
		 * @param cancellable a #GCancellable or %NULL
		 * @returns %NULL if #error is set. Otherwise a non-floating
		 *     #GVariant tuple with return values. Free with {@link G.variant_unref}.
		 * 
		 * return location for a #GUnixFDList or %NULL
		 */
		call_with_unix_fd_list_sync(bus_name: string | null, object_path: string, interface_name: string, method_name: string, parameters: GLib.Variant | null, reply_type: GLib.VariantType | null, flags: DBusCallFlags, timeout_msec: number, fd_list?: UnixFDList | null, cancellable?: Cancellable | null): [ GLib.Variant, UnixFDList | null ];
		/**
		 * Closes #connection. Note that this never causes the process to
		 * exit (this might only happen if the other end of a shared message
		 * bus connection disconnects, see #GDBusConnection:exit-on-close).
		 * 
		 * Once the connection is closed, operations such as sending a message
		 * will return with the error %G_IO_ERROR_CLOSED. Closing a connection
		 * will not automatically flush the connection so queued messages may
		 * be lost. Use {@link G.dbus_connection_flush} if you need such guarantees.
		 * 
		 * If #connection is already closed, this method fails with
		 * %G_IO_ERROR_CLOSED.
		 * 
		 * When #connection has been closed, the #GDBusConnection::closed
		 * signal is emitted in the
		 * [thread-default main context][g-main-context-push-thread-default]
		 * of the thread that #connection was constructed in.
		 * 
		 * This is an asynchronous method. When the operation is finished,
		 * #callback will be invoked in the
		 * [thread-default main context][g-main-context-push-thread-default]
		 * of the thread you are calling this method from. You can
		 * then call g_dbus_connection_close_finish() to get the result of the
		 * operation. See g_dbus_connection_close_sync() for the synchronous
		 * version.
		 * @param cancellable a #GCancellable or %NULL
		 * @param callback a #GAsyncReadyCallback to call when the request is
		 *     satisfied or %NULL if you don't care about the result
		 */
		close(cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;
		/**
		 * Finishes an operation started with {@link G.dbus_connection_close}.
		 * @param res a #GAsyncResult obtained from the #GAsyncReadyCallback passed
		 *     to {@link G.dbus_connection_close}
		 * @returns %TRUE if the operation succeeded, %FALSE if #error is set
		 */
		close_finish(res: AsyncResult): boolean;
		/**
		 * Synchronously closes #connection. The calling thread is blocked
		 * until this is done. See {@link G.dbus_connection_close} for the
		 * asynchronous version of this method and more details about what it
		 * does.
		 * @param cancellable a #GCancellable or %NULL
		 * @returns %TRUE if the operation succeeded, %FALSE if #error is set
		 */
		close_sync(cancellable?: Cancellable | null): boolean;
		/**
		 * Emits a signal.
		 * 
		 * If the parameters GVariant is floating, it is consumed.
		 * 
		 * This can only fail if #parameters is not compatible with the D-Bus protocol
		 * (%G_IO_ERROR_INVALID_ARGUMENT), or if #connection has been closed
		 * (%G_IO_ERROR_CLOSED).
		 * @param destination_bus_name the unique bus name for the destination
		 *     for the signal or %NULL to emit to all listeners
		 * @param object_path path of remote object
		 * @param interface_name D-Bus interface to emit a signal on
		 * @param signal_name the name of the signal to emit
		 * @param parameters a #GVariant tuple with parameters for the signal
		 *              or %NULL if not passing parameters
		 * @returns %TRUE unless #error is set
		 */
		emit_signal(destination_bus_name: string | null, object_path: string, interface_name: string, signal_name: string, parameters?: GLib.Variant | null): boolean;
		/**
		 * Exports #action_group on #connection at #object_path.
		 * 
		 * The implemented D-Bus API should be considered private.  It is
		 * subject to change in the future.
		 * 
		 * A given object path can only have one action group exported on it.
		 * If this constraint is violated, the export will fail and 0 will be
		 * returned (with #error set accordingly).
		 * 
		 * You can unexport the action group using
		 * {@link G.dbus_connection_unexport_action_group} with the return value of
		 * this function.
		 * 
		 * The thread default main context is taken at the time of this call.
		 * All incoming action activations and state change requests are
		 * reported from this context.  Any changes on the action group that
		 * cause it to emit signals must also come from this same context.
		 * Since incoming action activations and state change requests are
		 * rather likely to cause changes on the action group, this effectively
		 * limits a given action group to being exported from only one main
		 * context.
		 * @param object_path a D-Bus object path
		 * @param action_group a #GActionGroup
		 * @returns the ID of the export (never zero), or 0 in case of failure
		 */
		export_action_group(object_path: string, action_group: ActionGroup): number;
		/**
		 * Exports #menu on #connection at #object_path.
		 * 
		 * The implemented D-Bus API should be considered private.
		 * It is subject to change in the future.
		 * 
		 * An object path can only have one menu model exported on it. If this
		 * constraint is violated, the export will fail and 0 will be
		 * returned (with #error set accordingly).
		 * 
		 * You can unexport the menu model using
		 * {@link G.dbus_connection_unexport_menu_model} with the return value of
		 * this function.
		 * @param object_path a D-Bus object path
		 * @param menu a #GMenuModel
		 * @returns the ID of the export (never zero), or 0 in case of failure
		 */
		export_menu_model(object_path: string, menu: MenuModel): number;
		/**
		 * Asynchronously flushes #connection, that is, writes all queued
		 * outgoing message to the transport and then flushes the transport
		 * (using {@link G.output_stream_flush_async}). This is useful in programs
		 * that wants to emit a D-Bus signal and then exit immediately. Without
		 * flushing the connection, there is no guaranteed that the message has
		 * been sent to the networking buffers in the OS kernel.
		 * 
		 * This is an asynchronous method. When the operation is finished,
		 * #callback will be invoked in the
		 * [thread-default main context][g-main-context-push-thread-default]
		 * of the thread you are calling this method from. You can
		 * then call g_dbus_connection_flush_finish() to get the result of the
		 * operation. See g_dbus_connection_flush_sync() for the synchronous
		 * version.
		 * @param cancellable a #GCancellable or %NULL
		 * @param callback a #GAsyncReadyCallback to call when the
		 *     request is satisfied or %NULL if you don't care about the result
		 */
		flush(cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;
		/**
		 * Finishes an operation started with {@link G.dbus_connection_flush}.
		 * @param res a #GAsyncResult obtained from the #GAsyncReadyCallback passed
		 *     to {@link G.dbus_connection_flush}
		 * @returns %TRUE if the operation succeeded, %FALSE if #error is set
		 */
		flush_finish(res: AsyncResult): boolean;
		/**
		 * Synchronously flushes #connection. The calling thread is blocked
		 * until this is done. See {@link G.dbus_connection_flush} for the
		 * asynchronous version of this method and more details about what it
		 * does.
		 * @param cancellable a #GCancellable or %NULL
		 * @returns %TRUE if the operation succeeded, %FALSE if #error is set
		 */
		flush_sync(cancellable?: Cancellable | null): boolean;
		/**
		 * Gets the capabilities negotiated with the remote peer
		 * @returns zero or more flags from the #GDBusCapabilityFlags enumeration
		 */
		get_capabilities(): DBusCapabilityFlags;
		/**
		 * Gets whether the process is terminated when #connection is
		 * closed by the remote peer. See
		 * #GDBusConnection:exit-on-close for more details.
		 * @returns whether the process is terminated when #connection is
		 *     closed by the remote peer
		 */
		get_exit_on_close(): boolean;
		/**
		 * Gets the flags used to construct this connection
		 * @returns zero or more flags from the #GDBusConnectionFlags enumeration
		 */
		get_flags(): DBusConnectionFlags;
		/**
		 * The GUID of the peer performing the role of server when
		 * authenticating. See #GDBusConnection:guid for more details.
		 * @returns The GUID. Do not free this string, it is owned by
		 *     #connection.
		 */
		get_guid(): string;
		/**
		 * Retrieves the last serial number assigned to a #GDBusMessage on
		 * the current thread. This includes messages sent via both low-level
		 * API such as {@link G.dbus_connection_send_message} as well as
		 * high-level API such as g_dbus_connection_emit_signal(),
		 * g_dbus_connection_call() or g_dbus_proxy_call().
		 * @returns the last used serial or zero when no message has been sent
		 *     within the current thread
		 */
		get_last_serial(): number;
		/**
		 * Gets the credentials of the authenticated peer. This will always
		 * return %NULL unless #connection acted as a server
		 * (e.g. %G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER was passed)
		 * when set up and the client passed credentials as part of the
		 * authentication process.
		 * 
		 * In a message bus setup, the message bus is always the server and
		 * each application is a client. So this method will always return
		 * %NULL for message bus clients.
		 * @returns a #GCredentials or %NULL if not
		 *     available. Do not free this object, it is owned by #connection.
		 */
		get_peer_credentials(): Credentials | null;
		/**
		 * Gets the underlying stream used for IO.
		 * 
		 * While the #GDBusConnection is active, it will interact with this
		 * stream from a worker thread, so it is not safe to interact with
		 * the stream directly.
		 * @returns the stream used for IO
		 */
		get_stream(): IOStream;
		/**
		 * Gets the unique name of #connection as assigned by the message
		 * bus. This can also be used to figure out if #connection is a
		 * message bus connection.
		 * @returns the unique name or %NULL if #connection is not a message
		 *     bus connection. Do not free this string, it is owned by
		 *     #connection.
		 */
		get_unique_name(): string | null;
		/**
		 * Gets whether #connection is closed.
		 * @returns %TRUE if the connection is closed, %FALSE otherwise
		 */
		is_closed(): boolean;
		/**
		 * Version of {@link G.dbus_connection_register_object} using closures instead of a
		 * #GDBusInterfaceVTable for easier binding in other languages.
		 * @param object_path The object path to register at.
		 * @param interface_info Introspection data for the interface.
		 * @param method_call_closure #GClosure for handling incoming method calls.
		 * @param get_property_closure #GClosure for getting a property.
		 * @param set_property_closure #GClosure for setting a property.
		 * @returns 0 if #error is set, otherwise a registration ID (never 0)
		 * that can be used with {@link G.dbus_connection_unregister_object} .
		 */
		register_object(object_path: string, interface_info: DBusInterfaceInfo, method_call_closure?: GObject.Closure | null, get_property_closure?: GObject.Closure | null, set_property_closure?: GObject.Closure | null): number;
		/**
		 * Registers a whole subtree of dynamic objects.
		 * 
		 * The #enumerate and #introspection functions in #vtable are used to
		 * convey, to remote callers, what nodes exist in the subtree rooted
		 * by #object_path.
		 * 
		 * When handling remote calls into any node in the subtree, first the
		 * #enumerate function is used to check if the node exists. If the node exists
		 * or the #G_DBUS_SUBTREE_FLAGS_DISPATCH_TO_UNENUMERATED_NODES flag is set
		 * the #introspection function is used to check if the node supports the
		 * requested method. If so, the #dispatch function is used to determine
		 * where to dispatch the call. The collected #GDBusInterfaceVTable and
		 * #gpointer will be used to call into the interface vtable for processing
		 * the request.
		 * 
		 * All calls into user-provided code will be invoked in the
		 * [thread-default main context][g-main-context-push-thread-default]
		 * of the thread you are calling this method from.
		 * 
		 * If an existing subtree is already registered at #object_path or
		 * then #error is set to #G_IO_ERROR_EXISTS.
		 * 
		 * Note that it is valid to register regular objects (using
		 * {@link G.dbus_connection_register_object}) in a subtree registered with
		 * g_dbus_connection_register_subtree() - if so, the subtree handler
		 * is tried as the last resort. One way to think about a subtree
		 * handler is to consider it a fallback handler for object paths not
		 * registered via g_dbus_connection_register_object() or other bindings.
		 * 
		 * Note that #vtable will be copied so you cannot change it after
		 * registration.
		 * 
		 * See this [server][gdbus-subtree-server] for an example of how to use
		 * this method.
		 * @param object_path the object path to register the subtree at
		 * @param vtable a #GDBusSubtreeVTable to enumerate, introspect and
		 *     dispatch nodes in the subtree
		 * @param flags flags used to fine tune the behavior of the subtree
		 * @param user_data data to pass to functions in #vtable
		 * @returns 0 if #error is set, otherwise a subtree registration ID (never 0)
		 * that can be used with {@link G.dbus_connection_unregister_subtree}
		 */
		register_subtree(object_path: string, vtable: DBusSubtreeVTable, flags: DBusSubtreeFlags, user_data?: any | null): number;
		/**
		 * Removes a filter.
		 * 
		 * Note that since filters run in a different thread, there is a race
		 * condition where it is possible that the filter will be running even
		 * after calling {@link G.dbus_connection_remove_filter}, so you cannot just
		 * free data that the filter might be using. Instead, you should pass
		 * a #GDestroyNotify to g_dbus_connection_add_filter(), which will be
		 * called when it is guaranteed that the data is no longer needed.
		 * @param filter_id an identifier obtained from {@link G.dbus_connection_add_filter}
		 */
		remove_filter(filter_id: number): void;
		/**
		 * Asynchronously sends #message to the peer represented by #connection.
		 * 
		 * Unless #flags contain the
		 * %G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag, the serial number
		 * will be assigned by #connection and set on #message via
		 * {@link G.dbus_message_set_serial}. If #out_serial is not %NULL, then the
		 * serial number used will be written to this location prior to
		 * submitting the message to the underlying transport. While it has a `volatile`
		 * qualifier, this is a historical artifact and the argument passed to it should
		 * not be `volatile`.
		 * 
		 * If #connection is closed then the operation will fail with
		 * %G_IO_ERROR_CLOSED. If #message is not well-formed,
		 * the operation fails with %G_IO_ERROR_INVALID_ARGUMENT.
		 * 
		 * See this [server][gdbus-server] and [client][gdbus-unix-fd-client]
		 * for an example of how to use this low-level API to send and receive
		 * UNIX file descriptors.
		 * 
		 * Note that #message must be unlocked, unless #flags contain the
		 * %G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag.
		 * @param message a #GDBusMessage
		 * @param flags flags affecting how the message is sent
		 * @returns %TRUE if the message was well-formed and queued for
		 *     transmission, %FALSE if #error is set
		 * 
		 * return location for serial number assigned
		 *     to #message when sending it or %NULL
		 */
		send_message(message: DBusMessage, flags: DBusSendMessageFlags): [ boolean, number | null ];
		/**
		 * Asynchronously sends #message to the peer represented by #connection.
		 * 
		 * Unless #flags contain the
		 * %G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag, the serial number
		 * will be assigned by #connection and set on #message via
		 * {@link G.dbus_message_set_serial}. If #out_serial is not %NULL, then the
		 * serial number used will be written to this location prior to
		 * submitting the message to the underlying transport. While it has a `volatile`
		 * qualifier, this is a historical artifact and the argument passed to it should
		 * not be `volatile`.
		 * 
		 * If #connection is closed then the operation will fail with
		 * %G_IO_ERROR_CLOSED. If #cancellable is canceled, the operation will
		 * fail with %G_IO_ERROR_CANCELLED. If #message is not well-formed,
		 * the operation fails with %G_IO_ERROR_INVALID_ARGUMENT.
		 * 
		 * This is an asynchronous method. When the operation is finished, #callback
		 * will be invoked in the
		 * [thread-default main context][g-main-context-push-thread-default]
		 * of the thread you are calling this method from. You can then call
		 * g_dbus_connection_send_message_with_reply_finish() to get the result of the operation.
		 * See g_dbus_connection_send_message_with_reply_sync() for the synchronous version.
		 * 
		 * Note that #message must be unlocked, unless #flags contain the
		 * %G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag.
		 * 
		 * See this [server][gdbus-server] and [client][gdbus-unix-fd-client]
		 * for an example of how to use this low-level API to send and receive
		 * UNIX file descriptors.
		 * @param message a #GDBusMessage
		 * @param flags flags affecting how the message is sent
		 * @param timeout_msec the timeout in milliseconds, -1 to use the default
		 *     timeout or %G_MAXINT for no timeout
		 * @param cancellable a #GCancellable or %NULL
		 * @param callback a #GAsyncReadyCallback to call when the request
		 *     is satisfied or %NULL if you don't care about the result
		 * @returns return location for serial number assigned
		 *     to #message when sending it or %NULL
		 */
		send_message_with_reply(message: DBusMessage, flags: DBusSendMessageFlags, timeout_msec: number, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): number | null;
		/**
		 * Finishes an operation started with {@link G.dbus_connection_send_message_with_reply}.
		 * 
		 * Note that #error is only set if a local in-process error
		 * occurred. That is to say that the returned #GDBusMessage object may
		 * be of type %G_DBUS_MESSAGE_TYPE_ERROR. Use
		 * g_dbus_message_to_gerror() to transcode this to a #GError.
		 * 
		 * See this [server][gdbus-server] and [client][gdbus-unix-fd-client]
		 * for an example of how to use this low-level API to send and receive
		 * UNIX file descriptors.
		 * @param res a #GAsyncResult obtained from the #GAsyncReadyCallback passed to
		 *     {@link G.dbus_connection_send_message_with_reply}
		 * @returns a locked #GDBusMessage or %NULL if #error is set
		 */
		send_message_with_reply_finish(res: AsyncResult): DBusMessage;
		/**
		 * Synchronously sends #message to the peer represented by #connection
		 * and blocks the calling thread until a reply is received or the
		 * timeout is reached. See {@link G.dbus_connection_send_message_with_reply}
		 * for the asynchronous version of this method.
		 * 
		 * Unless #flags contain the
		 * %G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag, the serial number
		 * will be assigned by #connection and set on #message via
		 * g_dbus_message_set_serial(). If #out_serial is not %NULL, then the
		 * serial number used will be written to this location prior to
		 * submitting the message to the underlying transport. While it has a `volatile`
		 * qualifier, this is a historical artifact and the argument passed to it should
		 * not be `volatile`.
		 * 
		 * If #connection is closed then the operation will fail with
		 * %G_IO_ERROR_CLOSED. If #cancellable is canceled, the operation will
		 * fail with %G_IO_ERROR_CANCELLED. If #message is not well-formed,
		 * the operation fails with %G_IO_ERROR_INVALID_ARGUMENT.
		 * 
		 * Note that #error is only set if a local in-process error
		 * occurred. That is to say that the returned #GDBusMessage object may
		 * be of type %G_DBUS_MESSAGE_TYPE_ERROR. Use
		 * g_dbus_message_to_gerror() to transcode this to a #GError.
		 * 
		 * See this [server][gdbus-server] and [client][gdbus-unix-fd-client]
		 * for an example of how to use this low-level API to send and receive
		 * UNIX file descriptors.
		 * 
		 * Note that #message must be unlocked, unless #flags contain the
		 * %G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag.
		 * @param message a #GDBusMessage
		 * @param flags flags affecting how the message is sent.
		 * @param timeout_msec the timeout in milliseconds, -1 to use the default
		 *     timeout or %G_MAXINT for no timeout
		 * @param cancellable a #GCancellable or %NULL
		 * @returns a locked #GDBusMessage that is the reply
		 *     to #message or %NULL if #error is set
		 * 
		 * return location for serial number
		 *     assigned to #message when sending it or %NULL
		 */
		send_message_with_reply_sync(message: DBusMessage, flags: DBusSendMessageFlags, timeout_msec: number, cancellable?: Cancellable | null): [ DBusMessage, number | null ];
		/**
		 * Sets whether the process should be terminated when #connection is
		 * closed by the remote peer. See #GDBusConnection:exit-on-close for
		 * more details.
		 * 
		 * Note that this function should be used with care. Most modern UNIX
		 * desktops tie the notion of a user session with the session bus, and expect
		 * all of a user's applications to quit when their bus connection goes away.
		 * If you are setting #exit_on_close to %FALSE for the shared session
		 * bus connection, you should make sure that your application exits
		 * when the user session ends.
		 * @param exit_on_close whether the process should be terminated
		 *     when #connection is closed by the remote peer
		 */
		set_exit_on_close(exit_on_close: boolean): void;
		/**
		 * Subscribes to signals on #connection and invokes #callback with a whenever
		 * the signal is received. Note that #callback will be invoked in the
		 * [thread-default main context][g-main-context-push-thread-default]
		 * of the thread you are calling this method from.
		 * 
		 * If #connection is not a message bus connection, #sender must be
		 * %NULL.
		 * 
		 * If #sender is a well-known name note that #callback is invoked with
		 * the unique name for the owner of #sender, not the well-known name
		 * as one would expect. This is because the message bus rewrites the
		 * name. As such, to avoid certain race conditions, users should be
		 * tracking the name owner of the well-known name and use that when
		 * processing the received signal.
		 * 
		 * If one of %G_DBUS_SIGNAL_FLAGS_MATCH_ARG0_NAMESPACE or
		 * %G_DBUS_SIGNAL_FLAGS_MATCH_ARG0_PATH are given, #arg0 is
		 * interpreted as part of a namespace or path.  The first argument
		 * of a signal is matched against that part as specified by D-Bus.
		 * 
		 * If #user_data_free_func is non-%NULL, it will be called (in the
		 * thread-default main context of the thread you are calling this
		 * method from) at some point after #user_data is no longer
		 * needed. (It is not guaranteed to be called synchronously when the
		 * signal is unsubscribed from, and may be called after #connection
		 * has been destroyed.)
		 * 
		 * As #callback is potentially invoked in a different thread from where it’s
		 * emitted, it’s possible for this to happen after
		 * {@link G.dbus_connection_signal_unsubscribe} has been called in another thread.
		 * Due to this, #user_data should have a strong reference which is freed with
		 * #user_data_free_func, rather than pointing to data whose lifecycle is tied
		 * to the signal subscription. For example, if a #GObject is used to store the
		 * subscription ID from g_dbus_connection_signal_subscribe(), a strong reference
		 * to that #GObject must be passed to #user_data, and g_object_unref() passed to
		 * #user_data_free_func. You are responsible for breaking the resulting
		 * reference count cycle by explicitly unsubscribing from the signal when
		 * dropping the last external reference to the #GObject. Alternatively, a weak
		 * reference may be used.
		 * 
		 * It is guaranteed that if you unsubscribe from a signal using
		 * g_dbus_connection_signal_unsubscribe() from the same thread which made the
		 * corresponding g_dbus_connection_signal_subscribe() call, #callback will not
		 * be invoked after g_dbus_connection_signal_unsubscribe() returns.
		 * 
		 * The returned subscription identifier is an opaque value which is guaranteed
		 * to never be zero.
		 * 
		 * This function can never fail.
		 * @param sender sender name to match on (unique or well-known name)
		 *     or %NULL to listen from all senders
		 * @param interface_name D-Bus interface name to match on or %NULL to
		 *     match on all interfaces
		 * @param member D-Bus signal name to match on or %NULL to match on
		 *     all signals
		 * @param object_path object path to match on or %NULL to match on
		 *     all object paths
		 * @param arg0 contents of first string argument to match on or %NULL
		 *     to match on all kinds of arguments
		 * @param flags #GDBusSignalFlags describing how arg0 is used in subscribing to the
		 *     signal
		 * @param callback callback to invoke when there is a signal matching the requested data
		 * @returns a subscription identifier that can be used with {@link G.dbus_connection_signal_unsubscribe}
		 */
		signal_subscribe(sender: string | null, interface_name: string | null, member: string | null, object_path: string | null, arg0: string | null, flags: DBusSignalFlags, callback: DBusSignalCallback): number;
		/**
		 * Unsubscribes from signals.
		 * 
		 * Note that there may still be D-Bus traffic to process (relating to this
		 * signal subscription) in the current thread-default #GMainContext after this
		 * function has returned. You should continue to iterate the #GMainContext
		 * until the #GDestroyNotify function passed to
		 * {@link G.dbus_connection_signal_subscribe} is called, in order to avoid memory
		 * leaks through callbacks queued on the #GMainContext after it’s stopped being
		 * iterated.
		 * Alternatively, any idle source with a priority lower than %G_PRIORITY_DEFAULT
		 * that was scheduled after unsubscription, also indicates that all resources
		 * of this subscription are released.
		 * @param subscription_id a subscription id obtained from
		 *     {@link G.dbus_connection_signal_subscribe}
		 */
		signal_unsubscribe(subscription_id: number): void;
		/**
		 * If #connection was created with
		 * %G_DBUS_CONNECTION_FLAGS_DELAY_MESSAGE_PROCESSING, this method
		 * starts processing messages. Does nothing on if #connection wasn't
		 * created with this flag or if the method has already been called.
		 */
		start_message_processing(): void;
		/**
		 * Reverses the effect of a previous call to
		 * {@link G.dbus_connection_export_action_group}.
		 * 
		 * It is an error to call this function with an ID that wasn't returned
		 * from g_dbus_connection_export_action_group() or to call it with the
		 * same ID more than once.
		 * @param export_id the ID from {@link G.dbus_connection_export_action_group}
		 */
		unexport_action_group(export_id: number): void;
		/**
		 * Reverses the effect of a previous call to
		 * {@link G.dbus_connection_export_menu_model}.
		 * 
		 * It is an error to call this function with an ID that wasn't returned
		 * from g_dbus_connection_export_menu_model() or to call it with the
		 * same ID more than once.
		 * @param export_id the ID from {@link G.dbus_connection_export_menu_model}
		 */
		unexport_menu_model(export_id: number): void;
		/**
		 * Unregisters an object.
		 * @param registration_id a registration id obtained from
		 *     {@link G.dbus_connection_register_object}
		 * @returns %TRUE if the object was unregistered, %FALSE otherwise
		 */
		unregister_object(registration_id: number): boolean;
		/**
		 * Unregisters a subtree.
		 * @param registration_id a subtree registration id obtained from
		 *     {@link G.dbus_connection_register_subtree}
		 * @returns %TRUE if the subtree was unregistered, %FALSE otherwise
		 */
		unregister_subtree(registration_id: number): boolean;
		/**
		 * Emitted when the connection is closed.
		 * 
		 * The cause of this event can be
		 * 
		 * - If {@link G.dbus_connection_close} is called. In this case
		 *   #remote_peer_vanished is set to %FALSE and #error is %NULL.
		 * 
		 * - If the remote peer closes the connection. In this case
		 *   #remote_peer_vanished is set to %TRUE and #error is set.
		 * 
		 * - If the remote peer sends invalid or malformed data. In this
		 *   case #remote_peer_vanished is set to %FALSE and #error is set.
		 * 
		 * Upon receiving this signal, you should give up your reference to
		 * #connection. You are guaranteed that this signal is emitted only
		 * once.
		 * @param signal 
		 * @param callback Callback function
		 *  - owner: owner of the emitted event 
		 *  - remote_peer_vanished: %TRUE if #connection is closed because the
		 *     remote peer closed its end of the connection 
		 *  - error: a #GError with more details about the event or %NULL 
		 * 
		 * @returns Callback ID
		 */
		connect(signal: "closed", callback: (owner: this, remote_peer_vanished: boolean, error: GLib.Error | null) => void): number;

		connect(signal: "notify::capabilities", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::closed", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::exit-on-close", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::flags", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::guid", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::stream", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::unique-name", callback: (owner: this, ...args: any) => void): number;

	}

	type DBusConnectionInitOptionsMixin = GObject.ObjectInitOptions & AsyncInitableInitOptions & InitableInitOptions & 
	Pick<IDBusConnection,
		"exit_on_close" |
		"flags" |
		"guid" |
		"stream">;

	export interface DBusConnectionInitOptions extends DBusConnectionInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link DBusConnection} instead.
	 */
	type DBusConnectionMixin = IDBusConnection & GObject.Object & AsyncInitable & Initable;

	/**
	 * The #GDBusConnection type is used for D-Bus connections to remote
	 * peers such as a message buses. It is a low-level API that offers a
	 * lot of flexibility. For instance, it lets you establish a connection
	 * over any transport that can by represented as a #GIOStream.
	 * 
	 * This class is rarely used directly in D-Bus clients. If you are writing
	 * a D-Bus client, it is often easier to use the {@link G.bus_own_name},
	 * g_bus_watch_name() or g_dbus_proxy_new_for_bus() APIs.
	 * 
	 * As an exception to the usual GLib rule that a particular object must not
	 * be used by two threads at the same time, #GDBusConnection's methods may be
	 * called from any thread. This is so that g_bus_get() and g_bus_get_sync()
	 * can safely return the same #GDBusConnection when called from any thread.
	 * 
	 * Most of the ways to obtain a #GDBusConnection automatically initialize it
	 * (i.e. connect to D-Bus): for instance, g_dbus_connection_new() and
	 * g_bus_get(), and the synchronous versions of those methods, give you an
	 * initialized connection. Language bindings for GIO should use
	 * g_initable_new() or g_async_initable_new_async(), which also initialize the
	 * connection.
	 * 
	 * If you construct an uninitialized #GDBusConnection, such as via
	 * g_object_new(), you must initialize it via g_initable_init() or
	 * g_async_initable_init_async() before using its methods or properties.
	 * Calling methods or accessing properties on a #GDBusConnection that has not
	 * completed initialization successfully is considered to be invalid, and leads
	 * to undefined behaviour. In particular, if initialization fails with a
	 * #GError, the only valid thing you can do with that #GDBusConnection is to
	 * free it with g_object_unref().
	 * 
	 * ## An example D-Bus server # {#gdbus-server}
	 * 
	 * Here is an example for a D-Bus server:
	 * [gdbus-example-server.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gdbus-example-server.c)
	 * 
	 * ## An example for exporting a subtree # {#gdbus-subtree-server}
	 * 
	 * Here is an example for exporting a subtree:
	 * [gdbus-example-subtree.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gdbus-example-subtree.c)
	 * 
	 * ## An example for file descriptor passing # {#gdbus-unix-fd-client}
	 * 
	 * Here is an example for passing UNIX file descriptors:
	 * [gdbus-unix-fd-client.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gdbus-example-unix-fd-client.c)
	 * 
	 * ## An example for exporting a GObject # {#gdbus-export}
	 * 
	 * Here is an example for exporting a #GObject:
	 * [gdbus-example-export.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gdbus-example-export.c)
	 */
	interface DBusConnection extends DBusConnectionMixin {}

	class DBusConnection {
		public constructor(options?: Partial<DBusConnectionInitOptions>);
		/**
		 * Finishes an operation started with {@link G.dbus_connection_new}.
		 * @param res a #GAsyncResult obtained from the #GAsyncReadyCallback
		 *     passed to {@link G.dbus_connection_new}.
		 * @returns a #GDBusConnection or %NULL if #error is set. Free
		 *     with {@link GObject.unref}.
		 */
		public static new_finish(res: AsyncResult): DBusConnection;
		/**
		 * Finishes an operation started with {@link G.dbus_connection_new_for_address}.
		 * @param res a #GAsyncResult obtained from the #GAsyncReadyCallback passed
		 *     to {@link G.dbus_connection_new}
		 * @returns a #GDBusConnection or %NULL if #error is set.
		 *     Free with {@link GObject.unref}.
		 */
		public static new_for_address_finish(res: AsyncResult): DBusConnection;
		/**
		 * Synchronously connects and sets up a D-Bus client connection for
		 * exchanging D-Bus messages with an endpoint specified by #address
		 * which must be in the
		 * [D-Bus address format](https://dbus.freedesktop.org/doc/dbus-specification.html#addresses).
		 * 
		 * This constructor can only be used to initiate client-side
		 * connections - use {@link G.dbus_connection_new_sync} if you need to act
		 * as the server. In particular, #flags cannot contain the
		 * %G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER,
		 * %G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_ALLOW_ANONYMOUS or
		 * %G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_REQUIRE_SAME_USER flags.
		 * 
		 * This is a synchronous failable constructor. See
		 * g_dbus_connection_new_for_address() for the asynchronous version.
		 * 
		 * If #observer is not %NULL it may be used to control the
		 * authentication process.
		 * @param address a D-Bus address
		 * @param flags flags describing how to make the connection
		 * @param observer a #GDBusAuthObserver or %NULL
		 * @param cancellable a #GCancellable or %NULL
		 * @returns a #GDBusConnection or %NULL if #error is set.
		 *     Free with {@link GObject.unref}.
		 */
		public static new_for_address_sync(address: string, flags: DBusConnectionFlags, observer?: DBusAuthObserver | null, cancellable?: Cancellable | null): DBusConnection;
		/**
		 * Synchronously sets up a D-Bus connection for exchanging D-Bus messages
		 * with the end represented by #stream.
		 * 
		 * If #stream is a #GSocketConnection, then the corresponding #GSocket
		 * will be put into non-blocking mode.
		 * 
		 * The D-Bus connection will interact with #stream from a worker thread.
		 * As a result, the caller should not interact with #stream after this
		 * method has been called, except by calling {@link GObject.unref} on it.
		 * 
		 * If #observer is not %NULL it may be used to control the
		 * authentication process.
		 * 
		 * This is a synchronous failable constructor. See
		 * g_dbus_connection_new() for the asynchronous version.
		 * @param stream a #GIOStream
		 * @param guid the GUID to use if authenticating as a server or %NULL
		 * @param flags flags describing how to make the connection
		 * @param observer a #GDBusAuthObserver or %NULL
		 * @param cancellable a #GCancellable or %NULL
		 * @returns a #GDBusConnection or %NULL if #error is set.
		 *     Free with {@link GObject.unref}.
		 */
		public static new_sync(stream: IOStream, guid: string | null, flags: DBusConnectionFlags, observer?: DBusAuthObserver | null, cancellable?: Cancellable | null): DBusConnection;
		/**
		 * Asynchronously sets up a D-Bus connection for exchanging D-Bus messages
		 * with the end represented by #stream.
		 * 
		 * If #stream is a #GSocketConnection, then the corresponding #GSocket
		 * will be put into non-blocking mode.
		 * 
		 * The D-Bus connection will interact with #stream from a worker thread.
		 * As a result, the caller should not interact with #stream after this
		 * method has been called, except by calling {@link GObject.unref} on it.
		 * 
		 * If #observer is not %NULL it may be used to control the
		 * authentication process.
		 * 
		 * When the operation is finished, #callback will be invoked. You can
		 * then call g_dbus_connection_new_finish() to get the result of the
		 * operation.
		 * 
		 * This is an asynchronous failable constructor. See
		 * g_dbus_connection_new_sync() for the synchronous
		 * version.
		 * @param stream a #GIOStream
		 * @param guid the GUID to use if authenticating as a server or %NULL
		 * @param flags flags describing how to make the connection
		 * @param observer a #GDBusAuthObserver or %NULL
		 * @param cancellable a #GCancellable or %NULL
		 * @param callback a #GAsyncReadyCallback to call when the request is satisfied
		 */
		public static new(stream: IOStream, guid: string | null, flags: DBusConnectionFlags, observer?: DBusAuthObserver | null, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;
		/**
		 * Asynchronously connects and sets up a D-Bus client connection for
		 * exchanging D-Bus messages with an endpoint specified by #address
		 * which must be in the
		 * [D-Bus address format](https://dbus.freedesktop.org/doc/dbus-specification.html#addresses).
		 * 
		 * This constructor can only be used to initiate client-side
		 * connections - use {@link G.dbus_connection_new} if you need to act as the
		 * server. In particular, #flags cannot contain the
		 * %G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER,
		 * %G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_ALLOW_ANONYMOUS or
		 * %G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_REQUIRE_SAME_USER flags.
		 * 
		 * When the operation is finished, #callback will be invoked. You can
		 * then call g_dbus_connection_new_for_address_finish() to get the result of
		 * the operation.
		 * 
		 * If #observer is not %NULL it may be used to control the
		 * authentication process.
		 * 
		 * This is an asynchronous failable constructor. See
		 * g_dbus_connection_new_for_address_sync() for the synchronous
		 * version.
		 * @param address a D-Bus address
		 * @param flags flags describing how to make the connection
		 * @param observer a #GDBusAuthObserver or %NULL
		 * @param cancellable a #GCancellable or %NULL
		 * @param callback a #GAsyncReadyCallback to call when the request is satisfied
		 */
		public static new_for_address(address: string, flags: DBusConnectionFlags, observer?: DBusAuthObserver | null, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;
	}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link DBusInterfaceSkeleton} instead.
	 */
	interface IDBusInterfaceSkeleton {
		/**
		 * Flags from the #GDBusInterfaceSkeletonFlags enumeration.
		 */
		g_flags: DBusInterfaceSkeletonFlags;
		/**
		 * Exports #interface_ at #object_path on #connection.
		 * 
		 * This can be called multiple times to export the same #interface_
		 * onto multiple connections however the #object_path provided must be
		 * the same for all connections.
		 * 
		 * Use {@link G.dbus_interface_skeleton_unexport} to unexport the object.
		 * @param connection A #GDBusConnection to export #interface_ on.
		 * @param object_path The path to export the interface at.
		 * @returns %TRUE if the interface was exported on #connection, otherwise %FALSE with
		 * #error set.
		 */
		export(connection: DBusConnection, object_path: string): boolean;
		/**
		 * If #interface_ has outstanding changes, request for these changes to be
		 * emitted immediately.
		 * 
		 * For example, an exported D-Bus interface may queue up property
		 * changes and emit the
		 * `org.freedesktop.DBus.Properties.PropertiesChanged`
		 * signal later (e.g. in an idle handler). This technique is useful
		 * for collapsing multiple property changes into one.
		 */
		flush(): void;
		/**
		 * Gets the first connection that #interface_ is exported on, if any.
		 * @returns A #GDBusConnection or %NULL if #interface_ is
		 * not exported anywhere. Do not free, the object belongs to #interface_.
		 */
		get_connection(): DBusConnection | null;
		/**
		 * Gets a list of the connections that #interface_ is exported on.
		 * @returns A list of
		 *   all the connections that #interface_ is exported on. The returned
		 *   list should be freed with {@link G.list_free} after each element has
		 *   been freed with g_object_unref().
		 */
		get_connections(): DBusConnection[];
		/**
		 * Gets the #GDBusInterfaceSkeletonFlags that describes what the behavior
		 * of #interface_
		 * @returns One or more flags from the #GDBusInterfaceSkeletonFlags enumeration.
		 */
		get_flags(): DBusInterfaceSkeletonFlags;
		/**
		 * Gets D-Bus introspection information for the D-Bus interface
		 * implemented by #interface_.
		 * @returns A #GDBusInterfaceInfo (never %NULL). Do not free.
		 */
		get_info(): DBusInterfaceInfo;
		/**
		 * Gets the object path that #interface_ is exported on, if any.
		 * @returns A string owned by #interface_ or %NULL if #interface_ is not exported
		 * anywhere. Do not free, the string belongs to #interface_.
		 */
		get_object_path(): string | null;
		/**
		 * Gets all D-Bus properties for #interface_.
		 * @returns A #GVariant of type
		 * ['a{sv}'][G-VARIANT-TYPE-VARDICT:CAPS].
		 * Free with {@link G.variant_unref}.
		 */
		get_properties(): GLib.Variant;
		/**
		 * Gets the interface vtable for the D-Bus interface implemented by
		 * #interface_. The returned function pointers should expect #interface_
		 * itself to be passed as #user_data.
		 * @returns A #GDBusInterfaceVTable (never %NULL).
		 */
		get_vtable(): DBusInterfaceVTable;
		/**
		 * Checks if #interface_ is exported on #connection.
		 * @param connection A #GDBusConnection.
		 * @returns %TRUE if #interface_ is exported on #connection, %FALSE otherwise.
		 */
		has_connection(connection: DBusConnection): boolean;
		/**
		 * Sets flags describing what the behavior of #skeleton should be.
		 * @param flags Flags from the #GDBusInterfaceSkeletonFlags enumeration.
		 */
		set_flags(flags: DBusInterfaceSkeletonFlags): void;
		/**
		 * Stops exporting #interface_ on all connections it is exported on.
		 * 
		 * To unexport #interface_ from only a single connection, use
		 * {@link G.dbus_interface_skeleton_unexport_from_connection}
		 */
		unexport(): void;
		/**
		 * Stops exporting #interface_ on #connection.
		 * 
		 * To stop exporting on all connections the interface is exported on,
		 * use {@link G.dbus_interface_skeleton_unexport}.
		 * @param connection A #GDBusConnection.
		 */
		unexport_from_connection(connection: DBusConnection): void;
		/**
		 * Emitted when a method is invoked by a remote caller and used to
		 * determine if the method call is authorized.
		 * 
		 * Note that this signal is emitted in a thread dedicated to
		 * handling the method call so handlers are allowed to perform
		 * blocking IO. This means that it is appropriate to call e.g.
		 * {@link [polkit.authority_check_authorization_sync}](http://hal.freedesktop.org/docs/polkit/PolkitAuthority.html#polkit-authority-check-authorization-sync)
		 * with the
		 * [POLKIT_CHECK_AUTHORIZATION_FLAGS_ALLOW_USER_INTERACTION](http://hal.freedesktop.org/docs/polkit/PolkitAuthority.html#POLKIT-CHECK-AUTHORIZATION-FLAGS-ALLOW-USER-INTERACTION:CAPS)
		 * flag set.
		 * 
		 * If %FALSE is returned then no further handlers are run and the
		 * signal handler must take a reference to #invocation and finish
		 * handling the call (e.g. return an error via
		 * g_dbus_method_invocation_return_error()).
		 * 
		 * Otherwise, if %TRUE is returned, signal emission continues. If no
		 * handlers return %FALSE, then the method is dispatched. If
		 * #interface has an enclosing #GDBusObjectSkeleton, then the
		 * #GDBusObjectSkeleton::authorize-method signal handlers run before
		 * the handlers for this signal.
		 * 
		 * The default class handler just returns %TRUE.
		 * 
		 * Please note that the common case is optimized: if no signals
		 * handlers are connected and the default class handler isn't
		 * overridden (for both #interface and the enclosing
		 * #GDBusObjectSkeleton, if any) and #GDBusInterfaceSkeleton:g-flags does
		 * not have the
		 * %G_DBUS_INTERFACE_SKELETON_FLAGS_HANDLE_METHOD_INVOCATIONS_IN_THREAD
		 * flags set, no dedicated thread is ever used and the call will be
		 * handled in the same thread as the object that #interface belongs
		 * to was exported in.
		 * @param signal 
		 * @param callback Callback function
		 *  - owner: owner of the emitted event 
		 *  - invocation: A #GDBusMethodInvocation. 
		 *  - returns %TRUE if the call is authorized, %FALSE otherwise. 
		 * 
		 * @returns Callback ID
		 */
		connect(signal: "g-authorize-method", callback: (owner: this, invocation: DBusMethodInvocation) => boolean): number;

		connect(signal: "notify::g-flags", callback: (owner: this, ...args: any) => void): number;

	}

	type DBusInterfaceSkeletonInitOptionsMixin = GObject.ObjectInitOptions & DBusInterfaceInitOptions & 
	Pick<IDBusInterfaceSkeleton,
		"g_flags">;

	export interface DBusInterfaceSkeletonInitOptions extends DBusInterfaceSkeletonInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link DBusInterfaceSkeleton} instead.
	 */
	type DBusInterfaceSkeletonMixin = IDBusInterfaceSkeleton & GObject.Object & DBusInterface;

	/**
	 * Abstract base class for D-Bus interfaces on the service side.
	 */
	interface DBusInterfaceSkeleton extends DBusInterfaceSkeletonMixin {}

	class DBusInterfaceSkeleton {
		public constructor(options?: Partial<DBusInterfaceSkeletonInitOptions>);
	}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link DBusMenuModel} instead.
	 */
	interface IDBusMenuModel {

	}

	type DBusMenuModelInitOptionsMixin = MenuModelInitOptions
	export interface DBusMenuModelInitOptions extends DBusMenuModelInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link DBusMenuModel} instead.
	 */
	type DBusMenuModelMixin = IDBusMenuModel & MenuModel;

	/**
	 * #GDBusMenuModel is an implementation of #GMenuModel that can be used
	 * as a proxy for a menu model that is exported over D-Bus with
	 * {@link G.dbus_connection_export_menu_model}.
	 */
	interface DBusMenuModel extends DBusMenuModelMixin {}

	class DBusMenuModel {
		public constructor(options?: Partial<DBusMenuModelInitOptions>);
		/**
		 * Obtains a #GDBusMenuModel for the menu model which is exported
		 * at the given #bus_name and #object_path.
		 * 
		 * The thread default main context is taken at the time of this call.
		 * All signals on the menu model (and any linked models) are reported
		 * with respect to this context.  All calls on the returned menu model
		 * (and linked models) must also originate from this same context, with
		 * the thread default main context unchanged.
		 * @param connection a #GDBusConnection
		 * @param bus_name the bus name which exports the menu model
		 *     or %NULL if #connection is not a message bus connection
		 * @param object_path the object path at which the menu model is exported
		 * @returns a #GDBusMenuModel object. Free with
		 *     {@link GObject.unref}.
		 */
		public static get(connection: DBusConnection, bus_name: string | null, object_path: string): DBusMenuModel;
	}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link DBusMessage} instead.
	 */
	interface IDBusMessage {
		readonly locked: boolean;
		/**
		 * Copies #message. The copy is a deep copy and the returned
		 * #GDBusMessage is completely identical except that it is guaranteed
		 * to not be locked.
		 * 
		 * This operation can fail if e.g. #message contains file descriptors
		 * and the per-process or system-wide open files limit is reached.
		 * @returns A new #GDBusMessage or %NULL if #error is set.
		 *     Free with {@link GObject.unref}.
		 */
		copy(): DBusMessage;
		/**
		 * Convenience to get the first item in the body of #message.
		 * @returns The string item or %NULL if the first item in the body of
		 * #message is not a string.
		 */
		get_arg0(): string | null;
		/**
		 * Gets the body of a message.
		 * @returns A #GVariant or %NULL if the body is
		 * empty. Do not free, it is owned by #message.
		 */
		get_body(): GLib.Variant | null;
		/**
		 * Gets the byte order of #message.
		 * @returns The byte order.
		 */
		get_byte_order(): DBusMessageByteOrder;
		/**
		 * Convenience getter for the %G_DBUS_MESSAGE_HEADER_FIELD_DESTINATION header field.
		 * @returns The value.
		 */
		get_destination(): string | null;
		/**
		 * Convenience getter for the %G_DBUS_MESSAGE_HEADER_FIELD_ERROR_NAME header field.
		 * @returns The value.
		 */
		get_error_name(): string | null;
		/**
		 * Gets the flags for #message.
		 * @returns Flags that are set (typically values from the #GDBusMessageFlags enumeration bitwise ORed together).
		 */
		get_flags(): DBusMessageFlags;
		/**
		 * Gets a header field on #message.
		 * 
		 * The caller is responsible for checking the type of the returned #GVariant
		 * matches what is expected.
		 * @param header_field A 8-bit unsigned integer (typically a value from the #GDBusMessageHeaderField enumeration)
		 * @returns A #GVariant with the value if the header was found, %NULL
		 * otherwise. Do not free, it is owned by #message.
		 */
		get_header(header_field: DBusMessageHeaderField): GLib.Variant | null;
		/**
		 * Gets an array of all header fields on #message that are set.
		 * @returns An array of header fields
		 * terminated by %G_DBUS_MESSAGE_HEADER_FIELD_INVALID.  Each element
		 * is a #guchar. Free with {@link G.free}.
		 */
		get_header_fields(): number[];
		/**
		 * Convenience getter for the %G_DBUS_MESSAGE_HEADER_FIELD_INTERFACE header field.
		 * @returns The value.
		 */
		get_interface(): string | null;
		/**
		 * Checks whether #message is locked. To monitor changes to this
		 * value, conncet to the #GObject::notify signal to listen for changes
		 * on the #GDBusMessage:locked property.
		 * @returns %TRUE if #message is locked, %FALSE otherwise.
		 */
		get_locked(): boolean;
		/**
		 * Convenience getter for the %G_DBUS_MESSAGE_HEADER_FIELD_MEMBER header field.
		 * @returns The value.
		 */
		get_member(): string | null;
		/**
		 * Gets the type of #message.
		 * @returns A 8-bit unsigned integer (typically a value from the #GDBusMessageType enumeration).
		 */
		get_message_type(): DBusMessageType;
		/**
		 * Convenience getter for the %G_DBUS_MESSAGE_HEADER_FIELD_NUM_UNIX_FDS header field.
		 * @returns The value.
		 */
		get_num_unix_fds(): number;
		/**
		 * Convenience getter for the %G_DBUS_MESSAGE_HEADER_FIELD_PATH header field.
		 * @returns The value.
		 */
		get_path(): string | null;
		/**
		 * Convenience getter for the %G_DBUS_MESSAGE_HEADER_FIELD_REPLY_SERIAL header field.
		 * @returns The value.
		 */
		get_reply_serial(): number;
		/**
		 * Convenience getter for the %G_DBUS_MESSAGE_HEADER_FIELD_SENDER header field.
		 * @returns The value.
		 */
		get_sender(): string | null;
		/**
		 * Gets the serial for #message.
		 * @returns A #guint32.
		 */
		get_serial(): number;
		/**
		 * Convenience getter for the %G_DBUS_MESSAGE_HEADER_FIELD_SIGNATURE header field.
		 * 
		 * This will always be non-%NULL, but may be an empty string.
		 * @returns The value.
		 */
		get_signature(): string;
		/**
		 * Gets the UNIX file descriptors associated with #message, if any.
		 * 
		 * This method is only available on UNIX.
		 * 
		 * The file descriptors normally correspond to %G_VARIANT_TYPE_HANDLE
		 * values in the body of the message. For example,
		 * if {@link G.variant_get_handle} returns 5, that is intended to be a reference
		 * to the file descriptor that can be accessed by
		 * `g_unix_fd_list_get (list, 5, ...)`.
		 * @returns A #GUnixFDList or %NULL if no file descriptors are
		 * associated. Do not free, this object is owned by #message.
		 */
		get_unix_fd_list(): UnixFDList | null;
		/**
		 * If #message is locked, does nothing. Otherwise locks the message.
		 */
		lock(): void;
		/**
		 * Creates a new #GDBusMessage that is an error reply to #method_call_message.
		 * @param error_name A valid D-Bus error name.
		 * @param error_message_format The D-Bus error message in a printf() format.
		 * @returns A #GDBusMessage. Free with {@link GObject.unref}.
		 */
		new_method_error(error_name: string, error_message_format: string): DBusMessage;
		/**
		 * Creates a new #GDBusMessage that is an error reply to #method_call_message.
		 * @param error_name A valid D-Bus error name.
		 * @param error_message The D-Bus error message.
		 * @returns A #GDBusMessage. Free with {@link GObject.unref}.
		 */
		new_method_error_literal(error_name: string, error_message: string): DBusMessage;
		/**
		 * Like {@link G.dbus_message_new_method_error} but intended for language bindings.
		 * @param error_name A valid D-Bus error name.
		 * @param error_message_format The D-Bus error message in a printf() format.
		 * @param var_args Arguments for #error_message_format.
		 * @returns A #GDBusMessage. Free with {@link GObject.unref}.
		 */
		new_method_error_valist(error_name: string, error_message_format: string, var_args: any[]): DBusMessage;
		/**
		 * Creates a new #GDBusMessage that is a reply to #method_call_message.
		 * @returns #GDBusMessage. Free with {@link GObject.unref}.
		 */
		new_method_reply(): DBusMessage;
		/**
		 * Produces a human-readable multi-line description of #message.
		 * 
		 * The contents of the description has no ABI guarantees, the contents
		 * and formatting is subject to change at any time. Typical output
		 * looks something like this:
		 * |[
		 * Flags:   none
		 * Version: 0
		 * Serial:  4
		 * Headers:
		 *   path -> objectpath '/org/gtk/GDBus/TestObject'
		 *   interface -> 'org.gtk.GDBus.TestInterface'
		 *   member -> 'GimmeStdout'
		 *   destination -> ':1.146'
		 * Body: ()
		 * UNIX File Descriptors:
		 *   (none)
		 * ]|
		 * or
		 * |[
		 * Flags:   no-reply-expected
		 * Version: 0
		 * Serial:  477
		 * Headers:
		 *   reply-serial -> uint32 4
		 *   destination -> ':1.159'
		 *   sender -> ':1.146'
		 *   num-unix-fds -> uint32 1
		 * Body: ()
		 * UNIX File Descriptors:
		 *   fd 12: dev=0:10,mode=020620,ino=5,uid=500,gid=5,rdev=136:2,size=0,atime=1273085037,mtime=1273085851,ctime=1272982635
		 * ]|
		 * @param indent Indentation level.
		 * @returns A string that should be freed with {@link G.free}.
		 */
		print(indent: number): string;
		/**
		 * Sets the body #message. As a side-effect the
		 * %G_DBUS_MESSAGE_HEADER_FIELD_SIGNATURE header field is set to the
		 * type string of #body (or cleared if #body is %NULL).
		 * 
		 * If #body is floating, #message assumes ownership of #body.
		 * @param body Either %NULL or a #GVariant that is a tuple.
		 */
		set_body(body: GLib.Variant): void;
		/**
		 * Sets the byte order of #message.
		 * @param byte_order The byte order.
		 */
		set_byte_order(byte_order: DBusMessageByteOrder): void;
		/**
		 * Convenience setter for the %G_DBUS_MESSAGE_HEADER_FIELD_DESTINATION header field.
		 * @param value The value to set.
		 */
		set_destination(value?: string | null): void;
		/**
		 * Convenience setter for the %G_DBUS_MESSAGE_HEADER_FIELD_ERROR_NAME header field.
		 * @param value The value to set.
		 */
		set_error_name(value: string): void;
		/**
		 * Sets the flags to set on #message.
		 * @param flags Flags for #message that are set (typically values from the #GDBusMessageFlags
		 * enumeration bitwise ORed together).
		 */
		set_flags(flags: DBusMessageFlags): void;
		/**
		 * Sets a header field on #message.
		 * 
		 * If #value is floating, #message assumes ownership of #value.
		 * @param header_field A 8-bit unsigned integer (typically a value from the #GDBusMessageHeaderField enumeration)
		 * @param value A #GVariant to set the header field or %NULL to clear the header field.
		 */
		set_header(header_field: DBusMessageHeaderField, value?: GLib.Variant | null): void;
		/**
		 * Convenience setter for the %G_DBUS_MESSAGE_HEADER_FIELD_INTERFACE header field.
		 * @param value The value to set.
		 */
		set_interface(value?: string | null): void;
		/**
		 * Convenience setter for the %G_DBUS_MESSAGE_HEADER_FIELD_MEMBER header field.
		 * @param value The value to set.
		 */
		set_member(value?: string | null): void;
		/**
		 * Sets #message to be of #type.
		 * @param type A 8-bit unsigned integer (typically a value from the #GDBusMessageType enumeration).
		 */
		set_message_type(type: DBusMessageType): void;
		/**
		 * Convenience setter for the %G_DBUS_MESSAGE_HEADER_FIELD_NUM_UNIX_FDS header field.
		 * @param value The value to set.
		 */
		set_num_unix_fds(value: number): void;
		/**
		 * Convenience setter for the %G_DBUS_MESSAGE_HEADER_FIELD_PATH header field.
		 * @param value The value to set.
		 */
		set_path(value?: string | null): void;
		/**
		 * Convenience setter for the %G_DBUS_MESSAGE_HEADER_FIELD_REPLY_SERIAL header field.
		 * @param value The value to set.
		 */
		set_reply_serial(value: number): void;
		/**
		 * Convenience setter for the %G_DBUS_MESSAGE_HEADER_FIELD_SENDER header field.
		 * @param value The value to set.
		 */
		set_sender(value?: string | null): void;
		/**
		 * Sets the serial for #message.
		 * @param serial A #guint32.
		 */
		set_serial(serial: number): void;
		/**
		 * Convenience setter for the %G_DBUS_MESSAGE_HEADER_FIELD_SIGNATURE header field.
		 * @param value The value to set.
		 */
		set_signature(value?: string | null): void;
		/**
		 * Sets the UNIX file descriptors associated with #message. As a
		 * side-effect the %G_DBUS_MESSAGE_HEADER_FIELD_NUM_UNIX_FDS header
		 * field is set to the number of fds in #fd_list (or cleared if
		 * #fd_list is %NULL).
		 * 
		 * This method is only available on UNIX.
		 * 
		 * When designing D-Bus APIs that are intended to be interoperable,
		 * please note that non-GDBus implementations of D-Bus can usually only
		 * access file descriptors if they are referenced by a value of type
		 * %G_VARIANT_TYPE_HANDLE in the body of the message.
		 * @param fd_list A #GUnixFDList or %NULL.
		 */
		set_unix_fd_list(fd_list?: UnixFDList | null): void;
		/**
		 * Serializes #message to a blob. The byte order returned by
		 * {@link G.dbus_message_get_byte_order} will be used.
		 * @param capabilities A #GDBusCapabilityFlags describing what protocol features are supported.
		 * @returns A pointer to a
		 * valid binary D-Bus message of #out_size bytes generated by #message
		 * or %NULL if #error is set. Free with {@link G.free}.
		 * 
		 * Return location for size of generated blob.
		 */
		to_blob(capabilities: DBusCapabilityFlags): [ number[], number ];
		/**
		 * If #message is not of type %G_DBUS_MESSAGE_TYPE_ERROR does
		 * nothing and returns %FALSE.
		 * 
		 * Otherwise this method encodes the error in #message as a #GError
		 * using {@link G.dbus_error_set_dbus_error} using the information in the
		 * %G_DBUS_MESSAGE_HEADER_FIELD_ERROR_NAME header field of #message as
		 * well as the first string item in #message's body.
		 * @returns %TRUE if #error was set, %FALSE otherwise.
		 */
		to_gerror(): boolean;
		connect(signal: "notify::locked", callback: (owner: this, ...args: any) => void): number;

	}

	type DBusMessageInitOptionsMixin = GObject.ObjectInitOptions
	export interface DBusMessageInitOptions extends DBusMessageInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link DBusMessage} instead.
	 */
	type DBusMessageMixin = IDBusMessage & GObject.Object;

	/**
	 * A type for representing D-Bus messages that can be sent or received
	 * on a #GDBusConnection.
	 */
	interface DBusMessage extends DBusMessageMixin {}

	class DBusMessage {
		public constructor(options?: Partial<DBusMessageInitOptions>);
		/**
		 * Creates a new empty #GDBusMessage.
		 * @returns A #GDBusMessage. Free with {@link GObject.unref}.
		 */
		public static new(): DBusMessage;
		/**
		 * Creates a new #GDBusMessage from the data stored at #blob. The byte
		 * order that the message was in can be retrieved using
		 * {@link G.dbus_message_get_byte_order}.
		 * 
		 * If the #blob cannot be parsed, contains invalid fields, or contains invalid
		 * headers, %G_IO_ERROR_INVALID_ARGUMENT will be returned.
		 * @param blob A blob representing a binary D-Bus message.
		 * @param capabilities A #GDBusCapabilityFlags describing what protocol features are supported.
		 * @returns A new #GDBusMessage or %NULL if #error is set. Free with
		 * {@link GObject.unref}.
		 */
		public static new_from_blob(blob: number[], capabilities: DBusCapabilityFlags): DBusMessage;
		/**
		 * Creates a new #GDBusMessage for a method call.
		 * @param name A valid D-Bus name or %NULL.
		 * @param path A valid object path.
		 * @param interface_ A valid D-Bus interface name or %NULL.
		 * @param method A valid method name.
		 * @returns A #GDBusMessage. Free with {@link GObject.unref}.
		 */
		public static new_method_call(name: string | null, path: string, interface_: string | null, method: string): DBusMessage;
		/**
		 * Creates a new #GDBusMessage for a signal emission.
		 * @param path A valid object path.
		 * @param interface_ A valid D-Bus interface name.
		 * @param signal A valid signal name.
		 * @returns A #GDBusMessage. Free with {@link GObject.unref}.
		 */
		public static new_signal(path: string, interface_: string, signal: string): DBusMessage;
		/**
		 * Utility function to calculate how many bytes are needed to
		 * completely deserialize the D-Bus message stored at #blob.
		 * @param blob A blob representing a binary D-Bus message.
		 * @returns Number of bytes needed or -1 if #error is set (e.g. if
		 * #blob contains invalid data or not enough data is available to
		 * determine the size).
		 */
		public static bytes_needed(blob: number[]): number;
	}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link DBusMethodInvocation} instead.
	 */
	interface IDBusMethodInvocation {
		/**
		 * Gets the #GDBusConnection the method was invoked on.
		 * @returns A #GDBusConnection. Do not free, it is owned by #invocation.
		 */
		get_connection(): DBusConnection;
		/**
		 * Gets the name of the D-Bus interface the method was invoked on.
		 * 
		 * If this method call is a property Get, Set or GetAll call that has
		 * been redirected to the method call handler then
		 * "org.freedesktop.DBus.Properties" will be returned.  See
		 * #GDBusInterfaceVTable for more information.
		 * @returns A string. Do not free, it is owned by #invocation.
		 */
		get_interface_name(): string;
		/**
		 * Gets the #GDBusMessage for the method invocation. This is useful if
		 * you need to use low-level protocol features, such as UNIX file
		 * descriptor passing, that cannot be properly expressed in the
		 * #GVariant API.
		 * 
		 * See this [server][gdbus-server] and [client][gdbus-unix-fd-client]
		 * for an example of how to use this low-level API to send and receive
		 * UNIX file descriptors.
		 * @returns #GDBusMessage. Do not free, it is owned by #invocation.
		 */
		get_message(): DBusMessage;
		/**
		 * Gets information about the method call, if any.
		 * 
		 * If this method invocation is a property Get, Set or GetAll call that
		 * has been redirected to the method call handler then %NULL will be
		 * returned.  See {@link G.dbus_method_invocation_get_property_info} and
		 * #GDBusInterfaceVTable for more information.
		 * @returns A #GDBusMethodInfo or %NULL. Do not free, it is owned by #invocation.
		 */
		get_method_info(): DBusMethodInfo | null;
		/**
		 * Gets the name of the method that was invoked.
		 * @returns A string. Do not free, it is owned by #invocation.
		 */
		get_method_name(): string;
		/**
		 * Gets the object path the method was invoked on.
		 * @returns A string. Do not free, it is owned by #invocation.
		 */
		get_object_path(): string;
		/**
		 * Gets the parameters of the method invocation. If there are no input
		 * parameters then this will return a GVariant with 0 children rather than NULL.
		 * @returns A #GVariant tuple. Do not unref this because it is owned by #invocation.
		 */
		get_parameters(): GLib.Variant;
		/**
		 * Gets information about the property that this method call is for, if
		 * any.
		 * 
		 * This will only be set in the case of an invocation in response to a
		 * property Get or Set call that has been directed to the method call
		 * handler for an object on account of its {@link Property.get} or
		 * property_set() vtable pointers being unset.
		 * 
		 * See #GDBusInterfaceVTable for more information.
		 * 
		 * If the call was GetAll, %NULL will be returned.
		 * @returns a #GDBusPropertyInfo or %NULL
		 */
		get_property_info(): DBusPropertyInfo | null;
		/**
		 * Gets the bus name that invoked the method.
		 * @returns A string. Do not free, it is owned by #invocation.
		 */
		get_sender(): string;
		/**
		 * Gets the #user_data #gpointer passed to {@link G.dbus_connection_register_object}.
		 * @returns A #gpointer.
		 */
		get_user_data(): any | null;
		/**
		 * Finishes handling a D-Bus method call by returning an error.
		 * 
		 * This method will take ownership of #invocation. See
		 * #GDBusInterfaceVTable for more information about the ownership of
		 * #invocation.
		 * @param error_name A valid D-Bus error name.
		 * @param error_message A valid D-Bus error message.
		 */
		return_dbus_error(error_name: string, error_message: string): void;
		/**
		 * Finishes handling a D-Bus method call by returning an error.
		 * 
		 * See {@link G.dbus_error_encode_gerror} for details about what error name
		 * will be returned on the wire. In a nutshell, if the given error is
		 * registered using g_dbus_error_register_error() the name given
		 * during registration is used. Otherwise, a name of the form
		 * `org.gtk.GDBus.UnmappedGError.Quark...` is used. This provides
		 * transparent mapping of #GError between applications using GDBus.
		 * 
		 * If you are writing an application intended to be portable,
		 * always register errors with g_dbus_error_register_error()
		 * or use g_dbus_method_invocation_return_dbus_error().
		 * 
		 * This method will take ownership of #invocation. See
		 * #GDBusInterfaceVTable for more information about the ownership of
		 * #invocation.
		 * 
		 * Since 2.48, if the method call requested for a reply not to be sent
		 * then this call will free #invocation but otherwise do nothing (as per
		 * the recommendations of the D-Bus specification).
		 * @param domain A #GQuark for the #GError error domain.
		 * @param code The error code.
		 * @param format printf()-style format.
		 */
		return_error(domain: GLib.Quark, code: number, format: string): void;
		/**
		 * Like {@link G.dbus_method_invocation_return_error} but without printf()-style formatting.
		 * 
		 * This method will take ownership of #invocation. See
		 * #GDBusInterfaceVTable for more information about the ownership of
		 * #invocation.
		 * @param domain A #GQuark for the #GError error domain.
		 * @param code The error code.
		 * @param message The error message.
		 */
		return_error_literal(domain: GLib.Quark, code: number, message: string): void;
		/**
		 * Like {@link G.dbus_method_invocation_return_error} but intended for
		 * language bindings.
		 * 
		 * This method will take ownership of #invocation. See
		 * #GDBusInterfaceVTable for more information about the ownership of
		 * #invocation.
		 * @param domain A #GQuark for the #GError error domain.
		 * @param code The error code.
		 * @param format printf()-style format.
		 * @param var_args #va_list of parameters for #format.
		 */
		return_error_valist(domain: GLib.Quark, code: number, format: string, var_args: any[]): void;
		/**
		 * Like {@link G.dbus_method_invocation_return_error} but takes a #GError
		 * instead of the error domain, error code and message.
		 * 
		 * This method will take ownership of #invocation. See
		 * #GDBusInterfaceVTable for more information about the ownership of
		 * #invocation.
		 * @param error A #GError.
		 */
		return_gerror(error: GLib.Error): void;
		/**
		 * Finishes handling a D-Bus method call by returning #parameters.
		 * If the #parameters GVariant is floating, it is consumed.
		 * 
		 * It is an error if #parameters is not of the right format: it must be a tuple
		 * containing the out-parameters of the D-Bus method. Even if the method has a
		 * single out-parameter, it must be contained in a tuple. If the method has no
		 * out-parameters, #parameters may be %NULL or an empty tuple.
		 * 
		 * |[<!-- language="C" -->
		 * GDBusMethodInvocation *invocation = some_invocation;
		 * g_autofree gchar *result_string = NULL;
		 * g_autoptr (GError) error = NULL;
		 * 
		 * result_string = calculate_result (&error);
		 * 
		 * if (error != NULL)
		 *   g_dbus_method_invocation_return_gerror (invocation, error);
		 * else
		 *   g_dbus_method_invocation_return_value (invocation,
		 *                                          g_variant_new ("(s)", result_string));
		 * 
		 * // Do not free #invocation here; returning a value does that
		 * ]|
		 * 
		 * This method will take ownership of #invocation. See
		 * #GDBusInterfaceVTable for more information about the ownership of
		 * #invocation.
		 * 
		 * Since 2.48, if the method call requested for a reply not to be sent
		 * then this call will sink #parameters and free #invocation, but
		 * otherwise do nothing (as per the recommendations of the D-Bus
		 * specification).
		 * @param parameters A #GVariant tuple with out parameters for the method or %NULL if not passing any parameters.
		 */
		return_value(parameters?: GLib.Variant | null): void;
		/**
		 * Like {@link G.dbus_method_invocation_return_value} but also takes a #GUnixFDList.
		 * 
		 * This method is only available on UNIX.
		 * 
		 * This method will take ownership of #invocation. See
		 * #GDBusInterfaceVTable for more information about the ownership of
		 * #invocation.
		 * @param parameters A #GVariant tuple with out parameters for the method or %NULL if not passing any parameters.
		 * @param fd_list A #GUnixFDList or %NULL.
		 */
		return_value_with_unix_fd_list(parameters?: GLib.Variant | null, fd_list?: UnixFDList | null): void;
		/**
		 * Like {@link G.dbus_method_invocation_return_gerror} but takes ownership
		 * of #error so the caller does not need to free it.
		 * 
		 * This method will take ownership of #invocation. See
		 * #GDBusInterfaceVTable for more information about the ownership of
		 * #invocation.
		 * @param error A #GError.
		 */
		take_error(error: GLib.Error): void;
	}

	type DBusMethodInvocationInitOptionsMixin = GObject.ObjectInitOptions
	export interface DBusMethodInvocationInitOptions extends DBusMethodInvocationInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link DBusMethodInvocation} instead.
	 */
	type DBusMethodInvocationMixin = IDBusMethodInvocation & GObject.Object;

	/**
	 * Instances of the #GDBusMethodInvocation class are used when
	 * handling D-Bus method calls. It provides a way to asynchronously
	 * return results and errors.
	 * 
	 * The normal way to obtain a #GDBusMethodInvocation object is to receive
	 * it as an argument to the {@link Handle.method_call} function in a
	 * #GDBusInterfaceVTable that was passed to g_dbus_connection_register_object().
	 */
	interface DBusMethodInvocation extends DBusMethodInvocationMixin {}

	class DBusMethodInvocation {
		public constructor(options?: Partial<DBusMethodInvocationInitOptions>);
	}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link DBusObjectManagerClient} instead.
	 */
	interface IDBusObjectManagerClient {
		/**
		 * The #GDBusConnection to use.
		 */
		connection: DBusConnection;
		/**
		 * Flags from the #GDBusObjectManagerClientFlags enumeration.
		 */
		flags: DBusObjectManagerClientFlags;
		/**
		 * A #GDestroyNotify for the #gpointer user_data in #GDBusObjectManagerClient:get-proxy-type-user-data.
		 */
		get_proxy_type_destroy_notify: any;
		/**
		 * The #GDBusProxyTypeFunc to use when determining what #GType to
		 * use for interface proxies or %NULL.
		 */
		get_proxy_type_func: any;
		/**
		 * The #gpointer user_data to pass to #GDBusObjectManagerClient:get-proxy-type-func.
		 */
		get_proxy_type_user_data: any;
		/**
		 * The well-known name or unique name that the manager is for.
		 */
		name: string;
		/**
		 * The unique name that owns #GDBusObjectManagerClient:name or %NULL if
		 * no-one is currently owning the name. Connect to the
		 * #GObject::notify signal to track changes to this property.
		 */
		readonly name_owner: string;
		/**
		 * The object path the manager is for.
		 */
		object_path: string;
		/**
		 * Gets the #GDBusConnection used by #manager.
		 * @returns A #GDBusConnection object. Do not free,
		 *   the object belongs to #manager.
		 */
		get_connection(): DBusConnection;
		/**
		 * Gets the flags that #manager was constructed with.
		 * @returns Zero of more flags from the #GDBusObjectManagerClientFlags
		 * enumeration.
		 */
		get_flags(): DBusObjectManagerClientFlags;
		/**
		 * Gets the name that #manager is for, or %NULL if not a message bus
		 * connection.
		 * @returns A unique or well-known name. Do not free, the string
		 * belongs to #manager.
		 */
		get_name(): string;
		/**
		 * The unique name that owns the name that #manager is for or %NULL if
		 * no-one currently owns that name. You can connect to the
		 * #GObject::notify signal to track changes to the
		 * #GDBusObjectManagerClient:name-owner property.
		 * @returns The name owner or %NULL if no name owner
		 * exists. Free with {@link G.free}.
		 */
		get_name_owner(): string | null;
		/**
		 * Emitted when one or more D-Bus properties on proxy changes. The
		 * local cache has already been updated when this signal fires. Note
		 * that both #changed_properties and #invalidated_properties are
		 * guaranteed to never be %NULL (either may be empty though).
		 * 
		 * This signal exists purely as a convenience to avoid having to
		 * connect signals to all interface proxies managed by #manager.
		 * 
		 * This signal is emitted in the
		 * [thread-default main context][g-main-context-push-thread-default]
		 * that #manager was constructed in.
		 * @param signal 
		 * @param callback Callback function
		 *  - owner: owner of the emitted event 
		 *  - object_proxy: The #GDBusObjectProxy on which an interface has properties that are changing. 
		 *  - interface_proxy: The #GDBusProxy that has properties that are changing. 
		 *  - changed_properties: A #GVariant containing the properties that changed (type: `a{sv}`). 
		 *  - invalidated_properties: A %NULL terminated
		 *   array of properties that were invalidated. 
		 * 
		 * @returns Callback ID
		 */
		connect(signal: "interface-proxy-properties-changed", callback: (owner: this, object_proxy: DBusObjectProxy, interface_proxy: DBusProxy, changed_properties: GLib.Variant, invalidated_properties: string[]) => void): number;
		/**
		 * Emitted when a D-Bus signal is received on #interface_proxy.
		 * 
		 * This signal exists purely as a convenience to avoid having to
		 * connect signals to all interface proxies managed by #manager.
		 * 
		 * This signal is emitted in the
		 * [thread-default main context][g-main-context-push-thread-default]
		 * that #manager was constructed in.
		 * @param signal 
		 * @param callback Callback function
		 *  - owner: owner of the emitted event 
		 *  - object_proxy: The #GDBusObjectProxy on which an interface is emitting a D-Bus signal. 
		 *  - interface_proxy: The #GDBusProxy that is emitting a D-Bus signal. 
		 *  - sender_name: The sender of the signal or NULL if the connection is not a bus connection. 
		 *  - signal_name: The signal name. 
		 *  - parameters: A #GVariant tuple with parameters for the signal. 
		 * 
		 * @returns Callback ID
		 */
		connect(signal: "interface-proxy-signal", callback: (owner: this, object_proxy: DBusObjectProxy, interface_proxy: DBusProxy, sender_name: string, signal_name: string, parameters: GLib.Variant) => void): number;

		connect(signal: "notify::connection", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::flags", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::get-proxy-type-destroy-notify", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::get-proxy-type-func", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::get-proxy-type-user-data", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::name", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::name-owner", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::object-path", callback: (owner: this, ...args: any) => void): number;

	}

	type DBusObjectManagerClientInitOptionsMixin = GObject.ObjectInitOptions & AsyncInitableInitOptions & DBusObjectManagerInitOptions & InitableInitOptions & 
	Pick<IDBusObjectManagerClient,
		"connection" |
		"flags" |
		"get_proxy_type_destroy_notify" |
		"get_proxy_type_func" |
		"get_proxy_type_user_data" |
		"name" |
		"object_path">;

	export interface DBusObjectManagerClientInitOptions extends DBusObjectManagerClientInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link DBusObjectManagerClient} instead.
	 */
	type DBusObjectManagerClientMixin = IDBusObjectManagerClient & GObject.Object & AsyncInitable & DBusObjectManager & Initable;

	/**
	 * #GDBusObjectManagerClient is used to create, monitor and delete object
	 * proxies for remote objects exported by a #GDBusObjectManagerServer (or any
	 * code implementing the
	 * [org.freedesktop.DBus.ObjectManager](http://dbus.freedesktop.org/doc/dbus-specification.html#standard-interfaces-objectmanager)
	 * interface).
	 * 
	 * Once an instance of this type has been created, you can connect to
	 * the #GDBusObjectManager::object-added and
	 * #GDBusObjectManager::object-removed signals and inspect the
	 * #GDBusObjectProxy objects returned by
	 * {@link G.dbus_object_manager_get_objects}.
	 * 
	 * If the name for a #GDBusObjectManagerClient is not owned by anyone at
	 * object construction time, the default behavior is to request the
	 * message bus to launch an owner for the name. This behavior can be
	 * disabled using the %G_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_DO_NOT_AUTO_START
	 * flag. It's also worth noting that this only works if the name of
	 * interest is activatable in the first place. E.g. in some cases it
	 * is not possible to launch an owner for the requested name. In this
	 * case, #GDBusObjectManagerClient object construction still succeeds but
	 * there will be no object proxies
	 * (e.g. g_dbus_object_manager_get_objects() returns the empty list) and
	 * the #GDBusObjectManagerClient:name-owner property is %NULL.
	 * 
	 * The owner of the requested name can come and go (for example
	 * consider a system service being restarted) – #GDBusObjectManagerClient
	 * handles this case too; simply connect to the #GObject::notify
	 * signal to watch for changes on the #GDBusObjectManagerClient:name-owner
	 * property. When the name owner vanishes, the behavior is that
	 * #GDBusObjectManagerClient:name-owner is set to %NULL (this includes
	 * emission of the #GObject::notify signal) and then
	 * #GDBusObjectManager::object-removed signals are synthesized
	 * for all currently existing object proxies. Since
	 * #GDBusObjectManagerClient:name-owner is %NULL when this happens, you can
	 * use this information to disambiguate a synthesized signal from a
	 * genuine signal caused by object removal on the remote
	 * #GDBusObjectManager. Similarly, when a new name owner appears,
	 * #GDBusObjectManager::object-added signals are synthesized
	 * while #GDBusObjectManagerClient:name-owner is still %NULL. Only when all
	 * object proxies have been added, the #GDBusObjectManagerClient:name-owner
	 * is set to the new name owner (this includes emission of the
	 * #GObject::notify signal).  Furthermore, you are guaranteed that
	 * #GDBusObjectManagerClient:name-owner will alternate between a name owner
	 * (e.g. `:1.42`) and %NULL even in the case where
	 * the name of interest is atomically replaced
	 * 
	 * Ultimately, #GDBusObjectManagerClient is used to obtain #GDBusProxy
	 * instances. All signals (including the
	 * org.freedesktop.DBus.Properties::PropertiesChanged signal)
	 * delivered to #GDBusProxy instances are guaranteed to originate
	 * from the name owner. This guarantee along with the behavior
	 * described above, means that certain race conditions including the
	 * "half the proxy is from the old owner and the other half is from
	 * the new owner" problem cannot happen.
	 * 
	 * To avoid having the application connect to signals on the returned
	 * #GDBusObjectProxy and #GDBusProxy objects, the
	 * #GDBusObject::interface-added,
	 * #GDBusObject::interface-removed,
	 * #GDBusProxy::g-properties-changed and
	 * #GDBusProxy::g-signal signals
	 * are also emitted on the #GDBusObjectManagerClient instance managing these
	 * objects. The signals emitted are
	 * #GDBusObjectManager::interface-added,
	 * #GDBusObjectManager::interface-removed,
	 * #GDBusObjectManagerClient::interface-proxy-properties-changed and
	 * #GDBusObjectManagerClient::interface-proxy-signal.
	 * 
	 * Note that all callbacks and signals are emitted in the
	 * [thread-default main context][g-main-context-push-thread-default]
	 * that the #GDBusObjectManagerClient object was constructed
	 * in. Additionally, the #GDBusObjectProxy and #GDBusProxy objects
	 * originating from the #GDBusObjectManagerClient object will be created in
	 * the same context and, consequently, will deliver signals in the
	 * same main loop.
	 */
	interface DBusObjectManagerClient extends DBusObjectManagerClientMixin {}

	class DBusObjectManagerClient {
		public constructor(options?: Partial<DBusObjectManagerClientInitOptions>);
		/**
		 * Finishes an operation started with {@link G.dbus_object_manager_client_new}.
		 * @param res A #GAsyncResult obtained from the #GAsyncReadyCallback passed to {@link G.dbus_object_manager_client_new}.
		 * @returns A
		 *   #GDBusObjectManagerClient object or %NULL if #error is set. Free
		 *   with {@link GObject.unref}.
		 */
		public static new_finish(res: AsyncResult): DBusObjectManagerClient;
		/**
		 * Finishes an operation started with {@link G.dbus_object_manager_client_new_for_bus}.
		 * @param res A #GAsyncResult obtained from the #GAsyncReadyCallback passed to {@link G.dbus_object_manager_client_new_for_bus}.
		 * @returns A
		 *   #GDBusObjectManagerClient object or %NULL if #error is set. Free
		 *   with {@link GObject.unref}.
		 */
		public static new_for_bus_finish(res: AsyncResult): DBusObjectManagerClient;
		/**
		 * Like {@link G.dbus_object_manager_client_new_sync} but takes a #GBusType instead
		 * of a #GDBusConnection.
		 * 
		 * This is a synchronous failable constructor - the calling thread is
		 * blocked until a reply is received. See g_dbus_object_manager_client_new_for_bus()
		 * for the asynchronous version.
		 * @param bus_type A #GBusType.
		 * @param flags Zero or more flags from the #GDBusObjectManagerClientFlags enumeration.
		 * @param name The owner of the control object (unique or well-known name).
		 * @param object_path The object path of the control object.
		 * @param get_proxy_type_func A #GDBusProxyTypeFunc function or %NULL to always construct #GDBusProxy proxies.
		 * @param cancellable A #GCancellable or %NULL
		 * @returns A
		 *   #GDBusObjectManagerClient object or %NULL if #error is set. Free
		 *   with {@link GObject.unref}.
		 */
		public static new_for_bus_sync(bus_type: BusType, flags: DBusObjectManagerClientFlags, name: string, object_path: string, get_proxy_type_func?: DBusProxyTypeFunc | null, cancellable?: Cancellable | null): DBusObjectManagerClient;
		/**
		 * Creates a new #GDBusObjectManagerClient object.
		 * 
		 * This is a synchronous failable constructor - the calling thread is
		 * blocked until a reply is received. See {@link G.dbus_object_manager_client_new}
		 * for the asynchronous version.
		 * @param connection A #GDBusConnection.
		 * @param flags Zero or more flags from the #GDBusObjectManagerClientFlags enumeration.
		 * @param name The owner of the control object (unique or well-known name), or %NULL when not using a message bus connection.
		 * @param object_path The object path of the control object.
		 * @param get_proxy_type_func A #GDBusProxyTypeFunc function or %NULL to always construct #GDBusProxy proxies.
		 * @param cancellable A #GCancellable or %NULL
		 * @returns A
		 *   #GDBusObjectManagerClient object or %NULL if #error is set. Free
		 *   with {@link GObject.unref}.
		 */
		public static new_sync(connection: DBusConnection, flags: DBusObjectManagerClientFlags, name: string | null, object_path: string, get_proxy_type_func?: DBusProxyTypeFunc | null, cancellable?: Cancellable | null): DBusObjectManagerClient;
		/**
		 * Asynchronously creates a new #GDBusObjectManagerClient object.
		 * 
		 * This is an asynchronous failable constructor. When the result is
		 * ready, #callback will be invoked in the
		 * [thread-default main context][g-main-context-push-thread-default]
		 * of the thread you are calling this method from. You can
		 * then call {@link G.dbus_object_manager_client_new_finish} to get the result. See
		 * g_dbus_object_manager_client_new_sync() for the synchronous version.
		 * @param connection A #GDBusConnection.
		 * @param flags Zero or more flags from the #GDBusObjectManagerClientFlags enumeration.
		 * @param name The owner of the control object (unique or well-known name).
		 * @param object_path The object path of the control object.
		 * @param get_proxy_type_func A #GDBusProxyTypeFunc function or %NULL to always construct #GDBusProxy proxies.
		 * @param cancellable A #GCancellable or %NULL
		 * @param callback A #GAsyncReadyCallback to call when the request is satisfied.
		 */
		public static new(connection: DBusConnection, flags: DBusObjectManagerClientFlags, name: string, object_path: string, get_proxy_type_func?: DBusProxyTypeFunc | null, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;
		/**
		 * Like {@link G.dbus_object_manager_client_new} but takes a #GBusType instead of a
		 * #GDBusConnection.
		 * 
		 * This is an asynchronous failable constructor. When the result is
		 * ready, #callback will be invoked in the
		 * [thread-default main loop][g-main-context-push-thread-default]
		 * of the thread you are calling this method from. You can
		 * then call g_dbus_object_manager_client_new_for_bus_finish() to get the result. See
		 * g_dbus_object_manager_client_new_for_bus_sync() for the synchronous version.
		 * @param bus_type A #GBusType.
		 * @param flags Zero or more flags from the #GDBusObjectManagerClientFlags enumeration.
		 * @param name The owner of the control object (unique or well-known name).
		 * @param object_path The object path of the control object.
		 * @param get_proxy_type_func A #GDBusProxyTypeFunc function or %NULL to always construct #GDBusProxy proxies.
		 * @param cancellable A #GCancellable or %NULL
		 * @param callback A #GAsyncReadyCallback to call when the request is satisfied.
		 */
		public static new_for_bus(bus_type: BusType, flags: DBusObjectManagerClientFlags, name: string, object_path: string, get_proxy_type_func?: DBusProxyTypeFunc | null, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;
	}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link DBusObjectManagerServer} instead.
	 */
	interface IDBusObjectManagerServer {
		/**
		 * The #GDBusConnection to export objects on.
		 */
		connection: DBusConnection;
		/**
		 * The object path to register the manager object at.
		 */
		object_path: string;
		/**
		 * Exports #object on #manager.
		 * 
		 * If there is already a #GDBusObject exported at the object path,
		 * then the old object is removed.
		 * 
		 * The object path for #object must be in the hierarchy rooted by the
		 * object path for #manager.
		 * 
		 * Note that #manager will take a reference on #object for as long as
		 * it is exported.
		 * @param object A #GDBusObjectSkeleton.
		 */
		export(object: DBusObjectSkeleton): void;
		/**
		 * Like {@link G.dbus_object_manager_server_export} but appends a string of
		 * the form _N (with N being a natural number) to #object's object path
		 * if an object with the given path already exists. As such, the
		 * #GDBusObjectProxy:g-object-path property of #object may be modified.
		 * @param object An object.
		 */
		export_uniquely(object: DBusObjectSkeleton): void;
		/**
		 * Gets the #GDBusConnection used by #manager.
		 * @returns A #GDBusConnection object or %NULL if
		 *   #manager isn't exported on a connection. The returned object should
		 *   be freed with {@link GObject.unref}.
		 */
		get_connection(): DBusConnection | null;
		/**
		 * Returns whether #object is currently exported on #manager.
		 * @param object An object.
		 * @returns %TRUE if #object is exported
		 */
		is_exported(object: DBusObjectSkeleton): boolean;
		/**
		 * Exports all objects managed by #manager on #connection. If
		 * #connection is %NULL, stops exporting objects.
		 * @param connection A #GDBusConnection or %NULL.
		 */
		set_connection(connection?: DBusConnection | null): void;
		/**
		 * If #manager has an object at #path, removes the object. Otherwise
		 * does nothing.
		 * 
		 * Note that #object_path must be in the hierarchy rooted by the
		 * object path for #manager.
		 * @param object_path An object path.
		 * @returns %TRUE if object at #object_path was removed, %FALSE otherwise.
		 */
		unexport(object_path: string): boolean;
		connect(signal: "notify::connection", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::object-path", callback: (owner: this, ...args: any) => void): number;

	}

	type DBusObjectManagerServerInitOptionsMixin = GObject.ObjectInitOptions & DBusObjectManagerInitOptions & 
	Pick<IDBusObjectManagerServer,
		"connection" |
		"object_path">;

	export interface DBusObjectManagerServerInitOptions extends DBusObjectManagerServerInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link DBusObjectManagerServer} instead.
	 */
	type DBusObjectManagerServerMixin = IDBusObjectManagerServer & GObject.Object & DBusObjectManager;

	/**
	 * #GDBusObjectManagerServer is used to export #GDBusObject instances using
	 * the standardized
	 * [org.freedesktop.DBus.ObjectManager](http://dbus.freedesktop.org/doc/dbus-specification.html#standard-interfaces-objectmanager)
	 * interface. For example, remote D-Bus clients can get all objects
	 * and properties in a single call. Additionally, any change in the
	 * object hierarchy is broadcast using signals. This means that D-Bus
	 * clients can keep caches up to date by only listening to D-Bus
	 * signals.
	 * 
	 * The recommended path to export an object manager at is the path form of the
	 * well-known name of a D-Bus service, or below. For example, if a D-Bus service
	 * is available at the well-known name `net.example.ExampleService1`, the object
	 * manager should typically be exported at `/net/example/ExampleService1`, or
	 * below (to allow for multiple object managers in a service).
	 * 
	 * It is supported, but not recommended, to export an object manager at the root
	 * path, `/`.
	 * 
	 * See #GDBusObjectManagerClient for the client-side code that is
	 * intended to be used with #GDBusObjectManagerServer or any D-Bus
	 * object implementing the org.freedesktop.DBus.ObjectManager
	 * interface.
	 */
	interface DBusObjectManagerServer extends DBusObjectManagerServerMixin {}

	class DBusObjectManagerServer {
		public constructor(options?: Partial<DBusObjectManagerServerInitOptions>);
		/**
		 * Creates a new #GDBusObjectManagerServer object.
		 * 
		 * The returned server isn't yet exported on any connection. To do so,
		 * use {@link G.dbus_object_manager_server_set_connection}. Normally you
		 * want to export all of your objects before doing so to avoid
		 * [InterfacesAdded](http://dbus.freedesktop.org/doc/dbus-specification.html#standard-interfaces-objectmanager)
		 * signals being emitted.
		 * @param object_path The object path to export the manager object at.
		 * @returns A #GDBusObjectManagerServer object. Free with {@link GObject.unref}.
		 */
		public static new(object_path: string): DBusObjectManagerServer;
	}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link DBusObjectProxy} instead.
	 */
	interface IDBusObjectProxy {
		/**
		 * The connection of the proxy.
		 */
		g_connection: DBusConnection;
		/**
		 * The object path of the proxy.
		 */
		g_object_path: string;
		/**
		 * Gets the connection that #proxy is for.
		 * @returns A #GDBusConnection. Do not free, the
		 *   object is owned by #proxy.
		 */
		get_connection(): DBusConnection;
		connect(signal: "notify::g-connection", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::g-object-path", callback: (owner: this, ...args: any) => void): number;

	}

	type DBusObjectProxyInitOptionsMixin = GObject.ObjectInitOptions & DBusObjectInitOptions & 
	Pick<IDBusObjectProxy,
		"g_connection" |
		"g_object_path">;

	export interface DBusObjectProxyInitOptions extends DBusObjectProxyInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link DBusObjectProxy} instead.
	 */
	type DBusObjectProxyMixin = IDBusObjectProxy & GObject.Object & DBusObject;

	/**
	 * A #GDBusObjectProxy is an object used to represent a remote object
	 * with one or more D-Bus interfaces. Normally, you don't instantiate
	 * a #GDBusObjectProxy yourself - typically #GDBusObjectManagerClient
	 * is used to obtain it.
	 */
	interface DBusObjectProxy extends DBusObjectProxyMixin {}

	class DBusObjectProxy {
		public constructor(options?: Partial<DBusObjectProxyInitOptions>);
		/**
		 * Creates a new #GDBusObjectProxy for the given connection and
		 * object path.
		 * @param connection a #GDBusConnection
		 * @param object_path the object path
		 * @returns a new #GDBusObjectProxy
		 */
		public static new(connection: DBusConnection, object_path: string): DBusObjectProxy;
	}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link DBusObjectSkeleton} instead.
	 */
	interface IDBusObjectSkeleton {
		/**
		 * The object path where the object is exported.
		 */
		g_object_path: string;
		/**
		 * Adds #interface_ to #object.
		 * 
		 * If #object already contains a #GDBusInterfaceSkeleton with the same
		 * interface name, it is removed before #interface_ is added.
		 * 
		 * Note that #object takes its own reference on #interface_ and holds
		 * it until removed.
		 * @param interface_ A #GDBusInterfaceSkeleton.
		 */
		add_interface(interface_: DBusInterfaceSkeleton): void;
		/**
		 * This method simply calls {@link G.dbus_interface_skeleton_flush} on all
		 * interfaces belonging to #object. See that method for when flushing
		 * is useful.
		 */
		flush(): void;
		/**
		 * Removes #interface_ from #object.
		 * @param interface_ A #GDBusInterfaceSkeleton.
		 */
		remove_interface(interface_: DBusInterfaceSkeleton): void;
		/**
		 * Removes the #GDBusInterface with #interface_name from #object.
		 * 
		 * If no D-Bus interface of the given interface exists, this function
		 * does nothing.
		 * @param interface_name A D-Bus interface name.
		 */
		remove_interface_by_name(interface_name: string): void;
		/**
		 * Sets the object path for #object.
		 * @param object_path A valid D-Bus object path.
		 */
		set_object_path(object_path: string): void;
		/**
		 * Emitted when a method is invoked by a remote caller and used to
		 * determine if the method call is authorized.
		 * 
		 * This signal is like #GDBusInterfaceSkeleton's
		 * #GDBusInterfaceSkeleton::g-authorize-method signal,
		 * except that it is for the enclosing object.
		 * 
		 * The default class handler just returns %TRUE.
		 * @param signal 
		 * @param callback Callback function
		 *  - owner: owner of the emitted event 
		 *  - _interface: The #GDBusInterfaceSkeleton that #invocation is for. 
		 *  - invocation: A #GDBusMethodInvocation. 
		 *  - returns %TRUE if the call is authorized, %FALSE otherwise. 
		 * 
		 * @returns Callback ID
		 */
		connect(signal: "authorize-method", callback: (owner: this, _interface: DBusInterfaceSkeleton, invocation: DBusMethodInvocation) => boolean): number;

		connect(signal: "notify::g-object-path", callback: (owner: this, ...args: any) => void): number;

	}

	type DBusObjectSkeletonInitOptionsMixin = GObject.ObjectInitOptions & DBusObjectInitOptions & 
	Pick<IDBusObjectSkeleton,
		"g_object_path">;

	export interface DBusObjectSkeletonInitOptions extends DBusObjectSkeletonInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link DBusObjectSkeleton} instead.
	 */
	type DBusObjectSkeletonMixin = IDBusObjectSkeleton & GObject.Object & DBusObject;

	/**
	 * A #GDBusObjectSkeleton instance is essentially a group of D-Bus
	 * interfaces. The set of exported interfaces on the object may be
	 * dynamic and change at runtime.
	 * 
	 * This type is intended to be used with #GDBusObjectManager.
	 */
	interface DBusObjectSkeleton extends DBusObjectSkeletonMixin {}

	class DBusObjectSkeleton {
		public constructor(options?: Partial<DBusObjectSkeletonInitOptions>);
		/**
		 * Creates a new #GDBusObjectSkeleton.
		 * @param object_path An object path.
		 * @returns A #GDBusObjectSkeleton. Free with {@link GObject.unref}.
		 */
		public static new(object_path: string): DBusObjectSkeleton;
	}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link DBusProxy} instead.
	 */
	interface IDBusProxy {
		/**
		 * The #GDBusConnection the proxy is for.
		 */
		g_connection: DBusConnection;
		/**
		 * The timeout to use if -1 (specifying default timeout) is passed
		 * as #timeout_msec in the {@link G.dbus_proxy_call} and
		 * g_dbus_proxy_call_sync() functions.
		 * 
		 * This allows applications to set a proxy-wide timeout for all
		 * remote method invocations on the proxy. If this property is -1,
		 * the default timeout (typically 25 seconds) is used. If set to
		 * %G_MAXINT, then no timeout is used.
		 */
		g_default_timeout: number;
		/**
		 * Flags from the #GDBusProxyFlags enumeration.
		 */
		g_flags: DBusProxyFlags;
		/**
		 * Ensure that interactions with this proxy conform to the given
		 * interface. This is mainly to ensure that malformed data received
		 * from the other peer is ignored. The given #GDBusInterfaceInfo is
		 * said to be the "expected interface".
		 * 
		 * The checks performed are:
		 * - When completing a method call, if the type signature of
		 *   the reply message isn't what's expected, the reply is
		 *   discarded and the #GError is set to %G_IO_ERROR_INVALID_ARGUMENT.
		 * 
		 * - Received signals that have a type signature mismatch are dropped and
		 *   a warning is logged via {@link G.warning}.
		 * 
		 * - Properties received via the initial `GetAll()` call or via the
		 *   `::PropertiesChanged` signal (on the
		 *   [org.freedesktop.DBus.Properties](http://dbus.freedesktop.org/doc/dbus-specification.html#standard-interfaces-properties)
		 *   interface) or set using g_dbus_proxy_set_cached_property()
		 *   with a type signature mismatch are ignored and a warning is
		 *   logged via g_warning().
		 * 
		 * Note that these checks are never done on methods, signals and
		 * properties that are not referenced in the given
		 * #GDBusInterfaceInfo, since extending a D-Bus interface on the
		 * service-side is not considered an ABI break.
		 */
		g_interface_info: DBusInterfaceInfo;
		/**
		 * The D-Bus interface name the proxy is for.
		 */
		g_interface_name: string;
		/**
		 * The well-known or unique name that the proxy is for.
		 */
		g_name: string;
		/**
		 * The unique name that owns #GDBusProxy:g-name or %NULL if no-one
		 * currently owns that name. You may connect to #GObject::notify signal to
		 * track changes to this property.
		 */
		readonly g_name_owner: string;
		/**
		 * The object path the proxy is for.
		 */
		g_object_path: string;
		/**
		 * Asynchronously invokes the #method_name method on #proxy.
		 * 
		 * If #method_name contains any dots, then #name is split into interface and
		 * method name parts. This allows using #proxy for invoking methods on
		 * other interfaces.
		 * 
		 * If the #GDBusConnection associated with #proxy is closed then
		 * the operation will fail with %G_IO_ERROR_CLOSED. If
		 * #cancellable is canceled, the operation will fail with
		 * %G_IO_ERROR_CANCELLED. If #parameters contains a value not
		 * compatible with the D-Bus protocol, the operation fails with
		 * %G_IO_ERROR_INVALID_ARGUMENT.
		 * 
		 * If the #parameters #GVariant is floating, it is consumed. This allows
		 * convenient 'inline' use of {@link G.variant_new}, e.g.:
		 * |[<!-- language="C" -->
		 *  g_dbus_proxy_call (proxy,
		 *                     "TwoStrings",
		 *                     g_variant_new ("(ss)",
		 *                                    "Thing One",
		 *                                    "Thing Two"),
		 *                     G_DBUS_CALL_FLAGS_NONE,
		 *                     -1,
		 *                     NULL,
		 *                     (GAsyncReadyCallback) two_strings_done,
		 *                     &data);
		 * ]|
		 * 
		 * If #proxy has an expected interface (see
		 * #GDBusProxy:g-interface-info) and #method_name is referenced by it,
		 * then the return value is checked against the return type.
		 * 
		 * This is an asynchronous method. When the operation is finished,
		 * #callback will be invoked in the
		 * [thread-default main context][g-main-context-push-thread-default]
		 * of the thread you are calling this method from.
		 * You can then call g_dbus_proxy_call_finish() to get the result of
		 * the operation. See g_dbus_proxy_call_sync() for the synchronous
		 * version of this method.
		 * 
		 * If #callback is %NULL then the D-Bus method call message will be sent with
		 * the %G_DBUS_MESSAGE_FLAGS_NO_REPLY_EXPECTED flag set.
		 * @param method_name Name of method to invoke.
		 * @param parameters A #GVariant tuple with parameters for the signal or %NULL if not passing parameters.
		 * @param flags Flags from the #GDBusCallFlags enumeration.
		 * @param timeout_msec The timeout in milliseconds (with %G_MAXINT meaning
		 *                "infinite") or -1 to use the proxy default timeout.
		 * @param cancellable A #GCancellable or %NULL.
		 * @param callback A #GAsyncReadyCallback to call when the request is satisfied or %NULL if you don't
		 * care about the result of the method invocation.
		 */
		call(method_name: string, parameters: GLib.Variant | null, flags: DBusCallFlags, timeout_msec: number, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;
		/**
		 * Finishes an operation started with {@link G.dbus_proxy_call}.
		 * @param res A #GAsyncResult obtained from the #GAsyncReadyCallback passed to {@link G.dbus_proxy_call}.
		 * @returns %NULL if #error is set. Otherwise a #GVariant tuple with
		 * return values. Free with {@link G.variant_unref}.
		 */
		call_finish(res: AsyncResult): GLib.Variant;
		/**
		 * Synchronously invokes the #method_name method on #proxy.
		 * 
		 * If #method_name contains any dots, then #name is split into interface and
		 * method name parts. This allows using #proxy for invoking methods on
		 * other interfaces.
		 * 
		 * If the #GDBusConnection associated with #proxy is disconnected then
		 * the operation will fail with %G_IO_ERROR_CLOSED. If
		 * #cancellable is canceled, the operation will fail with
		 * %G_IO_ERROR_CANCELLED. If #parameters contains a value not
		 * compatible with the D-Bus protocol, the operation fails with
		 * %G_IO_ERROR_INVALID_ARGUMENT.
		 * 
		 * If the #parameters #GVariant is floating, it is consumed. This allows
		 * convenient 'inline' use of {@link G.variant_new}, e.g.:
		 * |[<!-- language="C" -->
		 *  g_dbus_proxy_call_sync (proxy,
		 *                          "TwoStrings",
		 *                          g_variant_new ("(ss)",
		 *                                         "Thing One",
		 *                                         "Thing Two"),
		 *                          G_DBUS_CALL_FLAGS_NONE,
		 *                          -1,
		 *                          NULL,
		 *                          &error);
		 * ]|
		 * 
		 * The calling thread is blocked until a reply is received. See
		 * g_dbus_proxy_call() for the asynchronous version of this
		 * method.
		 * 
		 * If #proxy has an expected interface (see
		 * #GDBusProxy:g-interface-info) and #method_name is referenced by it,
		 * then the return value is checked against the return type.
		 * @param method_name Name of method to invoke.
		 * @param parameters A #GVariant tuple with parameters for the signal
		 *              or %NULL if not passing parameters.
		 * @param flags Flags from the #GDBusCallFlags enumeration.
		 * @param timeout_msec The timeout in milliseconds (with %G_MAXINT meaning
		 *                "infinite") or -1 to use the proxy default timeout.
		 * @param cancellable A #GCancellable or %NULL.
		 * @returns %NULL if #error is set. Otherwise a #GVariant tuple with
		 * return values. Free with {@link G.variant_unref}.
		 */
		call_sync(method_name: string, parameters: GLib.Variant | null, flags: DBusCallFlags, timeout_msec: number, cancellable?: Cancellable | null): GLib.Variant;
		/**
		 * Like {@link G.dbus_proxy_call} but also takes a #GUnixFDList object.
		 * 
		 * This method is only available on UNIX.
		 * @param method_name Name of method to invoke.
		 * @param parameters A #GVariant tuple with parameters for the signal or %NULL if not passing parameters.
		 * @param flags Flags from the #GDBusCallFlags enumeration.
		 * @param timeout_msec The timeout in milliseconds (with %G_MAXINT meaning
		 *                "infinite") or -1 to use the proxy default timeout.
		 * @param fd_list A #GUnixFDList or %NULL.
		 * @param cancellable A #GCancellable or %NULL.
		 * @param callback A #GAsyncReadyCallback to call when the request is satisfied or %NULL if you don't
		 * care about the result of the method invocation.
		 */
		call_with_unix_fd_list(method_name: string, parameters: GLib.Variant | null, flags: DBusCallFlags, timeout_msec: number, fd_list?: UnixFDList | null, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;
		/**
		 * Finishes an operation started with {@link G.dbus_proxy_call_with_unix_fd_list}.
		 * @param res A #GAsyncResult obtained from the #GAsyncReadyCallback passed to {@link G.dbus_proxy_call_with_unix_fd_list}.
		 * @returns %NULL if #error is set. Otherwise a #GVariant tuple with
		 * return values. Free with {@link G.variant_unref}.
		 * 
		 * Return location for a #GUnixFDList or %NULL.
		 */
		call_with_unix_fd_list_finish(res: AsyncResult): [ GLib.Variant, UnixFDList | null ];
		/**
		 * Like {@link G.dbus_proxy_call_sync} but also takes and returns #GUnixFDList objects.
		 * 
		 * This method is only available on UNIX.
		 * @param method_name Name of method to invoke.
		 * @param parameters A #GVariant tuple with parameters for the signal
		 *              or %NULL if not passing parameters.
		 * @param flags Flags from the #GDBusCallFlags enumeration.
		 * @param timeout_msec The timeout in milliseconds (with %G_MAXINT meaning
		 *                "infinite") or -1 to use the proxy default timeout.
		 * @param fd_list A #GUnixFDList or %NULL.
		 * @param cancellable A #GCancellable or %NULL.
		 * @returns %NULL if #error is set. Otherwise a #GVariant tuple with
		 * return values. Free with {@link G.variant_unref}.
		 * 
		 * Return location for a #GUnixFDList or %NULL.
		 */
		call_with_unix_fd_list_sync(method_name: string, parameters: GLib.Variant | null, flags: DBusCallFlags, timeout_msec: number, fd_list?: UnixFDList | null, cancellable?: Cancellable | null): [ GLib.Variant, UnixFDList | null ];
		/**
		 * Looks up the value for a property from the cache. This call does no
		 * blocking IO.
		 * 
		 * If #proxy has an expected interface (see
		 * #GDBusProxy:g-interface-info) and #property_name is referenced by
		 * it, then #value is checked against the type of the property.
		 * @param property_name Property name.
		 * @returns A reference to the #GVariant instance
		 *    that holds the value for #property_name or %NULL if the value is not in
		 *    the cache. The returned reference must be freed with {@link G.variant_unref}.
		 */
		get_cached_property(property_name: string): GLib.Variant | null;
		/**
		 * Gets the names of all cached properties on #proxy.
		 * @returns A
		 *          %NULL-terminated array of strings or %NULL if
		 *          #proxy has no cached properties. Free the returned array with
		 *          {@link G.strfreev}.
		 */
		get_cached_property_names(): string[] | null;
		/**
		 * Gets the connection #proxy is for.
		 * @returns A #GDBusConnection owned by #proxy. Do not free.
		 */
		get_connection(): DBusConnection;
		/**
		 * Gets the timeout to use if -1 (specifying default timeout) is
		 * passed as #timeout_msec in the {@link G.dbus_proxy_call} and
		 * g_dbus_proxy_call_sync() functions.
		 * 
		 * See the #GDBusProxy:g-default-timeout property for more details.
		 * @returns Timeout to use for #proxy.
		 */
		get_default_timeout(): number;
		/**
		 * Gets the flags that #proxy was constructed with.
		 * @returns Flags from the #GDBusProxyFlags enumeration.
		 */
		get_flags(): DBusProxyFlags;
		/**
		 * Returns the #GDBusInterfaceInfo, if any, specifying the interface
		 * that #proxy conforms to. See the #GDBusProxy:g-interface-info
		 * property for more details.
		 * @returns A #GDBusInterfaceInfo or %NULL.
		 *    Do not unref the returned object, it is owned by #proxy.
		 */
		get_interface_info(): DBusInterfaceInfo | null;
		/**
		 * Gets the D-Bus interface name #proxy is for.
		 * @returns A string owned by #proxy. Do not free.
		 */
		get_interface_name(): string;
		/**
		 * Gets the name that #proxy was constructed for.
		 * 
		 * When connected to a message bus, this will usually be non-%NULL.
		 * However, it may be %NULL for a proxy that communicates using a peer-to-peer
		 * pattern.
		 * @returns A string owned by #proxy. Do not free.
		 */
		get_name(): string | null;
		/**
		 * The unique name that owns the name that #proxy is for or %NULL if
		 * no-one currently owns that name. You may connect to the
		 * #GObject::notify signal to track changes to the
		 * #GDBusProxy:g-name-owner property.
		 * @returns The name owner or %NULL if no name
		 *    owner exists. Free with {@link G.free}.
		 */
		get_name_owner(): string | null;
		/**
		 * Gets the object path #proxy is for.
		 * @returns A string owned by #proxy. Do not free.
		 */
		get_object_path(): string;
		/**
		 * If #value is not %NULL, sets the cached value for the property with
		 * name #property_name to the value in #value.
		 * 
		 * If #value is %NULL, then the cached value is removed from the
		 * property cache.
		 * 
		 * If #proxy has an expected interface (see
		 * #GDBusProxy:g-interface-info) and #property_name is referenced by
		 * it, then #value is checked against the type of the property.
		 * 
		 * If the #value #GVariant is floating, it is consumed. This allows
		 * convenient 'inline' use of {@link G.variant_new}, e.g.
		 * |[<!-- language="C" -->
		 *  g_dbus_proxy_set_cached_property (proxy,
		 *                                    "SomeProperty",
		 *                                    g_variant_new ("(si)",
		 *                                                  "A String",
		 *                                                  42));
		 * ]|
		 * 
		 * Normally you will not need to use this method since #proxy
		 * is tracking changes using the
		 * `org.freedesktop.DBus.Properties.PropertiesChanged`
		 * D-Bus signal. However, for performance reasons an object may
		 * decide to not use this signal for some properties and instead
		 * use a proprietary out-of-band mechanism to transmit changes.
		 * 
		 * As a concrete example, consider an object with a property
		 * `ChatroomParticipants` which is an array of strings. Instead of
		 * transmitting the same (long) array every time the property changes,
		 * it is more efficient to only transmit the delta using e.g. signals
		 * `ChatroomParticipantJoined(String name)` and
		 * `ChatroomParticipantParted(String name)`.
		 * @param property_name Property name.
		 * @param value Value for the property or %NULL to remove it from the cache.
		 */
		set_cached_property(property_name: string, value?: GLib.Variant | null): void;
		/**
		 * Sets the timeout to use if -1 (specifying default timeout) is
		 * passed as #timeout_msec in the {@link G.dbus_proxy_call} and
		 * g_dbus_proxy_call_sync() functions.
		 * 
		 * See the #GDBusProxy:g-default-timeout property for more details.
		 * @param timeout_msec Timeout in milliseconds.
		 */
		set_default_timeout(timeout_msec: number): void;
		/**
		 * Ensure that interactions with #proxy conform to the given
		 * interface. See the #GDBusProxy:g-interface-info property for more
		 * details.
		 * @param info Minimum interface this proxy conforms to
		 *    or %NULL to unset.
		 */
		set_interface_info(info?: DBusInterfaceInfo | null): void;
		/**
		 * Emitted when one or more D-Bus properties on #proxy changes. The
		 * local cache has already been updated when this signal fires. Note
		 * that both #changed_properties and #invalidated_properties are
		 * guaranteed to never be %NULL (either may be empty though).
		 * 
		 * If the proxy has the flag
		 * %G_DBUS_PROXY_FLAGS_GET_INVALIDATED_PROPERTIES set, then
		 * #invalidated_properties will always be empty.
		 * 
		 * This signal corresponds to the
		 * `PropertiesChanged` D-Bus signal on the
		 * `org.freedesktop.DBus.Properties` interface.
		 * @param signal 
		 * @param callback Callback function
		 *  - owner: owner of the emitted event 
		 *  - changed_properties: A #GVariant containing the properties that changed (type: `a{sv}`) 
		 *  - invalidated_properties: A %NULL terminated array of properties that was invalidated 
		 * 
		 * @returns Callback ID
		 */
		connect(signal: "g-properties-changed", callback: (owner: this, changed_properties: GLib.Variant, invalidated_properties: string[]) => void): number;
		/**
		 * Emitted when a signal from the remote object and interface that #proxy is for, has been received.
		 * @param signal 
		 * @param callback Callback function
		 *  - owner: owner of the emitted event 
		 *  - sender_name: The sender of the signal or %NULL if the connection is not a bus connection. 
		 *  - signal_name: The name of the signal. 
		 *  - parameters: A #GVariant tuple with parameters for the signal. 
		 * 
		 * @returns Callback ID
		 */
		connect(signal: "g-signal", callback: (owner: this, sender_name: string | null, signal_name: string, parameters: GLib.Variant) => void): number;

		connect(signal: "notify::g-connection", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::g-default-timeout", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::g-flags", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::g-interface-info", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::g-interface-name", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::g-name", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::g-name-owner", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::g-object-path", callback: (owner: this, ...args: any) => void): number;

	}

	type DBusProxyInitOptionsMixin = GObject.ObjectInitOptions & AsyncInitableInitOptions & DBusInterfaceInitOptions & InitableInitOptions & 
	Pick<IDBusProxy,
		"g_connection" |
		"g_default_timeout" |
		"g_flags" |
		"g_interface_info" |
		"g_interface_name" |
		"g_name" |
		"g_object_path">;

	export interface DBusProxyInitOptions extends DBusProxyInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link DBusProxy} instead.
	 */
	type DBusProxyMixin = IDBusProxy & GObject.Object & AsyncInitable & DBusInterface & Initable;

	/**
	 * #GDBusProxy is a base class used for proxies to access a D-Bus
	 * interface on a remote object. A #GDBusProxy can be constructed for
	 * both well-known and unique names.
	 * 
	 * By default, #GDBusProxy will cache all properties (and listen to
	 * changes) of the remote object, and proxy all signals that get
	 * emitted. This behaviour can be changed by passing suitable
	 * #GDBusProxyFlags when the proxy is created. If the proxy is for a
	 * well-known name, the property cache is flushed when the name owner
	 * vanishes and reloaded when a name owner appears.
	 * 
	 * The unique name owner of the proxy's name is tracked and can be read from
	 * #GDBusProxy:g-name-owner. Connect to the #GObject::notify signal to
	 * get notified of changes. Additionally, only signals and property
	 * changes emitted from the current name owner are considered and
	 * calls are always sent to the current name owner. This avoids a
	 * number of race conditions when the name is lost by one owner and
	 * claimed by another. However, if no name owner currently exists,
	 * then calls will be sent to the well-known name which may result in
	 * the message bus launching an owner (unless
	 * %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START is set).
	 * 
	 * If the proxy is for a stateless D-Bus service, where the name owner may
	 * be started and stopped between calls, the #GDBusProxy:g-name-owner tracking
	 * of #GDBusProxy will cause the proxy to drop signal and property changes from
	 * the service after it has restarted for the first time. When interacting
	 * with a stateless D-Bus service, do not use #GDBusProxy — use direct D-Bus
	 * method calls and signal connections.
	 * 
	 * The generic #GDBusProxy::g-properties-changed and
	 * #GDBusProxy::g-signal signals are not very convenient to work with.
	 * Therefore, the recommended way of working with proxies is to subclass
	 * #GDBusProxy, and have more natural properties and signals in your derived
	 * class. This [example][gdbus-example-gdbus-codegen] shows how this can
	 * easily be done using the [gdbus-codegen][gdbus-codegen] tool.
	 * 
	 * A #GDBusProxy instance can be used from multiple threads but note
	 * that all signals (e.g. #GDBusProxy::g-signal, #GDBusProxy::g-properties-changed
	 * and #GObject::notify) are emitted in the
	 * [thread-default main context][g-main-context-push-thread-default]
	 * of the thread where the instance was constructed.
	 * 
	 * An example using a proxy for a well-known name can be found in
	 * [gdbus-example-watch-proxy.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gdbus-example-watch-proxy.c)
	 */
	interface DBusProxy extends DBusProxyMixin {}

	class DBusProxy {
		public constructor(options?: Partial<DBusProxyInitOptions>);
		/**
		 * Finishes creating a #GDBusProxy.
		 * @param res A #GAsyncResult obtained from the #GAsyncReadyCallback function passed to {@link G.dbus_proxy_new}.
		 * @returns A #GDBusProxy or %NULL if #error is set.
		 *    Free with {@link GObject.unref}.
		 */
		public static new_finish(res: AsyncResult): DBusProxy;
		/**
		 * Finishes creating a #GDBusProxy.
		 * @param res A #GAsyncResult obtained from the #GAsyncReadyCallback function passed to {@link G.dbus_proxy_new_for_bus}.
		 * @returns A #GDBusProxy or %NULL if #error is set.
		 *    Free with {@link GObject.unref}.
		 */
		public static new_for_bus_finish(res: AsyncResult): DBusProxy;
		/**
		 * Like {@link G.dbus_proxy_new_sync} but takes a #GBusType instead of a #GDBusConnection.
		 * 
		 * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
		 * @param bus_type A #GBusType.
		 * @param flags Flags used when constructing the proxy.
		 * @param info A #GDBusInterfaceInfo specifying the minimal interface
		 *        that #proxy conforms to or %NULL.
		 * @param name A bus name (well-known or unique).
		 * @param object_path An object path.
		 * @param interface_name A D-Bus interface name.
		 * @param cancellable A #GCancellable or %NULL.
		 * @returns A #GDBusProxy or %NULL if error is set.
		 *    Free with {@link GObject.unref}.
		 */
		public static new_for_bus_sync(bus_type: BusType, flags: DBusProxyFlags, info: DBusInterfaceInfo | null, name: string, object_path: string, interface_name: string, cancellable?: Cancellable | null): DBusProxy;
		/**
		 * Creates a proxy for accessing #interface_name on the remote object
		 * at #object_path owned by #name at #connection and synchronously
		 * loads D-Bus properties unless the
		 * %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES flag is used.
		 * 
		 * If the %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS flag is not set, also sets up
		 * match rules for signals. Connect to the #GDBusProxy::g-signal signal
		 * to handle signals from the remote object.
		 * 
		 * If both %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES and
		 * %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS are set, this constructor is
		 * guaranteed to return immediately without blocking.
		 * 
		 * If #name is a well-known name and the
		 * %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START and %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION
		 * flags aren't set and no name owner currently exists, the message bus
		 * will be requested to launch a name owner for the name.
		 * 
		 * This is a synchronous failable constructor. See {@link G.dbus_proxy_new}
		 * and g_dbus_proxy_new_finish() for the asynchronous version.
		 * 
		 * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
		 * @param connection A #GDBusConnection.
		 * @param flags Flags used when constructing the proxy.
		 * @param info A #GDBusInterfaceInfo specifying the minimal interface that #proxy conforms to or %NULL.
		 * @param name A bus name (well-known or unique) or %NULL if #connection is not a message bus connection.
		 * @param object_path An object path.
		 * @param interface_name A D-Bus interface name.
		 * @param cancellable A #GCancellable or %NULL.
		 * @returns A #GDBusProxy or %NULL if error is set.
		 *    Free with {@link GObject.unref}.
		 */
		public static new_sync(connection: DBusConnection, flags: DBusProxyFlags, info: DBusInterfaceInfo | null, name: string | null, object_path: string, interface_name: string, cancellable?: Cancellable | null): DBusProxy;
		/**
		 * Creates a proxy for accessing #interface_name on the remote object
		 * at #object_path owned by #name at #connection and asynchronously
		 * loads D-Bus properties unless the
		 * %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES flag is used. Connect to
		 * the #GDBusProxy::g-properties-changed signal to get notified about
		 * property changes.
		 * 
		 * If the %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS flag is not set, also sets up
		 * match rules for signals. Connect to the #GDBusProxy::g-signal signal
		 * to handle signals from the remote object.
		 * 
		 * If both %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES and
		 * %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS are set, this constructor is
		 * guaranteed to complete immediately without blocking.
		 * 
		 * If #name is a well-known name and the
		 * %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START and %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION
		 * flags aren't set and no name owner currently exists, the message bus
		 * will be requested to launch a name owner for the name.
		 * 
		 * This is a failable asynchronous constructor - when the proxy is
		 * ready, #callback will be invoked and you can use
		 * {@link G.dbus_proxy_new_finish} to get the result.
		 * 
		 * See g_dbus_proxy_new_sync() and for a synchronous version of this constructor.
		 * 
		 * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
		 * @param connection A #GDBusConnection.
		 * @param flags Flags used when constructing the proxy.
		 * @param info A #GDBusInterfaceInfo specifying the minimal interface that #proxy conforms to or %NULL.
		 * @param name A bus name (well-known or unique) or %NULL if #connection is not a message bus connection.
		 * @param object_path An object path.
		 * @param interface_name A D-Bus interface name.
		 * @param cancellable A #GCancellable or %NULL.
		 * @param callback Callback function to invoke when the proxy is ready.
		 */
		public static new(connection: DBusConnection, flags: DBusProxyFlags, info: DBusInterfaceInfo | null, name: string | null, object_path: string, interface_name: string, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;
		/**
		 * Like {@link G.dbus_proxy_new} but takes a #GBusType instead of a #GDBusConnection.
		 * 
		 * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
		 * @param bus_type A #GBusType.
		 * @param flags Flags used when constructing the proxy.
		 * @param info A #GDBusInterfaceInfo specifying the minimal interface that #proxy conforms to or %NULL.
		 * @param name A bus name (well-known or unique).
		 * @param object_path An object path.
		 * @param interface_name A D-Bus interface name.
		 * @param cancellable A #GCancellable or %NULL.
		 * @param callback Callback function to invoke when the proxy is ready.
		 */
		public static new_for_bus(bus_type: BusType, flags: DBusProxyFlags, info: DBusInterfaceInfo | null, name: string, object_path: string, interface_name: string, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;
	}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link DBusServer} instead.
	 */
	interface IDBusServer {
		/**
		 * Whether the server is currently active.
		 */
		readonly active: boolean;
		/**
		 * The D-Bus address to listen on.
		 */
		address: string;
		/**
		 * A #GDBusAuthObserver object to assist in the authentication process or %NULL.
		 */
		authentication_observer: DBusAuthObserver;
		/**
		 * The D-Bus address that clients can use.
		 */
		readonly client_address: string;
		/**
		 * Flags from the #GDBusServerFlags enumeration.
		 */
		flags: DBusServerFlags;
		/**
		 * The GUID of the server.
		 * 
		 * See #GDBusConnection:guid for more details.
		 */
		guid: string;
		/**
		 * Gets a
		 * [D-Bus address](https://dbus.freedesktop.org/doc/dbus-specification.html#addresses)
		 * string that can be used by clients to connect to #server.
		 * 
		 * This is valid and non-empty if initializing the #GDBusServer succeeded.
		 * @returns A D-Bus address string. Do not free, the string is owned
		 * by #server.
		 */
		get_client_address(): string;
		/**
		 * Gets the flags for #server.
		 * @returns A set of flags from the #GDBusServerFlags enumeration.
		 */
		get_flags(): DBusServerFlags;
		/**
		 * Gets the GUID for #server, as provided to {@link G.dbus_server_new_sync}.
		 * @returns A D-Bus GUID. Do not free this string, it is owned by #server.
		 */
		get_guid(): string;
		/**
		 * Gets whether #server is active.
		 * @returns %TRUE if server is active, %FALSE otherwise.
		 */
		is_active(): boolean;
		/**
		 * Starts #server.
		 */
		start(): void;
		/**
		 * Stops #server.
		 */
		stop(): void;
		/**
		 * Emitted when a new authenticated connection has been made. Use
		 * {@link G.dbus_connection_get_peer_credentials} to figure out what
		 * identity (if any), was authenticated.
		 * 
		 * If you want to accept the connection, take a reference to the
		 * #connection object and return %TRUE. When you are done with the
		 * connection call g_dbus_connection_close() and give up your
		 * reference. Note that the other peer may disconnect at any time -
		 * a typical thing to do when accepting a connection is to listen to
		 * the #GDBusConnection::closed signal.
		 * 
		 * If #GDBusServer:flags contains %G_DBUS_SERVER_FLAGS_RUN_IN_THREAD
		 * then the signal is emitted in a new thread dedicated to the
		 * connection. Otherwise the signal is emitted in the
		 * [thread-default main context][g-main-context-push-thread-default]
		 * of the thread that #server was constructed in.
		 * 
		 * You are guaranteed that signal handlers for this signal runs
		 * before incoming messages on #connection are processed. This means
		 * that it's suitable to call g_dbus_connection_register_object() or
		 * similar from the signal handler.
		 * @param signal 
		 * @param callback Callback function
		 *  - owner: owner of the emitted event 
		 *  - connection: A #GDBusConnection for the new connection. 
		 *  - returns %TRUE to claim #connection, %FALSE to let other handlers
		 * run. 
		 * 
		 * @returns Callback ID
		 */
		connect(signal: "new-connection", callback: (owner: this, connection: DBusConnection) => boolean): number;

		connect(signal: "notify::active", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::address", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::authentication-observer", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::client-address", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::flags", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::guid", callback: (owner: this, ...args: any) => void): number;

	}

	type DBusServerInitOptionsMixin = GObject.ObjectInitOptions & InitableInitOptions & 
	Pick<IDBusServer,
		"address" |
		"authentication_observer" |
		"flags" |
		"guid">;

	export interface DBusServerInitOptions extends DBusServerInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link DBusServer} instead.
	 */
	type DBusServerMixin = IDBusServer & GObject.Object & Initable;

	/**
	 * #GDBusServer is a helper for listening to and accepting D-Bus
	 * connections. This can be used to create a new D-Bus server, allowing two
	 * peers to use the D-Bus protocol for their own specialized communication.
	 * A server instance provided in this way will not perform message routing or
	 * implement the org.freedesktop.DBus interface.
	 * 
	 * To just export an object on a well-known name on a message bus, such as the
	 * session or system bus, you should instead use {@link G.bus_own_name}.
	 * 
	 * An example of peer-to-peer communication with GDBus can be found
	 * in [gdbus-example-peer.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gdbus-example-peer.c).
	 * 
	 * Note that a minimal #GDBusServer will accept connections from any
	 * peer. In many use-cases it will be necessary to add a #GDBusAuthObserver
	 * that only accepts connections that have successfully authenticated
	 * as the same user that is running the #GDBusServer. Since GLib 2.68 this can
	 * be achieved more simply by passing the
	 * %G_DBUS_SERVER_FLAGS_AUTHENTICATION_REQUIRE_SAME_USER flag to the server.
	 */
	interface DBusServer extends DBusServerMixin {}

	class DBusServer {
		public constructor(options?: Partial<DBusServerInitOptions>);
		/**
		 * Creates a new D-Bus server that listens on the first address in
		 * #address that works.
		 * 
		 * Once constructed, you can use {@link G.dbus_server_get_client_address} to
		 * get a D-Bus address string that clients can use to connect.
		 * 
		 * To have control over the available authentication mechanisms and
		 * the users that are authorized to connect, it is strongly recommended
		 * to provide a non-%NULL #GDBusAuthObserver.
		 * 
		 * Connect to the #GDBusServer::new-connection signal to handle
		 * incoming connections.
		 * 
		 * The returned #GDBusServer isn't active - you have to start it with
		 * g_dbus_server_start().
		 * 
		 * #GDBusServer is used in this [example][gdbus-peer-to-peer].
		 * 
		 * This is a synchronous failable constructor. There is currently no
		 * asynchronous version.
		 * @param address A D-Bus address.
		 * @param flags Flags from the #GDBusServerFlags enumeration.
		 * @param guid A D-Bus GUID.
		 * @param observer A #GDBusAuthObserver or %NULL.
		 * @param cancellable A #GCancellable or %NULL.
		 * @returns A #GDBusServer or %NULL if #error is set. Free with
		 * {@link GObject.unref}.
		 */
		public static new_sync(address: string, flags: DBusServerFlags, guid: string, observer?: DBusAuthObserver | null, cancellable?: Cancellable | null): DBusServer;
	}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link DataInputStream} instead.
	 */
	interface IDataInputStream {
		/**
		 * The :byte-order property determines the byte ordering that
		 * is used when reading multi-byte entities (such as integers)
		 * from the stream.
		 */
		byte_order: DataStreamByteOrder;
		/**
		 * The :newline-type property determines what is considered
		 * as a line ending when reading complete lines from the stream.
		 */
		newline_type: DataStreamNewlineType;
		/**
		 * Gets the byte order for the data input stream.
		 * @returns the #stream's current #GDataStreamByteOrder.
		 */
		get_byte_order(): DataStreamByteOrder;
		/**
		 * Gets the current newline type for the #stream.
		 * @returns #GDataStreamNewlineType for the given #stream.
		 */
		get_newline_type(): DataStreamNewlineType;
		/**
		 * Reads an unsigned 8-bit/1-byte value from #stream.
		 * @param cancellable optional #GCancellable object, %NULL to ignore.
		 * @returns an unsigned 8-bit/1-byte value read from the #stream or `0`
		 * if an error occurred.
		 */
		read_byte(cancellable?: Cancellable | null): number;
		/**
		 * Reads a 16-bit/2-byte value from #stream.
		 * 
		 * In order to get the correct byte order for this read operation,
		 * see {@link G.data_input_stream_get_byte_order} and g_data_input_stream_set_byte_order().
		 * @param cancellable optional #GCancellable object, %NULL to ignore.
		 * @returns a signed 16-bit/2-byte value read from #stream or `0` if
		 * an error occurred.
		 */
		read_int16(cancellable?: Cancellable | null): number;
		/**
		 * Reads a signed 32-bit/4-byte value from #stream.
		 * 
		 * In order to get the correct byte order for this read operation,
		 * see {@link G.data_input_stream_get_byte_order} and g_data_input_stream_set_byte_order().
		 * 
		 * If #cancellable is not %NULL, then the operation can be cancelled by
		 * triggering the cancellable object from another thread. If the operation
		 * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
		 * @param cancellable optional #GCancellable object, %NULL to ignore.
		 * @returns a signed 32-bit/4-byte value read from the #stream or `0` if
		 * an error occurred.
		 */
		read_int32(cancellable?: Cancellable | null): number;
		/**
		 * Reads a 64-bit/8-byte value from #stream.
		 * 
		 * In order to get the correct byte order for this read operation,
		 * see {@link G.data_input_stream_get_byte_order} and g_data_input_stream_set_byte_order().
		 * 
		 * If #cancellable is not %NULL, then the operation can be cancelled by
		 * triggering the cancellable object from another thread. If the operation
		 * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
		 * @param cancellable optional #GCancellable object, %NULL to ignore.
		 * @returns a signed 64-bit/8-byte value read from #stream or `0` if
		 * an error occurred.
		 */
		read_int64(cancellable?: Cancellable | null): number;
		/**
		 * Reads a line from the data input stream.  Note that no encoding
		 * checks or conversion is performed; the input is not guaranteed to
		 * be UTF-8, and may in fact have embedded NUL characters.
		 * 
		 * If #cancellable is not %NULL, then the operation can be cancelled by
		 * triggering the cancellable object from another thread. If the operation
		 * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
		 * @param cancellable optional #GCancellable object, %NULL to ignore.
		 * @returns 
		 *  a NUL terminated byte array with the line that was read in
		 *  (without the newlines).  Set #length to a #gsize to get the length
		 *  of the read line.  On an error, it will return %NULL and #error
		 *  will be set. If there's no content to read, it will still return
		 *  %NULL, but #error won't be set.
		 * 
		 * a #gsize to get the length of the data read in.
		 */
		read_line(cancellable?: Cancellable | null): [ number[] | null, number | null ];
		/**
		 * The asynchronous version of {@link G.data_input_stream_read_line}.  It is
		 * an error to have two outstanding calls to this function.
		 * 
		 * When the operation is finished, #callback will be called. You
		 * can then call g_data_input_stream_read_line_finish() to get
		 * the result of the operation.
		 * @param io_priority the [I/O priority][io-priority] of the request
		 * @param cancellable optional #GCancellable object, %NULL to ignore.
		 * @param callback callback to call when the request is satisfied.
		 */
		read_line_async(io_priority: number, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;
		/**
		 * Finish an asynchronous call started by
		 * {@link G.data_input_stream_read_line_async}.  Note the warning about
		 * string encoding in g_data_input_stream_read_line() applies here as
		 * well.
		 * @param result the #GAsyncResult that was provided to the callback.
		 * @returns 
		 *  a NUL-terminated byte array with the line that was read in
		 *  (without the newlines).  Set #length to a #gsize to get the length
		 *  of the read line.  On an error, it will return %NULL and #error
		 *  will be set. If there's no content to read, it will still return
		 *  %NULL, but #error won't be set.
		 * 
		 * a #gsize to get the length of the data read in.
		 */
		read_line_finish(result: AsyncResult): [ number[] | null, number | null ];
		/**
		 * Finish an asynchronous call started by
		 * {@link G.data_input_stream_read_line_async}.
		 * @param result the #GAsyncResult that was provided to the callback.
		 * @returns a string with the line that
		 *  was read in (without the newlines).  Set #length to a #gsize to
		 *  get the length of the read line.  On an error, it will return
		 *  %NULL and #error will be set. For UTF-8 conversion errors, the set
		 *  error domain is %G_CONVERT_ERROR.  If there's no content to read,
		 *  it will still return %NULL, but #error won't be set.
		 * 
		 * a #gsize to get the length of the data read in.
		 */
		read_line_finish_utf8(result: AsyncResult): [ string | null, number | null ];
		/**
		 * Reads a UTF-8 encoded line from the data input stream.
		 * 
		 * If #cancellable is not %NULL, then the operation can be cancelled by
		 * triggering the cancellable object from another thread. If the operation
		 * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
		 * @param cancellable optional #GCancellable object, %NULL to ignore.
		 * @returns a NUL terminated UTF-8 string
		 *  with the line that was read in (without the newlines).  Set
		 *  #length to a #gsize to get the length of the read line.  On an
		 *  error, it will return %NULL and #error will be set.  For UTF-8
		 *  conversion errors, the set error domain is %G_CONVERT_ERROR.  If
		 *  there's no content to read, it will still return %NULL, but #error
		 *  won't be set.
		 * 
		 * a #gsize to get the length of the data read in.
		 */
		read_line_utf8(cancellable?: Cancellable | null): [ string | null, number | null ];
		/**
		 * Reads an unsigned 16-bit/2-byte value from #stream.
		 * 
		 * In order to get the correct byte order for this read operation,
		 * see {@link G.data_input_stream_get_byte_order} and g_data_input_stream_set_byte_order().
		 * @param cancellable optional #GCancellable object, %NULL to ignore.
		 * @returns an unsigned 16-bit/2-byte value read from the #stream or `0` if
		 * an error occurred.
		 */
		read_uint16(cancellable?: Cancellable | null): number;
		/**
		 * Reads an unsigned 32-bit/4-byte value from #stream.
		 * 
		 * In order to get the correct byte order for this read operation,
		 * see {@link G.data_input_stream_get_byte_order} and g_data_input_stream_set_byte_order().
		 * 
		 * If #cancellable is not %NULL, then the operation can be cancelled by
		 * triggering the cancellable object from another thread. If the operation
		 * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
		 * @param cancellable optional #GCancellable object, %NULL to ignore.
		 * @returns an unsigned 32-bit/4-byte value read from the #stream or `0` if
		 * an error occurred.
		 */
		read_uint32(cancellable?: Cancellable | null): number;
		/**
		 * Reads an unsigned 64-bit/8-byte value from #stream.
		 * 
		 * In order to get the correct byte order for this read operation,
		 * see {@link G.data_input_stream_get_byte_order}.
		 * 
		 * If #cancellable is not %NULL, then the operation can be cancelled by
		 * triggering the cancellable object from another thread. If the operation
		 * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
		 * @param cancellable optional #GCancellable object, %NULL to ignore.
		 * @returns an unsigned 64-bit/8-byte read from #stream or `0` if
		 * an error occurred.
		 */
		read_uint64(cancellable?: Cancellable | null): number;
		/**
		 * @deprecated
		 * Use {@link G.data_input_stream_read_upto} instead, which has more
		 *     consistent behaviour regarding the stop character.
		 * 
		 * Reads a string from the data input stream, up to the first
		 * occurrence of any of the stop characters.
		 * 
		 * Note that, in contrast to {@link G.data_input_stream_read_until_async},
		 * this function consumes the stop character that it finds.
		 * 
		 * Don't use this function in new code.  Its functionality is
		 * inconsistent with g_data_input_stream_read_until_async().  Both
		 * functions will be marked as deprecated in a future release.  Use
		 * g_data_input_stream_read_upto() instead, but note that that function
		 * does not consume the stop character.
		 * @param stop_chars characters to terminate the read.
		 * @param cancellable optional #GCancellable object, %NULL to ignore.
		 * @returns a string with the data that was read
		 *     before encountering any of the stop characters. Set #length to
		 *     a #gsize to get the length of the string. This function will
		 *     return %NULL on an error.
		 * 
		 * a #gsize to get the length of the data read in.
		 */
		read_until(stop_chars: string, cancellable?: Cancellable | null): [ string, number | null ];
		/**
		 * @deprecated
		 * Use {@link G.data_input_stream_read_upto_async} instead, which
		 *     has more consistent behaviour regarding the stop character.
		 * 
		 * The asynchronous version of {@link G.data_input_stream_read_until}.
		 * It is an error to have two outstanding calls to this function.
		 * 
		 * Note that, in contrast to g_data_input_stream_read_until(),
		 * this function does not consume the stop character that it finds.  You
		 * must read it for yourself.
		 * 
		 * When the operation is finished, #callback will be called. You
		 * can then call g_data_input_stream_read_until_finish() to get
		 * the result of the operation.
		 * 
		 * Don't use this function in new code.  Its functionality is
		 * inconsistent with g_data_input_stream_read_until().  Both functions
		 * will be marked as deprecated in a future release.  Use
		 * g_data_input_stream_read_upto_async() instead.
		 * @param stop_chars characters to terminate the read.
		 * @param io_priority the [I/O priority][io-priority] of the request
		 * @param cancellable optional #GCancellable object, %NULL to ignore.
		 * @param callback callback to call when the request is satisfied.
		 */
		read_until_async(stop_chars: string, io_priority: number, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;
		/**
		 * @deprecated
		 * Use {@link G.data_input_stream_read_upto_finish} instead, which
		 *     has more consistent behaviour regarding the stop character.
		 * 
		 * Finish an asynchronous call started by
		 * {@link G.data_input_stream_read_until_async}.
		 * @param result the #GAsyncResult that was provided to the callback.
		 * @returns a string with the data that was read
		 *     before encountering any of the stop characters. Set #length to
		 *     a #gsize to get the length of the string. This function will
		 *     return %NULL on an error.
		 * 
		 * a #gsize to get the length of the data read in.
		 */
		read_until_finish(result: AsyncResult): [ string, number | null ];
		/**
		 * Reads a string from the data input stream, up to the first
		 * occurrence of any of the stop characters.
		 * 
		 * In contrast to {@link G.data_input_stream_read_until}, this function
		 * does not consume the stop character. You have to use
		 * g_data_input_stream_read_byte() to get it before calling
		 * g_data_input_stream_read_upto() again.
		 * 
		 * Note that #stop_chars may contain '\0' if #stop_chars_len is
		 * specified.
		 * 
		 * The returned string will always be nul-terminated on success.
		 * @param stop_chars characters to terminate the read
		 * @param stop_chars_len length of #stop_chars. May be -1 if #stop_chars is
		 *     nul-terminated
		 * @param cancellable optional #GCancellable object, %NULL to ignore
		 * @returns a string with the data that was read
		 *     before encountering any of the stop characters. Set #length to
		 *     a #gsize to get the length of the string. This function will
		 *     return %NULL on an error
		 * 
		 * a #gsize to get the length of the data read in
		 */
		read_upto(stop_chars: string, stop_chars_len: number, cancellable?: Cancellable | null): [ string, number | null ];
		/**
		 * The asynchronous version of {@link G.data_input_stream_read_upto}.
		 * It is an error to have two outstanding calls to this function.
		 * 
		 * In contrast to g_data_input_stream_read_until(), this function
		 * does not consume the stop character. You have to use
		 * g_data_input_stream_read_byte() to get it before calling
		 * g_data_input_stream_read_upto() again.
		 * 
		 * Note that #stop_chars may contain '\0' if #stop_chars_len is
		 * specified.
		 * 
		 * When the operation is finished, #callback will be called. You
		 * can then call g_data_input_stream_read_upto_finish() to get
		 * the result of the operation.
		 * @param stop_chars characters to terminate the read
		 * @param stop_chars_len length of #stop_chars. May be -1 if #stop_chars is
		 *     nul-terminated
		 * @param io_priority the [I/O priority][io-priority] of the request
		 * @param cancellable optional #GCancellable object, %NULL to ignore
		 * @param callback callback to call when the request is satisfied
		 */
		read_upto_async(stop_chars: string, stop_chars_len: number, io_priority: number, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;
		/**
		 * Finish an asynchronous call started by
		 * {@link G.data_input_stream_read_upto_async}.
		 * 
		 * Note that this function does not consume the stop character. You
		 * have to use g_data_input_stream_read_byte() to get it before calling
		 * g_data_input_stream_read_upto_async() again.
		 * 
		 * The returned string will always be nul-terminated on success.
		 * @param result the #GAsyncResult that was provided to the callback
		 * @returns a string with the data that was read
		 *     before encountering any of the stop characters. Set #length to
		 *     a #gsize to get the length of the string. This function will
		 *     return %NULL on an error.
		 * 
		 * a #gsize to get the length of the data read in
		 */
		read_upto_finish(result: AsyncResult): [ string, number | null ];
		/**
		 * This function sets the byte order for the given #stream. All subsequent
		 * reads from the #stream will be read in the given #order.
		 * @param order a #GDataStreamByteOrder to set.
		 */
		set_byte_order(order: DataStreamByteOrder): void;
		/**
		 * Sets the newline type for the #stream.
		 * 
		 * Note that using G_DATA_STREAM_NEWLINE_TYPE_ANY is slightly unsafe. If a read
		 * chunk ends in "CR" we must read an additional byte to know if this is "CR" or
		 * "CR LF", and this might block if there is no more data available.
		 * @param type the type of new line return as #GDataStreamNewlineType.
		 */
		set_newline_type(type: DataStreamNewlineType): void;
		connect(signal: "notify::byte-order", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::newline-type", callback: (owner: this, ...args: any) => void): number;

	}

	type DataInputStreamInitOptionsMixin = BufferedInputStreamInitOptions & SeekableInitOptions & 
	Pick<IDataInputStream,
		"byte_order" |
		"newline_type">;

	export interface DataInputStreamInitOptions extends DataInputStreamInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link DataInputStream} instead.
	 */
	type DataInputStreamMixin = IDataInputStream & BufferedInputStream & Seekable;

	/**
	 * Data input stream implements #GInputStream and includes functions for
	 * reading structured data directly from a binary input stream.
	 */
	interface DataInputStream extends DataInputStreamMixin {}

	class DataInputStream {
		public constructor(options?: Partial<DataInputStreamInitOptions>);
		/**
		 * Creates a new data input stream for the #base_stream.
		 * @param base_stream a #GInputStream.
		 * @returns a new #GDataInputStream.
		 */
		public static new(base_stream: InputStream): DataInputStream;
	}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link DataOutputStream} instead.
	 */
	interface IDataOutputStream {
		/**
		 * Determines the byte ordering that is used when writing
		 * multi-byte entities (such as integers) to the stream.
		 */
		byte_order: DataStreamByteOrder;
		/**
		 * Gets the byte order for the stream.
		 * @returns the #GDataStreamByteOrder for the #stream.
		 */
		get_byte_order(): DataStreamByteOrder;
		/**
		 * Puts a byte into the output stream.
		 * @param data a #guchar.
		 * @param cancellable optional #GCancellable object, %NULL to ignore.
		 * @returns %TRUE if #data was successfully added to the #stream.
		 */
		put_byte(data: number, cancellable?: Cancellable | null): boolean;
		/**
		 * Puts a signed 16-bit integer into the output stream.
		 * @param data a #gint16.
		 * @param cancellable optional #GCancellable object, %NULL to ignore.
		 * @returns %TRUE if #data was successfully added to the #stream.
		 */
		put_int16(data: number, cancellable?: Cancellable | null): boolean;
		/**
		 * Puts a signed 32-bit integer into the output stream.
		 * @param data a #gint32.
		 * @param cancellable optional #GCancellable object, %NULL to ignore.
		 * @returns %TRUE if #data was successfully added to the #stream.
		 */
		put_int32(data: number, cancellable?: Cancellable | null): boolean;
		/**
		 * Puts a signed 64-bit integer into the stream.
		 * @param data a #gint64.
		 * @param cancellable optional #GCancellable object, %NULL to ignore.
		 * @returns %TRUE if #data was successfully added to the #stream.
		 */
		put_int64(data: number, cancellable?: Cancellable | null): boolean;
		/**
		 * Puts a string into the output stream.
		 * @param str a string.
		 * @param cancellable optional #GCancellable object, %NULL to ignore.
		 * @returns %TRUE if #string was successfully added to the #stream.
		 */
		put_string(str: string, cancellable?: Cancellable | null): boolean;
		/**
		 * Puts an unsigned 16-bit integer into the output stream.
		 * @param data a #guint16.
		 * @param cancellable optional #GCancellable object, %NULL to ignore.
		 * @returns %TRUE if #data was successfully added to the #stream.
		 */
		put_uint16(data: number, cancellable?: Cancellable | null): boolean;
		/**
		 * Puts an unsigned 32-bit integer into the stream.
		 * @param data a #guint32.
		 * @param cancellable optional #GCancellable object, %NULL to ignore.
		 * @returns %TRUE if #data was successfully added to the #stream.
		 */
		put_uint32(data: number, cancellable?: Cancellable | null): boolean;
		/**
		 * Puts an unsigned 64-bit integer into the stream.
		 * @param data a #guint64.
		 * @param cancellable optional #GCancellable object, %NULL to ignore.
		 * @returns %TRUE if #data was successfully added to the #stream.
		 */
		put_uint64(data: number, cancellable?: Cancellable | null): boolean;
		/**
		 * Sets the byte order of the data output stream to #order.
		 * @param order a %GDataStreamByteOrder.
		 */
		set_byte_order(order: DataStreamByteOrder): void;
		connect(signal: "notify::byte-order", callback: (owner: this, ...args: any) => void): number;

	}

	type DataOutputStreamInitOptionsMixin = FilterOutputStreamInitOptions & SeekableInitOptions & 
	Pick<IDataOutputStream,
		"byte_order">;

	export interface DataOutputStreamInitOptions extends DataOutputStreamInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link DataOutputStream} instead.
	 */
	type DataOutputStreamMixin = IDataOutputStream & FilterOutputStream & Seekable;

	/**
	 * Data output stream implements #GOutputStream and includes functions for
	 * writing data directly to an output stream.
	 */
	interface DataOutputStream extends DataOutputStreamMixin {}

	class DataOutputStream {
		public constructor(options?: Partial<DataOutputStreamInitOptions>);
		/**
		 * Creates a new data output stream for #base_stream.
		 * @param base_stream a #GOutputStream.
		 * @returns #GDataOutputStream.
		 */
		public static new(base_stream: OutputStream): DataOutputStream;
	}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link DesktopAppInfo} instead.
	 */
	interface IDesktopAppInfo {
		/**
		 * The origin filename of this #GDesktopAppInfo
		 */
		filename: string;
		/**
		 * Gets the user-visible display name of the "additional application
		 * action" specified by #action_name.
		 * 
		 * This corresponds to the "Name" key within the keyfile group for the
		 * action.
		 * @param action_name the name of the action as from
		 *   {@link G.desktop_app_info_list_actions}
		 * @returns the locale-specific action name
		 */
		get_action_name(action_name: string): string;
		/**
		 * Looks up a boolean value in the keyfile backing #info.
		 * 
		 * The #key is looked up in the "Desktop Entry" group.
		 * @param key the key to look up
		 * @returns the boolean value, or %FALSE if the key
		 *     is not found
		 */
		get_boolean(key: string): boolean;
		/**
		 * Gets the categories from the desktop file.
		 * @returns The unparsed Categories key from the desktop file;
		 *     i.e. no attempt is made to split it by ';' or validate it.
		 */
		get_categories(): string | null;
		/**
		 * When #info was created from a known filename, return it.  In some
		 * situations such as the #GDesktopAppInfo returned from
		 * {@link G.desktop_app_info_new_from_keyfile}, this function will return %NULL.
		 * @returns The full path to the file for #info,
		 *     or %NULL if not known.
		 */
		get_filename(): string | null;
		/**
		 * Gets the generic name from the desktop file.
		 * @returns The value of the GenericName key
		 */
		get_generic_name(): string | null;
		/**
		 * A desktop file is hidden if the Hidden key in it is
		 * set to True.
		 * @returns %TRUE if hidden, %FALSE otherwise.
		 */
		get_is_hidden(): boolean;
		/**
		 * Gets the keywords from the desktop file.
		 * @returns The value of the Keywords key
		 */
		get_keywords(): string[];
		/**
		 * Looks up a localized string value in the keyfile backing #info
		 * translated to the current locale.
		 * 
		 * The #key is looked up in the "Desktop Entry" group.
		 * @param key the key to look up
		 * @returns a newly allocated string, or %NULL if the key
		 *     is not found
		 */
		get_locale_string(key: string): string | null;
		/**
		 * Gets the value of the NoDisplay key, which helps determine if the
		 * application info should be shown in menus. See
		 * #G_KEY_FILE_DESKTOP_KEY_NO_DISPLAY and {@link G.app_info_should_show}.
		 * @returns The value of the NoDisplay key
		 */
		get_nodisplay(): boolean;
		/**
		 * Checks if the application info should be shown in menus that list available
		 * applications for a specific name of the desktop, based on the
		 * `OnlyShowIn` and `NotShowIn` keys.
		 * 
		 * #desktop_env should typically be given as %NULL, in which case the
		 * `XDG_CURRENT_DESKTOP` environment variable is consulted.  If you want
		 * to override the default mechanism then you may specify #desktop_env,
		 * but this is not recommended.
		 * 
		 * Note that {@link G.app_info_should_show} for #info will include this check (with
		 * %NULL for #desktop_env) as well as additional checks.
		 * @param desktop_env a string specifying a desktop name
		 * @returns %TRUE if the #info should be shown in #desktop_env according to the
		 * `OnlyShowIn` and `NotShowIn` keys, %FALSE
		 * otherwise.
		 */
		get_show_in(desktop_env?: string | null): boolean;
		/**
		 * Retrieves the StartupWMClass field from #info. This represents the
		 * WM_CLASS property of the main window of the application, if launched
		 * through #info.
		 * @returns the startup WM class, or %NULL if none is set
		 * in the desktop file.
		 */
		get_startup_wm_class(): string | null;
		/**
		 * Looks up a string value in the keyfile backing #info.
		 * 
		 * The #key is looked up in the "Desktop Entry" group.
		 * @param key the key to look up
		 * @returns a newly allocated string, or %NULL if the key
		 *     is not found
		 */
		get_string(key: string): string | null;
		/**
		 * Looks up a string list value in the keyfile backing #info.
		 * 
		 * The #key is looked up in the "Desktop Entry" group.
		 * @param key the key to look up
		 * @returns 
		 *  a %NULL-terminated string array or %NULL if the specified
		 *  key cannot be found. The array should be freed with {@link G.strfreev}.
		 * 
		 * return location for the number of returned strings, or %NULL
		 */
		get_string_list(key: string): [ string[], number | null ];
		/**
		 * Returns whether #key exists in the "Desktop Entry" group
		 * of the keyfile backing #info.
		 * @param key the key to look up
		 * @returns %TRUE if the #key exists
		 */
		has_key(key: string): boolean;
		/**
		 * Activates the named application action.
		 * 
		 * You may only call this function on action names that were
		 * returned from {@link G.desktop_app_info_list_actions}.
		 * 
		 * Note that if the main entry of the desktop file indicates that the
		 * application supports startup notification, and #launch_context is
		 * non-%NULL, then startup notification will be used when activating the
		 * action (and as such, invocation of the action on the receiving side
		 * must signal the end of startup notification when it is completed).
		 * This is the expected behaviour of applications declaring additional
		 * actions, as per the desktop file specification.
		 * 
		 * As with g_app_info_launch() there is no way to detect failures that
		 * occur while using this function.
		 * @param action_name the name of the action as from
		 *   {@link G.desktop_app_info_list_actions}
		 * @param launch_context a #GAppLaunchContext
		 */
		launch_action(action_name: string, launch_context?: AppLaunchContext | null): void;
		/**
		 * This function performs the equivalent of {@link G.app_info_launch_uris},
		 * but is intended primarily for operating system components that
		 * launch applications.  Ordinary applications should use
		 * g_app_info_launch_uris().
		 * 
		 * If the application is launched via GSpawn, then #spawn_flags, #user_setup
		 * and #user_setup_data are used for the call to g_spawn_async().
		 * Additionally, #pid_callback (with #pid_callback_data) will be called to
		 * inform about the PID of the created process. See g_spawn_async_with_pipes()
		 * for information on certain parameter conditions that can enable an
		 * optimized posix_spawn() codepath to be used.
		 * 
		 * If application launching occurs via some other mechanism (eg: D-Bus
		 * activation) then #spawn_flags, #user_setup, #user_setup_data,
		 * #pid_callback and #pid_callback_data are ignored.
		 * @param uris List of URIs
		 * @param launch_context a #GAppLaunchContext
		 * @param spawn_flags #GSpawnFlags, used for each process
		 * @returns %TRUE on successful launch, %FALSE otherwise.
		 */
		launch_uris_as_manager(uris: string[], launch_context: AppLaunchContext | null, spawn_flags: GLib.SpawnFlags): boolean;
		/**
		 * Equivalent to {@link G.desktop_app_info_launch_uris_as_manager} but allows
		 * you to pass in file descriptors for the stdin, stdout and stderr streams
		 * of the launched process.
		 * 
		 * If application launching occurs via some non-spawn mechanism (e.g. D-Bus
		 * activation) then #stdin_fd, #stdout_fd and #stderr_fd are ignored.
		 * @param uris List of URIs
		 * @param launch_context a #GAppLaunchContext
		 * @param spawn_flags #GSpawnFlags, used for each process
		 * @param stdin_fd file descriptor to use for child's stdin, or -1
		 * @param stdout_fd file descriptor to use for child's stdout, or -1
		 * @param stderr_fd file descriptor to use for child's stderr, or -1
		 * @returns %TRUE on successful launch, %FALSE otherwise.
		 */
		launch_uris_as_manager_with_fds(uris: string[], launch_context: AppLaunchContext | null, spawn_flags: GLib.SpawnFlags, stdin_fd: number, stdout_fd: number, stderr_fd: number): boolean;
		/**
		 * Returns the list of "additional application actions" supported on the
		 * desktop file, as per the desktop file specification.
		 * 
		 * As per the specification, this is the list of actions that are
		 * explicitly listed in the "Actions" key of the [Desktop Entry] group.
		 * @returns a list of strings, always non-%NULL
		 */
		list_actions(): string[];
		connect(signal: "notify::filename", callback: (owner: this, ...args: any) => void): number;

	}

	type DesktopAppInfoInitOptionsMixin = GObject.ObjectInitOptions & AppInfoInitOptions & 
	Pick<IDesktopAppInfo,
		"filename">;

	export interface DesktopAppInfoInitOptions extends DesktopAppInfoInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link DesktopAppInfo} instead.
	 */
	type DesktopAppInfoMixin = IDesktopAppInfo & GObject.Object & AppInfo;

	/**
	 * #GDesktopAppInfo is an implementation of #GAppInfo based on
	 * desktop files.
	 * 
	 * Note that `<gio/gdesktopappinfo.h>` belongs to the UNIX-specific
	 * GIO interfaces, thus you have to use the `gio-unix-2.0.pc` pkg-config
	 * file when using it.
	 */
	interface DesktopAppInfo extends DesktopAppInfoMixin {}

	class DesktopAppInfo {
		public constructor(options?: Partial<DesktopAppInfoInitOptions>);
		/**
		 * Creates a new #GDesktopAppInfo based on a desktop file id.
		 * 
		 * A desktop file id is the basename of the desktop file, including the
		 * .desktop extension. GIO is looking for a desktop file with this name
		 * in the `applications` subdirectories of the XDG
		 * data directories (i.e. the directories specified in the `XDG_DATA_HOME`
		 * and `XDG_DATA_DIRS` environment variables). GIO also supports the
		 * prefix-to-subdirectory mapping that is described in the
		 * [Menu Spec](http://standards.freedesktop.org/menu-spec/latest/)
		 * (i.e. a desktop id of kde-foo.desktop will match
		 * `/usr/share/applications/kde/foo.desktop`).
		 * @param desktop_id the desktop file id
		 * @returns a new #GDesktopAppInfo, or %NULL if no desktop
		 *     file with that id exists.
		 */
		public static new(desktop_id: string): DesktopAppInfo | null;
		/**
		 * Creates a new #GDesktopAppInfo.
		 * @param filename the path of a desktop file, in the GLib
		 *      filename encoding
		 * @returns a new #GDesktopAppInfo or %NULL on error.
		 */
		public static new_from_filename(filename: string): DesktopAppInfo | null;
		/**
		 * Creates a new #GDesktopAppInfo.
		 * @param key_file an opened #GKeyFile
		 * @returns a new #GDesktopAppInfo or %NULL on error.
		 */
		public static new_from_keyfile(key_file: GLib.KeyFile): DesktopAppInfo | null;
		/**
		 * Gets all applications that implement #interface.
		 * 
		 * An application implements an interface if that interface is listed in
		 * the Implements= line of the desktop file of the application.
		 * @param _interface the name of the interface
		 * @returns a list of #GDesktopAppInfo
		 * objects.
		 */
		public static get_implementations(_interface: string): DesktopAppInfo[];
		/**
		 * Searches desktop files for ones that match #search_string.
		 * 
		 * The return value is an array of strvs.  Each strv contains a list of
		 * applications that matched #search_string with an equal score.  The
		 * outer list is sorted by score so that the first strv contains the
		 * best-matching applications, and so on.
		 * The algorithm for determining matches is undefined and may change at
		 * any time.
		 * 
		 * None of the search results are subjected to the normal validation
		 * checks performed by {@link G.desktop_app_info_new} (for example, checking that
		 * the executable referenced by a result exists), and so it is possible for
		 * g_desktop_app_info_new() to return %NULL when passed an app ID returned by
		 * this function. It is expected that calling code will do this when
		 * subsequently creating a #GDesktopAppInfo for each result.
		 * @param search_string the search string to use
		 * @returns 
		 */
		public static search(search_string: string): string[][];
		/**
		 * @deprecated
		 * do not use this API.  Since 2.42 the value of the
		 * `XDG_CURRENT_DESKTOP` environment variable will be used.
		 * 
		 * Sets the name of the desktop that the application is running in.
		 * This is used by {@link G.app_info_should_show} and
		 * g_desktop_app_info_get_show_in() to evaluate the
		 * `OnlyShowIn` and `NotShowIn`
		 * desktop entry fields.
		 * 
		 * Should be called only once; subsequent calls are ignored.
		 * @param desktop_env a string specifying what desktop this is
		 */
		public static set_desktop_env(desktop_env: string): void;
	}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link Emblem} instead.
	 */
	interface IEmblem {
		icon: GObject.Object;
		origin: EmblemOrigin;
		/**
		 * Gives back the icon from #emblem.
		 * @returns a #GIcon. The returned object belongs to
		 *          the emblem and should not be modified or freed.
		 */
		get_icon(): Icon;
		/**
		 * Gets the origin of the emblem.
		 * @returns the origin of the emblem
		 */
		get_origin(): EmblemOrigin;
		connect(signal: "notify::icon", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::origin", callback: (owner: this, ...args: any) => void): number;

	}

	type EmblemInitOptionsMixin = GObject.ObjectInitOptions & IconInitOptions & 
	Pick<IEmblem,
		"icon" |
		"origin">;

	export interface EmblemInitOptions extends EmblemInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link Emblem} instead.
	 */
	type EmblemMixin = IEmblem & GObject.Object & Icon;

	/**
	 * #GEmblem is an implementation of #GIcon that supports
	 * having an emblem, which is an icon with additional properties.
	 * It can than be added to a #GEmblemedIcon.
	 * 
	 * Currently, only metainformation about the emblem's origin is
	 * supported. More may be added in the future.
	 */
	interface Emblem extends EmblemMixin {}

	class Emblem {
		public constructor(options?: Partial<EmblemInitOptions>);
		/**
		 * Creates a new emblem for #icon.
		 * @param icon a GIcon containing the icon.
		 * @returns a new #GEmblem.
		 */
		public static new(icon: Icon): Emblem;
		/**
		 * Creates a new emblem for #icon.
		 * @param icon a GIcon containing the icon.
		 * @param origin a GEmblemOrigin enum defining the emblem's origin
		 * @returns a new #GEmblem.
		 */
		public static new_with_origin(icon: Icon, origin: EmblemOrigin): Emblem;
	}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link EmblemedIcon} instead.
	 */
	interface IEmblemedIcon {
		gicon: Icon;
		/**
		 * Adds #emblem to the #GList of #GEmblems.
		 * @param emblem a #GEmblem
		 */
		add_emblem(emblem: Emblem): void;
		/**
		 * Removes all the emblems from #icon.
		 */
		clear_emblems(): void;
		/**
		 * Gets the list of emblems for the #icon.
		 * @returns a #GList of
		 *     #GEmblems that is owned by #emblemed
		 */
		get_emblems(): Emblem[];
		/**
		 * Gets the main icon for #emblemed.
		 * @returns a #GIcon that is owned by #emblemed
		 */
		get_icon(): Icon;
		connect(signal: "notify::gicon", callback: (owner: this, ...args: any) => void): number;

	}

	type EmblemedIconInitOptionsMixin = GObject.ObjectInitOptions & IconInitOptions & 
	Pick<IEmblemedIcon,
		"gicon">;

	export interface EmblemedIconInitOptions extends EmblemedIconInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link EmblemedIcon} instead.
	 */
	type EmblemedIconMixin = IEmblemedIcon & GObject.Object & Icon;

	/**
	 * #GEmblemedIcon is an implementation of #GIcon that supports
	 * adding an emblem to an icon. Adding multiple emblems to an
	 * icon is ensured via {@link G.emblemed_icon_add_emblem}.
	 * 
	 * Note that #GEmblemedIcon allows no control over the position
	 * of the emblems. See also #GEmblem for more information.
	 */
	interface EmblemedIcon extends EmblemedIconMixin {}

	class EmblemedIcon {
		public constructor(options?: Partial<EmblemedIconInitOptions>);
		/**
		 * Creates a new emblemed icon for #icon with the emblem #emblem.
		 * @param icon a #GIcon
		 * @param emblem a #GEmblem, or %NULL
		 * @returns a new #GIcon
		 */
		public static new(icon: Icon, emblem?: Emblem | null): EmblemedIcon;
	}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link FileEnumerator} instead.
	 */
	interface IFileEnumerator {
		/**
		 * Releases all resources used by this enumerator, making the
		 * enumerator return %G_IO_ERROR_CLOSED on all calls.
		 * 
		 * This will be automatically called when the last reference
		 * is dropped, but you might want to call this function to make
		 * sure resources are released as early as possible.
		 * @param cancellable optional #GCancellable object, %NULL to ignore.
		 * @returns #TRUE on success or #FALSE on error.
		 */
		close(cancellable?: Cancellable | null): boolean;
		/**
		 * Asynchronously closes the file enumerator.
		 * 
		 * If #cancellable is not %NULL, then the operation can be cancelled by
		 * triggering the cancellable object from another thread. If the operation
		 * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned in
		 * {@link G.file_enumerator_close_finish}.
		 * @param io_priority the [I/O priority][io-priority] of the request
		 * @param cancellable optional #GCancellable object, %NULL to ignore.
		 * @param callback a #GAsyncReadyCallback to call when the request is satisfied
		 */
		close_async(io_priority: number, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;
		/**
		 * Finishes closing a file enumerator, started from {@link G.file_enumerator_close_async}.
		 * 
		 * If the file enumerator was already closed when g_file_enumerator_close_async()
		 * was called, then this function will report %G_IO_ERROR_CLOSED in #error, and
		 * return %FALSE. If the file enumerator had pending operation when the close
		 * operation was started, then this function will report %G_IO_ERROR_PENDING, and
		 * return %FALSE.  If #cancellable was not %NULL, then the operation may have been
		 * cancelled by triggering the cancellable object from another thread. If the operation
		 * was cancelled, the error %G_IO_ERROR_CANCELLED will be set, and %FALSE will be
		 * returned.
		 * @param result a #GAsyncResult.
		 * @returns %TRUE if the close operation has finished successfully.
		 */
		close_finish(result: AsyncResult): boolean;
		/**
		 * Return a new #GFile which refers to the file named by #info in the source
		 * directory of #enumerator.  This function is primarily intended to be used
		 * inside loops with {@link G.file_enumerator_next_file}.
		 * 
		 * This is a convenience method that's equivalent to:
		 * |[<!-- language="C" -->
		 *   gchar *name = g_file_info_get_name (info);
		 *   GFile *child = g_file_get_child (g_file_enumerator_get_container (enumr),
		 *                                    name);
		 * ]|
		 * @param info a #GFileInfo gotten from {@link G.file_enumerator_next_file}
		 *   or the async equivalents.
		 * @returns a #GFile for the #GFileInfo passed it.
		 */
		get_child(info: FileInfo): File;
		/**
		 * Get the #GFile container which is being enumerated.
		 * @returns the #GFile which is being enumerated.
		 */
		get_container(): File;
		/**
		 * Checks if the file enumerator has pending operations.
		 * @returns %TRUE if the #enumerator has pending operations.
		 */
		has_pending(): boolean;
		/**
		 * Checks if the file enumerator has been closed.
		 * @returns %TRUE if the #enumerator is closed.
		 */
		is_closed(): boolean;
		/**
		 * This is a version of {@link G.file_enumerator_next_file} that's easier to
		 * use correctly from C programs.  With g_file_enumerator_next_file(),
		 * the gboolean return value signifies "end of iteration or error", which
		 * requires allocation of a temporary #GError.
		 * 
		 * In contrast, with this function, a %FALSE return from
		 * g_file_enumerator_iterate() *always* means
		 * "error".  End of iteration is signaled by #out_info or #out_child being %NULL.
		 * 
		 * Another crucial difference is that the references for #out_info and
		 * #out_child are owned by #direnum (they are cached as hidden
		 * properties).  You must not unref them in your own code.  This makes
		 * memory management significantly easier for C code in combination
		 * with loops.
		 * 
		 * Finally, this function optionally allows retrieving a #GFile as
		 * well.
		 * 
		 * You must specify at least one of #out_info or #out_child.
		 * 
		 * The code pattern for correctly using g_file_enumerator_iterate() from C
		 * is:
		 * 
		 * |[
		 * direnum = g_file_enumerate_children (file, ...);
		 * while (TRUE)
		 *   {
		 *     GFileInfo *info;
		 *     if (!g_file_enumerator_iterate (direnum, &info, NULL, cancellable, error))
		 *       goto out;
		 *     if (!info)
		 *       break;
		 *     ... do stuff with "info"; do not unref it! ...
		 *   }
		 * 
		 * out:
		 *   g_object_unref (direnum); // Note: frees the last #info
		 * ]|
		 * @param cancellable a #GCancellable
		 * @returns 
		 * 
		 * Output location for the next #GFileInfo, or %NULL
		 * 
		 * Output location for the next #GFile, or %NULL
		 */
		iterate(cancellable?: Cancellable | null): [ boolean, FileInfo | null, File | null ];
		/**
		 * Returns information for the next file in the enumerated object.
		 * Will block until the information is available. The #GFileInfo
		 * returned from this function will contain attributes that match the
		 * attribute string that was passed when the #GFileEnumerator was created.
		 * 
		 * See the documentation of #GFileEnumerator for information about the
		 * order of returned files.
		 * 
		 * On error, returns %NULL and sets #error to the error. If the
		 * enumerator is at the end, %NULL will be returned and #error will
		 * be unset.
		 * @param cancellable optional #GCancellable object, %NULL to ignore.
		 * @returns A #GFileInfo or %NULL on error
		 *    or end of enumerator.  Free the returned object with
		 *    {@link GObject.unref} when no longer needed.
		 */
		next_file(cancellable?: Cancellable | null): FileInfo | null;
		/**
		 * Request information for a number of files from the enumerator asynchronously.
		 * When all i/o for the operation is finished the #callback will be called with
		 * the requested information.
		 * 
		 * See the documentation of #GFileEnumerator for information about the
		 * order of returned files.
		 * 
		 * The callback can be called with less than #num_files files in case of error
		 * or at the end of the enumerator. In case of a partial error the callback will
		 * be called with any succeeding items and no error, and on the next request the
		 * error will be reported. If a request is cancelled the callback will be called
		 * with %G_IO_ERROR_CANCELLED.
		 * 
		 * During an async request no other sync and async calls are allowed, and will
		 * result in %G_IO_ERROR_PENDING errors.
		 * 
		 * Any outstanding i/o request with higher priority (lower numerical value) will
		 * be executed before an outstanding request with lower priority. Default
		 * priority is %G_PRIORITY_DEFAULT.
		 * @param num_files the number of file info objects to request
		 * @param io_priority the [I/O priority][io-priority] of the request
		 * @param cancellable optional #GCancellable object, %NULL to ignore.
		 * @param callback a #GAsyncReadyCallback to call when the request is satisfied
		 */
		next_files_async(num_files: number, io_priority: number, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;
		/**
		 * Finishes the asynchronous operation started with {@link G.file_enumerator_next_files_async}.
		 * @param result a #GAsyncResult.
		 * @returns a #GList of #GFileInfos. You must free the list with
		 *     {@link G.list_free} and unref the infos with g_object_unref() when you're
		 *     done with them.
		 */
		next_files_finish(result: AsyncResult): FileInfo[];
		/**
		 * Sets the file enumerator as having pending operations.
		 * @param pending a boolean value.
		 */
		set_pending(pending: boolean): void;
	}

	type FileEnumeratorInitOptionsMixin = GObject.ObjectInitOptions
	export interface FileEnumeratorInitOptions extends FileEnumeratorInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link FileEnumerator} instead.
	 */
	type FileEnumeratorMixin = IFileEnumerator & GObject.Object;

	/**
	 * #GFileEnumerator allows you to operate on a set of #GFiles,
	 * returning a #GFileInfo structure for each file enumerated (e.g.
	 * {@link G.file_enumerate_children} will return a #GFileEnumerator for each
	 * of the children within a directory).
	 * 
	 * To get the next file's information from a #GFileEnumerator, use
	 * g_file_enumerator_next_file() or its asynchronous version,
	 * g_file_enumerator_next_files_async(). Note that the asynchronous
	 * version will return a list of #GFileInfos, whereas the
	 * synchronous will only return the next file in the enumerator.
	 * 
	 * The ordering of returned files is unspecified for non-Unix
	 * platforms; for more information, see g_dir_read_name().  On Unix,
	 * when operating on local files, returned files will be sorted by
	 * inode number.  Effectively you can assume that the ordering of
	 * returned files will be stable between successive calls (and
	 * applications) assuming the directory is unchanged.
	 * 
	 * If your application needs a specific ordering, such as by name or
	 * modification time, you will have to implement that in your
	 * application code.
	 * 
	 * To close a #GFileEnumerator, use g_file_enumerator_close(), or
	 * its asynchronous version, g_file_enumerator_close_async(). Once
	 * a #GFileEnumerator is closed, no further actions may be performed
	 * on it, and it should be freed with g_object_unref().
	 */
	interface FileEnumerator extends FileEnumeratorMixin {}

	class FileEnumerator {
		public constructor(options?: Partial<FileEnumeratorInitOptions>);
	}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link FileIOStream} instead.
	 */
	interface IFileIOStream {
		/**
		 * Gets the entity tag for the file when it has been written.
		 * This must be called after the stream has been written
		 * and closed, as the etag can change while writing.
		 * @returns the entity tag for the stream.
		 */
		get_etag(): string | null;
		/**
		 * Queries a file io stream for the given #attributes.
		 * This function blocks while querying the stream. For the asynchronous
		 * version of this function, see {@link G.file_io_stream_query_info_async}.
		 * While the stream is blocked, the stream will set the pending flag
		 * internally, and any other operations on the stream will fail with
		 * %G_IO_ERROR_PENDING.
		 * 
		 * Can fail if the stream was already closed (with #error being set to
		 * %G_IO_ERROR_CLOSED), the stream has pending operations (with #error being
		 * set to %G_IO_ERROR_PENDING), or if querying info is not supported for
		 * the stream's interface (with #error being set to %G_IO_ERROR_NOT_SUPPORTED). I
		 * all cases of failure, %NULL will be returned.
		 * 
		 * If #cancellable is not %NULL, then the operation can be cancelled by
		 * triggering the cancellable object from another thread. If the operation
		 * was cancelled, the error %G_IO_ERROR_CANCELLED will be set, and %NULL will
		 * be returned.
		 * @param attributes a file attribute query string.
		 * @param cancellable optional #GCancellable object, %NULL to ignore.
		 * @returns a #GFileInfo for the #stream, or %NULL on error.
		 */
		query_info(attributes: string, cancellable?: Cancellable | null): FileInfo;
		/**
		 * Asynchronously queries the #stream for a #GFileInfo. When completed,
		 * #callback will be called with a #GAsyncResult which can be used to
		 * finish the operation with {@link G.file_io_stream_query_info_finish}.
		 * 
		 * For the synchronous version of this function, see
		 * g_file_io_stream_query_info().
		 * @param attributes a file attribute query string.
		 * @param io_priority the [I/O priority][gio-GIOScheduler] of the request
		 * @param cancellable optional #GCancellable object, %NULL to ignore.
		 * @param callback callback to call when the request is satisfied
		 */
		query_info_async(attributes: string, io_priority: number, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;
		/**
		 * Finalizes the asynchronous query started
		 * by {@link G.file_io_stream_query_info_async}.
		 * @param result a #GAsyncResult.
		 * @returns A #GFileInfo for the finished query.
		 */
		query_info_finish(result: AsyncResult): FileInfo;
	}

	type FileIOStreamInitOptionsMixin = IOStreamInitOptions & SeekableInitOptions
	export interface FileIOStreamInitOptions extends FileIOStreamInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link FileIOStream} instead.
	 */
	type FileIOStreamMixin = IFileIOStream & IOStream & Seekable;

	/**
	 * GFileIOStream provides io streams that both read and write to the same
	 * file handle.
	 * 
	 * GFileIOStream implements #GSeekable, which allows the io
	 * stream to jump to arbitrary positions in the file and to truncate
	 * the file, provided the filesystem of the file supports these
	 * operations.
	 * 
	 * To find the position of a file io stream, use
	 * {@link G.seekable_tell}.
	 * 
	 * To find out if a file io stream supports seeking, use g_seekable_can_seek().
	 * To position a file io stream, use g_seekable_seek().
	 * To find out if a file io stream supports truncating, use
	 * g_seekable_can_truncate(). To truncate a file io
	 * stream, use g_seekable_truncate().
	 * 
	 * The default implementation of all the #GFileIOStream operations
	 * and the implementation of #GSeekable just call into the same operations
	 * on the output stream.
	 */
	interface FileIOStream extends FileIOStreamMixin {}

	class FileIOStream {
		public constructor(options?: Partial<FileIOStreamInitOptions>);
	}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link FileIcon} instead.
	 */
	interface IFileIcon {
		/**
		 * The file containing the icon.
		 */
		file: File;
		/**
		 * Gets the #GFile associated with the given #icon.
		 * @returns a #GFile.
		 */
		get_file(): File;
		connect(signal: "notify::file", callback: (owner: this, ...args: any) => void): number;

	}

	type FileIconInitOptionsMixin = GObject.ObjectInitOptions & IconInitOptions & LoadableIconInitOptions & 
	Pick<IFileIcon,
		"file">;

	export interface FileIconInitOptions extends FileIconInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link FileIcon} instead.
	 */
	type FileIconMixin = IFileIcon & GObject.Object & Icon & LoadableIcon;

	/**
	 * #GFileIcon specifies an icon by pointing to an image file
	 * to be used as icon.
	 */
	interface FileIcon extends FileIconMixin {}

	class FileIcon {
		public constructor(options?: Partial<FileIconInitOptions>);
		/**
		 * Creates a new icon for a file.
		 * @param file a #GFile.
		 * @returns a #GIcon for the given
		 *   #file, or %NULL on error.
		 */
		public static new(file: File): FileIcon;
	}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link FileInfo} instead.
	 */
	interface IFileInfo {
		/**
		 * Clears the status information from #info.
		 */
		clear_status(): void;
		/**
		 * First clears all of the [GFileAttribute][gio-GFileAttribute] of #dest_info,
		 * and then copies all of the file attributes from #src_info to #dest_info.
		 * @param dest_info destination to copy attributes to.
		 */
		copy_into(dest_info: FileInfo): void;
		/**
		 * Duplicates a file info structure.
		 * @returns a duplicate #GFileInfo of #other.
		 */
		dup(): FileInfo;
		/**
		 * Gets the access time of the current #info and returns it as a
		 * #GDateTime.
		 * 
		 * This requires the %G_FILE_ATTRIBUTE_TIME_ACCESS attribute. If
		 * %G_FILE_ATTRIBUTE_TIME_ACCESS_USEC is provided, the resulting #GDateTime
		 * will have microsecond precision.
		 * @returns access time, or %NULL if unknown
		 */
		get_access_date_time(): GLib.DateTime | null;
		/**
		 * Gets the value of a attribute, formatted as a string.
		 * This escapes things as needed to make the string valid
		 * UTF-8.
		 * @param attribute a file attribute key.
		 * @returns a UTF-8 string associated with the given #attribute, or
		 *    %NULL if the attribute wasn’t set.
		 *    When you're done with the string it must be freed with {@link G.free}.
		 */
		get_attribute_as_string(attribute: string): string | null;
		/**
		 * Gets the value of a boolean attribute. If the attribute does not
		 * contain a boolean value, %FALSE will be returned.
		 * @param attribute a file attribute key.
		 * @returns the boolean value contained within the attribute.
		 */
		get_attribute_boolean(attribute: string): boolean;
		/**
		 * Gets the value of a byte string attribute. If the attribute does
		 * not contain a byte string, %NULL will be returned.
		 * @param attribute a file attribute key.
		 * @returns the contents of the #attribute value as a byte string, or
		 * %NULL otherwise.
		 */
		get_attribute_byte_string(attribute: string): string | null;
		/**
		 * Gets the attribute type, value and status for an attribute key.
		 * @param attribute a file attribute key
		 * @returns %TRUE if #info has an attribute named #attribute,
		 *      %FALSE otherwise.
		 * 
		 * return location for the attribute type, or %NULL
		 * 
		 * return location for the
		 *    attribute value, or %NULL; the attribute value will not be %NULL
		 * 
		 * return location for the attribute status, or %NULL
		 */
		get_attribute_data(attribute: string): [ boolean, FileAttributeType | null, any | null, FileAttributeStatus | null ];
		/**
		 * Gets a signed 32-bit integer contained within the attribute. If the
		 * attribute does not contain a signed 32-bit integer, or is invalid,
		 * 0 will be returned.
		 * @param attribute a file attribute key.
		 * @returns a signed 32-bit integer from the attribute.
		 */
		get_attribute_int32(attribute: string): number;
		/**
		 * Gets a signed 64-bit integer contained within the attribute. If the
		 * attribute does not contain a signed 64-bit integer, or is invalid,
		 * 0 will be returned.
		 * @param attribute a file attribute key.
		 * @returns a signed 64-bit integer from the attribute.
		 */
		get_attribute_int64(attribute: string): number;
		/**
		 * Gets the value of a #GObject attribute. If the attribute does
		 * not contain a #GObject, %NULL will be returned.
		 * @param attribute a file attribute key.
		 * @returns a #GObject associated with the given #attribute,
		 * or %NULL otherwise.
		 */
		get_attribute_object(attribute: string): GObject.Object | null;
		/**
		 * Gets the attribute status for an attribute key.
		 * @param attribute a file attribute key
		 * @returns a #GFileAttributeStatus for the given #attribute, or
		 *    %G_FILE_ATTRIBUTE_STATUS_UNSET if the key is invalid.
		 */
		get_attribute_status(attribute: string): FileAttributeStatus;
		/**
		 * Gets the value of a string attribute. If the attribute does
		 * not contain a string, %NULL will be returned.
		 * @param attribute a file attribute key.
		 * @returns the contents of the #attribute value as a UTF-8 string,
		 * or %NULL otherwise.
		 */
		get_attribute_string(attribute: string): string | null;
		/**
		 * Gets the value of a stringv attribute. If the attribute does
		 * not contain a stringv, %NULL will be returned.
		 * @param attribute a file attribute key.
		 * @returns the contents of the #attribute value as a stringv,
		 * or %NULL otherwise. Do not free. These returned strings are UTF-8.
		 */
		get_attribute_stringv(attribute: string): string[] | null;
		/**
		 * Gets the attribute type for an attribute key.
		 * @param attribute a file attribute key.
		 * @returns a #GFileAttributeType for the given #attribute, or
		 * %G_FILE_ATTRIBUTE_TYPE_INVALID if the key is not set.
		 */
		get_attribute_type(attribute: string): FileAttributeType;
		/**
		 * Gets an unsigned 32-bit integer contained within the attribute. If the
		 * attribute does not contain an unsigned 32-bit integer, or is invalid,
		 * 0 will be returned.
		 * @param attribute a file attribute key.
		 * @returns an unsigned 32-bit integer from the attribute.
		 */
		get_attribute_uint32(attribute: string): number;
		/**
		 * Gets a unsigned 64-bit integer contained within the attribute. If the
		 * attribute does not contain an unsigned 64-bit integer, or is invalid,
		 * 0 will be returned.
		 * @param attribute a file attribute key.
		 * @returns a unsigned 64-bit integer from the attribute.
		 */
		get_attribute_uint64(attribute: string): number;
		/**
		 * Gets the file's content type.
		 * @returns a string containing the file's content type,
		 * or %NULL if unknown.
		 */
		get_content_type(): string | null;
		/**
		 * Gets the creation time of the current #info and returns it as a
		 * #GDateTime.
		 * 
		 * This requires the %G_FILE_ATTRIBUTE_TIME_CREATED attribute. If
		 * %G_FILE_ATTRIBUTE_TIME_CREATED_USEC is provided, the resulting #GDateTime
		 * will have microsecond precision.
		 * @returns creation time, or %NULL if unknown
		 */
		get_creation_date_time(): GLib.DateTime | null;
		/**
		 * Returns the #GDateTime representing the deletion date of the file, as
		 * available in G_FILE_ATTRIBUTE_TRASH_DELETION_DATE. If the
		 * G_FILE_ATTRIBUTE_TRASH_DELETION_DATE attribute is unset, %NULL is returned.
		 * @returns a #GDateTime, or %NULL.
		 */
		get_deletion_date(): GLib.DateTime | null;
		/**
		 * Gets a display name for a file. This is guaranteed to always be set.
		 * @returns a string containing the display name.
		 */
		get_display_name(): string;
		/**
		 * Gets the edit name for a file.
		 * @returns a string containing the edit name.
		 */
		get_edit_name(): string;
		/**
		 * Gets the [entity tag][gfile-etag] for a given
		 * #GFileInfo. See %G_FILE_ATTRIBUTE_ETAG_VALUE.
		 * @returns a string containing the value of the "etag:value" attribute.
		 */
		get_etag(): string | null;
		/**
		 * Gets a file's type (whether it is a regular file, symlink, etc).
		 * This is different from the file's content type, see {@link G.file_info_get_content_type}.
		 * @returns a #GFileType for the given file.
		 */
		get_file_type(): FileType;
		/**
		 * Gets the icon for a file.
		 * @returns #GIcon for the given #info.
		 */
		get_icon(): Icon | null;
		/**
		 * Checks if a file is a backup file.
		 * @returns %TRUE if file is a backup file, %FALSE otherwise.
		 */
		get_is_backup(): boolean;
		/**
		 * Checks if a file is hidden.
		 * @returns %TRUE if the file is a hidden file, %FALSE otherwise.
		 */
		get_is_hidden(): boolean;
		/**
		 * Checks if a file is a symlink.
		 * @returns %TRUE if the given #info is a symlink.
		 */
		get_is_symlink(): boolean;
		/**
		 * Gets the modification time of the current #info and returns it as a
		 * #GDateTime.
		 * 
		 * This requires the %G_FILE_ATTRIBUTE_TIME_MODIFIED attribute. If
		 * %G_FILE_ATTRIBUTE_TIME_MODIFIED_USEC is provided, the resulting #GDateTime
		 * will have microsecond precision.
		 * @returns modification time, or %NULL if unknown
		 */
		get_modification_date_time(): GLib.DateTime | null;
		/**
		 * @deprecated
		 * Use {@link G.file_info_get_modification_date_time} instead, as
		 *    #GTimeVal is deprecated due to the year 2038 problem.
		 * 
		 * Gets the modification time of the current #info and sets it
		 * in #result.
		 * @returns a #GTimeVal.
		 */
		get_modification_time(): GLib.TimeVal;
		/**
		 * Gets the name for a file. This is guaranteed to always be set.
		 * @returns a string containing the file name.
		 */
		get_name(): string;
		/**
		 * Gets the file's size (in bytes). The size is retrieved through the value of
		 * the %G_FILE_ATTRIBUTE_STANDARD_SIZE attribute and is converted
		 * from #guint64 to #goffset before returning the result.
		 * @returns a #goffset containing the file's size (in bytes).
		 */
		get_size(): number;
		/**
		 * Gets the value of the sort_order attribute from the #GFileInfo.
		 * See %G_FILE_ATTRIBUTE_STANDARD_SORT_ORDER.
		 * @returns a #gint32 containing the value of the "standard::sort_order" attribute.
		 */
		get_sort_order(): number;
		/**
		 * Gets the symbolic icon for a file.
		 * @returns #GIcon for the given #info.
		 */
		get_symbolic_icon(): Icon | null;
		/**
		 * Gets the symlink target for a given #GFileInfo.
		 * @returns a string containing the symlink target.
		 */
		get_symlink_target(): string | null;
		/**
		 * Checks if a file info structure has an attribute named #attribute.
		 * @param attribute a file attribute key.
		 * @returns %TRUE if #info has an attribute named #attribute,
		 *     %FALSE otherwise.
		 */
		has_attribute(attribute: string): boolean;
		/**
		 * Checks if a file info structure has an attribute in the
		 * specified #name_space.
		 * @param name_space a file attribute namespace.
		 * @returns %TRUE if #info has an attribute in #name_space,
		 *     %FALSE otherwise.
		 */
		has_namespace(name_space: string): boolean;
		/**
		 * Lists the file info structure's attributes.
		 * @param name_space a file attribute key's namespace, or %NULL to list
		 *   all attributes.
		 * @returns a
		 * null-terminated array of strings of all of the possible attribute
		 * types for the given #name_space, or %NULL on error.
		 */
		list_attributes(name_space?: string | null): string[] | null;
		/**
		 * Removes all cases of #attribute from #info if it exists.
		 * @param attribute a file attribute key.
		 */
		remove_attribute(attribute: string): void;
		/**
		 * Sets the %G_FILE_ATTRIBUTE_TIME_ACCESS and
		 * %G_FILE_ATTRIBUTE_TIME_ACCESS_USEC attributes in the file info to the
		 * given date/time value.
		 * @param atime a #GDateTime.
		 */
		set_access_date_time(atime: GLib.DateTime): void;
		/**
		 * Sets the #attribute to contain the given value, if possible. To unset the
		 * attribute, use %G_FILE_ATTRIBUTE_TYPE_INVALID for #type.
		 * @param attribute a file attribute key.
		 * @param type a #GFileAttributeType
		 * @param value_p pointer to the value
		 */
		set_attribute(attribute: string, type: FileAttributeType, value_p: any): void;
		/**
		 * Sets the #attribute to contain the given #attr_value,
		 * if possible.
		 * @param attribute a file attribute key.
		 * @param attr_value a boolean value.
		 */
		set_attribute_boolean(attribute: string, attr_value: boolean): void;
		/**
		 * Sets the #attribute to contain the given #attr_value,
		 * if possible.
		 * @param attribute a file attribute key.
		 * @param attr_value a byte string.
		 */
		set_attribute_byte_string(attribute: string, attr_value: string): void;
		/**
		 * Sets the #attribute to contain the given #attr_value,
		 * if possible.
		 * @param attribute a file attribute key.
		 * @param attr_value a signed 32-bit integer
		 */
		set_attribute_int32(attribute: string, attr_value: number): void;
		/**
		 * Sets the #attribute to contain the given #attr_value,
		 * if possible.
		 * @param attribute attribute name to set.
		 * @param attr_value int64 value to set attribute to.
		 */
		set_attribute_int64(attribute: string, attr_value: number): void;
		/**
		 * Sets #mask on #info to match specific attribute types.
		 * @param mask a #GFileAttributeMatcher.
		 */
		set_attribute_mask(mask: FileAttributeMatcher): void;
		/**
		 * Sets the #attribute to contain the given #attr_value,
		 * if possible.
		 * @param attribute a file attribute key.
		 * @param attr_value a #GObject.
		 */
		set_attribute_object(attribute: string, attr_value: GObject.Object): void;
		/**
		 * Sets the attribute status for an attribute key. This is only
		 * needed by external code that implement {@link G.file_set_attributes_from_info}
		 * or similar functions.
		 * 
		 * The attribute must exist in #info for this to work. Otherwise %FALSE
		 * is returned and #info is unchanged.
		 * @param attribute a file attribute key
		 * @param status a #GFileAttributeStatus
		 * @returns %TRUE if the status was changed, %FALSE if the key was not set.
		 */
		set_attribute_status(attribute: string, status: FileAttributeStatus): boolean;
		/**
		 * Sets the #attribute to contain the given #attr_value,
		 * if possible.
		 * @param attribute a file attribute key.
		 * @param attr_value a UTF-8 string.
		 */
		set_attribute_string(attribute: string, attr_value: string): void;
		/**
		 * Sets the #attribute to contain the given #attr_value,
		 * if possible.
		 * 
		 * Sinze: 2.22
		 * @param attribute a file attribute key
		 * @param attr_value a %NULL
		 *   terminated array of UTF-8 strings.
		 */
		set_attribute_stringv(attribute: string, attr_value: string[]): void;
		/**
		 * Sets the #attribute to contain the given #attr_value,
		 * if possible.
		 * @param attribute a file attribute key.
		 * @param attr_value an unsigned 32-bit integer.
		 */
		set_attribute_uint32(attribute: string, attr_value: number): void;
		/**
		 * Sets the #attribute to contain the given #attr_value,
		 * if possible.
		 * @param attribute a file attribute key.
		 * @param attr_value an unsigned 64-bit integer.
		 */
		set_attribute_uint64(attribute: string, attr_value: number): void;
		/**
		 * Sets the content type attribute for a given #GFileInfo.
		 * See %G_FILE_ATTRIBUTE_STANDARD_CONTENT_TYPE.
		 * @param content_type a content type. See [GContentType][gio-GContentType]
		 */
		set_content_type(content_type: string): void;
		/**
		 * Sets the %G_FILE_ATTRIBUTE_TIME_CREATED and
		 * %G_FILE_ATTRIBUTE_TIME_CREATED_USEC attributes in the file info to the
		 * given date/time value.
		 * @param creation_time a #GDateTime.
		 */
		set_creation_date_time(creation_time: GLib.DateTime): void;
		/**
		 * Sets the display name for the current #GFileInfo.
		 * See %G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME.
		 * @param display_name a string containing a display name.
		 */
		set_display_name(display_name: string): void;
		/**
		 * Sets the edit name for the current file.
		 * See %G_FILE_ATTRIBUTE_STANDARD_EDIT_NAME.
		 * @param edit_name a string containing an edit name.
		 */
		set_edit_name(edit_name: string): void;
		/**
		 * Sets the file type in a #GFileInfo to #type.
		 * See %G_FILE_ATTRIBUTE_STANDARD_TYPE.
		 * @param type a #GFileType.
		 */
		set_file_type(type: FileType): void;
		/**
		 * Sets the icon for a given #GFileInfo.
		 * See %G_FILE_ATTRIBUTE_STANDARD_ICON.
		 * @param icon a #GIcon.
		 */
		set_icon(icon: Icon): void;
		/**
		 * Sets the "is_hidden" attribute in a #GFileInfo according to #is_hidden.
		 * See %G_FILE_ATTRIBUTE_STANDARD_IS_HIDDEN.
		 * @param is_hidden a #gboolean.
		 */
		set_is_hidden(is_hidden: boolean): void;
		/**
		 * Sets the "is_symlink" attribute in a #GFileInfo according to #is_symlink.
		 * See %G_FILE_ATTRIBUTE_STANDARD_IS_SYMLINK.
		 * @param is_symlink a #gboolean.
		 */
		set_is_symlink(is_symlink: boolean): void;
		/**
		 * Sets the %G_FILE_ATTRIBUTE_TIME_MODIFIED and
		 * %G_FILE_ATTRIBUTE_TIME_MODIFIED_USEC attributes in the file info to the
		 * given date/time value.
		 * @param mtime a #GDateTime.
		 */
		set_modification_date_time(mtime: GLib.DateTime): void;
		/**
		 * @deprecated
		 * Use {@link G.file_info_set_modification_date_time} instead, as
		 *    #GTimeVal is deprecated due to the year 2038 problem.
		 * 
		 * Sets the %G_FILE_ATTRIBUTE_TIME_MODIFIED and
		 * %G_FILE_ATTRIBUTE_TIME_MODIFIED_USEC attributes in the file info to the
		 * given time value.
		 * @param mtime a #GTimeVal.
		 */
		set_modification_time(mtime: GLib.TimeVal): void;
		/**
		 * Sets the name attribute for the current #GFileInfo.
		 * See %G_FILE_ATTRIBUTE_STANDARD_NAME.
		 * @param name a string containing a name.
		 */
		set_name(name: string): void;
		/**
		 * Sets the %G_FILE_ATTRIBUTE_STANDARD_SIZE attribute in the file info
		 * to the given size.
		 * @param size a #goffset containing the file's size.
		 */
		set_size(size: number): void;
		/**
		 * Sets the sort order attribute in the file info structure. See
		 * %G_FILE_ATTRIBUTE_STANDARD_SORT_ORDER.
		 * @param sort_order a sort order integer.
		 */
		set_sort_order(sort_order: number): void;
		/**
		 * Sets the symbolic icon for a given #GFileInfo.
		 * See %G_FILE_ATTRIBUTE_STANDARD_SYMBOLIC_ICON.
		 * @param icon a #GIcon.
		 */
		set_symbolic_icon(icon: Icon): void;
		/**
		 * Sets the %G_FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET attribute in the file info
		 * to the given symlink target.
		 * @param symlink_target a static string containing a path to a symlink target.
		 */
		set_symlink_target(symlink_target: string): void;
		/**
		 * Unsets a mask set by {@link G.file_info_set_attribute_mask}, if one
		 * is set.
		 */
		unset_attribute_mask(): void;
	}

	type FileInfoInitOptionsMixin = GObject.ObjectInitOptions
	export interface FileInfoInitOptions extends FileInfoInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link FileInfo} instead.
	 */
	type FileInfoMixin = IFileInfo & GObject.Object;

	/**
	 * Functionality for manipulating basic metadata for files. #GFileInfo
	 * implements methods for getting information that all files should
	 * contain, and allows for manipulation of extended attributes.
	 * 
	 * See [GFileAttribute][gio-GFileAttribute] for more information on how
	 * GIO handles file attributes.
	 * 
	 * To obtain a #GFileInfo for a #GFile, use {@link G.file_query_info} (or its
	 * async variant). To obtain a #GFileInfo for a file input or output
	 * stream, use g_file_input_stream_query_info() or
	 * g_file_output_stream_query_info() (or their async variants).
	 * 
	 * To change the actual attributes of a file, you should then set the
	 * attribute in the #GFileInfo and call g_file_set_attributes_from_info()
	 * or g_file_set_attributes_async() on a GFile.
	 * 
	 * However, not all attributes can be changed in the file. For instance,
	 * the actual size of a file cannot be changed via g_file_info_set_size().
	 * You may call g_file_query_settable_attributes() and
	 * g_file_query_writable_namespaces() to discover the settable attributes
	 * of a particular file at runtime.
	 * 
	 * The direct accessors, such as g_file_info_get_name(), are slightly more
	 * optimized than the generic attribute accessors, such as
	 * g_file_info_get_attribute_byte_string().This optimization will matter
	 * only if calling the API in a tight loop.
	 * 
	 * #GFileAttributeMatcher allows for searching through a #GFileInfo for
	 * attributes.
	 */
	interface FileInfo extends FileInfoMixin {}

	class FileInfo {
		public constructor(options?: Partial<FileInfoInitOptions>);
		/**
		 * Creates a new file info structure.
		 * @returns a #GFileInfo.
		 */
		public static new(): FileInfo;
	}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link FileInputStream} instead.
	 */
	interface IFileInputStream {
		/**
		 * Queries a file input stream the given #attributes. This function blocks
		 * while querying the stream. For the asynchronous (non-blocking) version
		 * of this function, see {@link G.file_input_stream_query_info_async}. While the
		 * stream is blocked, the stream will set the pending flag internally, and
		 * any other operations on the stream will fail with %G_IO_ERROR_PENDING.
		 * @param attributes a file attribute query string.
		 * @param cancellable optional #GCancellable object, %NULL to ignore.
		 * @returns a #GFileInfo, or %NULL on error.
		 */
		query_info(attributes: string, cancellable?: Cancellable | null): FileInfo;
		/**
		 * Queries the stream information asynchronously.
		 * When the operation is finished #callback will be called.
		 * You can then call {@link G.file_input_stream_query_info_finish}
		 * to get the result of the operation.
		 * 
		 * For the synchronous version of this function,
		 * see g_file_input_stream_query_info().
		 * 
		 * If #cancellable is not %NULL, then the operation can be cancelled by
		 * triggering the cancellable object from another thread. If the operation
		 * was cancelled, the error %G_IO_ERROR_CANCELLED will be set
		 * @param attributes a file attribute query string.
		 * @param io_priority the [I/O priority][io-priority] of the request
		 * @param cancellable optional #GCancellable object, %NULL to ignore.
		 * @param callback callback to call when the request is satisfied
		 */
		query_info_async(attributes: string, io_priority: number, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;
		/**
		 * Finishes an asynchronous info query operation.
		 * @param result a #GAsyncResult.
		 * @returns #GFileInfo.
		 */
		query_info_finish(result: AsyncResult): FileInfo;
	}

	type FileInputStreamInitOptionsMixin = InputStreamInitOptions & SeekableInitOptions
	export interface FileInputStreamInitOptions extends FileInputStreamInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link FileInputStream} instead.
	 */
	type FileInputStreamMixin = IFileInputStream & InputStream & Seekable;

	/**
	 * GFileInputStream provides input streams that take their
	 * content from a file.
	 * 
	 * GFileInputStream implements #GSeekable, which allows the input
	 * stream to jump to arbitrary positions in the file, provided the
	 * filesystem of the file allows it. To find the position of a file
	 * input stream, use {@link G.seekable_tell}. To find out if a file input
	 * stream supports seeking, use g_seekable_can_seek().
	 * To position a file input stream, use g_seekable_seek().
	 */
	interface FileInputStream extends FileInputStreamMixin {}

	class FileInputStream {
		public constructor(options?: Partial<FileInputStreamInitOptions>);
	}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link FileMonitor} instead.
	 */
	interface IFileMonitor {
		readonly cancelled: boolean;
		rate_limit: number;
		/**
		 * Cancels a file monitor.
		 * @returns always %TRUE
		 */
		cancel(): boolean;
		/**
		 * Emits the #GFileMonitor::changed signal if a change
		 * has taken place. Should be called from file monitor
		 * implementations only.
		 * 
		 * Implementations are responsible to call this method from the
		 * [thread-default main context][g-main-context-push-thread-default] of the
		 * thread that the monitor was created in.
		 * @param child a #GFile.
		 * @param other_file a #GFile.
		 * @param event_type a set of #GFileMonitorEvent flags.
		 */
		emit_event(child: File, other_file: File, event_type: FileMonitorEvent): void;
		/**
		 * Returns whether the monitor is canceled.
		 * @returns %TRUE if monitor is canceled. %FALSE otherwise.
		 */
		is_cancelled(): boolean;
		/**
		 * Sets the rate limit to which the #monitor will report
		 * consecutive change events to the same file.
		 * @param limit_msecs a non-negative integer with the limit in milliseconds
		 *     to poll for changes
		 */
		set_rate_limit(limit_msecs: number): void;
		/**
		 * Emitted when #file has been changed.
		 * 
		 * If using %G_FILE_MONITOR_WATCH_MOVES on a directory monitor, and
		 * the information is available (and if supported by the backend),
		 * #event_type may be %G_FILE_MONITOR_EVENT_RENAMED,
		 * %G_FILE_MONITOR_EVENT_MOVED_IN or %G_FILE_MONITOR_EVENT_MOVED_OUT.
		 * 
		 * In all cases #file will be a child of the monitored directory.  For
		 * renames, #file will be the old name and #other_file is the new
		 * name.  For "moved in" events, #file is the name of the file that
		 * appeared and #other_file is the old name that it was moved from (in
		 * another directory).  For "moved out" events, #file is the name of
		 * the file that used to be in this directory and #other_file is the
		 * name of the file at its new location.
		 * 
		 * It makes sense to treat %G_FILE_MONITOR_EVENT_MOVED_IN as
		 * equivalent to %G_FILE_MONITOR_EVENT_CREATED and
		 * %G_FILE_MONITOR_EVENT_MOVED_OUT as equivalent to
		 * %G_FILE_MONITOR_EVENT_DELETED, with extra information.
		 * %G_FILE_MONITOR_EVENT_RENAMED is equivalent to a delete/create
		 * pair.  This is exactly how the events will be reported in the case
		 * that the %G_FILE_MONITOR_WATCH_MOVES flag is not in use.
		 * 
		 * If using the deprecated flag %G_FILE_MONITOR_SEND_MOVED flag and #event_type is
		 * #G_FILE_MONITOR_EVENT_MOVED, #file will be set to a #GFile containing the
		 * old path, and #other_file will be set to a #GFile containing the new path.
		 * 
		 * In all the other cases, #other_file will be set to #NULL.
		 * @param signal 
		 * @param callback Callback function
		 *  - owner: owner of the emitted event 
		 *  - file: a #GFile. 
		 *  - other_file: a #GFile or #NULL. 
		 *  - event_type: a #GFileMonitorEvent. 
		 * 
		 * @returns Callback ID
		 */
		connect(signal: "changed", callback: (owner: this, file: File, other_file: File | null, event_type: FileMonitorEvent) => void): number;

		connect(signal: "notify::cancelled", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::rate-limit", callback: (owner: this, ...args: any) => void): number;

	}

	type FileMonitorInitOptionsMixin = GObject.ObjectInitOptions & 
	Pick<IFileMonitor,
		"rate_limit">;

	export interface FileMonitorInitOptions extends FileMonitorInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link FileMonitor} instead.
	 */
	type FileMonitorMixin = IFileMonitor & GObject.Object;

	/**
	 * Monitors a file or directory for changes.
	 * 
	 * To obtain a #GFileMonitor for a file or directory, use
	 * {@link G.file_monitor}, g_file_monitor_file(), or
	 * g_file_monitor_directory().
	 * 
	 * To get informed about changes to the file or directory you are
	 * monitoring, connect to the #GFileMonitor::changed signal. The
	 * signal will be emitted in the
	 * [thread-default main context][g-main-context-push-thread-default]
	 * of the thread that the monitor was created in
	 * (though if the global default main context is blocked, this may
	 * cause notifications to be blocked even if the thread-default
	 * context is still running).
	 */
	interface FileMonitor extends FileMonitorMixin {}

	class FileMonitor {
		public constructor(options?: Partial<FileMonitorInitOptions>);
	}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link FileOutputStream} instead.
	 */
	interface IFileOutputStream {
		/**
		 * Gets the entity tag for the file when it has been written.
		 * This must be called after the stream has been written
		 * and closed, as the etag can change while writing.
		 * @returns the entity tag for the stream.
		 */
		get_etag(): string | null;
		/**
		 * Queries a file output stream for the given #attributes.
		 * This function blocks while querying the stream. For the asynchronous
		 * version of this function, see {@link G.file_output_stream_query_info_async}.
		 * While the stream is blocked, the stream will set the pending flag
		 * internally, and any other operations on the stream will fail with
		 * %G_IO_ERROR_PENDING.
		 * 
		 * Can fail if the stream was already closed (with #error being set to
		 * %G_IO_ERROR_CLOSED), the stream has pending operations (with #error being
		 * set to %G_IO_ERROR_PENDING), or if querying info is not supported for
		 * the stream's interface (with #error being set to %G_IO_ERROR_NOT_SUPPORTED). In
		 * all cases of failure, %NULL will be returned.
		 * 
		 * If #cancellable is not %NULL, then the operation can be cancelled by
		 * triggering the cancellable object from another thread. If the operation
		 * was cancelled, the error %G_IO_ERROR_CANCELLED will be set, and %NULL will
		 * be returned.
		 * @param attributes a file attribute query string.
		 * @param cancellable optional #GCancellable object, %NULL to ignore.
		 * @returns a #GFileInfo for the #stream, or %NULL on error.
		 */
		query_info(attributes: string, cancellable?: Cancellable | null): FileInfo;
		/**
		 * Asynchronously queries the #stream for a #GFileInfo. When completed,
		 * #callback will be called with a #GAsyncResult which can be used to
		 * finish the operation with {@link G.file_output_stream_query_info_finish}.
		 * 
		 * For the synchronous version of this function, see
		 * g_file_output_stream_query_info().
		 * @param attributes a file attribute query string.
		 * @param io_priority the [I/O priority][gio-GIOScheduler] of the request
		 * @param cancellable optional #GCancellable object, %NULL to ignore.
		 * @param callback callback to call when the request is satisfied
		 */
		query_info_async(attributes: string, io_priority: number, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;
		/**
		 * Finalizes the asynchronous query started
		 * by {@link G.file_output_stream_query_info_async}.
		 * @param result a #GAsyncResult.
		 * @returns A #GFileInfo for the finished query.
		 */
		query_info_finish(result: AsyncResult): FileInfo;
	}

	type FileOutputStreamInitOptionsMixin = OutputStreamInitOptions & SeekableInitOptions
	export interface FileOutputStreamInitOptions extends FileOutputStreamInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link FileOutputStream} instead.
	 */
	type FileOutputStreamMixin = IFileOutputStream & OutputStream & Seekable;

	/**
	 * GFileOutputStream provides output streams that write their
	 * content to a file.
	 * 
	 * GFileOutputStream implements #GSeekable, which allows the output
	 * stream to jump to arbitrary positions in the file and to truncate
	 * the file, provided the filesystem of the file supports these
	 * operations.
	 * 
	 * To find the position of a file output stream, use {@link G.seekable_tell}.
	 * To find out if a file output stream supports seeking, use
	 * g_seekable_can_seek().To position a file output stream, use
	 * g_seekable_seek(). To find out if a file output stream supports
	 * truncating, use g_seekable_can_truncate(). To truncate a file output
	 * stream, use g_seekable_truncate().
	 */
	interface FileOutputStream extends FileOutputStreamMixin {}

	class FileOutputStream {
		public constructor(options?: Partial<FileOutputStreamInitOptions>);
	}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link FilenameCompleter} instead.
	 */
	interface IFilenameCompleter {
		/**
		 * Obtains a completion for #initial_text from #completer.
		 * @param initial_text text to be completed.
		 * @returns a completed string, or %NULL if no
		 *     completion exists. This string is not owned by GIO, so remember to {@link G.free}
		 *     it when finished.
		 */
		get_completion_suffix(initial_text: string): string | null;
		/**
		 * Gets an array of completion strings for a given initial text.
		 * @param initial_text text to be completed.
		 * @returns array of strings with possible completions for #initial_text.
		 * This array must be freed by {@link G.strfreev} when finished.
		 */
		get_completions(initial_text: string): string[];
		/**
		 * If #dirs_only is %TRUE, #completer will only
		 * complete directory names, and not file names.
		 * @param dirs_only a #gboolean.
		 */
		set_dirs_only(dirs_only: boolean): void;
		/**
		 * Emitted when the file name completion information comes available.
		 * @param signal 
		 * @param callback Callback function
		 *  - owner: owner of the emitted event 
		 * 
		 * @returns Callback ID
		 */
		connect(signal: "got-completion-data", callback: (owner: this) => void): number;

	}

	type FilenameCompleterInitOptionsMixin = GObject.ObjectInitOptions
	export interface FilenameCompleterInitOptions extends FilenameCompleterInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link FilenameCompleter} instead.
	 */
	type FilenameCompleterMixin = IFilenameCompleter & GObject.Object;

	/**
	 * Completes partial file and directory names given a partial string by
	 * looking in the file system for clues. Can return a list of possible
	 * completion strings for widget implementations.
	 */
	interface FilenameCompleter extends FilenameCompleterMixin {}

	class FilenameCompleter {
		public constructor(options?: Partial<FilenameCompleterInitOptions>);
		/**
		 * Creates a new filename completer.
		 * @returns a #GFilenameCompleter.
		 */
		public static new(): FilenameCompleter;
	}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link FilterInputStream} instead.
	 */
	interface IFilterInputStream {
		base_stream: InputStream;
		close_base_stream: boolean;
		// readonly base_stream: InputStream;
		/**
		 * Gets the base stream for the filter stream.
		 * @returns a #GInputStream.
		 */
		get_base_stream(): InputStream;
		/**
		 * Returns whether the base stream will be closed when #stream is
		 * closed.
		 * @returns %TRUE if the base stream will be closed.
		 */
		get_close_base_stream(): boolean;
		/**
		 * Sets whether the base stream will be closed when #stream is closed.
		 * @param close_base %TRUE to close the base stream.
		 */
		set_close_base_stream(close_base: boolean): void;
		connect(signal: "notify::base-stream", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::close-base-stream", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::base_stream", callback: (owner: this, ...args: any) => void): number;

	}

	type FilterInputStreamInitOptionsMixin = InputStreamInitOptions & 
	Pick<IFilterInputStream,
		"base_stream" |
		"close_base_stream">;

	export interface FilterInputStreamInitOptions extends FilterInputStreamInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link FilterInputStream} instead.
	 */
	type FilterInputStreamMixin = IFilterInputStream & InputStream;

	/**
	 * Base class for input stream implementations that perform some
	 * kind of filtering operation on a base stream. Typical examples
	 * of filtering operations are character set conversion, compression
	 * and byte order flipping.
	 */
	interface FilterInputStream extends FilterInputStreamMixin {}

	class FilterInputStream {
		public constructor(options?: Partial<FilterInputStreamInitOptions>);
	}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link FilterOutputStream} instead.
	 */
	interface IFilterOutputStream {
		base_stream: OutputStream;
		close_base_stream: boolean;
		// readonly base_stream: OutputStream;
		/**
		 * Gets the base stream for the filter stream.
		 * @returns a #GOutputStream.
		 */
		get_base_stream(): OutputStream;
		/**
		 * Returns whether the base stream will be closed when #stream is
		 * closed.
		 * @returns %TRUE if the base stream will be closed.
		 */
		get_close_base_stream(): boolean;
		/**
		 * Sets whether the base stream will be closed when #stream is closed.
		 * @param close_base %TRUE to close the base stream.
		 */
		set_close_base_stream(close_base: boolean): void;
		connect(signal: "notify::base-stream", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::close-base-stream", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::base_stream", callback: (owner: this, ...args: any) => void): number;

	}

	type FilterOutputStreamInitOptionsMixin = OutputStreamInitOptions & 
	Pick<IFilterOutputStream,
		"base_stream" |
		"close_base_stream">;

	export interface FilterOutputStreamInitOptions extends FilterOutputStreamInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link FilterOutputStream} instead.
	 */
	type FilterOutputStreamMixin = IFilterOutputStream & OutputStream;

	/**
	 * Base class for output stream implementations that perform some
	 * kind of filtering operation on a base stream. Typical examples
	 * of filtering operations are character set conversion, compression
	 * and byte order flipping.
	 */
	interface FilterOutputStream extends FilterOutputStreamMixin {}

	class FilterOutputStream {
		public constructor(options?: Partial<FilterOutputStreamInitOptions>);
	}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link IOModule} instead.
	 */
	interface IIOModule {
		/**
		 * Required API for GIO modules to implement.
		 * 
		 * This function is run after the module has been loaded into GIO,
		 * to initialize the module. Typically, this function will call
		 * {@link G.io_extension_point_implement}.
		 * 
		 * Since 2.56, this function should be named `g_io_<modulename>_load`, where
		 * `modulename` is the plugin’s filename with the `lib` or `libgio` prefix and
		 * everything after the first dot removed, and with `-` replaced with `_`
		 * throughout. For example, `libgiognutls-helper.so` becomes `gnutls_helper`.
		 * Using the new symbol names avoids name clashes when building modules
		 * statically. The old symbol names continue to be supported, but cannot be used
		 * for static builds.
		 */
		load(): void;
		/**
		 * Required API for GIO modules to implement.
		 * 
		 * This function is run when the module is being unloaded from GIO,
		 * to finalize the module.
		 * 
		 * Since 2.56, this function should be named `g_io_<modulename>_unload`, where
		 * `modulename` is the plugin’s filename with the `lib` or `libgio` prefix and
		 * everything after the first dot removed, and with `-` replaced with `_`
		 * throughout. For example, `libgiognutls-helper.so` becomes `gnutls_helper`.
		 * Using the new symbol names avoids name clashes when building modules
		 * statically. The old symbol names continue to be supported, but cannot be used
		 * for static builds.
		 */
		unload(): void;
	}

	type IOModuleInitOptionsMixin = GObject.TypeModuleInitOptions & GObject.TypePluginInitOptions
	export interface IOModuleInitOptions extends IOModuleInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link IOModule} instead.
	 */
	type IOModuleMixin = IIOModule & GObject.TypeModule & GObject.TypePlugin;

	/**
	 * Provides an interface and default functions for loading and unloading
	 * modules. This is used internally to make GIO extensible, but can also
	 * be used by others to implement module loading.
	 */
	interface IOModule extends IOModuleMixin {}

	class IOModule {
		public constructor(options?: Partial<IOModuleInitOptions>);
		/**
		 * Creates a new GIOModule that will load the specific
		 * shared library when in use.
		 * @param filename filename of the shared library module.
		 * @returns a #GIOModule from given #filename,
		 * or %NULL on error.
		 */
		public static new(filename: string): IOModule;
		/**
		 * Optional API for GIO modules to implement.
		 * 
		 * Should return a list of all the extension points that may be
		 * implemented in this module.
		 * 
		 * This method will not be called in normal use, however it may be
		 * called when probing existing modules and recording which extension
		 * points that this model is used for. This means we won't have to
		 * load and initialize this module unless its needed.
		 * 
		 * If this function is not implemented by the module the module will
		 * always be loaded, initialized and then unloaded on application
		 * startup so that it can register its extension points during init.
		 * 
		 * Note that a module need not actually implement all the extension
		 * points that {@link G.io_module_query} returns, since the exact list of
		 * extension may depend on runtime issues. However all extension
		 * points actually implemented must be returned by g_io_module_query()
		 * (if defined).
		 * 
		 * When installing a module that implements g_io_module_query() you must
		 * run gio-querymodules in order to build the cache files required for
		 * lazy loading.
		 * 
		 * Since 2.56, this function should be named `g_io_<modulename>_query`, where
		 * `modulename` is the plugin’s filename with the `lib` or `libgio` prefix and
		 * everything after the first dot removed, and with `-` replaced with `_`
		 * throughout. For example, `libgiognutls-helper.so` becomes `gnutls_helper`.
		 * Using the new symbol names avoids name clashes when building modules
		 * statically. The old symbol names continue to be supported, but cannot be used
		 * for static builds.
		 * @returns A %NULL-terminated array of strings,
		 *     listing the supported extension points of the module. The array
		 *     must be suitable for freeing with {@link G.strfreev}.
		 */
		public static query(): string[];
	}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link IOStream} instead.
	 */
	interface IIOStream {
		readonly closed: boolean;
		readonly input_stream: InputStream;
		readonly output_stream: OutputStream;
		/**
		 * Clears the pending flag on #stream.
		 */
		clear_pending(): void;
		/**
		 * Closes the stream, releasing resources related to it. This will also
		 * close the individual input and output streams, if they are not already
		 * closed.
		 * 
		 * Once the stream is closed, all other operations will return
		 * %G_IO_ERROR_CLOSED. Closing a stream multiple times will not
		 * return an error.
		 * 
		 * Closing a stream will automatically flush any outstanding buffers
		 * in the stream.
		 * 
		 * Streams will be automatically closed when the last reference
		 * is dropped, but you might want to call this function to make sure
		 * resources are released as early as possible.
		 * 
		 * Some streams might keep the backing store of the stream (e.g. a file
		 * descriptor) open after the stream is closed. See the documentation for
		 * the individual stream for details.
		 * 
		 * On failure the first error that happened will be reported, but the
		 * close operation will finish as much as possible. A stream that failed
		 * to close will still return %G_IO_ERROR_CLOSED for all operations.
		 * Still, it is important to check and report the error to the user,
		 * otherwise there might be a loss of data as all data might not be written.
		 * 
		 * If #cancellable is not NULL, then the operation can be cancelled by
		 * triggering the cancellable object from another thread. If the operation
		 * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
		 * Cancelling a close will still leave the stream closed, but some streams
		 * can use a faster close that doesn't block to e.g. check errors.
		 * 
		 * The default implementation of this method just calls close on the
		 * individual input/output streams.
		 * @param cancellable optional #GCancellable object, %NULL to ignore
		 * @returns %TRUE on success, %FALSE on failure
		 */
		close(cancellable?: Cancellable | null): boolean;
		/**
		 * Requests an asynchronous close of the stream, releasing resources
		 * related to it. When the operation is finished #callback will be
		 * called. You can then call {@link G.io_stream_close_finish} to get
		 * the result of the operation.
		 * 
		 * For behaviour details see g_io_stream_close().
		 * 
		 * The asynchronous methods have a default fallback that uses threads
		 * to implement asynchronicity, so they are optional for inheriting
		 * classes. However, if you override one you must override all.
		 * @param io_priority the io priority of the request
		 * @param cancellable optional cancellable object
		 * @param callback callback to call when the request is satisfied
		 */
		close_async(io_priority: number | null, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;
		/**
		 * Closes a stream.
		 * @param result a #GAsyncResult
		 * @returns %TRUE if stream was successfully closed, %FALSE otherwise.
		 */
		close_finish(result: AsyncResult): boolean;
		/**
		 * Gets the input stream for this object. This is used
		 * for reading.
		 * @returns a #GInputStream, owned by the #GIOStream.
		 * Do not free.
		 */
		get_input_stream(): InputStream;
		/**
		 * Gets the output stream for this object. This is used for
		 * writing.
		 * @returns a #GOutputStream, owned by the #GIOStream.
		 * Do not free.
		 */
		get_output_stream(): OutputStream;
		/**
		 * Checks if a stream has pending actions.
		 * @returns %TRUE if #stream has pending actions.
		 */
		has_pending(): boolean;
		/**
		 * Checks if a stream is closed.
		 * @returns %TRUE if the stream is closed.
		 */
		is_closed(): boolean;
		/**
		 * Sets #stream to have actions pending. If the pending flag is
		 * already set or #stream is closed, it will return %FALSE and set
		 * #error.
		 * @returns %TRUE if pending was previously unset and is now set.
		 */
		set_pending(): boolean;
		/**
		 * Asynchronously splice the output stream of #stream1 to the input stream of
		 * #stream2, and splice the output stream of #stream2 to the input stream of
		 * #stream1.
		 * 
		 * When the operation is finished #callback will be called.
		 * You can then call {@link G.io_stream_splice_finish} to get the
		 * result of the operation.
		 * @param stream2 a #GIOStream.
		 * @param flags a set of #GIOStreamSpliceFlags.
		 * @param io_priority the io priority of the request.
		 * @param cancellable optional #GCancellable object, %NULL to ignore.
		 * @param callback a #GAsyncReadyCallback.
		 */
		splice_async(stream2: IOStream, flags: IOStreamSpliceFlags, io_priority: number, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;
		connect(signal: "notify::closed", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::input-stream", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::output-stream", callback: (owner: this, ...args: any) => void): number;

	}

	type IOStreamInitOptionsMixin = GObject.ObjectInitOptions
	export interface IOStreamInitOptions extends IOStreamInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link IOStream} instead.
	 */
	type IOStreamMixin = IIOStream & GObject.Object;

	/**
	 * GIOStream represents an object that has both read and write streams.
	 * Generally the two streams act as separate input and output streams,
	 * but they share some common resources and state. For instance, for
	 * seekable streams, both streams may use the same position.
	 * 
	 * Examples of #GIOStream objects are #GSocketConnection, which represents
	 * a two-way network connection; and #GFileIOStream, which represents a
	 * file handle opened in read-write mode.
	 * 
	 * To do the actual reading and writing you need to get the substreams
	 * with {@link G.io_stream_get_input_stream} and g_io_stream_get_output_stream().
	 * 
	 * The #GIOStream object owns the input and the output streams, not the other
	 * way around, so keeping the substreams alive will not keep the #GIOStream
	 * object alive. If the #GIOStream object is freed it will be closed, thus
	 * closing the substreams, so even if the substreams stay alive they will
	 * always return %G_IO_ERROR_CLOSED for all operations.
	 * 
	 * To close a stream use g_io_stream_close() which will close the common
	 * stream object and also the individual substreams. You can also close
	 * the substreams themselves. In most cases this only marks the
	 * substream as closed, so further I/O on it fails but common state in the
	 * #GIOStream may still be open. However, some streams may support
	 * "half-closed" states where one direction of the stream is actually shut down.
	 * 
	 * Operations on #GIOStreams cannot be started while another operation on the
	 * #GIOStream or its substreams is in progress. Specifically, an application can
	 * read from the #GInputStream and write to the #GOutputStream simultaneously
	 * (either in separate threads, or as asynchronous operations in the same
	 * thread), but an application cannot start any #GIOStream operation while there
	 * is a #GIOStream, #GInputStream or #GOutputStream operation in progress, and
	 * an application can’t start any #GInputStream or #GOutputStream operation
	 * while there is a #GIOStream operation in progress.
	 * 
	 * This is a product of individual stream operations being associated with a
	 * given #GMainContext (the thread-default context at the time the operation was
	 * started), rather than entire streams being associated with a single
	 * #GMainContext.
	 * 
	 * GIO may run operations on #GIOStreams from other (worker) threads, and this
	 * may be exposed to application code in the behaviour of wrapper streams, such
	 * as #GBufferedInputStream or #GTlsConnection. With such wrapper APIs,
	 * application code may only run operations on the base (wrapped) stream when
	 * the wrapper stream is idle. Note that the semantics of such operations may
	 * not be well-defined due to the state the wrapper stream leaves the base
	 * stream in (though they are guaranteed not to crash).
	 */
	interface IOStream extends IOStreamMixin {}

	class IOStream {
		public constructor(options?: Partial<IOStreamInitOptions>);
		/**
		 * Finishes an asynchronous io stream splice operation.
		 * @param result a #GAsyncResult.
		 * @returns %TRUE on success, %FALSE otherwise.
		 */
		public static splice_finish(result: AsyncResult): boolean;
	}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link InetAddress} instead.
	 */
	interface IInetAddress {
		bytes: any;
		family: SocketFamily;
		/**
		 * Whether this is the "any" address for its family.
		 * See {@link G.inet_address_get_is_any}.
		 */
		readonly is_any: boolean;
		/**
		 * Whether this is a link-local address.
		 * See {@link G.inet_address_get_is_link_local}.
		 */
		readonly is_link_local: boolean;
		/**
		 * Whether this is the loopback address for its family.
		 * See {@link G.inet_address_get_is_loopback}.
		 */
		readonly is_loopback: boolean;
		/**
		 * Whether this is a global multicast address.
		 * See {@link G.inet_address_get_is_mc_global}.
		 */
		readonly is_mc_global: boolean;
		/**
		 * Whether this is a link-local multicast address.
		 * See {@link G.inet_address_get_is_mc_link_local}.
		 */
		readonly is_mc_link_local: boolean;
		/**
		 * Whether this is a node-local multicast address.
		 * See {@link G.inet_address_get_is_mc_node_local}.
		 */
		readonly is_mc_node_local: boolean;
		/**
		 * Whether this is an organization-local multicast address.
		 * See {@link G.inet_address_get_is_mc_org_local}.
		 */
		readonly is_mc_org_local: boolean;
		/**
		 * Whether this is a site-local multicast address.
		 * See {@link G.inet_address_get_is_mc_site_local}.
		 */
		readonly is_mc_site_local: boolean;
		/**
		 * Whether this is a multicast address.
		 * See {@link G.inet_address_get_is_multicast}.
		 */
		readonly is_multicast: boolean;
		/**
		 * Whether this is a site-local address.
		 * See {@link G.inet_address_get_is_loopback}.
		 */
		readonly is_site_local: boolean;
		/**
		 * Checks if two #GInetAddress instances are equal, e.g. the same address.
		 * @param other_address Another #GInetAddress.
		 * @returns %TRUE if #address and #other_address are equal, %FALSE otherwise.
		 */
		equal(other_address: InetAddress): boolean;
		/**
		 * Gets #address's family
		 * @returns #address's family
		 */
		get_family(): SocketFamily;
		/**
		 * Tests whether #address is the "any" address for its family.
		 * @returns %TRUE if #address is the "any" address for its family.
		 */
		get_is_any(): boolean;
		/**
		 * Tests whether #address is a link-local address (that is, if it
		 * identifies a host on a local network that is not connected to the
		 * Internet).
		 * @returns %TRUE if #address is a link-local address.
		 */
		get_is_link_local(): boolean;
		/**
		 * Tests whether #address is the loopback address for its family.
		 * @returns %TRUE if #address is the loopback address for its family.
		 */
		get_is_loopback(): boolean;
		/**
		 * Tests whether #address is a global multicast address.
		 * @returns %TRUE if #address is a global multicast address.
		 */
		get_is_mc_global(): boolean;
		/**
		 * Tests whether #address is a link-local multicast address.
		 * @returns %TRUE if #address is a link-local multicast address.
		 */
		get_is_mc_link_local(): boolean;
		/**
		 * Tests whether #address is a node-local multicast address.
		 * @returns %TRUE if #address is a node-local multicast address.
		 */
		get_is_mc_node_local(): boolean;
		/**
		 * Tests whether #address is an organization-local multicast address.
		 * @returns %TRUE if #address is an organization-local multicast address.
		 */
		get_is_mc_org_local(): boolean;
		/**
		 * Tests whether #address is a site-local multicast address.
		 * @returns %TRUE if #address is a site-local multicast address.
		 */
		get_is_mc_site_local(): boolean;
		/**
		 * Tests whether #address is a multicast address.
		 * @returns %TRUE if #address is a multicast address.
		 */
		get_is_multicast(): boolean;
		/**
		 * Tests whether #address is a site-local address such as 10.0.0.1
		 * (that is, the address identifies a host on a local network that can
		 * not be reached directly from the Internet, but which may have
		 * outgoing Internet connectivity via a NAT or firewall).
		 * @returns %TRUE if #address is a site-local address.
		 */
		get_is_site_local(): boolean;
		/**
		 * Gets the size of the native raw binary address for #address. This
		 * is the size of the data that you get from {@link G.inet_address_to_bytes}.
		 * @returns the number of bytes used for the native version of #address.
		 */
		get_native_size(): number;
		/**
		 * Gets the raw binary address data from #address.
		 * @returns a pointer to an internal array of the bytes in #address,
		 * which should not be modified, stored, or freed. The size of this
		 * array can be gotten with {@link G.inet_address_get_native_size}.
		 */
		to_bytes(): number;
		/**
		 * Converts #address to string form.
		 * @returns a representation of #address as a string, which should be
		 * freed after use.
		 */
		to_string(): string;
		connect(signal: "notify::bytes", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::family", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::is-any", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::is-link-local", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::is-loopback", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::is-mc-global", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::is-mc-link-local", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::is-mc-node-local", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::is-mc-org-local", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::is-mc-site-local", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::is-multicast", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::is-site-local", callback: (owner: this, ...args: any) => void): number;

	}

	type InetAddressInitOptionsMixin = GObject.ObjectInitOptions & 
	Pick<IInetAddress,
		"bytes" |
		"family">;

	export interface InetAddressInitOptions extends InetAddressInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link InetAddress} instead.
	 */
	type InetAddressMixin = IInetAddress & GObject.Object;

	/**
	 * #GInetAddress represents an IPv4 or IPv6 internet address. Use
	 * {@link G.resolver_lookup_by_name} or g_resolver_lookup_by_name_async() to
	 * look up the #GInetAddress for a hostname. Use
	 * g_resolver_lookup_by_address() or
	 * g_resolver_lookup_by_address_async() to look up the hostname for a
	 * #GInetAddress.
	 * 
	 * To actually connect to a remote host, you will need a
	 * #GInetSocketAddress (which includes a #GInetAddress as well as a
	 * port number).
	 */
	interface InetAddress extends InetAddressMixin {}

	class InetAddress {
		public constructor(options?: Partial<InetAddressInitOptions>);
		/**
		 * Creates a #GInetAddress for the "any" address (unassigned/"don't
		 * care") for #family.
		 * @param family the address family
		 * @returns a new #GInetAddress corresponding to the "any" address
		 * for #family.
		 *     Free the returned object with {@link GObject.unref}.
		 */
		public static new_any(family: SocketFamily): InetAddress;
		/**
		 * Creates a new #GInetAddress from the given #family and #bytes.
		 * #bytes should be 4 bytes for %G_SOCKET_FAMILY_IPV4 and 16 bytes for
		 * %G_SOCKET_FAMILY_IPV6.
		 * @param bytes raw address data
		 * @param family the address family of #bytes
		 * @returns a new #GInetAddress corresponding to #family and #bytes.
		 *     Free the returned object with {@link GObject.unref}.
		 */
		public static new_from_bytes(bytes: number[], family: SocketFamily): InetAddress;
		/**
		 * Parses #string as an IP address and creates a new #GInetAddress.
		 * @param string a string representation of an IP address
		 * @returns a new #GInetAddress corresponding
		 * to #string, or %NULL if #string could not be parsed.
		 *     Free the returned object with {@link GObject.unref}.
		 */
		public static new_from_string(string: string): InetAddress | null;
		/**
		 * Creates a #GInetAddress for the loopback address for #family.
		 * @param family the address family
		 * @returns a new #GInetAddress corresponding to the loopback address
		 * for #family.
		 *     Free the returned object with {@link GObject.unref}.
		 */
		public static new_loopback(family: SocketFamily): InetAddress;
	}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link InetAddressMask} instead.
	 */
	interface IInetAddressMask {
		address: InetAddress;
		readonly family: SocketFamily;
		length: number;
		/**
		 * Tests if #mask and #mask2 are the same mask.
		 * @param mask2 another #GInetAddressMask
		 * @returns whether #mask and #mask2 are the same mask
		 */
		equal(mask2: InetAddressMask): boolean;
		/**
		 * Gets #mask's base address
		 * @returns #mask's base address
		 */
		get_address(): InetAddress;
		/**
		 * Gets the #GSocketFamily of #mask's address
		 * @returns the #GSocketFamily of #mask's address
		 */
		get_family(): SocketFamily;
		/**
		 * Gets #mask's length
		 * @returns #mask's length
		 */
		get_length(): number;
		/**
		 * Tests if #address falls within the range described by #mask.
		 * @param address a #GInetAddress
		 * @returns whether #address falls within the range described by
		 * #mask.
		 */
		matches(address: InetAddress): boolean;
		/**
		 * Converts #mask back to its corresponding string form.
		 * @returns a string corresponding to #mask.
		 */
		to_string(): string;
		connect(signal: "notify::address", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::family", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::length", callback: (owner: this, ...args: any) => void): number;

	}

	type InetAddressMaskInitOptionsMixin = GObject.ObjectInitOptions & InitableInitOptions & 
	Pick<IInetAddressMask,
		"address" |
		"length">;

	export interface InetAddressMaskInitOptions extends InetAddressMaskInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link InetAddressMask} instead.
	 */
	type InetAddressMaskMixin = IInetAddressMask & GObject.Object & Initable;

	/**
	 * #GInetAddressMask represents a range of IPv4 or IPv6 addresses
	 * described by a base address and a length indicating how many bits
	 * of the base address are relevant for matching purposes. These are
	 * often given in string form. Eg, "10.0.0.0/8", or "fe80::/10".
	 */
	interface InetAddressMask extends InetAddressMaskMixin {}

	class InetAddressMask {
		public constructor(options?: Partial<InetAddressMaskInitOptions>);
		/**
		 * Creates a new #GInetAddressMask representing all addresses whose
		 * first #length bits match #addr.
		 * @param addr a #GInetAddress
		 * @param length number of bits of #addr to use
		 * @returns a new #GInetAddressMask, or %NULL on error
		 */
		public static new(addr: InetAddress, length: number): InetAddressMask;
		/**
		 * Parses #mask_string as an IP address and (optional) length, and
		 * creates a new #GInetAddressMask. The length, if present, is
		 * delimited by a "/". If it is not present, then the length is
		 * assumed to be the full length of the address.
		 * @param mask_string an IP address or address/length string
		 * @returns a new #GInetAddressMask corresponding to #string, or %NULL
		 * on error.
		 */
		public static new_from_string(mask_string: string): InetAddressMask;
	}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link InetSocketAddress} instead.
	 */
	interface IInetSocketAddress {
		address: InetAddress;
		/**
		 * The `sin6_flowinfo` field, for IPv6 addresses.
		 */
		flowinfo: number;
		port: number;
		scope_id: number;
		/**
		 * Gets #address's #GInetAddress.
		 * @returns the #GInetAddress for #address, which must be
		 * {@link GObject.ref}'d if it will be stored
		 */
		get_address(): InetAddress;
		/**
		 * Gets the `sin6_flowinfo` field from #address,
		 * which must be an IPv6 address.
		 * @returns the flowinfo field
		 */
		get_flowinfo(): number;
		/**
		 * Gets #address's port.
		 * @returns the port for #address
		 */
		get_port(): number;
		/**
		 * Gets the `sin6_scope_id` field from #address,
		 * which must be an IPv6 address.
		 * @returns the scope id field
		 */
		get_scope_id(): number;
		connect(signal: "notify::address", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::flowinfo", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::port", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::scope-id", callback: (owner: this, ...args: any) => void): number;

	}

	type InetSocketAddressInitOptionsMixin = SocketAddressInitOptions & SocketConnectableInitOptions & 
	Pick<IInetSocketAddress,
		"address" |
		"flowinfo" |
		"port" |
		"scope_id">;

	export interface InetSocketAddressInitOptions extends InetSocketAddressInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link InetSocketAddress} instead.
	 */
	type InetSocketAddressMixin = IInetSocketAddress & SocketAddress & SocketConnectable;

	/**
	 * An IPv4 or IPv6 socket address; that is, the combination of a
	 * #GInetAddress and a port number.
	 */
	interface InetSocketAddress extends InetSocketAddressMixin {}

	class InetSocketAddress {
		public constructor(options?: Partial<InetSocketAddressInitOptions>);
		/**
		 * Creates a new #GInetSocketAddress for #address and #port.
		 * @param address a #GInetAddress
		 * @param port a port number
		 * @returns a new #GInetSocketAddress
		 */
		public static new(address: InetAddress, port: number): SocketAddress;
		/**
		 * Creates a new #GInetSocketAddress for #address and #port.
		 * 
		 * If #address is an IPv6 address, it can also contain a scope ID
		 * (separated from the address by a `%`).
		 * @param address the string form of an IP address
		 * @param port a port number
		 * @returns a new #GInetSocketAddress,
		 * or %NULL if #address cannot be parsed.
		 */
		public static new_from_string(address: string, port: number): SocketAddress | null;
	}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link InputStream} instead.
	 */
	interface IInputStream {
		/**
		 * Clears the pending flag on #stream.
		 */
		clear_pending(): void;
		/**
		 * Closes the stream, releasing resources related to it.
		 * 
		 * Once the stream is closed, all other operations will return %G_IO_ERROR_CLOSED.
		 * Closing a stream multiple times will not return an error.
		 * 
		 * Streams will be automatically closed when the last reference
		 * is dropped, but you might want to call this function to make sure
		 * resources are released as early as possible.
		 * 
		 * Some streams might keep the backing store of the stream (e.g. a file descriptor)
		 * open after the stream is closed. See the documentation for the individual
		 * stream for details.
		 * 
		 * On failure the first error that happened will be reported, but the close
		 * operation will finish as much as possible. A stream that failed to
		 * close will still return %G_IO_ERROR_CLOSED for all operations. Still, it
		 * is important to check and report the error to the user.
		 * 
		 * If #cancellable is not %NULL, then the operation can be cancelled by
		 * triggering the cancellable object from another thread. If the operation
		 * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
		 * Cancelling a close will still leave the stream closed, but some streams
		 * can use a faster close that doesn't block to e.g. check errors.
		 * @param cancellable optional #GCancellable object, %NULL to ignore.
		 * @returns %TRUE on success, %FALSE on failure
		 */
		close(cancellable?: Cancellable | null): boolean;
		/**
		 * Requests an asynchronous closes of the stream, releasing resources related to it.
		 * When the operation is finished #callback will be called.
		 * You can then call {@link G.input_stream_close_finish} to get the result of the
		 * operation.
		 * 
		 * For behaviour details see g_input_stream_close().
		 * 
		 * The asynchronous methods have a default fallback that uses threads to implement
		 * asynchronicity, so they are optional for inheriting classes. However, if you
		 * override one you must override all.
		 * @param io_priority the [I/O priority][io-priority] of the request
		 * @param cancellable optional cancellable object
		 * @param callback callback to call when the request is satisfied
		 */
		close_async(io_priority: number | null, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;
		/**
		 * Finishes closing a stream asynchronously, started from {@link G.input_stream_close_async}.
		 * @param result a #GAsyncResult.
		 * @returns %TRUE if the stream was closed successfully.
		 */
		close_finish(result: AsyncResult): boolean;
		/**
		 * Checks if an input stream has pending actions.
		 * @returns %TRUE if #stream has pending actions.
		 */
		has_pending(): boolean;
		/**
		 * Checks if an input stream is closed.
		 * @returns %TRUE if the stream is closed.
		 */
		is_closed(): boolean;
		/**
		 * Tries to read #count bytes from the stream into the buffer starting at
		 * #buffer. Will block during this read.
		 * 
		 * If count is zero returns zero and does nothing. A value of #count
		 * larger than %G_MAXSSIZE will cause a %G_IO_ERROR_INVALID_ARGUMENT error.
		 * 
		 * On success, the number of bytes read into the buffer is returned.
		 * It is not an error if this is not the same as the requested size, as it
		 * can happen e.g. near the end of a file. Zero is returned on end of file
		 * (or if #count is zero),  but never otherwise.
		 * 
		 * The returned #buffer is not a nul-terminated string, it can contain nul bytes
		 * at any position, and this function doesn't nul-terminate the #buffer.
		 * 
		 * If #cancellable is not %NULL, then the operation can be cancelled by
		 * triggering the cancellable object from another thread. If the operation
		 * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
		 * operation was partially finished when the operation was cancelled the
		 * partial result will be returned, without an error.
		 * 
		 * On error -1 is returned and #error is set accordingly.
		 * @param cancellable optional #GCancellable object, %NULL to ignore.
		 * @returns Number of bytes read, or -1 on error, or 0 on end of file.
		 * 
		 * 
		 *     a buffer to read data into (which should be at least count bytes long).
		 */
		read(cancellable?: Cancellable | null): [ number, number[] ];
		/**
		 * Tries to read #count bytes from the stream into the buffer starting at
		 * #buffer. Will block during this read.
		 * 
		 * This function is similar to {@link G.input_stream_read}, except it tries to
		 * read as many bytes as requested, only stopping on an error or end of stream.
		 * 
		 * On a successful read of #count bytes, or if we reached the end of the
		 * stream,  %TRUE is returned, and #bytes_read is set to the number of bytes
		 * read into #buffer.
		 * 
		 * If there is an error during the operation %FALSE is returned and #error
		 * is set to indicate the error status.
		 * 
		 * As a special exception to the normal conventions for functions that
		 * use #GError, if this function returns %FALSE (and sets #error) then
		 * #bytes_read will be set to the number of bytes that were successfully
		 * read before the error was encountered.  This functionality is only
		 * available from C.  If you need it from another language then you must
		 * write your own loop around g_input_stream_read().
		 * @param cancellable optional #GCancellable object, %NULL to ignore.
		 * @returns %TRUE on success, %FALSE if there was an error
		 * 
		 * 
		 *     a buffer to read data into (which should be at least count bytes long).
		 * 
		 * location to store the number of bytes that was read from the stream
		 */
		read_all(cancellable?: Cancellable | null): [ boolean, number[], number ];
		/**
		 * Request an asynchronous read of #count bytes from the stream into the
		 * buffer starting at #buffer.
		 * 
		 * This is the asynchronous equivalent of {@link G.input_stream_read_all}.
		 * 
		 * Call g_input_stream_read_all_finish() to collect the result.
		 * 
		 * Any outstanding I/O request with higher priority (lower numerical
		 * value) will be executed before an outstanding request with lower
		 * priority. Default priority is %G_PRIORITY_DEFAULT.
		 * @param io_priority the [I/O priority][io-priority] of the request
		 * @param cancellable optional #GCancellable object, %NULL to ignore
		 * @param callback callback to call when the request is satisfied
		 * @returns 
		 *     a buffer to read data into (which should be at least count bytes long)
		 */
		read_all_async(io_priority: number, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): number[];
		/**
		 * Finishes an asynchronous stream read operation started with
		 * {@link G.input_stream_read_all_async}.
		 * 
		 * As a special exception to the normal conventions for functions that
		 * use #GError, if this function returns %FALSE (and sets #error) then
		 * #bytes_read will be set to the number of bytes that were successfully
		 * read before the error was encountered.  This functionality is only
		 * available from C.  If you need it from another language then you must
		 * write your own loop around g_input_stream_read_async().
		 * @param result a #GAsyncResult
		 * @returns %TRUE on success, %FALSE if there was an error
		 * 
		 * location to store the number of bytes that was read from the stream
		 */
		read_all_finish(result: AsyncResult): [ boolean, number ];
		/**
		 * Request an asynchronous read of #count bytes from the stream into the buffer
		 * starting at #buffer. When the operation is finished #callback will be called.
		 * You can then call {@link G.input_stream_read_finish} to get the result of the
		 * operation.
		 * 
		 * During an async request no other sync and async calls are allowed on #stream, and will
		 * result in %G_IO_ERROR_PENDING errors.
		 * 
		 * A value of #count larger than %G_MAXSSIZE will cause a %G_IO_ERROR_INVALID_ARGUMENT error.
		 * 
		 * On success, the number of bytes read into the buffer will be passed to the
		 * callback. It is not an error if this is not the same as the requested size, as it
		 * can happen e.g. near the end of a file, but generally we try to read
		 * as many bytes as requested. Zero is returned on end of file
		 * (or if #count is zero),  but never otherwise.
		 * 
		 * Any outstanding i/o request with higher priority (lower numerical value) will
		 * be executed before an outstanding request with lower priority. Default
		 * priority is %G_PRIORITY_DEFAULT.
		 * 
		 * The asynchronous methods have a default fallback that uses threads to implement
		 * asynchronicity, so they are optional for inheriting classes. However, if you
		 * override one you must override all.
		 * @param io_priority the [I/O priority][io-priority]
		 * of the request.
		 * @param cancellable optional #GCancellable object, %NULL to ignore.
		 * @param callback callback to call when the request is satisfied
		 * @returns 
		 *     a buffer to read data into (which should be at least count bytes long).
		 */
		read_async(io_priority: number, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): number[];
		/**
		 * Like {@link G.input_stream_read}, this tries to read #count bytes from
		 * the stream in a blocking fashion. However, rather than reading into
		 * a user-supplied buffer, this will create a new #GBytes containing
		 * the data that was read. This may be easier to use from language
		 * bindings.
		 * 
		 * If count is zero, returns a zero-length #GBytes and does nothing. A
		 * value of #count larger than %G_MAXSSIZE will cause a
		 * %G_IO_ERROR_INVALID_ARGUMENT error.
		 * 
		 * On success, a new #GBytes is returned. It is not an error if the
		 * size of this object is not the same as the requested size, as it
		 * can happen e.g. near the end of a file. A zero-length #GBytes is
		 * returned on end of file (or if #count is zero), but never
		 * otherwise.
		 * 
		 * If #cancellable is not %NULL, then the operation can be cancelled by
		 * triggering the cancellable object from another thread. If the operation
		 * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
		 * operation was partially finished when the operation was cancelled the
		 * partial result will be returned, without an error.
		 * 
		 * On error %NULL is returned and #error is set accordingly.
		 * @param count maximum number of bytes that will be read from the stream. Common
		 * values include 4096 and 8192.
		 * @param cancellable optional #GCancellable object, %NULL to ignore.
		 * @returns a new #GBytes, or %NULL on error
		 */
		read_bytes(count: number, cancellable?: Cancellable | null): GLib.Bytes;
		/**
		 * Request an asynchronous read of #count bytes from the stream into a
		 * new #GBytes. When the operation is finished #callback will be
		 * called. You can then call {@link G.input_stream_read_bytes_finish} to get the
		 * result of the operation.
		 * 
		 * During an async request no other sync and async calls are allowed
		 * on #stream, and will result in %G_IO_ERROR_PENDING errors.
		 * 
		 * A value of #count larger than %G_MAXSSIZE will cause a
		 * %G_IO_ERROR_INVALID_ARGUMENT error.
		 * 
		 * On success, the new #GBytes will be passed to the callback. It is
		 * not an error if this is smaller than the requested size, as it can
		 * happen e.g. near the end of a file, but generally we try to read as
		 * many bytes as requested. Zero is returned on end of file (or if
		 * #count is zero), but never otherwise.
		 * 
		 * Any outstanding I/O request with higher priority (lower numerical
		 * value) will be executed before an outstanding request with lower
		 * priority. Default priority is %G_PRIORITY_DEFAULT.
		 * @param count the number of bytes that will be read from the stream
		 * @param io_priority the [I/O priority][io-priority] of the request
		 * @param cancellable optional #GCancellable object, %NULL to ignore.
		 * @param callback callback to call when the request is satisfied
		 */
		read_bytes_async(count: number, io_priority: number, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;
		/**
		 * Finishes an asynchronous stream read-into-#GBytes operation.
		 * @param result a #GAsyncResult.
		 * @returns the newly-allocated #GBytes, or %NULL on error
		 */
		read_bytes_finish(result: AsyncResult): GLib.Bytes;
		/**
		 * Finishes an asynchronous stream read operation.
		 * @param result a #GAsyncResult.
		 * @returns number of bytes read in, or -1 on error, or 0 on end of file.
		 */
		read_finish(result: AsyncResult): number;
		/**
		 * Sets #stream to have actions pending. If the pending flag is
		 * already set or #stream is closed, it will return %FALSE and set
		 * #error.
		 * @returns %TRUE if pending was previously unset and is now set.
		 */
		set_pending(): boolean;
		/**
		 * Tries to skip #count bytes from the stream. Will block during the operation.
		 * 
		 * This is identical to {@link G.input_stream_read}, from a behaviour standpoint,
		 * but the bytes that are skipped are not returned to the user. Some
		 * streams have an implementation that is more efficient than reading the data.
		 * 
		 * This function is optional for inherited classes, as the default implementation
		 * emulates it using read.
		 * 
		 * If #cancellable is not %NULL, then the operation can be cancelled by
		 * triggering the cancellable object from another thread. If the operation
		 * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
		 * operation was partially finished when the operation was cancelled the
		 * partial result will be returned, without an error.
		 * @param count the number of bytes that will be skipped from the stream
		 * @param cancellable optional #GCancellable object, %NULL to ignore.
		 * @returns Number of bytes skipped, or -1 on error
		 */
		skip(count: number, cancellable?: Cancellable | null): number;
		/**
		 * Request an asynchronous skip of #count bytes from the stream.
		 * When the operation is finished #callback will be called.
		 * You can then call {@link G.input_stream_skip_finish} to get the result
		 * of the operation.
		 * 
		 * During an async request no other sync and async calls are allowed,
		 * and will result in %G_IO_ERROR_PENDING errors.
		 * 
		 * A value of #count larger than %G_MAXSSIZE will cause a %G_IO_ERROR_INVALID_ARGUMENT error.
		 * 
		 * On success, the number of bytes skipped will be passed to the callback.
		 * It is not an error if this is not the same as the requested size, as it
		 * can happen e.g. near the end of a file, but generally we try to skip
		 * as many bytes as requested. Zero is returned on end of file
		 * (or if #count is zero), but never otherwise.
		 * 
		 * Any outstanding i/o request with higher priority (lower numerical value)
		 * will be executed before an outstanding request with lower priority.
		 * Default priority is %G_PRIORITY_DEFAULT.
		 * 
		 * The asynchronous methods have a default fallback that uses threads to
		 * implement asynchronicity, so they are optional for inheriting classes.
		 * However, if you override one, you must override all.
		 * @param count the number of bytes that will be skipped from the stream
		 * @param io_priority the [I/O priority][io-priority] of the request
		 * @param cancellable optional #GCancellable object, %NULL to ignore.
		 * @param callback callback to call when the request is satisfied
		 */
		skip_async(count: number, io_priority: number, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;
		/**
		 * Finishes a stream skip operation.
		 * @param result a #GAsyncResult.
		 * @returns the size of the bytes skipped, or `-1` on error.
		 */
		skip_finish(result: AsyncResult): number;
	}

	type InputStreamInitOptionsMixin = GObject.ObjectInitOptions
	export interface InputStreamInitOptions extends InputStreamInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link InputStream} instead.
	 */
	type InputStreamMixin = IInputStream & GObject.Object;

	/**
	 * #GInputStream has functions to read from a stream {@link (g.input_stream_read}),
	 * to close a stream (g_input_stream_close()) and to skip some content
	 * (g_input_stream_skip()).
	 * 
	 * To copy the content of an input stream to an output stream without
	 * manually handling the reads and writes, use g_output_stream_splice().
	 * 
	 * See the documentation for #GIOStream for details of thread safety of
	 * streaming APIs.
	 * 
	 * All of these functions have async variants too.
	 */
	interface InputStream extends InputStreamMixin {}

	class InputStream {
		public constructor(options?: Partial<InputStreamInitOptions>);
	}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link ListStore} instead.
	 */
	interface IListStore {
		/**
		 * The type of items contained in this list store. Items must be
		 * subclasses of #GObject.
		 */
		item_type: GObject.Type;
		/**
		 * Appends #item to #store. #item must be of type #GListStore:item-type.
		 * 
		 * This function takes a ref on #item.
		 * 
		 * Use {@link G.list_store_splice} to append multiple items at the same time
		 * efficiently.
		 * @param item the new item
		 */
		append(item: GObject.Object): void;
		/**
		 * Looks up the given #item in the list store by looping over the items until
		 * the first occurrence of #item. If #item was not found, then #position will
		 * not be set, and this method will return %FALSE.
		 * 
		 * If you need to compare the two items with a custom comparison function, use
		 * {@link G.list_store_find_with_equal_func} with a custom #GEqualFunc instead.
		 * @param item an item
		 * @returns Whether #store contains #item. If it was found, #position will be
		 * set to the position where #item occurred for the first time.
		 * 
		 * the first position of #item, if it was found.
		 */
		find(item: GObject.Object): [ boolean, number | null ];
		/**
		 * Looks up the given #item in the list store by looping over the items and
		 * comparing them with #compare_func until the first occurrence of #item which
		 * matches. If #item was not found, then #position will not be set, and this
		 * method will return %FALSE.
		 * @param item an item
		 * @param equal_func A custom equality check function
		 * @returns Whether #store contains #item. If it was found, #position will be
		 * set to the position where #item occurred for the first time.
		 * 
		 * the first position of #item, if it was found.
		 */
		find_with_equal_func(item: GObject.Object, equal_func: GLib.EqualFunc): [ boolean, number | null ];
		/**
		 * Inserts #item into #store at #position. #item must be of type
		 * #GListStore:item-type or derived from it. #position must be smaller
		 * than the length of the list, or equal to it to append.
		 * 
		 * This function takes a ref on #item.
		 * 
		 * Use {@link G.list_store_splice} to insert multiple items at the same time
		 * efficiently.
		 * @param position the position at which to insert the new item
		 * @param item the new item
		 */
		insert(position: number, item: GObject.Object): void;
		/**
		 * Inserts #item into #store at a position to be determined by the
		 * #compare_func.
		 * 
		 * The list must already be sorted before calling this function or the
		 * result is undefined.  Usually you would approach this by only ever
		 * inserting items by way of this function.
		 * 
		 * This function takes a ref on #item.
		 * @param item the new item
		 * @param compare_func pairwise comparison function for sorting
		 * @returns the position at which #item was inserted
		 */
		insert_sorted(item: GObject.Object, compare_func: GLib.CompareDataFunc): number;
		/**
		 * Removes the item from #store that is at #position. #position must be
		 * smaller than the current length of the list.
		 * 
		 * Use {@link G.list_store_splice} to remove multiple items at the same time
		 * efficiently.
		 * @param position the position of the item that is to be removed
		 */
		remove(position: number): void;
		/**
		 * Removes all items from #store.
		 */
		remove_all(): void;
		/**
		 * Sort the items in #store according to #compare_func.
		 * @param compare_func pairwise comparison function for sorting
		 */
		sort(compare_func: GLib.CompareDataFunc): void;
		/**
		 * Changes #store by removing #n_removals items and adding #n_additions
		 * items to it. #additions must contain #n_additions items of type
		 * #GListStore:item-type.  %NULL is not permitted.
		 * 
		 * This function is more efficient than {@link G.list_store_insert} and
		 * g_list_store_remove(), because it only emits
		 * #GListModel::items-changed once for the change.
		 * 
		 * This function takes a ref on each item in #additions.
		 * 
		 * The parameters #position and #n_removals must be correct (ie:
		 * #position + #n_removals must be less than or equal to the length of
		 * the list at the time this function is called).
		 * @param position the position at which to make the change
		 * @param n_removals the number of items to remove
		 * @param additions the items to add
		 */
		splice(position: number, n_removals: number, additions: GObject.Object[]): void;
		connect(signal: "notify::item-type", callback: (owner: this, ...args: any) => void): number;

	}

	type ListStoreInitOptionsMixin = GObject.ObjectInitOptions & ListModelInitOptions & 
	Pick<IListStore,
		"item_type">;

	export interface ListStoreInitOptions extends ListStoreInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link ListStore} instead.
	 */
	type ListStoreMixin = IListStore & GObject.Object & ListModel;

	/**
	 * #GListStore is a simple implementation of #GListModel that stores all
	 * items in memory.
	 * 
	 * It provides insertions, deletions, and lookups in logarithmic time
	 * with a fast path for the common case of iterating the list linearly.
	 */
	interface ListStore extends ListStoreMixin {}

	class ListStore {
		public constructor(options?: Partial<ListStoreInitOptions>);
		/**
		 * Creates a new #GListStore with items of type #item_type. #item_type
		 * must be a subclass of #GObject.
		 * @param item_type the #GType of items in the list
		 * @returns a new #GListStore
		 */
		public static new(item_type: GObject.Type): ListStore;
	}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link MemoryInputStream} instead.
	 */
	interface IMemoryInputStream {
		/**
		 * Appends #bytes to data that can be read from the input stream.
		 * @param bytes input data
		 */
		add_bytes(bytes: GLib.Bytes): void;
		/**
		 * Appends #data to data that can be read from the input stream
		 * @param data input data
		 */
		add_data(data: number[]): void;
	}

	type MemoryInputStreamInitOptionsMixin = InputStreamInitOptions & PollableInputStreamInitOptions & SeekableInitOptions
	export interface MemoryInputStreamInitOptions extends MemoryInputStreamInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link MemoryInputStream} instead.
	 */
	type MemoryInputStreamMixin = IMemoryInputStream & InputStream & PollableInputStream & Seekable;

	/**
	 * #GMemoryInputStream is a class for using arbitrary
	 * memory chunks as input for GIO streaming input operations.
	 * 
	 * As of GLib 2.34, #GMemoryInputStream implements
	 * #GPollableInputStream.
	 */
	interface MemoryInputStream extends MemoryInputStreamMixin {}

	class MemoryInputStream {
		public constructor(options?: Partial<MemoryInputStreamInitOptions>);
		/**
		 * Creates a new empty #GMemoryInputStream.
		 * @returns a new #GInputStream
		 */
		public static new(): InputStream;
		/**
		 * Creates a new #GMemoryInputStream with data from the given #bytes.
		 * @param bytes a #GBytes
		 * @returns new #GInputStream read from #bytes
		 */
		public static new_from_bytes(bytes: GLib.Bytes): InputStream;
		/**
		 * Creates a new #GMemoryInputStream with data in memory of a given size.
		 * @param data input data
		 * @returns new #GInputStream read from #data of #len bytes.
		 */
		public static new_from_data(data: number[]): InputStream;
	}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link MemoryOutputStream} instead.
	 */
	interface IMemoryOutputStream {
		/**
		 * Pointer to buffer where data will be written.
		 */
		data: any;
		/**
		 * Size of data written to the buffer.
		 */
		readonly data_size: number;
		/**
		 * Function called with the buffer as argument when the stream is destroyed.
		 */
		destroy_function: any;
		/**
		 * Function with realloc semantics called to enlarge the buffer.
		 */
		realloc_function: any;
		/**
		 * Current size of the data buffer.
		 */
		size: number;
		/**
		 * Gets any loaded data from the #ostream.
		 * 
		 * Note that the returned pointer may become invalid on the next
		 * write or truncate operation on the stream.
		 * @returns pointer to the stream's data, or %NULL if the data
		 *    has been stolen
		 */
		get_data(): any | null;
		/**
		 * Returns the number of bytes from the start up to including the last
		 * byte written in the stream that has not been truncated away.
		 * @returns the number of bytes written to the stream
		 */
		get_data_size(): number;
		/**
		 * Gets the size of the currently allocated data area (available from
		 * {@link G.memory_output_stream_get_data}).
		 * 
		 * You probably don't want to use this function on resizable streams.
		 * See g_memory_output_stream_get_data_size() instead.  For resizable
		 * streams the size returned by this function is an implementation
		 * detail and may be change at any time in response to operations on the
		 * stream.
		 * 
		 * If the stream is fixed-sized (ie: no realloc was passed to
		 * g_memory_output_stream_new()) then this is the maximum size of the
		 * stream and further writes will return %G_IO_ERROR_NO_SPACE.
		 * 
		 * In any case, if you want the number of bytes currently written to the
		 * stream, use g_memory_output_stream_get_data_size().
		 * @returns the number of bytes allocated for the data buffer
		 */
		get_size(): number;
		/**
		 * Returns data from the #ostream as a #GBytes. #ostream must be
		 * closed before calling this function.
		 * @returns the stream's data
		 */
		steal_as_bytes(): GLib.Bytes;
		/**
		 * Gets any loaded data from the #ostream. Ownership of the data
		 * is transferred to the caller; when no longer needed it must be
		 * freed using the free function set in #ostream's
		 * #GMemoryOutputStream:destroy-function property.
		 * 
		 * #ostream must be closed before calling this function.
		 * @returns the stream's data, or %NULL if it has previously
		 *    been stolen
		 */
		steal_data(): any | null;
		connect(signal: "notify::data", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::data-size", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::destroy-function", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::realloc-function", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::size", callback: (owner: this, ...args: any) => void): number;

	}

	type MemoryOutputStreamInitOptionsMixin = OutputStreamInitOptions & PollableOutputStreamInitOptions & SeekableInitOptions & 
	Pick<IMemoryOutputStream,
		"data" |
		"destroy_function" |
		"realloc_function" |
		"size">;

	export interface MemoryOutputStreamInitOptions extends MemoryOutputStreamInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link MemoryOutputStream} instead.
	 */
	type MemoryOutputStreamMixin = IMemoryOutputStream & OutputStream & PollableOutputStream & Seekable;

	/**
	 * #GMemoryOutputStream is a class for using arbitrary
	 * memory chunks as output for GIO streaming output operations.
	 * 
	 * As of GLib 2.34, #GMemoryOutputStream trivially implements
	 * #GPollableOutputStream: it always polls as ready.
	 */
	interface MemoryOutputStream extends MemoryOutputStreamMixin {}

	class MemoryOutputStream {
		public constructor(options?: Partial<MemoryOutputStreamInitOptions>);
		/**
		 * Creates a new #GMemoryOutputStream.
		 * 
		 * In most cases this is not the function you want.  See
		 * {@link G.memory_output_stream_new_resizable} instead.
		 * 
		 * If #data is non-%NULL, the stream will use that for its internal storage.
		 * 
		 * If #realloc_fn is non-%NULL, it will be used for resizing the internal
		 * storage when necessary and the stream will be considered resizable.
		 * In that case, the stream will start out being (conceptually) empty.
		 * #size is used only as a hint for how big #data is.  Specifically,
		 * seeking to the end of a newly-created stream will seek to zero, not
		 * #size.  Seeking past the end of the stream and then writing will
		 * introduce a zero-filled gap.
		 * 
		 * If #realloc_fn is %NULL then the stream is fixed-sized.  Seeking to
		 * the end will seek to #size exactly.  Writing past the end will give
		 * an 'out of space' error.  Attempting to seek past the end will fail.
		 * Unlike the resizable case, seeking to an offset within the stream and
		 * writing will preserve the bytes passed in as #data before that point
		 * and will return them as part of g_memory_output_stream_steal_data().
		 * If you intend to seek you should probably therefore ensure that #data
		 * is properly initialised.
		 * 
		 * It is probably only meaningful to provide #data and #size in the case
		 * that you want a fixed-sized stream.  Put another way: if #realloc_fn
		 * is non-%NULL then it makes most sense to give #data as %NULL and
		 * #size as 0 (allowing #GMemoryOutputStream to do the initial
		 * allocation for itself).
		 * 
		 * |[<!-- language="C" -->
		 * // a stream that can grow
		 * stream = g_memory_output_stream_new (NULL, 0, realloc, free);
		 * 
		 * // another stream that can grow
		 * stream2 = g_memory_output_stream_new (NULL, 0, g_realloc, g_free);
		 * 
		 * // a fixed-size stream
		 * data = malloc (200);
		 * stream3 = g_memory_output_stream_new (data, 200, NULL, free);
		 * ]|
		 * @param data pointer to a chunk of memory to use, or %NULL
		 * @param size the size of #data
		 * @param realloc_function a function with realloc() semantics (like g_realloc())
		 *     to be called when #data needs to be grown, or %NULL
		 * @returns A newly created #GMemoryOutputStream object.
		 */
		public static new(data: any | null, size: number, realloc_function?: ReallocFunc | null): OutputStream;
		/**
		 * Creates a new #GMemoryOutputStream, using {@link G.realloc} and g_free()
		 * for memory allocation.
		 * @returns 
		 */
		public static new_resizable(): OutputStream;
	}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link Menu} instead.
	 */
	interface IMenu {
		/**
		 * Convenience function for appending a normal menu item to the end of
		 * #menu.  Combine {@link G.menu_item_new} and g_menu_insert_item() for a more
		 * flexible alternative.
		 * @param label the section label, or %NULL
		 * @param detailed_action the detailed action string, or %NULL
		 */
		append(label?: string | null, detailed_action?: string | null): void;
		/**
		 * Appends #item to the end of #menu.
		 * 
		 * See {@link G.menu_insert_item} for more information.
		 * @param item a #GMenuItem to append
		 */
		append_item(item: MenuItem): void;
		/**
		 * Convenience function for appending a section menu item to the end of
		 * #menu.  Combine {@link G.menu_item_new_section} and g_menu_insert_item() for a
		 * more flexible alternative.
		 * @param label the section label, or %NULL
		 * @param section a #GMenuModel with the items of the section
		 */
		append_section(label: string | null, section: MenuModel): void;
		/**
		 * Convenience function for appending a submenu menu item to the end of
		 * #menu.  Combine {@link G.menu_item_new_submenu} and g_menu_insert_item() for a
		 * more flexible alternative.
		 * @param label the section label, or %NULL
		 * @param submenu a #GMenuModel with the items of the submenu
		 */
		append_submenu(label: string | null, submenu: MenuModel): void;
		/**
		 * Marks #menu as frozen.
		 * 
		 * After the menu is frozen, it is an error to attempt to make any
		 * changes to it.  In effect this means that the #GMenu API must no
		 * longer be used.
		 * 
		 * This function causes {@link G.menu_model_is_mutable} to begin returning
		 * %FALSE, which has some positive performance implications.
		 */
		freeze(): void;
		/**
		 * Convenience function for inserting a normal menu item into #menu.
		 * Combine {@link G.menu_item_new} and g_menu_insert_item() for a more flexible
		 * alternative.
		 * @param position the position at which to insert the item
		 * @param label the section label, or %NULL
		 * @param detailed_action the detailed action string, or %NULL
		 */
		insert(position: number, label?: string | null, detailed_action?: string | null): void;
		/**
		 * Inserts #item into #menu.
		 * 
		 * The "insertion" is actually done by copying all of the attribute and
		 * link values of #item and using them to form a new item within #menu.
		 * As such, #item itself is not really inserted, but rather, a menu item
		 * that is exactly the same as the one presently described by #item.
		 * 
		 * This means that #item is essentially useless after the insertion
		 * occurs.  Any changes you make to it are ignored unless it is inserted
		 * again (at which point its updated values will be copied).
		 * 
		 * You should probably just free #item once you're done.
		 * 
		 * There are many convenience functions to take care of common cases.
		 * See {@link G.menu_insert}, g_menu_insert_section() and
		 * g_menu_insert_submenu() as well as "prepend" and "append" variants of
		 * each of these functions.
		 * @param position the position at which to insert the item
		 * @param item the #GMenuItem to insert
		 */
		insert_item(position: number, item: MenuItem): void;
		/**
		 * Convenience function for inserting a section menu item into #menu.
		 * Combine {@link G.menu_item_new_section} and g_menu_insert_item() for a more
		 * flexible alternative.
		 * @param position the position at which to insert the item
		 * @param label the section label, or %NULL
		 * @param section a #GMenuModel with the items of the section
		 */
		insert_section(position: number, label: string | null, section: MenuModel): void;
		/**
		 * Convenience function for inserting a submenu menu item into #menu.
		 * Combine {@link G.menu_item_new_submenu} and g_menu_insert_item() for a more
		 * flexible alternative.
		 * @param position the position at which to insert the item
		 * @param label the section label, or %NULL
		 * @param submenu a #GMenuModel with the items of the submenu
		 */
		insert_submenu(position: number, label: string | null, submenu: MenuModel): void;
		/**
		 * Convenience function for prepending a normal menu item to the start
		 * of #menu.  Combine {@link G.menu_item_new} and g_menu_insert_item() for a more
		 * flexible alternative.
		 * @param label the section label, or %NULL
		 * @param detailed_action the detailed action string, or %NULL
		 */
		prepend(label?: string | null, detailed_action?: string | null): void;
		/**
		 * Prepends #item to the start of #menu.
		 * 
		 * See {@link G.menu_insert_item} for more information.
		 * @param item a #GMenuItem to prepend
		 */
		prepend_item(item: MenuItem): void;
		/**
		 * Convenience function for prepending a section menu item to the start
		 * of #menu.  Combine {@link G.menu_item_new_section} and g_menu_insert_item() for
		 * a more flexible alternative.
		 * @param label the section label, or %NULL
		 * @param section a #GMenuModel with the items of the section
		 */
		prepend_section(label: string | null, section: MenuModel): void;
		/**
		 * Convenience function for prepending a submenu menu item to the start
		 * of #menu.  Combine {@link G.menu_item_new_submenu} and g_menu_insert_item() for
		 * a more flexible alternative.
		 * @param label the section label, or %NULL
		 * @param submenu a #GMenuModel with the items of the submenu
		 */
		prepend_submenu(label: string | null, submenu: MenuModel): void;
		/**
		 * Removes an item from the menu.
		 * 
		 * #position gives the index of the item to remove.
		 * 
		 * It is an error if position is not in range the range from 0 to one
		 * less than the number of items in the menu.
		 * 
		 * It is not possible to remove items by identity since items are added
		 * to the menu simply by copying their links and attributes (ie:
		 * identity of the item itself is not preserved).
		 * @param position the position of the item to remove
		 */
		remove(position: number): void;
		/**
		 * Removes all items in the menu.
		 */
		remove_all(): void;
	}

	type MenuInitOptionsMixin = MenuModelInitOptions
	export interface MenuInitOptions extends MenuInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link Menu} instead.
	 */
	type MenuMixin = IMenu & MenuModel;

	/**
	 * #GMenu is a simple implementation of #GMenuModel.
	 * You populate a #GMenu by adding #GMenuItem instances to it.
	 * 
	 * There are some convenience functions to allow you to directly
	 * add items (avoiding #GMenuItem) for the common cases. To add
	 * a regular item, use {@link G.menu_insert}. To add a section, use
	 * g_menu_insert_section(). To add a submenu, use
	 * g_menu_insert_submenu().
	 */
	interface Menu extends MenuMixin {}

	class Menu {
		public constructor(options?: Partial<MenuInitOptions>);
		/**
		 * Creates a new #GMenu.
		 * 
		 * The new menu has no items.
		 * @returns a new #GMenu
		 */
		public static new(): Menu;
	}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link MenuAttributeIter} instead.
	 */
	interface IMenuAttributeIter {
		/**
		 * Gets the name of the attribute at the current iterator position, as
		 * a string.
		 * 
		 * The iterator is not advanced.
		 * @returns the name of the attribute
		 */
		get_name(): string;
		/**
		 * This function combines {@link G.menu_attribute_iter_next} with
		 * g_menu_attribute_iter_get_name() and g_menu_attribute_iter_get_value().
		 * 
		 * First the iterator is advanced to the next (possibly first) attribute.
		 * If that fails, then %FALSE is returned and there are no other
		 * effects.
		 * 
		 * If successful, #name and #value are set to the name and value of the
		 * attribute that has just been advanced to.  At this point,
		 * g_menu_attribute_iter_get_name() and g_menu_attribute_iter_get_value() will
		 * return the same values again.
		 * 
		 * The value returned in #name remains valid for as long as the iterator
		 * remains at the current position.  The value returned in #value must
		 * be unreffed using g_variant_unref() when it is no longer in use.
		 * @returns %TRUE on success, or %FALSE if there is no additional
		 *     attribute
		 * 
		 * the type of the attribute
		 * 
		 * the attribute value
		 */
		get_next(): [ boolean, string | null, GLib.Variant | null ];
		/**
		 * Gets the value of the attribute at the current iterator position.
		 * 
		 * The iterator is not advanced.
		 * @returns the value of the current attribute
		 */
		get_value(): GLib.Variant;
		/**
		 * Attempts to advance the iterator to the next (possibly first)
		 * attribute.
		 * 
		 * %TRUE is returned on success, or %FALSE if there are no more
		 * attributes.
		 * 
		 * You must call this function when you first acquire the iterator
		 * to advance it to the first attribute (and determine if the first
		 * attribute exists at all).
		 * @returns %TRUE on success, or %FALSE when there are no more attributes
		 */
		next(): boolean;
	}

	type MenuAttributeIterInitOptionsMixin = GObject.ObjectInitOptions
	export interface MenuAttributeIterInitOptions extends MenuAttributeIterInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link MenuAttributeIter} instead.
	 */
	type MenuAttributeIterMixin = IMenuAttributeIter & GObject.Object;

	/**
	 * #GMenuAttributeIter is an opaque structure type.  You must access it
	 * using the functions below.
	 */
	interface MenuAttributeIter extends MenuAttributeIterMixin {}

	class MenuAttributeIter {
		public constructor(options?: Partial<MenuAttributeIterInitOptions>);
	}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link MenuItem} instead.
	 */
	interface IMenuItem {
		/**
		 * Queries the named #attribute on #menu_item.
		 * 
		 * If the attribute exists and matches the #GVariantType corresponding
		 * to #format_string then #format_string is used to deconstruct the
		 * value into the positional parameters and %TRUE is returned.
		 * 
		 * If the attribute does not exist, or it does exist but has the wrong
		 * type, then the positional parameters are ignored and %FALSE is
		 * returned.
		 * @param attribute the attribute name to query
		 * @param format_string a #GVariant format string
		 * @returns %TRUE if the named attribute was found with the expected
		 *     type
		 */
		get_attribute(attribute: string, format_string: string): boolean;
		/**
		 * Queries the named #attribute on #menu_item.
		 * 
		 * If #expected_type is specified and the attribute does not have this
		 * type, %NULL is returned.  %NULL is also returned if the attribute
		 * simply does not exist.
		 * @param attribute the attribute name to query
		 * @param expected_type the expected type of the attribute
		 * @returns the attribute value, or %NULL
		 */
		get_attribute_value(attribute: string, expected_type?: GLib.VariantType | null): GLib.Variant | null;
		/**
		 * Queries the named #link on #menu_item.
		 * @param link the link name to query
		 * @returns the link, or %NULL
		 */
		get_link(link: string): MenuModel | null;
		/**
		 * Sets or unsets the "action" and "target" attributes of #menu_item.
		 * 
		 * If #action is %NULL then both the "action" and "target" attributes
		 * are unset (and #format_string is ignored along with the positional
		 * parameters).
		 * 
		 * If #action is non-%NULL then the "action" attribute is set.
		 * #format_string is then inspected.  If it is non-%NULL then the proper
		 * position parameters are collected to create a #GVariant instance to
		 * use as the target value.  If it is %NULL then the positional
		 * parameters are ignored and the "target" attribute is unset.
		 * 
		 * See also {@link G.menu_item_set_action_and_target_value} for an equivalent
		 * call that directly accepts a #GVariant.  See
		 * g_menu_item_set_detailed_action() for a more convenient version that
		 * works with string-typed targets.
		 * 
		 * See also g_menu_item_set_action_and_target_value() for a
		 * description of the semantics of the action and target attributes.
		 * @param action the name of the action for this item
		 * @param format_string a GVariant format string
		 */
		set_action_and_target(action?: string | null, format_string?: string | null): void;
		/**
		 * Sets or unsets the "action" and "target" attributes of #menu_item.
		 * 
		 * If #action is %NULL then both the "action" and "target" attributes
		 * are unset (and #target_value is ignored).
		 * 
		 * If #action is non-%NULL then the "action" attribute is set.  The
		 * "target" attribute is then set to the value of #target_value if it is
		 * non-%NULL or unset otherwise.
		 * 
		 * Normal menu items (ie: not submenu, section or other custom item
		 * types) are expected to have the "action" attribute set to identify
		 * the action that they are associated with.  The state type of the
		 * action help to determine the disposition of the menu item.  See
		 * #GAction and #GActionGroup for an overview of actions.
		 * 
		 * In general, clicking on the menu item will result in activation of
		 * the named action with the "target" attribute given as the parameter
		 * to the action invocation.  If the "target" attribute is not set then
		 * the action is invoked with no parameter.
		 * 
		 * If the action has no state then the menu item is usually drawn as a
		 * plain menu item (ie: with no additional decoration).
		 * 
		 * If the action has a boolean state then the menu item is usually drawn
		 * as a toggle menu item (ie: with a checkmark or equivalent
		 * indication).  The item should be marked as 'toggled' or 'checked'
		 * when the boolean state is %TRUE.
		 * 
		 * If the action has a string state then the menu item is usually drawn
		 * as a radio menu item (ie: with a radio bullet or equivalent
		 * indication).  The item should be marked as 'selected' when the string
		 * state is equal to the value of the #target property.
		 * 
		 * See {@link G.menu_item_set_action_and_target} or
		 * g_menu_item_set_detailed_action() for two equivalent calls that are
		 * probably more convenient for most uses.
		 * @param action the name of the action for this item
		 * @param target_value a #GVariant to use as the action target
		 */
		set_action_and_target_value(action?: string | null, target_value?: GLib.Variant | null): void;
		/**
		 * Sets or unsets an attribute on #menu_item.
		 * 
		 * The attribute to set or unset is specified by #attribute. This
		 * can be one of the standard attribute names %G_MENU_ATTRIBUTE_LABEL,
		 * %G_MENU_ATTRIBUTE_ACTION, %G_MENU_ATTRIBUTE_TARGET, or a custom
		 * attribute name.
		 * Attribute names are restricted to lowercase characters, numbers
		 * and '-'. Furthermore, the names must begin with a lowercase character,
		 * must not end with a '-', and must not contain consecutive dashes.
		 * 
		 * If #format_string is non-%NULL then the proper position parameters
		 * are collected to create a #GVariant instance to use as the attribute
		 * value.  If it is %NULL then the positional parameterrs are ignored
		 * and the named attribute is unset.
		 * 
		 * See also {@link G.menu_item_set_attribute_value} for an equivalent call
		 * that directly accepts a #GVariant.
		 * @param attribute the attribute to set
		 * @param format_string a #GVariant format string, or %NULL
		 */
		set_attribute(attribute: string, format_string?: string | null): void;
		/**
		 * Sets or unsets an attribute on #menu_item.
		 * 
		 * The attribute to set or unset is specified by #attribute. This
		 * can be one of the standard attribute names %G_MENU_ATTRIBUTE_LABEL,
		 * %G_MENU_ATTRIBUTE_ACTION, %G_MENU_ATTRIBUTE_TARGET, or a custom
		 * attribute name.
		 * Attribute names are restricted to lowercase characters, numbers
		 * and '-'. Furthermore, the names must begin with a lowercase character,
		 * must not end with a '-', and must not contain consecutive dashes.
		 * 
		 * must consist only of lowercase
		 * ASCII characters, digits and '-'.
		 * 
		 * If #value is non-%NULL then it is used as the new value for the
		 * attribute.  If #value is %NULL then the attribute is unset. If
		 * the #value #GVariant is floating, it is consumed.
		 * 
		 * See also {@link G.menu_item_set_attribute} for a more convenient way to do
		 * the same.
		 * @param attribute the attribute to set
		 * @param value a #GVariant to use as the value, or %NULL
		 */
		set_attribute_value(attribute: string, value?: GLib.Variant | null): void;
		/**
		 * Sets the "action" and possibly the "target" attribute of #menu_item.
		 * 
		 * The format of #detailed_action is the same format parsed by
		 * {@link G.action_parse_detailed_name}.
		 * 
		 * See g_menu_item_set_action_and_target() or
		 * g_menu_item_set_action_and_target_value() for more flexible (but
		 * slightly less convenient) alternatives.
		 * 
		 * See also g_menu_item_set_action_and_target_value() for a description of
		 * the semantics of the action and target attributes.
		 * @param detailed_action the "detailed" action string
		 */
		set_detailed_action(detailed_action: string): void;
		/**
		 * Sets (or unsets) the icon on #menu_item.
		 * 
		 * This call is the same as calling {@link G.icon_serialize} and using the
		 * result as the value to g_menu_item_set_attribute_value() for
		 * %G_MENU_ATTRIBUTE_ICON.
		 * 
		 * This API is only intended for use with "noun" menu items; things like
		 * bookmarks or applications in an "Open With" menu.  Don't use it on
		 * menu items corresponding to verbs (eg: stock icons for 'Save' or
		 * 'Quit').
		 * 
		 * If #icon is %NULL then the icon is unset.
		 * @param icon a #GIcon, or %NULL
		 */
		set_icon(icon: Icon): void;
		/**
		 * Sets or unsets the "label" attribute of #menu_item.
		 * 
		 * If #label is non-%NULL it is used as the label for the menu item.  If
		 * it is %NULL then the label attribute is unset.
		 * @param label the label to set, or %NULL to unset
		 */
		set_label(label?: string | null): void;
		/**
		 * Creates a link from #menu_item to #model if non-%NULL, or unsets it.
		 * 
		 * Links are used to establish a relationship between a particular menu
		 * item and another menu.  For example, %G_MENU_LINK_SUBMENU is used to
		 * associate a submenu with a particular menu item, and %G_MENU_LINK_SECTION
		 * is used to create a section. Other types of link can be used, but there
		 * is no guarantee that clients will be able to make sense of them.
		 * Link types are restricted to lowercase characters, numbers
		 * and '-'. Furthermore, the names must begin with a lowercase character,
		 * must not end with a '-', and must not contain consecutive dashes.
		 * @param link type of link to establish or unset
		 * @param model the #GMenuModel to link to (or %NULL to unset)
		 */
		set_link(link: string, model?: MenuModel | null): void;
		/**
		 * Sets or unsets the "section" link of #menu_item to #section.
		 * 
		 * The effect of having one menu appear as a section of another is
		 * exactly as it sounds: the items from #section become a direct part of
		 * the menu that #menu_item is added to.  See {@link G.menu_item_new_section}
		 * for more information about what it means for a menu item to be a
		 * section.
		 * @param section a #GMenuModel, or %NULL
		 */
		set_section(section?: MenuModel | null): void;
		/**
		 * Sets or unsets the "submenu" link of #menu_item to #submenu.
		 * 
		 * If #submenu is non-%NULL, it is linked to.  If it is %NULL then the
		 * link is unset.
		 * 
		 * The effect of having one menu appear as a submenu of another is
		 * exactly as it sounds.
		 * @param submenu a #GMenuModel, or %NULL
		 */
		set_submenu(submenu?: MenuModel | null): void;
	}

	type MenuItemInitOptionsMixin = GObject.ObjectInitOptions
	export interface MenuItemInitOptions extends MenuItemInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link MenuItem} instead.
	 */
	type MenuItemMixin = IMenuItem & GObject.Object;

	/**
	 * #GMenuItem is an opaque structure type.  You must access it using the
	 * functions below.
	 */
	interface MenuItem extends MenuItemMixin {}

	class MenuItem {
		public constructor(options?: Partial<MenuItemInitOptions>);
		/**
		 * Creates a new #GMenuItem.
		 * 
		 * If #label is non-%NULL it is used to set the "label" attribute of the
		 * new item.
		 * 
		 * If #detailed_action is non-%NULL it is used to set the "action" and
		 * possibly the "target" attribute of the new item.  See
		 * {@link G.menu_item_set_detailed_action} for more information.
		 * @param label the section label, or %NULL
		 * @param detailed_action the detailed action string, or %NULL
		 * @returns a new #GMenuItem
		 */
		public static new(label?: string | null, detailed_action?: string | null): MenuItem;
		/**
		 * Creates a #GMenuItem as an exact copy of an existing menu item in a
		 * #GMenuModel.
		 * 
		 * #item_index must be valid (ie: be sure to call
		 * {@link G.menu_model_get_n_items} first).
		 * @param model a #GMenuModel
		 * @param item_index the index of an item in #model
		 * @returns a new #GMenuItem.
		 */
		public static new_from_model(model: MenuModel, item_index: number): MenuItem;
		/**
		 * Creates a new #GMenuItem representing a section.
		 * 
		 * This is a convenience API around {@link G.menu_item_new} and
		 * g_menu_item_set_section().
		 * 
		 * The effect of having one menu appear as a section of another is
		 * exactly as it sounds: the items from #section become a direct part of
		 * the menu that #menu_item is added to.
		 * 
		 * Visual separation is typically displayed between two non-empty
		 * sections.  If #label is non-%NULL then it will be encorporated into
		 * this visual indication.  This allows for labeled subsections of a
		 * menu.
		 * 
		 * As a simple example, consider a typical "Edit" menu from a simple
		 * program.  It probably contains an "Undo" and "Redo" item, followed by
		 * a separator, followed by "Cut", "Copy" and "Paste".
		 * 
		 * This would be accomplished by creating three #GMenu instances.  The
		 * first would be populated with the "Undo" and "Redo" items, and the
		 * second with the "Cut", "Copy" and "Paste" items.  The first and
		 * second menus would then be added as submenus of the third.  In XML
		 * format, this would look something like the following:
		 * |[
		 * <menu id='edit-menu'>
		 *   <section>
		 *     <item label='Undo'/>
		 *     <item label='Redo'/>
		 *   </section>
		 *   <section>
		 *     <item label='Cut'/>
		 *     <item label='Copy'/>
		 *     <item label='Paste'/>
		 *   </section>
		 * </menu>
		 * ]|
		 * 
		 * The following example is exactly equivalent.  It is more illustrative
		 * of the exact relationship between the menus and items (keeping in
		 * mind that the 'link' element defines a new menu that is linked to the
		 * containing one).  The style of the second example is more verbose and
		 * difficult to read (and therefore not recommended except for the
		 * purpose of understanding what is really going on).
		 * |[
		 * <menu id='edit-menu'>
		 *   <item>
		 *     <link name='section'>
		 *       <item label='Undo'/>
		 *       <item label='Redo'/>
		 *     </link>
		 *   </item>
		 *   <item>
		 *     <link name='section'>
		 *       <item label='Cut'/>
		 *       <item label='Copy'/>
		 *       <item label='Paste'/>
		 *     </link>
		 *   </item>
		 * </menu>
		 * ]|
		 * @param label the section label, or %NULL
		 * @param section a #GMenuModel with the items of the section
		 * @returns a new #GMenuItem
		 */
		public static new_section(label: string | null, section: MenuModel): MenuItem;
		/**
		 * Creates a new #GMenuItem representing a submenu.
		 * 
		 * This is a convenience API around {@link G.menu_item_new} and
		 * g_menu_item_set_submenu().
		 * @param label the section label, or %NULL
		 * @param submenu a #GMenuModel with the items of the submenu
		 * @returns a new #GMenuItem
		 */
		public static new_submenu(label: string | null, submenu: MenuModel): MenuItem;
	}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link MenuLinkIter} instead.
	 */
	interface IMenuLinkIter {
		/**
		 * Gets the name of the link at the current iterator position.
		 * 
		 * The iterator is not advanced.
		 * @returns the type of the link
		 */
		get_name(): string;
		/**
		 * This function combines {@link G.menu_link_iter_next} with
		 * g_menu_link_iter_get_name() and g_menu_link_iter_get_value().
		 * 
		 * First the iterator is advanced to the next (possibly first) link.
		 * If that fails, then %FALSE is returned and there are no other effects.
		 * 
		 * If successful, #out_link and #value are set to the name and #GMenuModel
		 * of the link that has just been advanced to.  At this point,
		 * g_menu_link_iter_get_name() and g_menu_link_iter_get_value() will return the
		 * same values again.
		 * 
		 * The value returned in #out_link remains valid for as long as the iterator
		 * remains at the current position.  The value returned in #value must
		 * be unreffed using g_object_unref() when it is no longer in use.
		 * @returns %TRUE on success, or %FALSE if there is no additional link
		 * 
		 * the name of the link
		 * 
		 * the linked #GMenuModel
		 */
		get_next(): [ boolean, string | null, MenuModel | null ];
		/**
		 * Gets the linked #GMenuModel at the current iterator position.
		 * 
		 * The iterator is not advanced.
		 * @returns the #GMenuModel that is linked to
		 */
		get_value(): MenuModel;
		/**
		 * Attempts to advance the iterator to the next (possibly first)
		 * link.
		 * 
		 * %TRUE is returned on success, or %FALSE if there are no more links.
		 * 
		 * You must call this function when you first acquire the iterator to
		 * advance it to the first link (and determine if the first link exists
		 * at all).
		 * @returns %TRUE on success, or %FALSE when there are no more links
		 */
		next(): boolean;
	}

	type MenuLinkIterInitOptionsMixin = GObject.ObjectInitOptions
	export interface MenuLinkIterInitOptions extends MenuLinkIterInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link MenuLinkIter} instead.
	 */
	type MenuLinkIterMixin = IMenuLinkIter & GObject.Object;

	/**
	 * #GMenuLinkIter is an opaque structure type.  You must access it using
	 * the functions below.
	 */
	interface MenuLinkIter extends MenuLinkIterMixin {}

	class MenuLinkIter {
		public constructor(options?: Partial<MenuLinkIterInitOptions>);
	}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link MenuModel} instead.
	 */
	interface IMenuModel {
		/**
		 * Queries item at position #item_index in #model for the attribute
		 * specified by #attribute.
		 * 
		 * If the attribute exists and matches the #GVariantType corresponding
		 * to #format_string then #format_string is used to deconstruct the
		 * value into the positional parameters and %TRUE is returned.
		 * 
		 * If the attribute does not exist, or it does exist but has the wrong
		 * type, then the positional parameters are ignored and %FALSE is
		 * returned.
		 * 
		 * This function is a mix of {@link G.menu_model_get_item_attribute_value} and
		 * g_variant_get(), followed by a g_variant_unref().  As such,
		 * #format_string must make a complete copy of the data (since the
		 * #GVariant may go away after the call to g_variant_unref()).  In
		 * particular, no '&' characters are allowed in #format_string.
		 * @param item_index the index of the item
		 * @param attribute the attribute to query
		 * @param format_string a #GVariant format string
		 * @returns %TRUE if the named attribute was found with the expected
		 *     type
		 */
		get_item_attribute(item_index: number, attribute: string, format_string: string): boolean;
		/**
		 * Queries the item at position #item_index in #model for the attribute
		 * specified by #attribute.
		 * 
		 * If #expected_type is non-%NULL then it specifies the expected type of
		 * the attribute.  If it is %NULL then any type will be accepted.
		 * 
		 * If the attribute exists and matches #expected_type (or if the
		 * expected type is unspecified) then the value is returned.
		 * 
		 * If the attribute does not exist, or does not match the expected type
		 * then %NULL is returned.
		 * @param item_index the index of the item
		 * @param attribute the attribute to query
		 * @param expected_type the expected type of the attribute, or
		 *     %NULL
		 * @returns the value of the attribute
		 */
		get_item_attribute_value(item_index: number, attribute: string, expected_type?: GLib.VariantType | null): GLib.Variant | null;
		/**
		 * Queries the item at position #item_index in #model for the link
		 * specified by #link.
		 * 
		 * If the link exists, the linked #GMenuModel is returned.  If the link
		 * does not exist, %NULL is returned.
		 * @param item_index the index of the item
		 * @param link the link to query
		 * @returns the linked #GMenuModel, or %NULL
		 */
		get_item_link(item_index: number, link: string): MenuModel | null;
		/**
		 * Query the number of items in #model.
		 * @returns the number of items
		 */
		get_n_items(): number;
		/**
		 * Queries if #model is mutable.
		 * 
		 * An immutable #GMenuModel will never emit the #GMenuModel::items-changed
		 * signal. Consumers of the model may make optimisations accordingly.
		 * @returns %TRUE if the model is mutable (ie: "items-changed" may be
		 *     emitted).
		 */
		is_mutable(): boolean;
		/**
		 * Requests emission of the #GMenuModel::items-changed signal on #model.
		 * 
		 * This function should never be called except by #GMenuModel
		 * subclasses.  Any other calls to this function will very likely lead
		 * to a violation of the interface of the model.
		 * 
		 * The implementation should update its internal representation of the
		 * menu before emitting the signal.  The implementation should further
		 * expect to receive queries about the new state of the menu (and
		 * particularly added menu items) while signal handlers are running.
		 * 
		 * The implementation must dispatch this call directly from a mainloop
		 * entry and not in response to calls -- particularly those from the
		 * #GMenuModel API.  Said another way: the menu must not change while
		 * user code is running without returning to the mainloop.
		 * @param position the position of the change
		 * @param removed the number of items removed
		 * @param added the number of items added
		 */
		items_changed(position: number, removed: number, added: number): void;
		/**
		 * Creates a #GMenuAttributeIter to iterate over the attributes of
		 * the item at position #item_index in #model.
		 * 
		 * You must free the iterator with {@link GObject.unref} when you are done.
		 * @param item_index the index of the item
		 * @returns a new #GMenuAttributeIter
		 */
		iterate_item_attributes(item_index: number): MenuAttributeIter;
		/**
		 * Creates a #GMenuLinkIter to iterate over the links of the item at
		 * position #item_index in #model.
		 * 
		 * You must free the iterator with {@link GObject.unref} when you are done.
		 * @param item_index the index of the item
		 * @returns a new #GMenuLinkIter
		 */
		iterate_item_links(item_index: number): MenuLinkIter;
		/**
		 * Emitted when a change has occurred to the menu.
		 * 
		 * The only changes that can occur to a menu is that items are removed
		 * or added.  Items may not change (except by being removed and added
		 * back in the same location).  This signal is capable of describing
		 * both of those changes (at the same time).
		 * 
		 * The signal means that starting at the index #position, #removed
		 * items were removed and #added items were added in their place.  If
		 * #removed is zero then only items were added.  If #added is zero
		 * then only items were removed.
		 * 
		 * As an example, if the menu contains items a, b, c, d (in that
		 * order) and the signal (2, 1, 3) occurs then the new composition of
		 * the menu will be a, b, _, _, _, d (with each _ representing some
		 * new item).
		 * 
		 * Signal handlers may query the model (particularly the added items)
		 * and expect to see the results of the modification that is being
		 * reported.  The signal is emitted after the modification.
		 * @param signal 
		 * @param callback Callback function
		 *  - owner: owner of the emitted event 
		 *  - position: the position of the change 
		 *  - removed: the number of items removed 
		 *  - added: the number of items added 
		 * 
		 * @returns Callback ID
		 */
		connect(signal: "items-changed", callback: (owner: this, position: number, removed: number, added: number) => void): number;

	}

	type MenuModelInitOptionsMixin = GObject.ObjectInitOptions
	export interface MenuModelInitOptions extends MenuModelInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link MenuModel} instead.
	 */
	type MenuModelMixin = IMenuModel & GObject.Object;

	/**
	 * #GMenuModel represents the contents of a menu -- an ordered list of
	 * menu items. The items are associated with actions, which can be
	 * activated through them. Items can be grouped in sections, and may
	 * have submenus associated with them. Both items and sections usually
	 * have some representation data, such as labels or icons. The type of
	 * the associated action (ie whether it is stateful, and what kind of
	 * state it has) can influence the representation of the item.
	 * 
	 * The conceptual model of menus in #GMenuModel is hierarchical:
	 * sections and submenus are again represented by #GMenuModels.
	 * Menus themselves do not define their own roles. Rather, the role
	 * of a particular #GMenuModel is defined by the item that references
	 * it (or, in the case of the 'root' menu, is defined by the context
	 * in which it is used).
	 * 
	 * As an example, consider the visible portions of this menu:
	 * 
	 * ## An example menu # {#menu-example}
	 * 
	 * ![](menu-example.png)
	 * 
	 * There are 8 "menus" visible in the screenshot: one menubar, two
	 * submenus and 5 sections:
	 * 
	 * - the toplevel menubar (containing 4 items)
	 * - the View submenu (containing 3 sections)
	 * - the first section of the View submenu (containing 2 items)
	 * - the second section of the View submenu (containing 1 item)
	 * - the final section of the View submenu (containing 1 item)
	 * - the Highlight Mode submenu (containing 2 sections)
	 * - the Sources section (containing 2 items)
	 * - the Markup section (containing 2 items)
	 * 
	 * The [example][menu-model] illustrates the conceptual connection between
	 * these 8 menus. Each large block in the figure represents a menu and the
	 * smaller blocks within the large block represent items in that menu. Some
	 * items contain references to other menus.
	 * 
	 * ## A menu example # {#menu-model}
	 * 
	 * ![](menu-model.png)
	 * 
	 * Notice that the separators visible in the [example][menu-example]
	 * appear nowhere in the [menu model][menu-model]. This is because
	 * separators are not explicitly represented in the menu model. Instead,
	 * a separator is inserted between any two non-empty sections of a menu.
	 * Section items can have labels just like any other item. In that case,
	 * a display system may show a section header instead of a separator.
	 * 
	 * The motivation for this abstract model of application controls is
	 * that modern user interfaces tend to make these controls available
	 * outside the application. Examples include global menus, jumplists,
	 * dash boards, etc. To support such uses, it is necessary to 'export'
	 * information about actions and their representation in menus, which
	 * is exactly what the [GActionGroup exporter][gio-GActionGroup-exporter]
	 * and the [GMenuModel exporter][gio-GMenuModel-exporter] do for
	 * #GActionGroup and #GMenuModel. The client-side counterparts to
	 * make use of the exported information are #GDBusActionGroup and
	 * #GDBusMenuModel.
	 * 
	 * The API of #GMenuModel is very generic, with iterators for the
	 * attributes and links of an item, see {@link G.menu_model_iterate_item_attributes}
	 * and g_menu_model_iterate_item_links(). The 'standard' attributes and
	 * link types have predefined names: %G_MENU_ATTRIBUTE_LABEL,
	 * %G_MENU_ATTRIBUTE_ACTION, %G_MENU_ATTRIBUTE_TARGET, %G_MENU_LINK_SECTION
	 * and %G_MENU_LINK_SUBMENU.
	 * 
	 * Items in a #GMenuModel represent active controls if they refer to
	 * an action that can get activated when the user interacts with the
	 * menu item. The reference to the action is encoded by the string id
	 * in the %G_MENU_ATTRIBUTE_ACTION attribute. An action id uniquely
	 * identifies an action in an action group. Which action group(s) provide
	 * actions depends on the context in which the menu model is used.
	 * E.g. when the model is exported as the application menu of a
	 * #GtkApplication, actions can be application-wide or window-specific
	 * (and thus come from two different action groups). By convention, the
	 * application-wide actions have names that start with "app.", while the
	 * names of window-specific actions start with "win.".
	 * 
	 * While a wide variety of stateful actions is possible, the following
	 * is the minimum that is expected to be supported by all users of exported
	 * menu information:
	 * - an action with no parameter type and no state
	 * - an action with no parameter type and boolean state
	 * - an action with string parameter type and string state
	 * 
	 * ## Stateless
	 * 
	 * A stateless action typically corresponds to an ordinary menu item.
	 * 
	 * Selecting such a menu item will activate the action (with no parameter).
	 * 
	 * ## Boolean State
	 * 
	 * An action with a boolean state will most typically be used with a "toggle"
	 * or "switch" menu item. The state can be set directly, but activating the
	 * action (with no parameter) results in the state being toggled.
	 * 
	 * Selecting a toggle menu item will activate the action. The menu item should
	 * be rendered as "checked" when the state is true.
	 * 
	 * ## String Parameter and State
	 * 
	 * Actions with string parameters and state will most typically be used to
	 * represent an enumerated choice over the items available for a group of
	 * radio menu items. Activating the action with a string parameter is
	 * equivalent to setting that parameter as the state.
	 * 
	 * Radio menu items, in addition to being associated with the action, will
	 * have a target value. Selecting that menu item will result in activation
	 * of the action with the target value as the parameter. The menu item should
	 * be rendered as "selected" when the state of the action is equal to the
	 * target value of the menu item.
	 */
	interface MenuModel extends MenuModelMixin {}

	class MenuModel {
		public constructor(options?: Partial<MenuModelInitOptions>);
	}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link MountOperation} instead.
	 */
	interface IMountOperation {
		/**
		 * Whether to use an anonymous user when authenticating.
		 */
		anonymous: boolean;
		/**
		 * The index of the user's choice when a question is asked during the
		 * mount operation. See the #GMountOperation::ask-question signal.
		 */
		choice: number;
		/**
		 * The domain to use for the mount operation.
		 */
		domain: string;
		/**
		 * Whether the device to be unlocked is a TCRYPT hidden volume.
		 * See [the VeraCrypt documentation](https://www.veracrypt.fr/en/Hidden%20Volume.html).
		 */
		is_tcrypt_hidden_volume: boolean;
		/**
		 * Whether the device to be unlocked is a TCRYPT system volume.
		 * In this context, a system volume is a volume with a bootloader
		 * and operating system installed. This is only supported for Windows
		 * operating systems. For further documentation, see
		 * [the VeraCrypt documentation](https://www.veracrypt.fr/en/System%20Encryption.html).
		 */
		is_tcrypt_system_volume: boolean;
		/**
		 * The password that is used for authentication when carrying out
		 * the mount operation.
		 */
		password: string;
		/**
		 * Determines if and how the password information should be saved.
		 */
		password_save: PasswordSave;
		/**
		 * The VeraCrypt PIM value, when unlocking a VeraCrypt volume. See
		 * [the VeraCrypt documentation](https://www.veracrypt.fr/en/Personal%20Iterations%20Multiplier%20(PIM).html).
		 */
		pim: number;
		/**
		 * The user name that is used for authentication when carrying out
		 * the mount operation.
		 */
		username: string;
		/**
		 * Check to see whether the mount operation is being used
		 * for an anonymous user.
		 * @returns %TRUE if mount operation is anonymous.
		 */
		get_anonymous(): boolean;
		/**
		 * Gets a choice from the mount operation.
		 * @returns an integer containing an index of the user's choice from
		 * the choice's list, or `0`.
		 */
		get_choice(): number;
		/**
		 * Gets the domain of the mount operation.
		 * @returns a string set to the domain.
		 */
		get_domain(): string | null;
		/**
		 * Check to see whether the mount operation is being used
		 * for a TCRYPT hidden volume.
		 * @returns %TRUE if mount operation is for hidden volume.
		 */
		get_is_tcrypt_hidden_volume(): boolean;
		/**
		 * Check to see whether the mount operation is being used
		 * for a TCRYPT system volume.
		 * @returns %TRUE if mount operation is for system volume.
		 */
		get_is_tcrypt_system_volume(): boolean;
		/**
		 * Gets a password from the mount operation.
		 * @returns a string containing the password within #op.
		 */
		get_password(): string | null;
		/**
		 * Gets the state of saving passwords for the mount operation.
		 * @returns a #GPasswordSave flag.
		 */
		get_password_save(): PasswordSave;
		/**
		 * Gets a PIM from the mount operation.
		 * @returns The VeraCrypt PIM within #op.
		 */
		get_pim(): number;
		/**
		 * Get the user name from the mount operation.
		 * @returns a string containing the user name.
		 */
		get_username(): string | null;
		/**
		 * Emits the #GMountOperation::reply signal.
		 * @param result a #GMountOperationResult
		 */
		reply(result: MountOperationResult): void;
		/**
		 * Sets the mount operation to use an anonymous user if #anonymous is %TRUE.
		 * @param anonymous boolean value.
		 */
		set_anonymous(anonymous: boolean): void;
		/**
		 * Sets a default choice for the mount operation.
		 * @param choice an integer.
		 */
		set_choice(choice: number): void;
		/**
		 * Sets the mount operation's domain.
		 * @param domain the domain to set.
		 */
		set_domain(domain?: string | null): void;
		/**
		 * Sets the mount operation to use a hidden volume if #hidden_volume is %TRUE.
		 * @param hidden_volume boolean value.
		 */
		set_is_tcrypt_hidden_volume(hidden_volume: boolean): void;
		/**
		 * Sets the mount operation to use a system volume if #system_volume is %TRUE.
		 * @param system_volume boolean value.
		 */
		set_is_tcrypt_system_volume(system_volume: boolean): void;
		/**
		 * Sets the mount operation's password to #password.
		 * @param password password to set.
		 */
		set_password(password?: string | null): void;
		/**
		 * Sets the state of saving passwords for the mount operation.
		 * @param save a set of #GPasswordSave flags.
		 */
		set_password_save(save: PasswordSave): void;
		/**
		 * Sets the mount operation's PIM to #pim.
		 * @param pim an unsigned integer.
		 */
		set_pim(pim: number): void;
		/**
		 * Sets the user name within #op to #username.
		 * @param username input username.
		 */
		set_username(username?: string | null): void;
		/**
		 * Emitted by the backend when e.g. a device becomes unavailable
		 * while a mount operation is in progress.
		 * 
		 * Implementations of GMountOperation should handle this signal
		 * by dismissing open password dialogs.
		 * @param signal 
		 * @param callback Callback function
		 *  - owner: owner of the emitted event 
		 * 
		 * @returns Callback ID
		 */
		connect(signal: "aborted", callback: (owner: this) => void): number;
		/**
		 * Emitted when a mount operation asks the user for a password.
		 * 
		 * If the message contains a line break, the first line should be
		 * presented as a heading. For example, it may be used as the
		 * primary text in a #GtkMessageDialog.
		 * @param signal 
		 * @param callback Callback function
		 *  - owner: owner of the emitted event 
		 *  - message: string containing a message to display to the user. 
		 *  - default_user: string containing the default user name. 
		 *  - default_domain: string containing the default domain. 
		 *  - flags: a set of #GAskPasswordFlags. 
		 * 
		 * @returns Callback ID
		 */
		connect(signal: "ask-password", callback: (owner: this, message: string, default_user: string, default_domain: string, flags: AskPasswordFlags) => void): number;
		/**
		 * Emitted when asking the user a question and gives a list of
		 * choices for the user to choose from.
		 * 
		 * If the message contains a line break, the first line should be
		 * presented as a heading. For example, it may be used as the
		 * primary text in a #GtkMessageDialog.
		 * @param signal 
		 * @param callback Callback function
		 *  - owner: owner of the emitted event 
		 *  - message: string containing a message to display to the user. 
		 *  - choices: an array of strings for each possible choice. 
		 * 
		 * @returns Callback ID
		 */
		connect(signal: "ask-question", callback: (owner: this, message: string, choices: string[]) => void): number;
		/**
		 * Emitted when the user has replied to the mount operation.
		 * @param signal 
		 * @param callback Callback function
		 *  - owner: owner of the emitted event 
		 *  - result: a #GMountOperationResult indicating how the request was handled 
		 * 
		 * @returns Callback ID
		 */
		connect(signal: "reply", callback: (owner: this, result: MountOperationResult) => void): number;
		/**
		 * Emitted when one or more processes are blocking an operation
		 * e.g. unmounting/ejecting a #GMount or stopping a #GDrive.
		 * 
		 * Note that this signal may be emitted several times to update the
		 * list of blocking processes as processes close files. The
		 * application should only respond with {@link G.mount_operation_reply} to
		 * the latest signal (setting #GMountOperation:choice to the choice
		 * the user made).
		 * 
		 * If the message contains a line break, the first line should be
		 * presented as a heading. For example, it may be used as the
		 * primary text in a #GtkMessageDialog.
		 * @param signal 
		 * @param callback Callback function
		 *  - owner: owner of the emitted event 
		 *  - message: string containing a message to display to the user. 
		 *  - processes: an array of #GPid for processes
		 *   blocking the operation. 
		 *  - choices: an array of strings for each possible choice. 
		 * 
		 * @returns Callback ID
		 */
		connect(signal: "show-processes", callback: (owner: this, message: string, processes: GLib.Pid[], choices: string[]) => void): number;
		/**
		 * Emitted when an unmount operation has been busy for more than some time
		 * (typically 1.5 seconds).
		 * 
		 * When unmounting or ejecting a volume, the kernel might need to flush
		 * pending data in its buffers to the volume stable storage, and this operation
		 * can take a considerable amount of time. This signal may be emitted several
		 * times as long as the unmount operation is outstanding, and then one
		 * last time when the operation is completed, with #bytes_left set to zero.
		 * 
		 * Implementations of GMountOperation should handle this signal by
		 * showing an UI notification, and then dismiss it, or show another notification
		 * of completion, when #bytes_left reaches zero.
		 * 
		 * If the message contains a line break, the first line should be
		 * presented as a heading. For example, it may be used as the
		 * primary text in a #GtkMessageDialog.
		 * @param signal 
		 * @param callback Callback function
		 *  - owner: owner of the emitted event 
		 *  - message: string containing a message to display to the user 
		 *  - time_left: the estimated time left before the operation completes,
		 *     in microseconds, or -1 
		 *  - bytes_left: the amount of bytes to be written before the operation
		 *     completes (or -1 if such amount is not known), or zero if the operation
		 *     is completed 
		 * 
		 * @returns Callback ID
		 */
		connect(signal: "show-unmount-progress", callback: (owner: this, message: string, time_left: number, bytes_left: number) => void): number;

		connect(signal: "notify::anonymous", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::choice", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::domain", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::is-tcrypt-hidden-volume", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::is-tcrypt-system-volume", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::password", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::password-save", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::pim", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::username", callback: (owner: this, ...args: any) => void): number;

	}

	type MountOperationInitOptionsMixin = GObject.ObjectInitOptions & 
	Pick<IMountOperation,
		"anonymous" |
		"choice" |
		"domain" |
		"is_tcrypt_hidden_volume" |
		"is_tcrypt_system_volume" |
		"password" |
		"password_save" |
		"pim" |
		"username">;

	export interface MountOperationInitOptions extends MountOperationInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link MountOperation} instead.
	 */
	type MountOperationMixin = IMountOperation & GObject.Object;

	/**
	 * #GMountOperation provides a mechanism for interacting with the user.
	 * It can be used for authenticating mountable operations, such as loop
	 * mounting files, hard drive partitions or server locations. It can
	 * also be used to ask the user questions or show a list of applications
	 * preventing unmount or eject operations from completing.
	 * 
	 * Note that #GMountOperation is used for more than just #GMount
	 * objects – for example it is also used in {@link G.drive_start} and
	 * g_drive_stop().
	 * 
	 * Users should instantiate a subclass of this that implements all the
	 * various callbacks to show the required dialogs, such as
	 * #GtkMountOperation. If no user interaction is desired (for example
	 * when automounting filesystems at login time), usually %NULL can be
	 * passed, see each method taking a #GMountOperation for details.
	 * 
	 * The term ‘TCRYPT’ is used to mean ‘compatible with TrueCrypt and VeraCrypt’.
	 * [TrueCrypt](https://en.wikipedia.org/wiki/TrueCrypt) is a discontinued system for
	 * encrypting file containers, partitions or whole disks, typically used with Windows.
	 * [VeraCrypt](https://www.veracrypt.fr/) is a maintained fork of TrueCrypt with various
	 * improvements and auditing fixes.
	 */
	interface MountOperation extends MountOperationMixin {}

	class MountOperation {
		public constructor(options?: Partial<MountOperationInitOptions>);
		/**
		 * Creates a new mount operation.
		 * @returns a #GMountOperation.
		 */
		public static new(): MountOperation;
	}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link NativeSocketAddress} instead.
	 */
	interface INativeSocketAddress {

	}

	type NativeSocketAddressInitOptionsMixin = SocketAddressInitOptions & SocketConnectableInitOptions
	export interface NativeSocketAddressInitOptions extends NativeSocketAddressInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link NativeSocketAddress} instead.
	 */
	type NativeSocketAddressMixin = INativeSocketAddress & SocketAddress & SocketConnectable;

	/**
	 * A socket address of some unknown native type.
	 */
	interface NativeSocketAddress extends NativeSocketAddressMixin {}

	class NativeSocketAddress {
		public constructor(options?: Partial<NativeSocketAddressInitOptions>);
		/**
		 * Creates a new #GNativeSocketAddress for #native and #len.
		 * @param _native a native address object
		 * @param len the length of #native, in bytes
		 * @returns a new #GNativeSocketAddress
		 */
		public static new(_native: any | null, len: number): SocketAddress;
	}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link NativeVolumeMonitor} instead.
	 */
	interface INativeVolumeMonitor {

	}

	type NativeVolumeMonitorInitOptionsMixin = VolumeMonitorInitOptions
	export interface NativeVolumeMonitorInitOptions extends NativeVolumeMonitorInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link NativeVolumeMonitor} instead.
	 */
	type NativeVolumeMonitorMixin = INativeVolumeMonitor & VolumeMonitor;

	interface NativeVolumeMonitor extends NativeVolumeMonitorMixin {}

	class NativeVolumeMonitor {
		public constructor(options?: Partial<NativeVolumeMonitorInitOptions>);
	}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link NetworkAddress} instead.
	 */
	interface INetworkAddress {
		hostname: string;
		port: number;
		scheme: string;
		/**
		 * Gets #addr's hostname. This might be either UTF-8 or ASCII-encoded,
		 * depending on what #addr was created with.
		 * @returns #addr's hostname
		 */
		get_hostname(): string;
		/**
		 * Gets #addr's port number
		 * @returns #addr's port (which may be 0)
		 */
		get_port(): number;
		/**
		 * Gets #addr's scheme
		 * @returns #addr's scheme (%NULL if not built from URI)
		 */
		get_scheme(): string | null;
		connect(signal: "notify::hostname", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::port", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::scheme", callback: (owner: this, ...args: any) => void): number;

	}

	type NetworkAddressInitOptionsMixin = GObject.ObjectInitOptions & SocketConnectableInitOptions & 
	Pick<INetworkAddress,
		"hostname" |
		"port" |
		"scheme">;

	export interface NetworkAddressInitOptions extends NetworkAddressInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link NetworkAddress} instead.
	 */
	type NetworkAddressMixin = INetworkAddress & GObject.Object & SocketConnectable;

	/**
	 * #GNetworkAddress provides an easy way to resolve a hostname and
	 * then attempt to connect to that host, handling the possibility of
	 * multiple IP addresses and multiple address families.
	 * 
	 * The enumeration results of resolved addresses *may* be cached as long
	 * as this object is kept alive which may have unexpected results if
	 * alive for too long.
	 * 
	 * See #GSocketConnectable for an example of using the connectable
	 * interface.
	 */
	interface NetworkAddress extends NetworkAddressMixin {}

	class NetworkAddress {
		public constructor(options?: Partial<NetworkAddressInitOptions>);
		/**
		 * Creates a new #GSocketConnectable for connecting to the given
		 * #hostname and #port.
		 * 
		 * Note that depending on the configuration of the machine, a
		 * #hostname of `localhost` may refer to the IPv4 loopback address
		 * only, or to both IPv4 and IPv6; use
		 * {@link G.network_address_new_loopback} to create a #GNetworkAddress that
		 * is guaranteed to resolve to both addresses.
		 * @param hostname the hostname
		 * @param port the port
		 * @returns the new #GNetworkAddress
		 */
		public static new(hostname: string, port: number): NetworkAddress;
		/**
		 * Creates a new #GSocketConnectable for connecting to the local host
		 * over a loopback connection to the given #port. This is intended for
		 * use in connecting to local services which may be running on IPv4 or
		 * IPv6.
		 * 
		 * The connectable will return IPv4 and IPv6 loopback addresses,
		 * regardless of how the host resolves `localhost`. By contrast,
		 * {@link G.network_address_new} will often only return an IPv4 address when
		 * resolving `localhost`, and an IPv6 address for `localhost6`.
		 * 
		 * g_network_address_get_hostname() will always return `localhost` for
		 * a #GNetworkAddress created with this constructor.
		 * @param port the port
		 * @returns the new #GNetworkAddress
		 */
		public static new_loopback(port: number): NetworkAddress;
		/**
		 * Creates a new #GSocketConnectable for connecting to the given
		 * #hostname and #port. May fail and return %NULL in case
		 * parsing #host_and_port fails.
		 * 
		 * #host_and_port may be in any of a number of recognised formats; an IPv6
		 * address, an IPv4 address, or a domain name (in which case a DNS
		 * lookup is performed). Quoting with [] is supported for all address
		 * types. A port override may be specified in the usual way with a
		 * colon.
		 * 
		 * If no port is specified in #host_and_port then #default_port will be
		 * used as the port number to connect to.
		 * 
		 * In general, #host_and_port is expected to be provided by the user
		 * (allowing them to give the hostname, and a port override if necessary)
		 * and #default_port is expected to be provided by the application.
		 * 
		 * (The port component of #host_and_port can also be specified as a
		 * service name rather than as a numeric port, but this functionality
		 * is deprecated, because it depends on the contents of /etc/services,
		 * which is generally quite sparse on platforms other than Linux.)
		 * @param host_and_port the hostname and optionally a port
		 * @param default_port the default port if not in #host_and_port
		 * @returns the new
		 *   #GNetworkAddress, or %NULL on error
		 */
		public static parse(host_and_port: string, default_port: number): NetworkAddress;
		/**
		 * Creates a new #GSocketConnectable for connecting to the given
		 * #uri. May fail and return %NULL in case parsing #uri fails.
		 * 
		 * Using this rather than {@link G.network_address_new} or
		 * g_network_address_parse() allows #GSocketClient to determine
		 * when to use application-specific proxy protocols.
		 * @param uri the hostname and optionally a port
		 * @param default_port The default port if none is found in the URI
		 * @returns the new
		 *   #GNetworkAddress, or %NULL on error
		 */
		public static parse_uri(uri: string, default_port: number): NetworkAddress;
	}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link NetworkService} instead.
	 */
	interface INetworkService {
		domain: string;
		protocol: string;
		scheme: string;
		service: string;
		/**
		 * Gets the domain that #srv serves. This might be either UTF-8 or
		 * ASCII-encoded, depending on what #srv was created with.
		 * @returns #srv's domain name
		 */
		get_domain(): string;
		/**
		 * Gets #srv's protocol name (eg, "tcp").
		 * @returns #srv's protocol name
		 */
		get_protocol(): string;
		/**
		 * Gets the URI scheme used to resolve proxies. By default, the service name
		 * is used as scheme.
		 * @returns #srv's scheme name
		 */
		get_scheme(): string;
		/**
		 * Gets #srv's service name (eg, "ldap").
		 * @returns #srv's service name
		 */
		get_service(): string;
		/**
		 * Set's the URI scheme used to resolve proxies. By default, the service name
		 * is used as scheme.
		 * @param scheme a URI scheme
		 */
		set_scheme(scheme: string): void;
		connect(signal: "notify::domain", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::protocol", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::scheme", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::service", callback: (owner: this, ...args: any) => void): number;

	}

	type NetworkServiceInitOptionsMixin = GObject.ObjectInitOptions & SocketConnectableInitOptions & 
	Pick<INetworkService,
		"domain" |
		"protocol" |
		"scheme" |
		"service">;

	export interface NetworkServiceInitOptions extends NetworkServiceInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link NetworkService} instead.
	 */
	type NetworkServiceMixin = INetworkService & GObject.Object & SocketConnectable;

	/**
	 * Like #GNetworkAddress does with hostnames, #GNetworkService
	 * provides an easy way to resolve a SRV record, and then attempt to
	 * connect to one of the hosts that implements that service, handling
	 * service priority/weighting, multiple IP addresses, and multiple
	 * address families.
	 * 
	 * See #GSrvTarget for more information about SRV records, and see
	 * #GSocketConnectable for an example of using the connectable
	 * interface.
	 */
	interface NetworkService extends NetworkServiceMixin {}

	class NetworkService {
		public constructor(options?: Partial<NetworkServiceInitOptions>);
		/**
		 * Creates a new #GNetworkService representing the given #service,
		 * #protocol, and #domain. This will initially be unresolved; use the
		 * #GSocketConnectable interface to resolve it.
		 * @param service the service type to look up (eg, "ldap")
		 * @param protocol the networking protocol to use for #service (eg, "tcp")
		 * @param domain the DNS domain to look up the service in
		 * @returns a new #GNetworkService
		 */
		public static new(service: string, protocol: string, domain: string): NetworkService;
	}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link Notification} instead.
	 */
	interface INotification {
		/**
		 * Adds a button to #notification that activates the action in
		 * #detailed_action when clicked. That action must be an
		 * application-wide action (starting with "app."). If #detailed_action
		 * contains a target, the action will be activated with that target as
		 * its parameter.
		 * 
		 * See {@link G.action_parse_detailed_name} for a description of the format
		 * for #detailed_action.
		 * @param label label of the button
		 * @param detailed_action a detailed action name
		 */
		add_button(label: string, detailed_action: string): void;
		/**
		 * Adds a button to #notification that activates #action when clicked.
		 * #action must be an application-wide action (it must start with "app.").
		 * 
		 * If #target is non-%NULL, #action will be activated with #target as
		 * its parameter.
		 * @param label label of the button
		 * @param action an action name
		 * @param target a #GVariant to use as #action's parameter, or %NULL
		 */
		add_button_with_target(label: string, action: string, target?: GLib.Variant | null): void;
		/**
		 * Sets the body of #notification to #body.
		 * @param body the new body for #notification, or %NULL
		 */
		set_body(body?: string | null): void;
		/**
		 * Sets the type of #notification to #category. Categories have a main
		 * type like `email`, `im` or `device` and can have a detail separated
		 * by a `.`, e.g. `im.received` or `email.arrived`. Setting the category
		 * helps the notification server to select proper feedback to the user.
		 * 
		 * Standard categories are [listed in the specification](https://specifications.freedesktop.org/notification-spec/latest/ar01s06.html).
		 * @param category the category for #notification, or %NULL for no category
		 */
		set_category(category?: string | null): void;
		/**
		 * Sets the default action of #notification to #detailed_action. This
		 * action is activated when the notification is clicked on.
		 * 
		 * The action in #detailed_action must be an application-wide action (it
		 * must start with "app."). If #detailed_action contains a target, the
		 * given action will be activated with that target as its parameter.
		 * See {@link G.action_parse_detailed_name} for a description of the format
		 * for #detailed_action.
		 * 
		 * When no default action is set, the application that the notification
		 * was sent on is activated.
		 * @param detailed_action a detailed action name
		 */
		set_default_action(detailed_action: string): void;
		/**
		 * Sets the default action of #notification to #action. This action is
		 * activated when the notification is clicked on. It must be an
		 * application-wide action (start with "app.").
		 * 
		 * If #target is non-%NULL, #action will be activated with #target as
		 * its parameter.
		 * 
		 * When no default action is set, the application that the notification
		 * was sent on is activated.
		 * @param action an action name
		 * @param target a #GVariant to use as #action's parameter, or %NULL
		 */
		set_default_action_and_target(action: string, target?: GLib.Variant | null): void;
		/**
		 * Sets the icon of #notification to #icon.
		 * @param icon the icon to be shown in #notification, as a #GIcon
		 */
		set_icon(icon: Icon): void;
		/**
		 * Sets the priority of #notification to #priority. See
		 * #GNotificationPriority for possible values.
		 * @param priority a #GNotificationPriority
		 */
		set_priority(priority: NotificationPriority): void;
		/**
		 * Sets the title of #notification to #title.
		 * @param title the new title for #notification
		 */
		set_title(title: string): void;
		/**
		 * @deprecated
		 * Since 2.42, this has been deprecated in favour of
		 *    {@link G.notification_set_priority}.
		 * 
		 * Deprecated in favor of {@link G.notification_set_priority}.
		 * @param urgent %TRUE if #notification is urgent
		 */
		set_urgent(urgent: boolean): void;
	}

	type NotificationInitOptionsMixin = GObject.ObjectInitOptions
	export interface NotificationInitOptions extends NotificationInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link Notification} instead.
	 */
	type NotificationMixin = INotification & GObject.Object;

	/**
	 * #GNotification is a mechanism for creating a notification to be shown
	 * to the user -- typically as a pop-up notification presented by the
	 * desktop environment shell.
	 * 
	 * The key difference between #GNotification and other similar APIs is
	 * that, if supported by the desktop environment, notifications sent
	 * with #GNotification will persist after the application has exited,
	 * and even across system reboots.
	 * 
	 * Since the user may click on a notification while the application is
	 * not running, applications using #GNotification should be able to be
	 * started as a D-Bus service, using #GApplication.
	 * 
	 * In order for #GNotification to work, the application must have installed
	 * a `.desktop` file. For example:
	 * |[
	 *  [Desktop Entry]
	 *   Name=Test Application
	 *   Comment=Description of what Test Application does
	 *   Exec=gnome-test-application
	 *   Icon=org.gnome.TestApplication
	 *   Terminal=false
	 *   Type=Application
	 *   Categories=GNOME;GTK;TestApplication Category;
	 *   StartupNotify=true
	 *   DBusActivatable=true
	 *   X-GNOME-UsesNotifications=true
	 * ]|
	 * 
	 * The `X-GNOME-UsesNotifications` key indicates to GNOME Control Center
	 * that this application uses notifications, so it can be listed in the
	 * Control Center’s ‘Notifications’ panel.
	 * 
	 * The `.desktop` file must be named as `org.gnome.TestApplication.desktop`,
	 * where `org.gnome.TestApplication` is the ID passed to {@link G.application_new}.
	 * 
	 * User interaction with a notification (either the default action, or
	 * buttons) must be associated with actions on the application (ie:
	 * "app." actions).  It is not possible to route user interaction
	 * through the notification itself, because the object will not exist if
	 * the application is autostarted as a result of a notification being
	 * clicked.
	 * 
	 * A notification can be sent with g_application_send_notification().
	 */
	interface Notification extends NotificationMixin {}

	class Notification {
		public constructor(options?: Partial<NotificationInitOptions>);
		/**
		 * Creates a new #GNotification with #title as its title.
		 * 
		 * After populating #notification with more details, it can be sent to
		 * the desktop shell with {@link G.application_send_notification}. Changing
		 * any properties after this call will not have any effect until
		 * resending #notification.
		 * @param title the title of the notification
		 * @returns a new #GNotification instance
		 */
		public static new(title: string): Notification;
	}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link OutputStream} instead.
	 */
	interface IOutputStream {
		/**
		 * Clears the pending flag on #stream.
		 */
		clear_pending(): void;
		/**
		 * Closes the stream, releasing resources related to it.
		 * 
		 * Once the stream is closed, all other operations will return %G_IO_ERROR_CLOSED.
		 * Closing a stream multiple times will not return an error.
		 * 
		 * Closing a stream will automatically flush any outstanding buffers in the
		 * stream.
		 * 
		 * Streams will be automatically closed when the last reference
		 * is dropped, but you might want to call this function to make sure
		 * resources are released as early as possible.
		 * 
		 * Some streams might keep the backing store of the stream (e.g. a file descriptor)
		 * open after the stream is closed. See the documentation for the individual
		 * stream for details.
		 * 
		 * On failure the first error that happened will be reported, but the close
		 * operation will finish as much as possible. A stream that failed to
		 * close will still return %G_IO_ERROR_CLOSED for all operations. Still, it
		 * is important to check and report the error to the user, otherwise
		 * there might be a loss of data as all data might not be written.
		 * 
		 * If #cancellable is not %NULL, then the operation can be cancelled by
		 * triggering the cancellable object from another thread. If the operation
		 * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
		 * Cancelling a close will still leave the stream closed, but there some streams
		 * can use a faster close that doesn't block to e.g. check errors. On
		 * cancellation (as with any error) there is no guarantee that all written
		 * data will reach the target.
		 * @param cancellable optional cancellable object
		 * @returns %TRUE on success, %FALSE on failure
		 */
		close(cancellable?: Cancellable | null): boolean;
		/**
		 * Requests an asynchronous close of the stream, releasing resources
		 * related to it. When the operation is finished #callback will be
		 * called. You can then call {@link G.output_stream_close_finish} to get
		 * the result of the operation.
		 * 
		 * For behaviour details see g_output_stream_close().
		 * 
		 * The asynchronous methods have a default fallback that uses threads
		 * to implement asynchronicity, so they are optional for inheriting
		 * classes. However, if you override one you must override all.
		 * @param io_priority the io priority of the request.
		 * @param cancellable optional cancellable object
		 * @param callback callback to call when the request is satisfied
		 */
		close_async(io_priority: number | null, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;
		/**
		 * Closes an output stream.
		 * @param result a #GAsyncResult.
		 * @returns %TRUE if stream was successfully closed, %FALSE otherwise.
		 */
		close_finish(result: AsyncResult): boolean;
		/**
		 * Forces a write of all user-space buffered data for the given
		 * #stream. Will block during the operation. Closing the stream will
		 * implicitly cause a flush.
		 * 
		 * This function is optional for inherited classes.
		 * 
		 * If #cancellable is not %NULL, then the operation can be cancelled by
		 * triggering the cancellable object from another thread. If the operation
		 * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
		 * @param cancellable optional cancellable object
		 * @returns %TRUE on success, %FALSE on error
		 */
		flush(cancellable?: Cancellable | null): boolean;
		/**
		 * Forces an asynchronous write of all user-space buffered data for
		 * the given #stream.
		 * For behaviour details see {@link G.output_stream_flush}.
		 * 
		 * When the operation is finished #callback will be
		 * called. You can then call g_output_stream_flush_finish() to get the
		 * result of the operation.
		 * @param io_priority the io priority of the request.
		 * @param cancellable optional #GCancellable object, %NULL to ignore.
		 * @param callback a #GAsyncReadyCallback to call when the request is satisfied
		 */
		flush_async(io_priority: number, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;
		/**
		 * Finishes flushing an output stream.
		 * @param result a GAsyncResult.
		 * @returns %TRUE if flush operation succeeded, %FALSE otherwise.
		 */
		flush_finish(result: AsyncResult): boolean;
		/**
		 * Checks if an output stream has pending actions.
		 * @returns %TRUE if #stream has pending actions.
		 */
		has_pending(): boolean;
		/**
		 * Checks if an output stream has already been closed.
		 * @returns %TRUE if #stream is closed. %FALSE otherwise.
		 */
		is_closed(): boolean;
		/**
		 * Checks if an output stream is being closed. This can be
		 * used inside e.g. a flush implementation to see if the
		 * flush (or other i/o operation) is called from within
		 * the closing operation.
		 * @returns %TRUE if #stream is being closed. %FALSE otherwise.
		 */
		is_closing(): boolean;
		/**
		 * This is a utility function around {@link G.output_stream_write_all}. It
		 * uses g_strdup_vprintf() to turn #format and #... into a string that
		 * is then written to #stream.
		 * 
		 * See the documentation of g_output_stream_write_all() about the
		 * behavior of the actual write operation.
		 * 
		 * Note that partial writes cannot be properly checked with this
		 * function due to the variable length of the written string, if you
		 * need precise control over partial write failures, you need to
		 * create you own printf()-like wrapper around g_output_stream_write()
		 * or g_output_stream_write_all().
		 * @param cancellable optional #GCancellable object, %NULL to ignore.
		 * @param error location to store the error occurring, or %NULL to ignore
		 * @param format the format string. See the printf() documentation
		 * @returns %TRUE on success, %FALSE if there was an error
		 * 
		 * location to store the number of bytes that was
		 *     written to the stream
		 */
		printf(cancellable: Cancellable | null, error: GLib.Error, format: string): [ boolean, number | null ];
		/**
		 * Sets #stream to have actions pending. If the pending flag is
		 * already set or #stream is closed, it will return %FALSE and set
		 * #error.
		 * @returns %TRUE if pending was previously unset and is now set.
		 */
		set_pending(): boolean;
		/**
		 * Splices an input stream into an output stream.
		 * @param source a #GInputStream.
		 * @param flags a set of #GOutputStreamSpliceFlags.
		 * @param cancellable optional #GCancellable object, %NULL to ignore.
		 * @returns a #gssize containing the size of the data spliced, or
		 *     -1 if an error occurred. Note that if the number of bytes
		 *     spliced is greater than %G_MAXSSIZE, then that will be
		 *     returned, and there is no way to determine the actual number
		 *     of bytes spliced.
		 */
		splice(source: InputStream, flags: OutputStreamSpliceFlags, cancellable?: Cancellable | null): number;
		/**
		 * Splices a stream asynchronously.
		 * When the operation is finished #callback will be called.
		 * You can then call {@link G.output_stream_splice_finish} to get the
		 * result of the operation.
		 * 
		 * For the synchronous, blocking version of this function, see
		 * g_output_stream_splice().
		 * @param source a #GInputStream.
		 * @param flags a set of #GOutputStreamSpliceFlags.
		 * @param io_priority the io priority of the request.
		 * @param cancellable optional #GCancellable object, %NULL to ignore.
		 * @param callback a #GAsyncReadyCallback.
		 */
		splice_async(source: InputStream, flags: OutputStreamSpliceFlags, io_priority: number, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;
		/**
		 * Finishes an asynchronous stream splice operation.
		 * @param result a #GAsyncResult.
		 * @returns a #gssize of the number of bytes spliced. Note that if the
		 *     number of bytes spliced is greater than %G_MAXSSIZE, then that
		 *     will be returned, and there is no way to determine the actual
		 *     number of bytes spliced.
		 */
		splice_finish(result: AsyncResult): number;
		/**
		 * This is a utility function around {@link G.output_stream_write_all}. It
		 * uses g_strdup_vprintf() to turn #format and #args into a string that
		 * is then written to #stream.
		 * 
		 * See the documentation of g_output_stream_write_all() about the
		 * behavior of the actual write operation.
		 * 
		 * Note that partial writes cannot be properly checked with this
		 * function due to the variable length of the written string, if you
		 * need precise control over partial write failures, you need to
		 * create you own printf()-like wrapper around g_output_stream_write()
		 * or g_output_stream_write_all().
		 * @param cancellable optional #GCancellable object, %NULL to ignore.
		 * @param error location to store the error occurring, or %NULL to ignore
		 * @param format the format string. See the printf() documentation
		 * @param args the parameters to insert into the format string
		 * @returns %TRUE on success, %FALSE if there was an error
		 * 
		 * location to store the number of bytes that was
		 *     written to the stream
		 */
		vprintf(cancellable: Cancellable | null, error: GLib.Error, format: string, args: any[]): [ boolean, number | null ];
		/**
		 * Tries to write #count bytes from #buffer into the stream. Will block
		 * during the operation.
		 * 
		 * If count is 0, returns 0 and does nothing. A value of #count
		 * larger than %G_MAXSSIZE will cause a %G_IO_ERROR_INVALID_ARGUMENT error.
		 * 
		 * On success, the number of bytes written to the stream is returned.
		 * It is not an error if this is not the same as the requested size, as it
		 * can happen e.g. on a partial I/O error, or if there is not enough
		 * storage in the stream. All writes block until at least one byte
		 * is written or an error occurs; 0 is never returned (unless
		 * #count is 0).
		 * 
		 * If #cancellable is not %NULL, then the operation can be cancelled by
		 * triggering the cancellable object from another thread. If the operation
		 * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
		 * operation was partially finished when the operation was cancelled the
		 * partial result will be returned, without an error.
		 * 
		 * On error -1 is returned and #error is set accordingly.
		 * @param buffer the buffer containing the data to write.
		 * @param cancellable optional cancellable object
		 * @returns Number of bytes written, or -1 on error
		 */
		write(buffer: number[], cancellable?: Cancellable | null): number;
		/**
		 * Tries to write #count bytes from #buffer into the stream. Will block
		 * during the operation.
		 * 
		 * This function is similar to {@link G.output_stream_write}, except it tries to
		 * write as many bytes as requested, only stopping on an error.
		 * 
		 * On a successful write of #count bytes, %TRUE is returned, and #bytes_written
		 * is set to #count.
		 * 
		 * If there is an error during the operation %FALSE is returned and #error
		 * is set to indicate the error status.
		 * 
		 * As a special exception to the normal conventions for functions that
		 * use #GError, if this function returns %FALSE (and sets #error) then
		 * #bytes_written will be set to the number of bytes that were
		 * successfully written before the error was encountered.  This
		 * functionality is only available from C.  If you need it from another
		 * language then you must write your own loop around
		 * g_output_stream_write().
		 * @param buffer the buffer containing the data to write.
		 * @param cancellable optional #GCancellable object, %NULL to ignore.
		 * @returns %TRUE on success, %FALSE if there was an error
		 * 
		 * location to store the number of bytes that was
		 *     written to the stream
		 */
		write_all(buffer: number[], cancellable?: Cancellable | null): [ boolean, number | null ];
		/**
		 * Request an asynchronous write of #count bytes from #buffer into
		 * the stream. When the operation is finished #callback will be called.
		 * You can then call {@link G.output_stream_write_all_finish} to get the result of the
		 * operation.
		 * 
		 * This is the asynchronous version of g_output_stream_write_all().
		 * 
		 * Call g_output_stream_write_all_finish() to collect the result.
		 * 
		 * Any outstanding I/O request with higher priority (lower numerical
		 * value) will be executed before an outstanding request with lower
		 * priority. Default priority is %G_PRIORITY_DEFAULT.
		 * 
		 * Note that no copy of #buffer will be made, so it must stay valid
		 * until #callback is called.
		 * @param buffer the buffer containing the data to write
		 * @param io_priority the io priority of the request
		 * @param cancellable optional #GCancellable object, %NULL to ignore
		 * @param callback callback to call when the request is satisfied
		 */
		write_all_async(buffer: number[], io_priority: number, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;
		/**
		 * Finishes an asynchronous stream write operation started with
		 * {@link G.output_stream_write_all_async}.
		 * 
		 * As a special exception to the normal conventions for functions that
		 * use #GError, if this function returns %FALSE (and sets #error) then
		 * #bytes_written will be set to the number of bytes that were
		 * successfully written before the error was encountered.  This
		 * functionality is only available from C.  If you need it from another
		 * language then you must write your own loop around
		 * g_output_stream_write_async().
		 * @param result a #GAsyncResult
		 * @returns %TRUE on success, %FALSE if there was an error
		 * 
		 * location to store the number of bytes that was written to the stream
		 */
		write_all_finish(result: AsyncResult): [ boolean, number | null ];
		/**
		 * Request an asynchronous write of #count bytes from #buffer into
		 * the stream. When the operation is finished #callback will be called.
		 * You can then call {@link G.output_stream_write_finish} to get the result of the
		 * operation.
		 * 
		 * During an async request no other sync and async calls are allowed,
		 * and will result in %G_IO_ERROR_PENDING errors.
		 * 
		 * A value of #count larger than %G_MAXSSIZE will cause a
		 * %G_IO_ERROR_INVALID_ARGUMENT error.
		 * 
		 * On success, the number of bytes written will be passed to the
		 * #callback. It is not an error if this is not the same as the
		 * requested size, as it can happen e.g. on a partial I/O error,
		 * but generally we try to write as many bytes as requested.
		 * 
		 * You are guaranteed that this method will never fail with
		 * %G_IO_ERROR_WOULD_BLOCK - if #stream can't accept more data, the
		 * method will just wait until this changes.
		 * 
		 * Any outstanding I/O request with higher priority (lower numerical
		 * value) will be executed before an outstanding request with lower
		 * priority. Default priority is %G_PRIORITY_DEFAULT.
		 * 
		 * The asynchronous methods have a default fallback that uses threads
		 * to implement asynchronicity, so they are optional for inheriting
		 * classes. However, if you override one you must override all.
		 * 
		 * For the synchronous, blocking version of this function, see
		 * g_output_stream_write().
		 * 
		 * Note that no copy of #buffer will be made, so it must stay valid
		 * until #callback is called. See g_output_stream_write_bytes_async()
		 * for a #GBytes version that will automatically hold a reference to
		 * the contents (without copying) for the duration of the call.
		 * @param buffer the buffer containing the data to write.
		 * @param io_priority the io priority of the request.
		 * @param cancellable optional #GCancellable object, %NULL to ignore.
		 * @param callback callback to call when the request is satisfied
		 */
		write_async(buffer: number[], io_priority: number, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;
		/**
		 * A wrapper function for {@link G.output_stream_write} which takes a
		 * #GBytes as input.  This can be more convenient for use by language
		 * bindings or in other cases where the refcounted nature of #GBytes
		 * is helpful over a bare pointer interface.
		 * 
		 * However, note that this function may still perform partial writes,
		 * just like g_output_stream_write().  If that occurs, to continue
		 * writing, you will need to create a new #GBytes containing just the
		 * remaining bytes, using g_bytes_new_from_bytes(). Passing the same
		 * #GBytes instance multiple times potentially can result in duplicated
		 * data in the output stream.
		 * @param bytes the #GBytes to write
		 * @param cancellable optional cancellable object
		 * @returns Number of bytes written, or -1 on error
		 */
		write_bytes(bytes: GLib.Bytes, cancellable?: Cancellable | null): number;
		/**
		 * This function is similar to {@link G.output_stream_write_async}, but
		 * takes a #GBytes as input.  Due to the refcounted nature of #GBytes,
		 * this allows the stream to avoid taking a copy of the data.
		 * 
		 * However, note that this function may still perform partial writes,
		 * just like g_output_stream_write_async(). If that occurs, to continue
		 * writing, you will need to create a new #GBytes containing just the
		 * remaining bytes, using g_bytes_new_from_bytes(). Passing the same
		 * #GBytes instance multiple times potentially can result in duplicated
		 * data in the output stream.
		 * 
		 * For the synchronous, blocking version of this function, see
		 * g_output_stream_write_bytes().
		 * @param bytes The bytes to write
		 * @param io_priority the io priority of the request.
		 * @param cancellable optional #GCancellable object, %NULL to ignore.
		 * @param callback callback to call when the request is satisfied
		 */
		write_bytes_async(bytes: GLib.Bytes, io_priority: number | null, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;
		/**
		 * Finishes a stream write-from-#GBytes operation.
		 * @param result a #GAsyncResult.
		 * @returns a #gssize containing the number of bytes written to the stream.
		 */
		write_bytes_finish(result: AsyncResult): number;
		/**
		 * Finishes a stream write operation.
		 * @param result a #GAsyncResult.
		 * @returns a #gssize containing the number of bytes written to the stream.
		 */
		write_finish(result: AsyncResult): number;
		/**
		 * Tries to write the bytes contained in the #n_vectors #vectors into the
		 * stream. Will block during the operation.
		 * 
		 * If #n_vectors is 0 or the sum of all bytes in #vectors is 0, returns 0 and
		 * does nothing.
		 * 
		 * On success, the number of bytes written to the stream is returned.
		 * It is not an error if this is not the same as the requested size, as it
		 * can happen e.g. on a partial I/O error, or if there is not enough
		 * storage in the stream. All writes block until at least one byte
		 * is written or an error occurs; 0 is never returned (unless
		 * #n_vectors is 0 or the sum of all bytes in #vectors is 0).
		 * 
		 * If #cancellable is not %NULL, then the operation can be cancelled by
		 * triggering the cancellable object from another thread. If the operation
		 * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
		 * operation was partially finished when the operation was cancelled the
		 * partial result will be returned, without an error.
		 * 
		 * Some implementations of {@link G.output_stream_writev} may have limitations on the
		 * aggregate buffer size, and will return %G_IO_ERROR_INVALID_ARGUMENT if these
		 * are exceeded. For example, when writing to a local file on UNIX platforms,
		 * the aggregate buffer size must not exceed %G_MAXSSIZE bytes.
		 * @param vectors the buffer containing the #GOutputVectors to write.
		 * @param cancellable optional cancellable object
		 * @returns %TRUE on success, %FALSE if there was an error
		 * 
		 * location to store the number of bytes that were
		 *     written to the stream
		 */
		writev(vectors: OutputVector[], cancellable?: Cancellable | null): [ boolean, number | null ];
		/**
		 * Tries to write the bytes contained in the #n_vectors #vectors into the
		 * stream. Will block during the operation.
		 * 
		 * This function is similar to {@link G.output_stream_writev}, except it tries to
		 * write as many bytes as requested, only stopping on an error.
		 * 
		 * On a successful write of all #n_vectors vectors, %TRUE is returned, and
		 * #bytes_written is set to the sum of all the sizes of #vectors.
		 * 
		 * If there is an error during the operation %FALSE is returned and #error
		 * is set to indicate the error status.
		 * 
		 * As a special exception to the normal conventions for functions that
		 * use #GError, if this function returns %FALSE (and sets #error) then
		 * #bytes_written will be set to the number of bytes that were
		 * successfully written before the error was encountered.  This
		 * functionality is only available from C. If you need it from another
		 * language then you must write your own loop around
		 * g_output_stream_write().
		 * 
		 * The content of the individual elements of #vectors might be changed by this
		 * function.
		 * @param vectors the buffer containing the #GOutputVectors to write.
		 * @param cancellable optional #GCancellable object, %NULL to ignore.
		 * @returns %TRUE on success, %FALSE if there was an error
		 * 
		 * location to store the number of bytes that were
		 *     written to the stream
		 */
		writev_all(vectors: OutputVector[], cancellable?: Cancellable | null): [ boolean, number | null ];
		/**
		 * Request an asynchronous write of the bytes contained in the #n_vectors #vectors into
		 * the stream. When the operation is finished #callback will be called.
		 * You can then call {@link G.output_stream_writev_all_finish} to get the result of the
		 * operation.
		 * 
		 * This is the asynchronous version of g_output_stream_writev_all().
		 * 
		 * Call g_output_stream_writev_all_finish() to collect the result.
		 * 
		 * Any outstanding I/O request with higher priority (lower numerical
		 * value) will be executed before an outstanding request with lower
		 * priority. Default priority is %G_PRIORITY_DEFAULT.
		 * 
		 * Note that no copy of #vectors will be made, so it must stay valid
		 * until #callback is called. The content of the individual elements
		 * of #vectors might be changed by this function.
		 * @param vectors the buffer containing the #GOutputVectors to write.
		 * @param io_priority the I/O priority of the request
		 * @param cancellable optional #GCancellable object, %NULL to ignore
		 * @param callback callback to call when the request is satisfied
		 */
		writev_all_async(vectors: OutputVector[], io_priority: number, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;
		/**
		 * Finishes an asynchronous stream write operation started with
		 * {@link G.output_stream_writev_all_async}.
		 * 
		 * As a special exception to the normal conventions for functions that
		 * use #GError, if this function returns %FALSE (and sets #error) then
		 * #bytes_written will be set to the number of bytes that were
		 * successfully written before the error was encountered.  This
		 * functionality is only available from C.  If you need it from another
		 * language then you must write your own loop around
		 * g_output_stream_writev_async().
		 * @param result a #GAsyncResult
		 * @returns %TRUE on success, %FALSE if there was an error
		 * 
		 * location to store the number of bytes that were written to the stream
		 */
		writev_all_finish(result: AsyncResult): [ boolean, number | null ];
		/**
		 * Request an asynchronous write of the bytes contained in #n_vectors #vectors into
		 * the stream. When the operation is finished #callback will be called.
		 * You can then call {@link G.output_stream_writev_finish} to get the result of the
		 * operation.
		 * 
		 * During an async request no other sync and async calls are allowed,
		 * and will result in %G_IO_ERROR_PENDING errors.
		 * 
		 * On success, the number of bytes written will be passed to the
		 * #callback. It is not an error if this is not the same as the
		 * requested size, as it can happen e.g. on a partial I/O error,
		 * but generally we try to write as many bytes as requested.
		 * 
		 * You are guaranteed that this method will never fail with
		 * %G_IO_ERROR_WOULD_BLOCK — if #stream can't accept more data, the
		 * method will just wait until this changes.
		 * 
		 * Any outstanding I/O request with higher priority (lower numerical
		 * value) will be executed before an outstanding request with lower
		 * priority. Default priority is %G_PRIORITY_DEFAULT.
		 * 
		 * The asynchronous methods have a default fallback that uses threads
		 * to implement asynchronicity, so they are optional for inheriting
		 * classes. However, if you override one you must override all.
		 * 
		 * For the synchronous, blocking version of this function, see
		 * g_output_stream_writev().
		 * 
		 * Note that no copy of #vectors will be made, so it must stay valid
		 * until #callback is called.
		 * @param vectors the buffer containing the #GOutputVectors to write.
		 * @param io_priority the I/O priority of the request.
		 * @param cancellable optional #GCancellable object, %NULL to ignore.
		 * @param callback callback to call when the request is satisfied
		 */
		writev_async(vectors: OutputVector[], io_priority: number, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;
		/**
		 * Finishes a stream writev operation.
		 * @param result a #GAsyncResult.
		 * @returns %TRUE on success, %FALSE if there was an error
		 * 
		 * location to store the number of bytes that were written to the stream
		 */
		writev_finish(result: AsyncResult): [ boolean, number | null ];
	}

	type OutputStreamInitOptionsMixin = GObject.ObjectInitOptions
	export interface OutputStreamInitOptions extends OutputStreamInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link OutputStream} instead.
	 */
	type OutputStreamMixin = IOutputStream & GObject.Object;

	/**
	 * #GOutputStream has functions to write to a stream {@link (g.output_stream_write}),
	 * to close a stream (g_output_stream_close()) and to flush pending writes
	 * (g_output_stream_flush()).
	 * 
	 * To copy the content of an input stream to an output stream without
	 * manually handling the reads and writes, use g_output_stream_splice().
	 * 
	 * See the documentation for #GIOStream for details of thread safety of
	 * streaming APIs.
	 * 
	 * All of these functions have async variants too.
	 */
	interface OutputStream extends OutputStreamMixin {}

	class OutputStream {
		public constructor(options?: Partial<OutputStreamInitOptions>);
	}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link Permission} instead.
	 */
	interface IPermission {
		/**
		 * %TRUE if the caller currently has permission to perform the action that
		 * #permission represents the permission to perform.
		 */
		readonly allowed: boolean;
		/**
		 * %TRUE if it is generally possible to acquire the permission by calling
		 * {@link G.permission_acquire}.
		 */
		readonly can_acquire: boolean;
		/**
		 * %TRUE if it is generally possible to release the permission by calling
		 * {@link G.permission_release}.
		 */
		readonly can_release: boolean;
		/**
		 * Attempts to acquire the permission represented by #permission.
		 * 
		 * The precise method by which this happens depends on the permission
		 * and the underlying authentication mechanism.  A simple example is
		 * that a dialog may appear asking the user to enter their password.
		 * 
		 * You should check with {@link G.permission_get_can_acquire} before calling
		 * this function.
		 * 
		 * If the permission is acquired then %TRUE is returned.  Otherwise,
		 * %FALSE is returned and #error is set appropriately.
		 * 
		 * This call is blocking, likely for a very long time (in the case that
		 * user interaction is required).  See g_permission_acquire_async() for
		 * the non-blocking version.
		 * @param cancellable a #GCancellable, or %NULL
		 * @returns %TRUE if the permission was successfully acquired
		 */
		acquire(cancellable?: Cancellable | null): boolean;
		/**
		 * Attempts to acquire the permission represented by #permission.
		 * 
		 * This is the first half of the asynchronous version of
		 * {@link G.permission_acquire}.
		 * @param cancellable a #GCancellable, or %NULL
		 * @param callback the #GAsyncReadyCallback to call when done
		 */
		acquire_async(cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;
		/**
		 * Collects the result of attempting to acquire the permission
		 * represented by #permission.
		 * 
		 * This is the second half of the asynchronous version of
		 * {@link G.permission_acquire}.
		 * @param result the #GAsyncResult given to the #GAsyncReadyCallback
		 * @returns %TRUE if the permission was successfully acquired
		 */
		acquire_finish(result: AsyncResult): boolean;
		/**
		 * Gets the value of the 'allowed' property.  This property is %TRUE if
		 * the caller currently has permission to perform the action that
		 * #permission represents the permission to perform.
		 * @returns the value of the 'allowed' property
		 */
		get_allowed(): boolean;
		/**
		 * Gets the value of the 'can-acquire' property.  This property is %TRUE
		 * if it is generally possible to acquire the permission by calling
		 * {@link G.permission_acquire}.
		 * @returns the value of the 'can-acquire' property
		 */
		get_can_acquire(): boolean;
		/**
		 * Gets the value of the 'can-release' property.  This property is %TRUE
		 * if it is generally possible to release the permission by calling
		 * {@link G.permission_release}.
		 * @returns the value of the 'can-release' property
		 */
		get_can_release(): boolean;
		/**
		 * This function is called by the #GPermission implementation to update
		 * the properties of the permission.  You should never call this
		 * function except from a #GPermission implementation.
		 * 
		 * GObject notify signals are generated, as appropriate.
		 * @param allowed the new value for the 'allowed' property
		 * @param can_acquire the new value for the 'can-acquire' property
		 * @param can_release the new value for the 'can-release' property
		 */
		impl_update(allowed: boolean, can_acquire: boolean, can_release: boolean): void;
		/**
		 * Attempts to release the permission represented by #permission.
		 * 
		 * The precise method by which this happens depends on the permission
		 * and the underlying authentication mechanism.  In most cases the
		 * permission will be dropped immediately without further action.
		 * 
		 * You should check with {@link G.permission_get_can_release} before calling
		 * this function.
		 * 
		 * If the permission is released then %TRUE is returned.  Otherwise,
		 * %FALSE is returned and #error is set appropriately.
		 * 
		 * This call is blocking, likely for a very long time (in the case that
		 * user interaction is required).  See g_permission_release_async() for
		 * the non-blocking version.
		 * @param cancellable a #GCancellable, or %NULL
		 * @returns %TRUE if the permission was successfully released
		 */
		release(cancellable?: Cancellable | null): boolean;
		/**
		 * Attempts to release the permission represented by #permission.
		 * 
		 * This is the first half of the asynchronous version of
		 * {@link G.permission_release}.
		 * @param cancellable a #GCancellable, or %NULL
		 * @param callback the #GAsyncReadyCallback to call when done
		 */
		release_async(cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;
		/**
		 * Collects the result of attempting to release the permission
		 * represented by #permission.
		 * 
		 * This is the second half of the asynchronous version of
		 * {@link G.permission_release}.
		 * @param result the #GAsyncResult given to the #GAsyncReadyCallback
		 * @returns %TRUE if the permission was successfully released
		 */
		release_finish(result: AsyncResult): boolean;
		connect(signal: "notify::allowed", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::can-acquire", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::can-release", callback: (owner: this, ...args: any) => void): number;

	}

	type PermissionInitOptionsMixin = GObject.ObjectInitOptions
	export interface PermissionInitOptions extends PermissionInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link Permission} instead.
	 */
	type PermissionMixin = IPermission & GObject.Object;

	/**
	 * A #GPermission represents the status of the caller's permission to
	 * perform a certain action.
	 * 
	 * You can query if the action is currently allowed and if it is
	 * possible to acquire the permission so that the action will be allowed
	 * in the future.
	 * 
	 * There is also an API to actually acquire the permission and one to
	 * release it.
	 * 
	 * As an example, a #GPermission might represent the ability for the
	 * user to write to a #GSettings object.  This #GPermission object could
	 * then be used to decide if it is appropriate to show a "Click here to
	 * unlock" button in a dialog and to provide the mechanism to invoke
	 * when that button is clicked.
	 */
	interface Permission extends PermissionMixin {}

	class Permission {
		public constructor(options?: Partial<PermissionInitOptions>);
	}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link PropertyAction} instead.
	 */
	interface IPropertyAction {
		/**
		 * If #action is currently enabled.
		 * 
		 * If the action is disabled then calls to {@link G.action_activate} and
		 * g_action_change_state() have no effect.
		 */
		readonly enabled: boolean;
		/**
		 * If %TRUE, the state of the action will be the negation of the
		 * property value, provided the property is boolean.
		 */
		invert_boolean: boolean;
		/**
		 * The name of the action.  This is mostly meaningful for identifying
		 * the action once it has been added to a #GActionMap.
		 */
		name: string;
		/**
		 * The type of the parameter that must be given when activating the
		 * action.
		 */
		readonly parameter_type: GLib.VariantType;
		/**
		 * The state of the action, or %NULL if the action is stateless.
		 */
		readonly state: GLib.Variant;
		/**
		 * The #GVariantType of the state that the action has, or %NULL if the
		 * action is stateless.
		 */
		readonly state_type: GLib.VariantType;

		connect(signal: "notify::enabled", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::invert-boolean", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::name", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::parameter-type", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::state", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::state-type", callback: (owner: this, ...args: any) => void): number;

	}

	type PropertyActionInitOptionsMixin = GObject.ObjectInitOptions & ActionInitOptions & 
	Pick<IPropertyAction,
		"invert_boolean" |
		"name">;

	export interface PropertyActionInitOptions extends PropertyActionInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link PropertyAction} instead.
	 */
	type PropertyActionMixin = IPropertyAction & GObject.Object & Action;

	/**
	 * A #GPropertyAction is a way to get a #GAction with a state value
	 * reflecting and controlling the value of a #GObject property.
	 * 
	 * The state of the action will correspond to the value of the property.
	 * Changing it will change the property (assuming the requested value
	 * matches the requirements as specified in the #GParamSpec).
	 * 
	 * Only the most common types are presently supported.  Booleans are
	 * mapped to booleans, strings to strings, signed/unsigned integers to
	 * int32/uint32 and floats and doubles to doubles.
	 * 
	 * If the property is an enum then the state will be string-typed and
	 * conversion will automatically be performed between the enum value and
	 * "nick" string as per the #GEnumValue table.
	 * 
	 * Flags types are not currently supported.
	 * 
	 * Properties of object types, boxed types and pointer types are not
	 * supported and probably never will be.
	 * 
	 * Properties of #GVariant types are not currently supported.
	 * 
	 * If the property is boolean-valued then the action will have a NULL
	 * parameter type, and activating the action (with no parameter) will
	 * toggle the value of the property.
	 * 
	 * In all other cases, the parameter type will correspond to the type of
	 * the property.
	 * 
	 * The general idea here is to reduce the number of locations where a
	 * particular piece of state is kept (and therefore has to be synchronised
	 * between). #GPropertyAction does not have a separate state that is kept
	 * in sync with the property value -- its state is the property value.
	 * 
	 * For example, it might be useful to create a #GAction corresponding to
	 * the "visible-child-name" property of a #GtkStack so that the current
	 * page can be switched from a menu.  The active radio indication in the
	 * menu is then directly determined from the active page of the
	 * #GtkStack.
	 * 
	 * An anti-example would be binding the "active-id" property on a
	 * #GtkComboBox.  This is because the state of the combobox itself is
	 * probably uninteresting and is actually being used to control
	 * something else.
	 * 
	 * Another anti-example would be to bind to the "visible-child-name"
	 * property of a #GtkStack if this value is actually stored in
	 * #GSettings.  In that case, the real source of the value is
	 * #GSettings.  If you want a #GAction to control a setting stored in
	 * #GSettings, see {@link G.settings_create_action} instead, and possibly
	 * combine its use with g_settings_bind().
	 */
	interface PropertyAction extends PropertyActionMixin {}

	class PropertyAction {
		public constructor(options?: Partial<PropertyActionInitOptions>);
		/**
		 * Creates a #GAction corresponding to the value of property
		 * #property_name on #object.
		 * 
		 * The property must be existent and readable and writable (and not
		 * construct-only).
		 * 
		 * This function takes a reference on #object and doesn't release it
		 * until the action is destroyed.
		 * @param name the name of the action to create
		 * @param object the object that has the property
		 *   to wrap
		 * @param property_name the name of the property
		 * @returns a new #GPropertyAction
		 */
		public static new(name: string, object: GObject.Object, property_name: string): PropertyAction;
	}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link ProxyAddress} instead.
	 */
	interface IProxyAddress {
		destination_hostname: string;
		destination_port: number;
		/**
		 * The protocol being spoke to the destination host, or %NULL if
		 * the #GProxyAddress doesn't know.
		 */
		destination_protocol: string;
		password: string;
		protocol: string;
		/**
		 * The URI string that the proxy was constructed from (or %NULL
		 * if the creator didn't specify this).
		 */
		uri: string;
		username: string;
		/**
		 * Gets #proxy's destination hostname; that is, the name of the host
		 * that will be connected to via the proxy, not the name of the proxy
		 * itself.
		 * @returns the #proxy's destination hostname
		 */
		get_destination_hostname(): string;
		/**
		 * Gets #proxy's destination port; that is, the port on the
		 * destination host that will be connected to via the proxy, not the
		 * port number of the proxy itself.
		 * @returns the #proxy's destination port
		 */
		get_destination_port(): number;
		/**
		 * Gets the protocol that is being spoken to the destination
		 * server; eg, "http" or "ftp".
		 * @returns the #proxy's destination protocol
		 */
		get_destination_protocol(): string;
		/**
		 * Gets #proxy's password.
		 * @returns the #proxy's password
		 */
		get_password(): string | null;
		/**
		 * Gets #proxy's protocol. eg, "socks" or "http"
		 * @returns the #proxy's protocol
		 */
		get_protocol(): string;
		/**
		 * Gets the proxy URI that #proxy was constructed from.
		 * @returns the #proxy's URI, or %NULL if unknown
		 */
		get_uri(): string | null;
		/**
		 * Gets #proxy's username.
		 * @returns the #proxy's username
		 */
		get_username(): string | null;
		connect(signal: "notify::destination-hostname", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::destination-port", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::destination-protocol", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::password", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::protocol", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::uri", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::username", callback: (owner: this, ...args: any) => void): number;

	}

	type ProxyAddressInitOptionsMixin = InetSocketAddressInitOptions & SocketConnectableInitOptions & 
	Pick<IProxyAddress,
		"destination_hostname" |
		"destination_port" |
		"destination_protocol" |
		"password" |
		"protocol" |
		"uri" |
		"username">;

	export interface ProxyAddressInitOptions extends ProxyAddressInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link ProxyAddress} instead.
	 */
	type ProxyAddressMixin = IProxyAddress & InetSocketAddress & SocketConnectable;

	/**
	 * Support for proxied #GInetSocketAddress.
	 */
	interface ProxyAddress extends ProxyAddressMixin {}

	class ProxyAddress {
		public constructor(options?: Partial<ProxyAddressInitOptions>);
		/**
		 * Creates a new #GProxyAddress for #inetaddr with #protocol that should
		 * tunnel through #dest_hostname and #dest_port.
		 * 
		 * (Note that this method doesn't set the #GProxyAddress:uri or
		 * #GProxyAddress:destination-protocol fields; use {@link GObject.new}
		 * directly if you want to set those.)
		 * @param inetaddr The proxy server #GInetAddress.
		 * @param port The proxy server port.
		 * @param protocol The proxy protocol to support, in lower case (e.g. socks, http).
		 * @param dest_hostname The destination hostname the proxy should tunnel to.
		 * @param dest_port The destination port to tunnel to.
		 * @param username The username to authenticate to the proxy server
		 *     (or %NULL).
		 * @param password The password to authenticate to the proxy server
		 *     (or %NULL).
		 * @returns a new #GProxyAddress
		 */
		public static new(inetaddr: InetAddress, port: number, protocol: string, dest_hostname: string, dest_port: number, username?: string | null, password?: string | null): SocketAddress;
	}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link ProxyAddressEnumerator} instead.
	 */
	interface IProxyAddressEnumerator {
		connectable: SocketConnectable;
		/**
		 * The default port to use if #GProxyAddressEnumerator:uri does not
		 * specify one.
		 */
		default_port: number;
		/**
		 * The proxy resolver to use.
		 */
		proxy_resolver: ProxyResolver;
		uri: string;

		connect(signal: "notify::connectable", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::default-port", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::proxy-resolver", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::uri", callback: (owner: this, ...args: any) => void): number;

	}

	type ProxyAddressEnumeratorInitOptionsMixin = SocketAddressEnumeratorInitOptions & 
	Pick<IProxyAddressEnumerator,
		"connectable" |
		"default_port" |
		"proxy_resolver" |
		"uri">;

	export interface ProxyAddressEnumeratorInitOptions extends ProxyAddressEnumeratorInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link ProxyAddressEnumerator} instead.
	 */
	type ProxyAddressEnumeratorMixin = IProxyAddressEnumerator & SocketAddressEnumerator;

	/**
	 * #GProxyAddressEnumerator is a wrapper around #GSocketAddressEnumerator which
	 * takes the #GSocketAddress instances returned by the #GSocketAddressEnumerator
	 * and wraps them in #GProxyAddress instances, using the given
	 * #GProxyAddressEnumerator:proxy-resolver.
	 * 
	 * This enumerator will be returned (for example, by
	 * {@link G.socket_connectable_enumerate}) as appropriate when a proxy is configured;
	 * there should be no need to manually wrap a #GSocketAddressEnumerator instance
	 * with one.
	 */
	interface ProxyAddressEnumerator extends ProxyAddressEnumeratorMixin {}

	class ProxyAddressEnumerator {
		public constructor(options?: Partial<ProxyAddressEnumeratorInitOptions>);
	}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link Resolver} instead.
	 */
	interface IResolver {
		/**
		 * Synchronously reverse-resolves #address to determine its
		 * associated hostname.
		 * 
		 * If the DNS resolution fails, #error (if non-%NULL) will be set to
		 * a value from #GResolverError.
		 * 
		 * If #cancellable is non-%NULL, it can be used to cancel the
		 * operation, in which case #error (if non-%NULL) will be set to
		 * %G_IO_ERROR_CANCELLED.
		 * @param address the address to reverse-resolve
		 * @param cancellable a #GCancellable, or %NULL
		 * @returns a hostname (either ASCII-only, or in ASCII-encoded
		 *     form), or %NULL on error.
		 */
		lookup_by_address(address: InetAddress, cancellable?: Cancellable | null): string;
		/**
		 * Begins asynchronously reverse-resolving #address to determine its
		 * associated hostname, and eventually calls #callback, which must
		 * call {@link G.resolver_lookup_by_address_finish} to get the final result.
		 * @param address the address to reverse-resolve
		 * @param cancellable a #GCancellable, or %NULL
		 * @param callback callback to call after resolution completes
		 */
		lookup_by_address_async(address: InetAddress, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;
		/**
		 * Retrieves the result of a previous call to
		 * {@link G.resolver_lookup_by_address_async}.
		 * 
		 * If the DNS resolution failed, #error (if non-%NULL) will be set to
		 * a value from #GResolverError. If the operation was cancelled,
		 * #error will be set to %G_IO_ERROR_CANCELLED.
		 * @param result the result passed to your #GAsyncReadyCallback
		 * @returns a hostname (either ASCII-only, or in ASCII-encoded
		 * form), or %NULL on error.
		 */
		lookup_by_address_finish(result: AsyncResult): string;
		/**
		 * Synchronously resolves #hostname to determine its associated IP
		 * address(es). #hostname may be an ASCII-only or UTF-8 hostname, or
		 * the textual form of an IP address (in which case this just becomes
		 * a wrapper around {@link G.inet_address_new_from_string}).
		 * 
		 * On success, g_resolver_lookup_by_name() will return a non-empty #GList of
		 * #GInetAddress, sorted in order of preference and guaranteed to not
		 * contain duplicates. That is, if using the result to connect to
		 * #hostname, you should attempt to connect to the first address
		 * first, then the second if the first fails, etc. If you are using
		 * the result to listen on a socket, it is appropriate to add each
		 * result using e.g. g_socket_listener_add_address().
		 * 
		 * If the DNS resolution fails, #error (if non-%NULL) will be set to a
		 * value from #GResolverError and %NULL will be returned.
		 * 
		 * If #cancellable is non-%NULL, it can be used to cancel the
		 * operation, in which case #error (if non-%NULL) will be set to
		 * %G_IO_ERROR_CANCELLED.
		 * 
		 * If you are planning to connect to a socket on the resolved IP
		 * address, it may be easier to create a #GNetworkAddress and use its
		 * #GSocketConnectable interface.
		 * @param hostname the hostname to look up
		 * @param cancellable a #GCancellable, or %NULL
		 * @returns a non-empty #GList
		 * of #GInetAddress, or %NULL on error. You
		 * must unref each of the addresses and free the list when you are
		 * done with it. (You can use {@link G.resolver_free_addresses} to do this.)
		 */
		lookup_by_name(hostname: string, cancellable?: Cancellable | null): InetAddress[];
		/**
		 * Begins asynchronously resolving #hostname to determine its
		 * associated IP address(es), and eventually calls #callback, which
		 * must call {@link G.resolver_lookup_by_name_finish} to get the result.
		 * See g_resolver_lookup_by_name() for more details.
		 * @param hostname the hostname to look up the address of
		 * @param cancellable a #GCancellable, or %NULL
		 * @param callback callback to call after resolution completes
		 */
		lookup_by_name_async(hostname: string, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;
		/**
		 * Retrieves the result of a call to
		 * {@link G.resolver_lookup_by_name_async}.
		 * 
		 * If the DNS resolution failed, #error (if non-%NULL) will be set to
		 * a value from #GResolverError. If the operation was cancelled,
		 * #error will be set to %G_IO_ERROR_CANCELLED.
		 * @param result the result passed to your #GAsyncReadyCallback
		 * @returns a #GList
		 * of #GInetAddress, or %NULL on error. See {@link G.resolver_lookup_by_name}
		 * for more details.
		 */
		lookup_by_name_finish(result: AsyncResult): InetAddress[];
		/**
		 * This differs from {@link G.resolver_lookup_by_name} in that you can modify
		 * the lookup behavior with #flags. For example this can be used to limit
		 * results with #G_RESOLVER_NAME_LOOKUP_FLAGS_IPV4_ONLY.
		 * @param hostname the hostname to look up
		 * @param flags extra #GResolverNameLookupFlags for the lookup
		 * @param cancellable a #GCancellable, or %NULL
		 * @returns a non-empty #GList
		 * of #GInetAddress, or %NULL on error. You
		 * must unref each of the addresses and free the list when you are
		 * done with it. (You can use {@link G.resolver_free_addresses} to do this.)
		 */
		lookup_by_name_with_flags(hostname: string, flags: ResolverNameLookupFlags, cancellable?: Cancellable | null): InetAddress[];
		/**
		 * Begins asynchronously resolving #hostname to determine its
		 * associated IP address(es), and eventually calls #callback, which
		 * must call {@link G.resolver_lookup_by_name_with_flags_finish} to get the result.
		 * See g_resolver_lookup_by_name() for more details.
		 * @param hostname the hostname to look up the address of
		 * @param flags extra #GResolverNameLookupFlags for the lookup
		 * @param cancellable a #GCancellable, or %NULL
		 * @param callback callback to call after resolution completes
		 */
		lookup_by_name_with_flags_async(hostname: string, flags: ResolverNameLookupFlags, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;
		/**
		 * Retrieves the result of a call to
		 * {@link G.resolver_lookup_by_name_with_flags_async}.
		 * 
		 * If the DNS resolution failed, #error (if non-%NULL) will be set to
		 * a value from #GResolverError. If the operation was cancelled,
		 * #error will be set to %G_IO_ERROR_CANCELLED.
		 * @param result the result passed to your #GAsyncReadyCallback
		 * @returns a #GList
		 * of #GInetAddress, or %NULL on error. See {@link G.resolver_lookup_by_name}
		 * for more details.
		 */
		lookup_by_name_with_flags_finish(result: AsyncResult): InetAddress[];
		/**
		 * Synchronously performs a DNS record lookup for the given #rrname and returns
		 * a list of records as #GVariant tuples. See #GResolverRecordType for
		 * information on what the records contain for each #record_type.
		 * 
		 * If the DNS resolution fails, #error (if non-%NULL) will be set to
		 * a value from #GResolverError and %NULL will be returned.
		 * 
		 * If #cancellable is non-%NULL, it can be used to cancel the
		 * operation, in which case #error (if non-%NULL) will be set to
		 * %G_IO_ERROR_CANCELLED.
		 * @param rrname the DNS name to look up the record for
		 * @param record_type the type of DNS record to look up
		 * @param cancellable a #GCancellable, or %NULL
		 * @returns a non-empty #GList of
		 * #GVariant, or %NULL on error. You must free each of the records and the list
		 * when you are done with it. (You can use {@link G.list_free_full} with
		 * g_variant_unref() to do this.)
		 */
		lookup_records(rrname: string, record_type: ResolverRecordType, cancellable?: Cancellable | null): GLib.Variant[];
		/**
		 * Begins asynchronously performing a DNS lookup for the given
		 * #rrname, and eventually calls #callback, which must call
		 * {@link G.resolver_lookup_records_finish} to get the final result. See
		 * g_resolver_lookup_records() for more details.
		 * @param rrname the DNS name to look up the record for
		 * @param record_type the type of DNS record to look up
		 * @param cancellable a #GCancellable, or %NULL
		 * @param callback callback to call after resolution completes
		 */
		lookup_records_async(rrname: string, record_type: ResolverRecordType, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;
		/**
		 * Retrieves the result of a previous call to
		 * {@link G.resolver_lookup_records_async}. Returns a non-empty list of records as
		 * #GVariant tuples. See #GResolverRecordType for information on what the
		 * records contain.
		 * 
		 * If the DNS resolution failed, #error (if non-%NULL) will be set to
		 * a value from #GResolverError. If the operation was cancelled,
		 * #error will be set to %G_IO_ERROR_CANCELLED.
		 * @param result the result passed to your #GAsyncReadyCallback
		 * @returns a non-empty #GList of
		 * #GVariant, or %NULL on error. You must free each of the records and the list
		 * when you are done with it. (You can use {@link G.list_free_full} with
		 * g_variant_unref() to do this.)
		 */
		lookup_records_finish(result: AsyncResult): GLib.Variant[];
		/**
		 * Synchronously performs a DNS SRV lookup for the given #service and
		 * #protocol in the given #domain and returns an array of #GSrvTarget.
		 * #domain may be an ASCII-only or UTF-8 hostname. Note also that the
		 * #service and #protocol arguments do not include the leading underscore
		 * that appears in the actual DNS entry.
		 * 
		 * On success, {@link G.resolver_lookup_service} will return a non-empty #GList of
		 * #GSrvTarget, sorted in order of preference. (That is, you should
		 * attempt to connect to the first target first, then the second if
		 * the first fails, etc.)
		 * 
		 * If the DNS resolution fails, #error (if non-%NULL) will be set to
		 * a value from #GResolverError and %NULL will be returned.
		 * 
		 * If #cancellable is non-%NULL, it can be used to cancel the
		 * operation, in which case #error (if non-%NULL) will be set to
		 * %G_IO_ERROR_CANCELLED.
		 * 
		 * If you are planning to connect to the service, it is usually easier
		 * to create a #GNetworkService and use its #GSocketConnectable
		 * interface.
		 * @param service the service type to look up (eg, "ldap")
		 * @param protocol the networking protocol to use for #service (eg, "tcp")
		 * @param domain the DNS domain to look up the service in
		 * @param cancellable a #GCancellable, or %NULL
		 * @returns a non-empty #GList of
		 * #GSrvTarget, or %NULL on error. You must free each of the targets and the
		 * list when you are done with it. (You can use {@link G.resolver_free_targets} to do
		 * this.)
		 */
		lookup_service(service: string, protocol: string, domain: string, cancellable?: Cancellable | null): SrvTarget[];
		/**
		 * Begins asynchronously performing a DNS SRV lookup for the given
		 * #service and #protocol in the given #domain, and eventually calls
		 * #callback, which must call {@link G.resolver_lookup_service_finish} to
		 * get the final result. See g_resolver_lookup_service() for more
		 * details.
		 * @param service the service type to look up (eg, "ldap")
		 * @param protocol the networking protocol to use for #service (eg, "tcp")
		 * @param domain the DNS domain to look up the service in
		 * @param cancellable a #GCancellable, or %NULL
		 * @param callback callback to call after resolution completes
		 */
		lookup_service_async(service: string, protocol: string, domain: string, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;
		/**
		 * Retrieves the result of a previous call to
		 * {@link G.resolver_lookup_service_async}.
		 * 
		 * If the DNS resolution failed, #error (if non-%NULL) will be set to
		 * a value from #GResolverError. If the operation was cancelled,
		 * #error will be set to %G_IO_ERROR_CANCELLED.
		 * @param result the result passed to your #GAsyncReadyCallback
		 * @returns a non-empty #GList of
		 * #GSrvTarget, or %NULL on error. See {@link G.resolver_lookup_service} for more
		 * details.
		 */
		lookup_service_finish(result: AsyncResult): SrvTarget[];
		/**
		 * Sets #resolver to be the application's default resolver (reffing
		 * #resolver, and unreffing the previous default resolver, if any).
		 * Future calls to {@link G.resolver_get_default} will return this resolver.
		 * 
		 * This can be used if an application wants to perform any sort of DNS
		 * caching or "pinning"; it can implement its own #GResolver that
		 * calls the original default resolver for DNS operations, and
		 * implements its own cache policies on top of that, and then set
		 * itself as the default resolver for all later code to use.
		 */
		set_default(): void;
		/**
		 * Emitted when the resolver notices that the system resolver
		 * configuration has changed.
		 * @param signal 
		 * @param callback Callback function
		 *  - owner: owner of the emitted event 
		 * 
		 * @returns Callback ID
		 */
		connect(signal: "reload", callback: (owner: this) => void): number;

	}

	type ResolverInitOptionsMixin = GObject.ObjectInitOptions
	export interface ResolverInitOptions extends ResolverInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link Resolver} instead.
	 */
	type ResolverMixin = IResolver & GObject.Object;

	/**
	 * #GResolver provides cancellable synchronous and asynchronous DNS
	 * resolution, for hostnames {@link (g.resolver_lookup_by_address},
	 * g_resolver_lookup_by_name() and their async variants) and SRV
	 * (service) records (g_resolver_lookup_service()).
	 * 
	 * #GNetworkAddress and #GNetworkService provide wrappers around
	 * #GResolver functionality that also implement #GSocketConnectable,
	 * making it easy to connect to a remote host/service.
	 */
	interface Resolver extends ResolverMixin {}

	class Resolver {
		public constructor(options?: Partial<ResolverInitOptions>);
		/**
		 * Frees #addresses (which should be the return value from
		 * {@link G.resolver_lookup_by_name} or g_resolver_lookup_by_name_finish()).
		 * (This is a convenience method; you can also simply free the results
		 * by hand.)
		 * @param addresses a #GList of #GInetAddress
		 */
		public static free_addresses(addresses: any[]): void;
		/**
		 * Frees #targets (which should be the return value from
		 * {@link G.resolver_lookup_service} or g_resolver_lookup_service_finish()).
		 * (This is a convenience method; you can also simply free the
		 * results by hand.)
		 * @param targets a #GList of #GSrvTarget
		 */
		public static free_targets(targets: any[]): void;
		/**
		 * Gets the default #GResolver. You should unref it when you are done
		 * with it. #GResolver may use its reference count as a hint about how
		 * many threads it should allocate for concurrent DNS resolutions.
		 * @returns the default #GResolver.
		 */
		public static get_default(): Resolver;
	}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link Settings} instead.
	 */
	interface ISettings {
		/**
		 * The name of the context that the settings are stored in.
		 */
		backend: SettingsBackend;
		/**
		 * Whether the #GSettings object is in 'delay-apply' mode. See
		 * {@link G.settings_delay} for details.
		 */
		readonly delay_apply: boolean;
		/**
		 * If this property is %TRUE, the #GSettings object has outstanding
		 * changes that will be applied when {@link G.settings_apply} is called.
		 */
		readonly has_unapplied: boolean;
		/**
		 * The path within the backend where the settings are stored.
		 */
		path: string;
		/**
		 * @deprecated
		 * Use the 'schema-id' property instead.  In a future
		 * version, this property may instead refer to a #GSettingsSchema.
		 * 
		 * The name of the schema that describes the types of keys
		 * for this #GSettings object.
		 * 
		 * The type of this property is *not* #GSettingsSchema.
		 * #GSettingsSchema has only existed since version 2.32 and
		 * unfortunately this name was used in previous versions to refer to
		 * the schema ID rather than the schema itself.  Take care to use the
		 * 'settings-schema' property if you wish to pass in a
		 * #GSettingsSchema.
		 */
		schema: string;
		/**
		 * The name of the schema that describes the types of keys
		 * for this #GSettings object.
		 */
		schema_id: string;
		/**
		 * The #GSettingsSchema describing the types of keys for this
		 * #GSettings object.
		 * 
		 * Ideally, this property would be called 'schema'.  #GSettingsSchema
		 * has only existed since version 2.32, however, and before then the
		 * 'schema' property was used to refer to the ID of the schema rather
		 * than the schema itself.  Take care.
		 */
		settings_schema: SettingsSchema;
		/**
		 * Applies any changes that have been made to the settings.  This
		 * function does nothing unless #settings is in 'delay-apply' mode;
		 * see {@link G.settings_delay}.  In the normal case settings are always
		 * applied immediately.
		 */
		apply(): void;
		/**
		 * Create a binding between the #key in the #settings object
		 * and the property #property of #object.
		 * 
		 * The binding uses the default GIO mapping functions to map
		 * between the settings and property values. These functions
		 * handle booleans, numeric types and string types in a
		 * straightforward way. Use {@link G.settings_bind_with_mapping} if
		 * you need a custom mapping, or map between types that are not
		 * supported by the default mapping functions.
		 * 
		 * Unless the #flags include %G_SETTINGS_BIND_NO_SENSITIVITY, this
		 * function also establishes a binding between the writability of
		 * #key and the "sensitive" property of #object (if #object has
		 * a boolean property by that name). See g_settings_bind_writable()
		 * for more details about writable bindings.
		 * 
		 * Note that the lifecycle of the binding is tied to #object,
		 * and that you can have only one binding per object property.
		 * If you bind the same property twice on the same object, the second
		 * binding overrides the first one.
		 * @param key the key to bind
		 * @param object a #GObject
		 * @param property the name of the property to bind
		 * @param flags flags for the binding
		 */
		bind(key: string, object: GObject.Object, property: string, flags: SettingsBindFlags): void;
		/**
		 * Create a binding between the #key in the #settings object
		 * and the property #property of #object.
		 * 
		 * The binding uses the provided mapping functions to map between
		 * settings and property values.
		 * 
		 * Note that the lifecycle of the binding is tied to #object,
		 * and that you can have only one binding per object property.
		 * If you bind the same property twice on the same object, the second
		 * binding overrides the first one.
		 * @param key the key to bind
		 * @param object a #GObject
		 * @param property the name of the property to bind
		 * @param flags flags for the binding
		 * @param get_mapping a function that gets called to convert values
		 *     from #settings to #object, or %NULL to use the default GIO mapping
		 * @param set_mapping a function that gets called to convert values
		 *     from #object to #settings, or %NULL to use the default GIO mapping
		 */
		bind_with_mapping(key: string, object: GObject.Object, property: string, flags: SettingsBindFlags, get_mapping: SettingsBindGetMapping, set_mapping: SettingsBindSetMapping): void;
		/**
		 * Create a binding between the writability of #key in the
		 * #settings object and the property #property of #object.
		 * The property must be boolean; "sensitive" or "visible"
		 * properties of widgets are the most likely candidates.
		 * 
		 * Writable bindings are always uni-directional; changes of the
		 * writability of the setting will be propagated to the object
		 * property, not the other way.
		 * 
		 * When the #inverted argument is %TRUE, the binding inverts the
		 * value as it passes from the setting to the object, i.e. #property
		 * will be set to %TRUE if the key is not writable.
		 * 
		 * Note that the lifecycle of the binding is tied to #object,
		 * and that you can have only one binding per object property.
		 * If you bind the same property twice on the same object, the second
		 * binding overrides the first one.
		 * @param key the key to bind
		 * @param object a #GObject
		 * @param property the name of a boolean property to bind
		 * @param inverted whether to 'invert' the value
		 */
		bind_writable(key: string, object: GObject.Object, property: string, inverted: boolean): void;
		/**
		 * Creates a #GAction corresponding to a given #GSettings key.
		 * 
		 * The action has the same name as the key.
		 * 
		 * The value of the key becomes the state of the action and the action
		 * is enabled when the key is writable.  Changing the state of the
		 * action results in the key being written to.  Changes to the value or
		 * writability of the key cause appropriate change notifications to be
		 * emitted for the action.
		 * 
		 * For boolean-valued keys, action activations take no parameter and
		 * result in the toggling of the value.  For all other types,
		 * activations take the new value for the key (which must have the
		 * correct type).
		 * @param key the name of a key in #settings
		 * @returns a new #GAction
		 */
		create_action(key: string): Action;
		/**
		 * Changes the #GSettings object into 'delay-apply' mode. In this
		 * mode, changes to #settings are not immediately propagated to the
		 * backend, but kept locally until {@link G.settings_apply} is called.
		 */
		delay(): void;
		/**
		 * Gets the value that is stored at #key in #settings.
		 * 
		 * A convenience function that combines {@link G.settings_get_value} with
		 * g_variant_get().
		 * 
		 * It is a programmer error to give a #key that isn't contained in the
		 * schema for #settings or for the #GVariantType of #format to mismatch
		 * the type given in the schema.
		 * @param key the key to get the value for
		 * @param format a #GVariant format string
		 */
		get(key: string, format: string): void;
		/**
		 * Gets the value that is stored at #key in #settings.
		 * 
		 * A convenience variant of {@link G.settings_get} for booleans.
		 * 
		 * It is a programmer error to give a #key that isn't specified as
		 * having a boolean type in the schema for #settings.
		 * @param key the key to get the value for
		 * @returns a boolean
		 */
		get_boolean(key: string): boolean;
		/**
		 * Creates a child settings object which has a base path of
		 * `base-path/#name`, where `base-path` is the base path of
		 * #settings.
		 * 
		 * The schema for the child settings object must have been declared
		 * in the schema of #settings using a <child> element.
		 * @param name the name of the child schema
		 * @returns a 'child' settings object
		 */
		get_child(name: string): Settings;
		/**
		 * Gets the "default value" of a key.
		 * 
		 * This is the value that would be read if {@link G.settings_reset} were to be
		 * called on the key.
		 * 
		 * Note that this may be a different value than returned by
		 * g_settings_schema_key_get_default_value() if the system administrator
		 * has provided a default value.
		 * 
		 * Comparing the return values of g_settings_get_default_value() and
		 * g_settings_get_value() is not sufficient for determining if a value
		 * has been set because the user may have explicitly set the value to
		 * something that happens to be equal to the default.  The difference
		 * here is that if the default changes in the future, the user's key
		 * will still be set.
		 * 
		 * This function may be useful for adding an indication to a UI of what
		 * the default value was before the user set it.
		 * 
		 * It is a programmer error to give a #key that isn't contained in the
		 * schema for #settings.
		 * @param key the key to get the default value for
		 * @returns the default value
		 */
		get_default_value(key: string): GLib.Variant | null;
		/**
		 * Gets the value that is stored at #key in #settings.
		 * 
		 * A convenience variant of {@link G.settings_get} for doubles.
		 * 
		 * It is a programmer error to give a #key that isn't specified as
		 * having a 'double' type in the schema for #settings.
		 * @param key the key to get the value for
		 * @returns a double
		 */
		get_double(key: string): number;
		/**
		 * Gets the value that is stored in #settings for #key and converts it
		 * to the enum value that it represents.
		 * 
		 * In order to use this function the type of the value must be a string
		 * and it must be marked in the schema file as an enumerated type.
		 * 
		 * It is a programmer error to give a #key that isn't contained in the
		 * schema for #settings or is not marked as an enumerated type.
		 * 
		 * If the value stored in the configuration database is not a valid
		 * value for the enumerated type then this function will return the
		 * default value.
		 * @param key the key to get the value for
		 * @returns the enum value
		 */
		get_enum(key: string): number;
		/**
		 * Gets the value that is stored in #settings for #key and converts it
		 * to the flags value that it represents.
		 * 
		 * In order to use this function the type of the value must be an array
		 * of strings and it must be marked in the schema file as a flags type.
		 * 
		 * It is a programmer error to give a #key that isn't contained in the
		 * schema for #settings or is not marked as a flags type.
		 * 
		 * If the value stored in the configuration database is not a valid
		 * value for the flags type then this function will return the default
		 * value.
		 * @param key the key to get the value for
		 * @returns the flags value
		 */
		get_flags(key: string): number;
		/**
		 * Returns whether the #GSettings object has any unapplied
		 * changes.  This can only be the case if it is in 'delayed-apply' mode.
		 * @returns %TRUE if #settings has unapplied changes
		 */
		get_has_unapplied(): boolean;
		/**
		 * Gets the value that is stored at #key in #settings.
		 * 
		 * A convenience variant of {@link G.settings_get} for 32-bit integers.
		 * 
		 * It is a programmer error to give a #key that isn't specified as
		 * having a int32 type in the schema for #settings.
		 * @param key the key to get the value for
		 * @returns an integer
		 */
		get_int(key: string): number;
		/**
		 * Gets the value that is stored at #key in #settings.
		 * 
		 * A convenience variant of {@link G.settings_get} for 64-bit integers.
		 * 
		 * It is a programmer error to give a #key that isn't specified as
		 * having a int64 type in the schema for #settings.
		 * @param key the key to get the value for
		 * @returns a 64-bit integer
		 */
		get_int64(key: string): number;
		/**
		 * Gets the value that is stored at #key in #settings, subject to
		 * application-level validation/mapping.
		 * 
		 * You should use this function when the application needs to perform
		 * some processing on the value of the key (for example, parsing).  The
		 * #mapping function performs that processing.  If the function
		 * indicates that the processing was unsuccessful (due to a parse error,
		 * for example) then the mapping is tried again with another value.
		 * 
		 * This allows a robust 'fall back to defaults' behaviour to be
		 * implemented somewhat automatically.
		 * 
		 * The first value that is tried is the user's setting for the key.  If
		 * the mapping function fails to map this value, other values may be
		 * tried in an unspecified order (system or site defaults, translated
		 * schema default values, untranslated schema default values, etc).
		 * 
		 * If the mapping function fails for all possible values, one additional
		 * attempt is made: the mapping function is called with a %NULL value.
		 * If the mapping function still indicates failure at this point then
		 * the application will be aborted.
		 * 
		 * The result parameter for the #mapping function is pointed to a
		 * #gpointer which is initially set to %NULL.  The same pointer is given
		 * to each invocation of #mapping.  The final value of that #gpointer is
		 * what is returned by this function.  %NULL is valid; it is returned
		 * just as any other value would be.
		 * @param key the key to get the value for
		 * @param mapping the function to map the value in the
		 *           settings database to the value used by the application
		 * @returns the result, which may be %NULL
		 */
		get_mapped(key: string, mapping: SettingsGetMapping): any | null;
		/**
		 * @deprecated
		 * Use {@link G.settings_schema_key_get_range} instead.
		 * 
		 * Queries the range of a key.
		 * @param key the key to query the range of
		 * @returns 
		 */
		get_range(key: string): GLib.Variant;
		/**
		 * Gets the value that is stored at #key in #settings.
		 * 
		 * A convenience variant of {@link G.settings_get} for strings.
		 * 
		 * It is a programmer error to give a #key that isn't specified as
		 * having a string type in the schema for #settings.
		 * @param key the key to get the value for
		 * @returns a newly-allocated string
		 */
		get_string(key: string): string;
		/**
		 * A convenience variant of {@link G.settings_get} for string arrays.
		 * 
		 * It is a programmer error to give a #key that isn't specified as
		 * having an array of strings type in the schema for #settings.
		 * @param key the key to get the value for
		 * @returns a
		 * newly-allocated, %NULL-terminated array of strings, the value that
		 * is stored at #key in #settings.
		 */
		get_strv(key: string): string[];
		/**
		 * Gets the value that is stored at #key in #settings.
		 * 
		 * A convenience variant of {@link G.settings_get} for 32-bit unsigned
		 * integers.
		 * 
		 * It is a programmer error to give a #key that isn't specified as
		 * having a uint32 type in the schema for #settings.
		 * @param key the key to get the value for
		 * @returns an unsigned integer
		 */
		get_uint(key: string): number;
		/**
		 * Gets the value that is stored at #key in #settings.
		 * 
		 * A convenience variant of {@link G.settings_get} for 64-bit unsigned
		 * integers.
		 * 
		 * It is a programmer error to give a #key that isn't specified as
		 * having a uint64 type in the schema for #settings.
		 * @param key the key to get the value for
		 * @returns a 64-bit unsigned integer
		 */
		get_uint64(key: string): number;
		/**
		 * Checks the "user value" of a key, if there is one.
		 * 
		 * The user value of a key is the last value that was set by the user.
		 * 
		 * After calling {@link G.settings_reset} this function should always return
		 * %NULL (assuming something is not wrong with the system
		 * configuration).
		 * 
		 * It is possible that g_settings_get_value() will return a different
		 * value than this function.  This can happen in the case that the user
		 * set a value for a key that was subsequently locked down by the system
		 * administrator -- this function will return the user's old value.
		 * 
		 * This function may be useful for adding a "reset" option to a UI or
		 * for providing indication that a particular value has been changed.
		 * 
		 * It is a programmer error to give a #key that isn't contained in the
		 * schema for #settings.
		 * @param key the key to get the user value for
		 * @returns the user's value, if set
		 */
		get_user_value(key: string): GLib.Variant | null;
		/**
		 * Gets the value that is stored in #settings for #key.
		 * 
		 * It is a programmer error to give a #key that isn't contained in the
		 * schema for #settings.
		 * @param key the key to get the value for
		 * @returns a new #GVariant
		 */
		get_value(key: string): GLib.Variant;
		/**
		 * Finds out if a key can be written or not
		 * @param name the name of a key
		 * @returns %TRUE if the key #name is writable
		 */
		is_writable(name: string): boolean;
		/**
		 * Gets the list of children on #settings.
		 * 
		 * The list is exactly the list of strings for which it is not an error
		 * to call {@link G.settings_get_child}.
		 * 
		 * There is little reason to call this function from "normal" code, since
		 * you should already know what children are in your schema. This function
		 * may still be useful there for introspection reasons, however.
		 * 
		 * You should free the return value with g_strfreev() when you are done
		 * with it.
		 * @returns a list of the children on
		 *    #settings, in no defined order
		 */
		list_children(): string[];
		/**
		 * @deprecated
		 * Use {@link G.settings_schema_list_keys} instead.
		 * 
		 * Introspects the list of keys on #settings.
		 * 
		 * You should probably not be calling this function from "normal" code
		 * (since you should already know what keys are in your schema).  This
		 * function is intended for introspection reasons.
		 * 
		 * You should free the return value with {@link G.strfreev} when you are done
		 * with it.
		 * @returns a list of the keys on
		 *    #settings, in no defined order
		 */
		list_keys(): string[];
		/**
		 * @deprecated
		 * Use {@link G.settings_schema_key_range_check} instead.
		 * 
		 * Checks if the given #value is of the correct type and within the
		 * permitted range for #key.
		 * @param key the key to check
		 * @param value the value to check
		 * @returns %TRUE if #value is valid for #key
		 */
		range_check(key: string, value: GLib.Variant): boolean;
		/**
		 * Resets #key to its default value.
		 * 
		 * This call resets the key, as much as possible, to its default value.
		 * That might be the value specified in the schema or the one set by the
		 * administrator.
		 * @param key the name of a key
		 */
		reset(key: string): void;
		/**
		 * Reverts all non-applied changes to the settings.  This function
		 * does nothing unless #settings is in 'delay-apply' mode; see
		 * {@link G.settings_delay}.  In the normal case settings are always applied
		 * immediately.
		 * 
		 * Change notifications will be emitted for affected keys.
		 */
		revert(): void;
		/**
		 * Sets #key in #settings to #value.
		 * 
		 * A convenience function that combines {@link G.settings_set_value} with
		 * g_variant_new().
		 * 
		 * It is a programmer error to give a #key that isn't contained in the
		 * schema for #settings or for the #GVariantType of #format to mismatch
		 * the type given in the schema.
		 * @param key the name of the key to set
		 * @param format a #GVariant format string
		 * @returns %TRUE if setting the key succeeded,
		 *     %FALSE if the key was not writable
		 */
		set(key: string, format: string): boolean;
		/**
		 * Sets #key in #settings to #value.
		 * 
		 * A convenience variant of {@link G.settings_set} for booleans.
		 * 
		 * It is a programmer error to give a #key that isn't specified as
		 * having a boolean type in the schema for #settings.
		 * @param key the name of the key to set
		 * @param value the value to set it to
		 * @returns %TRUE if setting the key succeeded,
		 *     %FALSE if the key was not writable
		 */
		set_boolean(key: string, value: boolean): boolean;
		/**
		 * Sets #key in #settings to #value.
		 * 
		 * A convenience variant of {@link G.settings_set} for doubles.
		 * 
		 * It is a programmer error to give a #key that isn't specified as
		 * having a 'double' type in the schema for #settings.
		 * @param key the name of the key to set
		 * @param value the value to set it to
		 * @returns %TRUE if setting the key succeeded,
		 *     %FALSE if the key was not writable
		 */
		set_double(key: string, value: number): boolean;
		/**
		 * Looks up the enumerated type nick for #value and writes it to #key,
		 * within #settings.
		 * 
		 * It is a programmer error to give a #key that isn't contained in the
		 * schema for #settings or is not marked as an enumerated type, or for
		 * #value not to be a valid value for the named type.
		 * 
		 * After performing the write, accessing #key directly with
		 * {@link G.settings_get_string} will return the 'nick' associated with
		 * #value.
		 * @param key a key, within #settings
		 * @param value an enumerated value
		 * @returns %TRUE, if the set succeeds
		 */
		set_enum(key: string, value: number): boolean;
		/**
		 * Looks up the flags type nicks for the bits specified by #value, puts
		 * them in an array of strings and writes the array to #key, within
		 * #settings.
		 * 
		 * It is a programmer error to give a #key that isn't contained in the
		 * schema for #settings or is not marked as a flags type, or for #value
		 * to contain any bits that are not value for the named type.
		 * 
		 * After performing the write, accessing #key directly with
		 * {@link G.settings_get_strv} will return an array of 'nicks'; one for each
		 * bit in #value.
		 * @param key a key, within #settings
		 * @param value a flags value
		 * @returns %TRUE, if the set succeeds
		 */
		set_flags(key: string, value: number): boolean;
		/**
		 * Sets #key in #settings to #value.
		 * 
		 * A convenience variant of {@link G.settings_set} for 32-bit integers.
		 * 
		 * It is a programmer error to give a #key that isn't specified as
		 * having a int32 type in the schema for #settings.
		 * @param key the name of the key to set
		 * @param value the value to set it to
		 * @returns %TRUE if setting the key succeeded,
		 *     %FALSE if the key was not writable
		 */
		set_int(key: string, value: number): boolean;
		/**
		 * Sets #key in #settings to #value.
		 * 
		 * A convenience variant of {@link G.settings_set} for 64-bit integers.
		 * 
		 * It is a programmer error to give a #key that isn't specified as
		 * having a int64 type in the schema for #settings.
		 * @param key the name of the key to set
		 * @param value the value to set it to
		 * @returns %TRUE if setting the key succeeded,
		 *     %FALSE if the key was not writable
		 */
		set_int64(key: string, value: number): boolean;
		/**
		 * Sets #key in #settings to #value.
		 * 
		 * A convenience variant of {@link G.settings_set} for strings.
		 * 
		 * It is a programmer error to give a #key that isn't specified as
		 * having a string type in the schema for #settings.
		 * @param key the name of the key to set
		 * @param value the value to set it to
		 * @returns %TRUE if setting the key succeeded,
		 *     %FALSE if the key was not writable
		 */
		set_string(key: string, value: string): boolean;
		/**
		 * Sets #key in #settings to #value.
		 * 
		 * A convenience variant of {@link G.settings_set} for string arrays.  If
		 * #value is %NULL, then #key is set to be the empty array.
		 * 
		 * It is a programmer error to give a #key that isn't specified as
		 * having an array of strings type in the schema for #settings.
		 * @param key the name of the key to set
		 * @param value the value to set it to, or %NULL
		 * @returns %TRUE if setting the key succeeded,
		 *     %FALSE if the key was not writable
		 */
		set_strv(key: string, value?: string[] | null): boolean;
		/**
		 * Sets #key in #settings to #value.
		 * 
		 * A convenience variant of {@link G.settings_set} for 32-bit unsigned
		 * integers.
		 * 
		 * It is a programmer error to give a #key that isn't specified as
		 * having a uint32 type in the schema for #settings.
		 * @param key the name of the key to set
		 * @param value the value to set it to
		 * @returns %TRUE if setting the key succeeded,
		 *     %FALSE if the key was not writable
		 */
		set_uint(key: string, value: number): boolean;
		/**
		 * Sets #key in #settings to #value.
		 * 
		 * A convenience variant of {@link G.settings_set} for 64-bit unsigned
		 * integers.
		 * 
		 * It is a programmer error to give a #key that isn't specified as
		 * having a uint64 type in the schema for #settings.
		 * @param key the name of the key to set
		 * @param value the value to set it to
		 * @returns %TRUE if setting the key succeeded,
		 *     %FALSE if the key was not writable
		 */
		set_uint64(key: string, value: number): boolean;
		/**
		 * Sets #key in #settings to #value.
		 * 
		 * It is a programmer error to give a #key that isn't contained in the
		 * schema for #settings or for #value to have the incorrect type, per
		 * the schema.
		 * 
		 * If #value is floating then this function consumes the reference.
		 * @param key the name of the key to set
		 * @param value a #GVariant of the correct type
		 * @returns %TRUE if setting the key succeeded,
		 *     %FALSE if the key was not writable
		 */
		set_value(key: string, value: GLib.Variant): boolean;
		/**
		 * The "change-event" signal is emitted once per change event that
		 * affects this settings object.  You should connect to this signal
		 * only if you are interested in viewing groups of changes before they
		 * are split out into multiple emissions of the "changed" signal.
		 * For most use cases it is more appropriate to use the "changed" signal.
		 * 
		 * In the event that the change event applies to one or more specified
		 * keys, #keys will be an array of #GQuark of length #n_keys.  In the
		 * event that the change event applies to the #GSettings object as a
		 * whole (ie: potentially every key has been changed) then #keys will
		 * be %NULL and #n_keys will be 0.
		 * 
		 * The default handler for this signal invokes the "changed" signal
		 * for each affected key.  If any other connected handler returns
		 * %TRUE then this default functionality will be suppressed.
		 * @param signal 
		 * @param callback Callback function
		 *  - owner: owner of the emitted event 
		 *  - keys: 
		 *        an array of #GQuarks for the changed keys, or %NULL 
		 *  - returns %TRUE to stop other handlers from being invoked for the
		 *          event. FALSE to propagate the event further. 
		 * 
		 * @returns Callback ID
		 */
		connect(signal: "change-event", callback: (owner: this, keys: GLib.Quark[] | null) => boolean): number;
		/**
		 * The "changed" signal is emitted when a key has potentially changed.
		 * You should call one of the {@link G.settings_get} calls to check the new
		 * value.
		 * 
		 * This signal supports detailed connections.  You can connect to the
		 * detailed signal "changed::x" in order to only receive callbacks
		 * when key "x" changes.
		 * 
		 * Note that #settings only emits this signal if you have read #key at
		 * least once while a signal handler was already connected for #key.
		 * @param signal 
		 * @param callback Callback function
		 *  - owner: owner of the emitted event 
		 *  - key: the name of the key that changed 
		 * 
		 * @returns Callback ID
		 */
		connect(signal: "changed", callback: (owner: this, key: string) => void): number;
		/**
		 * The "writable-change-event" signal is emitted once per writability
		 * change event that affects this settings object.  You should connect
		 * to this signal if you are interested in viewing groups of changes
		 * before they are split out into multiple emissions of the
		 * "writable-changed" signal.  For most use cases it is more
		 * appropriate to use the "writable-changed" signal.
		 * 
		 * In the event that the writability change applies only to a single
		 * key, #key will be set to the #GQuark for that key.  In the event
		 * that the writability change affects the entire settings object,
		 * #key will be 0.
		 * 
		 * The default handler for this signal invokes the "writable-changed"
		 * and "changed" signals for each affected key.  This is done because
		 * changes in writability might also imply changes in value (if for
		 * example, a new mandatory setting is introduced).  If any other
		 * connected handler returns %TRUE then this default functionality
		 * will be suppressed.
		 * @param signal 
		 * @param callback Callback function
		 *  - owner: owner of the emitted event 
		 *  - key: the quark of the key, or 0 
		 *  - returns %TRUE to stop other handlers from being invoked for the
		 *          event. FALSE to propagate the event further. 
		 * 
		 * @returns Callback ID
		 */
		connect(signal: "writable-change-event", callback: (owner: this, key: number) => boolean): number;
		/**
		 * The "writable-changed" signal is emitted when the writability of a
		 * key has potentially changed.  You should call
		 * {@link G.settings_is_writable} in order to determine the new status.
		 * 
		 * This signal supports detailed connections.  You can connect to the
		 * detailed signal "writable-changed::x" in order to only receive
		 * callbacks when the writability of "x" changes.
		 * @param signal 
		 * @param callback Callback function
		 *  - owner: owner of the emitted event 
		 *  - key: the key 
		 * 
		 * @returns Callback ID
		 */
		connect(signal: "writable-changed", callback: (owner: this, key: string) => void): number;

		connect(signal: "notify::backend", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::delay-apply", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::has-unapplied", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::path", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::schema", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::schema-id", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::settings-schema", callback: (owner: this, ...args: any) => void): number;

	}

	type SettingsInitOptionsMixin = GObject.ObjectInitOptions & 
	Pick<ISettings,
		"backend" |
		"path" |
		"schema" |
		"schema_id" |
		"settings_schema">;

	export interface SettingsInitOptions extends SettingsInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link Settings} instead.
	 */
	type SettingsMixin = ISettings & GObject.Object;

	/**
	 * The #GSettings class provides a convenient API for storing and retrieving
	 * application settings.
	 * 
	 * Reads and writes can be considered to be non-blocking.  Reading
	 * settings with #GSettings is typically extremely fast: on
	 * approximately the same order of magnitude (but slower than) a
	 * #GHashTable lookup.  Writing settings is also extremely fast in terms
	 * of time to return to your application, but can be extremely expensive
	 * for other threads and other processes.  Many settings backends
	 * (including dconf) have lazy initialisation which means in the common
	 * case of the user using their computer without modifying any settings
	 * a lot of work can be avoided.  For dconf, the D-Bus service doesn't
	 * even need to be started in this case.  For this reason, you should
	 * only ever modify #GSettings keys in response to explicit user action.
	 * Particular care should be paid to ensure that modifications are not
	 * made during startup -- for example, when setting the initial value
	 * of preferences widgets.  The built-in {@link G.settings_bind} functionality
	 * is careful not to write settings in response to notify signals as a
	 * result of modifications that it makes to widgets.
	 * 
	 * When creating a GSettings instance, you have to specify a schema
	 * that describes the keys in your settings and their types and default
	 * values, as well as some other information.
	 * 
	 * Normally, a schema has a fixed path that determines where the settings
	 * are stored in the conceptual global tree of settings. However, schemas
	 * can also be '[relocatable][gsettings-relocatable]', i.e. not equipped with
	 * a fixed path. This is
	 * useful e.g. when the schema describes an 'account', and you want to be
	 * able to store a arbitrary number of accounts.
	 * 
	 * Paths must start with and end with a forward slash character ('/')
	 * and must not contain two sequential slash characters.  Paths should
	 * be chosen based on a domain name associated with the program or
	 * library to which the settings belong.  Examples of paths are
	 * "/org/gtk/settings/file-chooser/" and "/ca/desrt/dconf-editor/".
	 * Paths should not start with "/apps/", "/desktop/" or "/system/" as
	 * they often did in GConf.
	 * 
	 * Unlike other configuration systems (like GConf), GSettings does not
	 * restrict keys to basic types like strings and numbers. GSettings stores
	 * values as #GVariant, and allows any #GVariantType for keys. Key names
	 * are restricted to lowercase characters, numbers and '-'. Furthermore,
	 * the names must begin with a lowercase character, must not end
	 * with a '-', and must not contain consecutive dashes.
	 * 
	 * Similar to GConf, the default values in GSettings schemas can be
	 * localized, but the localized values are stored in gettext catalogs
	 * and looked up with the domain that is specified in the
	 * `gettext-domain` attribute of the <schemalist> or <schema>
	 * elements and the category that is specified in the `l10n` attribute of
	 * the <default> element. The string which is translated includes all text in
	 * the <default> element, including any surrounding quotation marks.
	 * 
	 * The `l10n` attribute must be set to `messages` or `time`, and sets the
	 * [locale category for
	 * translation](https://www.gnu.org/software/gettext/manual/html_node/Aspects.html#index-locale-categories-1).
	 * The `messages` category should be used by default; use `time` for
	 * translatable date or time formats. A translation comment can be added as an
	 * XML comment immediately above the <default> element — it is recommended to
	 * add these comments to aid translators understand the meaning and
	 * implications of the default value. An optional translation `context`
	 * attribute can be set on the <default> element to disambiguate multiple
	 * defaults which use the same string.
	 * 
	 * For example:
	 * |[
	 *  <!-- Translators: A list of words which are not allowed to be typed, in
	 *       GVariant serialization syntax.
	 *       See: https://developer.gnome.org/glib/stable/gvariant-text.html -->
	 *  <default l10n='messages' context='Banned words'>['bad', 'words']</default>
	 * ]|
	 * 
	 * Translations of default values must remain syntactically valid serialized
	 * #GVariants (e.g. retaining any surrounding quotation marks) or runtime
	 * errors will occur.
	 * 
	 * GSettings uses schemas in a compact binary form that is created
	 * by the [glib-compile-schemas][glib-compile-schemas]
	 * utility. The input is a schema description in an XML format.
	 * 
	 * A DTD for the gschema XML format can be found here:
	 * [gschema.dtd](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/gschema.dtd)
	 * 
	 * The [glib-compile-schemas][glib-compile-schemas] tool expects schema
	 * files to have the extension `.gschema.xml`.
	 * 
	 * At runtime, schemas are identified by their id (as specified in the
	 * id attribute of the <schema> element). The convention for schema
	 * ids is to use a dotted name, similar in style to a D-Bus bus name,
	 * e.g. "org.gnome.SessionManager". In particular, if the settings are
	 * for a specific service that owns a D-Bus bus name, the D-Bus bus name
	 * and schema id should match. For schemas which deal with settings not
	 * associated with one named application, the id should not use
	 * StudlyCaps, e.g. "org.gnome.font-rendering".
	 * 
	 * In addition to #GVariant types, keys can have types that have
	 * enumerated types. These can be described by a <choice>,
	 * <enum> or <flags> element, as seen in the
	 * [example][schema-enumerated]. The underlying type of such a key
	 * is string, but you can use g_settings_get_enum(), g_settings_set_enum(),
	 * g_settings_get_flags(), g_settings_set_flags() access the numeric values
	 * corresponding to the string value of enum and flags keys.
	 * 
	 * An example for default value:
	 * |[
	 * <schemalist>
	 *   <schema id="org.gtk.Test" path="/org/gtk/Test/" gettext-domain="test">
	 * 
	 *     <key name="greeting" type="s">
	 *       <default l10n="messages">"Hello, earthlings"</default>
	 *       <summary>A greeting</summary>
	 *       <description>
	 *         Greeting of the invading martians
	 *       </description>
	 *     </key>
	 * 
	 *     <key name="box" type="(ii)">
	 *       <default>(20,30)</default>
	 *     </key>
	 * 
	 *     <key name="empty-string" type="s">
	 *       <default>""</default>
	 *       <summary>Empty strings have to be provided in GVariant form</summary>
	 *     </key>
	 * 
	 *   </schema>
	 * </schemalist>
	 * ]|
	 * 
	 * An example for ranges, choices and enumerated types:
	 * |[
	 * <schemalist>
	 * 
	 *   <enum id="org.gtk.Test.myenum">
	 *     <value nick="first" value="1"/>
	 *     <value nick="second" value="2"/>
	 *   </enum>
	 * 
	 *   <flags id="org.gtk.Test.myflags">
	 *     <value nick="flag1" value="1"/>
	 *     <value nick="flag2" value="2"/>
	 *     <value nick="flag3" value="4"/>
	 *   </flags>
	 * 
	 *   <schema id="org.gtk.Test">
	 * 
	 *     <key name="key-with-range" type="i">
	 *       <range min="1" max="100"/>
	 *       <default>10</default>
	 *     </key>
	 * 
	 *     <key name="key-with-choices" type="s">
	 *       <choices>
	 *         <choice value='Elisabeth'/>
	 *         <choice value='Annabeth'/>
	 *         <choice value='Joe'/>
	 *       </choices>
	 *       <aliases>
	 *         <alias value='Anna' target='Annabeth'/>
	 *         <alias value='Beth' target='Elisabeth'/>
	 *       </aliases>
	 *       <default>'Joe'</default>
	 *     </key>
	 * 
	 *     <key name='enumerated-key' enum='org.gtk.Test.myenum'>
	 *       <default>'first'</default>
	 *     </key>
	 * 
	 *     <key name='flags-key' flags='org.gtk.Test.myflags'>
	 *       <default>["flag1","flag2"]</default>
	 *     </key>
	 *   </schema>
	 * </schemalist>
	 * ]|
	 * 
	 * ## Vendor overrides
	 * 
	 * Default values are defined in the schemas that get installed by
	 * an application. Sometimes, it is necessary for a vendor or distributor
	 * to adjust these defaults. Since patching the XML source for the schema
	 * is inconvenient and error-prone,
	 * [glib-compile-schemas][glib-compile-schemas] reads so-called vendor
	 * override' files. These are keyfiles in the same directory as the XML
	 * schema sources which can override default values. The schema id serves
	 * as the group name in the key file, and the values are expected in
	 * serialized GVariant form, as in the following example:
	 * |[
	 *     [org.gtk.Example]
	 *     key1='string'
	 *     key2=1.5
	 * ]|
	 * 
	 * glib-compile-schemas expects schema files to have the extension
	 * `.gschema.override`.
	 * 
	 * ## Binding
	 * 
	 * A very convenient feature of GSettings lets you bind #GObject properties
	 * directly to settings, using g_settings_bind(). Once a GObject property
	 * has been bound to a setting, changes on either side are automatically
	 * propagated to the other side. GSettings handles details like mapping
	 * between GObject and GVariant types, and preventing infinite cycles.
	 * 
	 * This makes it very easy to hook up a preferences dialog to the
	 * underlying settings. To make this even more convenient, GSettings
	 * looks for a boolean property with the name "sensitivity" and
	 * automatically binds it to the writability of the bound setting.
	 * If this 'magic' gets in the way, it can be suppressed with the
	 * #G_SETTINGS_BIND_NO_SENSITIVITY flag.
	 * 
	 * ## Relocatable schemas # {#gsettings-relocatable}
	 * 
	 * A relocatable schema is one with no `path` attribute specified on its
	 * <schema> element. By using g_settings_new_with_path(), a #GSettings object
	 * can be instantiated for a relocatable schema, assigning a path to the
	 * instance. Paths passed to g_settings_new_with_path() will typically be
	 * constructed dynamically from a constant prefix plus some form of instance
	 * identifier; but they must still be valid GSettings paths. Paths could also
	 * be constant and used with a globally installed schema originating from a
	 * dependency library.
	 * 
	 * For example, a relocatable schema could be used to store geometry information
	 * for different windows in an application. If the schema ID was
	 * `org.foo.MyApp.Window`, it could be instantiated for paths
	 * `/org/foo/MyApp/main/`, `/org/foo/MyApp/document-1/`,
	 * `/org/foo/MyApp/document-2/`, etc. If any of the paths are well-known
	 * they can be specified as <child> elements in the parent schema, e.g.:
	 * |[
	 * <schema id="org.foo.MyApp" path="/org/foo/MyApp/">
	 *   <child name="main" schema="org.foo.MyApp.Window"/>
	 * </schema>
	 * ]|
	 * 
	 * ## Build system integration # {#gsettings-build-system}
	 * 
	 * GSettings comes with autotools integration to simplify compiling and
	 * installing schemas. To add GSettings support to an application, add the
	 * following to your `configure.ac`:
	 * |[
	 * GLIB_GSETTINGS
	 * ]|
	 * 
	 * In the appropriate `Makefile.am`, use the following snippet to compile and
	 * install the named schema:
	 * |[
	 * gsettings_SCHEMAS = org.foo.MyApp.gschema.xml
	 * EXTRA_DIST = $(gsettings_SCHEMAS)
	 * 
	 * #GSETTINGS_RULES#
	 * ]|
	 * 
	 * No changes are needed to the build system to mark a schema XML file for
	 * translation. Assuming it sets the `gettext-domain` attribute, a schema may
	 * be marked for translation by adding it to `POTFILES.in`, assuming gettext
	 * 0.19 is in use (the preferred method for translation):
	 * |[
	 * data/org.foo.MyApp.gschema.xml
	 * ]|
	 * 
	 * Alternatively, if intltool 0.50.1 is in use:
	 * |[
	 * [type: gettext/gsettings]data/org.foo.MyApp.gschema.xml
	 * ]|
	 * 
	 * GSettings will use gettext to look up translations for the <summary> and
	 * <description> elements, and also any <default> elements which have a `l10n`
	 * attribute set. Translations must not be included in the `.gschema.xml` file
	 * by the build system, for example by using intltool XML rules with a
	 * `.gschema.xml.in` template.
	 * 
	 * If an enumerated type defined in a C header file is to be used in a GSettings
	 * schema, it can either be defined manually using an <enum> element in the
	 * schema XML, or it can be extracted automatically from the C header. This
	 * approach is preferred, as it ensures the two representations are always
	 * synchronised. To do so, add the following to the relevant `Makefile.am`:
	 * |[
	 * gsettings_ENUM_NAMESPACE = org.foo.MyApp
	 * gsettings_ENUM_FILES = my-app-enums.h my-app-misc.h
	 * ]|
	 * 
	 * `gsettings_ENUM_NAMESPACE` specifies the schema namespace for the enum files,
	 * which are specified in `gsettings_ENUM_FILES`. This will generate a
	 * `org.foo.MyApp.enums.xml` file containing the extracted enums, which will be
	 * automatically included in the schema compilation, install and uninstall
	 * rules. It should not be committed to version control or included in
	 * `EXTRA_DIST`.
	 */
	interface Settings extends SettingsMixin {}

	class Settings {
		public constructor(options?: Partial<SettingsInitOptions>);
		/**
		 * Creates a new #GSettings object with the schema specified by
		 * #schema_id.
		 * 
		 * It is an error for the schema to not exist: schemas are an
		 * essential part of a program, as they provide type information.
		 * If schemas need to be dynamically loaded (for example, from an
		 * optional runtime dependency), {@link G.settings_schema_source_lookup}
		 * can be used to test for their existence before loading them.
		 * 
		 * Signals on the newly created #GSettings object will be dispatched
		 * via the thread-default #GMainContext in effect at the time of the
		 * call to g_settings_new().  The new #GSettings will hold a reference
		 * on the context.  See g_main_context_push_thread_default().
		 * @param schema_id the id of the schema
		 * @returns a new #GSettings object
		 */
		public static new(schema_id: string): Settings;
		/**
		 * Creates a new #GSettings object with a given schema, backend and
		 * path.
		 * 
		 * It should be extremely rare that you ever want to use this function.
		 * It is made available for advanced use-cases (such as plugin systems
		 * that want to provide access to schemas loaded from custom locations,
		 * etc).
		 * 
		 * At the most basic level, a #GSettings object is a pure composition of
		 * 4 things: a #GSettingsSchema, a #GSettingsBackend, a path within that
		 * backend, and a #GMainContext to which signals are dispatched.
		 * 
		 * This constructor therefore gives you full control over constructing
		 * #GSettings instances.  The first 3 parameters are given directly as
		 * #schema, #backend and #path, and the main context is taken from the
		 * thread-default (as per {@link G.settings_new}).
		 * 
		 * If #backend is %NULL then the default backend is used.
		 * 
		 * If #path is %NULL then the path from the schema is used.  It is an
		 * error if #path is %NULL and the schema has no path of its own or if
		 * #path is non-%NULL and not equal to the path that the schema does
		 * have.
		 * @param schema a #GSettingsSchema
		 * @param backend a #GSettingsBackend
		 * @param path the path to use
		 * @returns a new #GSettings object
		 */
		public static new_full(schema: SettingsSchema, backend?: SettingsBackend | null, path?: string | null): Settings;
		/**
		 * Creates a new #GSettings object with the schema specified by
		 * #schema_id and a given #GSettingsBackend.
		 * 
		 * Creating a #GSettings object with a different backend allows accessing
		 * settings from a database other than the usual one. For example, it may make
		 * sense to pass a backend corresponding to the "defaults" settings database on
		 * the system to get a settings object that modifies the system default
		 * settings instead of the settings for this user.
		 * @param schema_id the id of the schema
		 * @param backend the #GSettingsBackend to use
		 * @returns a new #GSettings object
		 */
		public static new_with_backend(schema_id: string, backend: SettingsBackend): Settings;
		/**
		 * Creates a new #GSettings object with the schema specified by
		 * #schema_id and a given #GSettingsBackend and path.
		 * 
		 * This is a mix of {@link G.settings_new_with_backend} and
		 * g_settings_new_with_path().
		 * @param schema_id the id of the schema
		 * @param backend the #GSettingsBackend to use
		 * @param path the path to use
		 * @returns a new #GSettings object
		 */
		public static new_with_backend_and_path(schema_id: string, backend: SettingsBackend, path: string): Settings;
		/**
		 * Creates a new #GSettings object with the relocatable schema specified
		 * by #schema_id and a given path.
		 * 
		 * You only need to do this if you want to directly create a settings
		 * object with a schema that doesn't have a specified path of its own.
		 * That's quite rare.
		 * 
		 * It is a programmer error to call this function for a schema that
		 * has an explicitly specified path.
		 * 
		 * It is a programmer error if #path is not a valid path.  A valid path
		 * begins and ends with '/' and does not contain two consecutive '/'
		 * characters.
		 * @param schema_id the id of the schema
		 * @param path the path to use
		 * @returns a new #GSettings object
		 */
		public static new_with_path(schema_id: string, path: string): Settings;
		/**
		 * @deprecated
		 * Use {@link G.settings_schema_source_list_schemas} instead
		 * 
		 * Deprecated.
		 * @returns a list of relocatable
		 *   #GSettings schemas that are available, in no defined order.  The list must
		 *   not be modified or freed.
		 */
		public static list_relocatable_schemas(): string[];
		/**
		 * @deprecated
		 * Use {@link G.settings_schema_source_list_schemas} instead.
		 * If you used g_settings_list_schemas() to check for the presence of
		 * a particular schema, use g_settings_schema_source_lookup() instead
		 * of your whole loop.
		 * 
		 * Deprecated.
		 * @returns a list of #GSettings
		 *   schemas that are available, in no defined order.  The list must not be
		 *   modified or freed.
		 */
		public static list_schemas(): string[];
		/**
		 * Ensures that all pending operations are complete for the default backend.
		 * 
		 * Writes made to a #GSettings are handled asynchronously.  For this
		 * reason, it is very unlikely that the changes have it to disk by the
		 * time {@link G.settings_set} returns.
		 * 
		 * This call will block until all of the writes have made it to the
		 * backend.  Since the mainloop is not running, no change notifications
		 * will be dispatched during this call (but some may be queued by the
		 * time the call is done).
		 */
		public static sync(): void;
		/**
		 * Removes an existing binding for #property on #object.
		 * 
		 * Note that bindings are automatically removed when the
		 * object is finalized, so it is rarely necessary to call this
		 * function.
		 * @param object the object
		 * @param property the property whose binding is removed
		 */
		public static unbind(object: GObject.Object, property: string): void;
	}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link SettingsBackend} instead.
	 */
	interface ISettingsBackend {
		/**
		 * Signals that a single key has possibly changed.  Backend
		 * implementations should call this if a key has possibly changed its
		 * value.
		 * 
		 * #key must be a valid key (ie starting with a slash, not containing
		 * '//', and not ending with a slash).
		 * 
		 * The implementation must call this function during any call to
		 * {@link G.settings_backend_write}, before the call returns (except in the
		 * case that no keys are actually changed and it cares to detect this
		 * fact).  It may not rely on the existence of a mainloop for
		 * dispatching the signal later.
		 * 
		 * The implementation may call this function at any other time it likes
		 * in response to other events (such as changes occurring outside of the
		 * program).  These calls may originate from a mainloop or may originate
		 * in response to any other action (including from calls to
		 * g_settings_backend_write()).
		 * 
		 * In the case that this call is in response to a call to
		 * g_settings_backend_write() then #origin_tag must be set to the same
		 * value that was passed to that call.
		 * @param key the name of the key
		 * @param origin_tag the origin tag
		 */
		changed(key: string, origin_tag?: any | null): void;
		/**
		 * This call is a convenience wrapper.  It gets the list of changes from
		 * #tree, computes the longest common prefix and calls
		 * {@link G.settings_backend_changed}.
		 * @param tree a #GTree containing the changes
		 * @param origin_tag the origin tag
		 */
		changed_tree(tree: GLib.Tree, origin_tag?: any | null): void;
		/**
		 * Signals that a list of keys have possibly changed.  Backend
		 * implementations should call this if keys have possibly changed their
		 * values.
		 * 
		 * #path must be a valid path (ie starting and ending with a slash and
		 * not containing '//').  Each string in #items must form a valid key
		 * name when #path is prefixed to it (ie: each item must not start or
		 * end with '/' and must not contain '//').
		 * 
		 * The meaning of this signal is that any of the key names resulting
		 * from the contatenation of #path with each item in #items may have
		 * changed.
		 * 
		 * The same rules for when notifications must occur apply as per
		 * {@link G.settings_backend_changed}.  These two calls can be used
		 * interchangeably if exactly one item has changed (although in that
		 * case g_settings_backend_changed() is definitely preferred).
		 * 
		 * For efficiency reasons, the implementation should strive for #path to
		 * be as long as possible (ie: the longest common prefix of all of the
		 * keys that were changed) but this is not strictly required.
		 * @param path the path containing the changes
		 * @param items the %NULL-terminated list of changed keys
		 * @param origin_tag the origin tag
		 */
		keys_changed(path: string, items: string[], origin_tag?: any | null): void;
		/**
		 * Signals that all keys below a given path may have possibly changed.
		 * Backend implementations should call this if an entire path of keys
		 * have possibly changed their values.
		 * 
		 * #path must be a valid path (ie starting and ending with a slash and
		 * not containing '//').
		 * 
		 * The meaning of this signal is that any of the key which has a name
		 * starting with #path may have changed.
		 * 
		 * The same rules for when notifications must occur apply as per
		 * {@link G.settings_backend_changed}.  This call might be an appropriate
		 * reasponse to a 'reset' call but implementations are also free to
		 * explicitly list the keys that were affected by that call if they can
		 * easily do so.
		 * 
		 * For efficiency reasons, the implementation should strive for #path to
		 * be as long as possible (ie: the longest common prefix of all of the
		 * keys that were changed) but this is not strictly required.  As an
		 * example, if this function is called with the path of "/" then every
		 * single key in the application will be notified of a possible change.
		 * @param path the path containing the changes
		 * @param origin_tag the origin tag
		 */
		path_changed(path: string, origin_tag?: any | null): void;
		/**
		 * Signals that the writability of all keys below a given path may have
		 * changed.
		 * 
		 * Since GSettings performs no locking operations for itself, this call
		 * will always be made in response to external events.
		 * @param path the name of the path
		 */
		path_writable_changed(path: string): void;
		/**
		 * Signals that the writability of a single key has possibly changed.
		 * 
		 * Since GSettings performs no locking operations for itself, this call
		 * will always be made in response to external events.
		 * @param key the name of the key
		 */
		writable_changed(key: string): void;
	}

	type SettingsBackendInitOptionsMixin = GObject.ObjectInitOptions
	export interface SettingsBackendInitOptions extends SettingsBackendInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link SettingsBackend} instead.
	 */
	type SettingsBackendMixin = ISettingsBackend & GObject.Object;

	/**
	 * The #GSettingsBackend interface defines a generic interface for
	 * non-strictly-typed data that is stored in a hierarchy. To implement
	 * an alternative storage backend for #GSettings, you need to implement
	 * the #GSettingsBackend interface and then make it implement the
	 * extension point #G_SETTINGS_BACKEND_EXTENSION_POINT_NAME.
	 * 
	 * The interface defines methods for reading and writing values, a
	 * method for determining if writing of certain values will fail
	 * (lockdown) and a change notification mechanism.
	 * 
	 * The semantics of the interface are very precisely defined and
	 * implementations must carefully adhere to the expectations of
	 * callers that are documented on each of the interface methods.
	 * 
	 * Some of the #GSettingsBackend functions accept or return a #GTree.
	 * These trees always have strings as keys and #GVariant as values.
	 * {@link G.settings_backend_create_tree} is a convenience function to create
	 * suitable trees.
	 * 
	 * The #GSettingsBackend API is exported to allow third-party
	 * implementations, but does not carry the same stability guarantees
	 * as the public GIO API. For this reason, you have to define the
	 * C preprocessor symbol %G_SETTINGS_ENABLE_BACKEND before including
	 * `gio/gsettingsbackend.h`.
	 */
	interface SettingsBackend extends SettingsBackendMixin {}

	class SettingsBackend {
		public constructor(options?: Partial<SettingsBackendInitOptions>);
		/**
		 * Calculate the longest common prefix of all keys in a tree and write
		 * out an array of the key names relative to that prefix and,
		 * optionally, the value to store at each of those keys.
		 * 
		 * You must free the value returned in #path, #keys and #values using
		 * {@link G.free}.  You should not attempt to free or unref the contents of
		 * #keys or #values.
		 * @param tree a #GTree containing the changes
		 * @returns the location to save the path
		 * 
		 * the
		 *        location to save the relative keys
		 * 
		 * 
		 *          the location to save the values, or %NULL
		 */
		public static flatten_tree(tree: GLib.Tree): [ string, string[], GLib.Variant[] | null ];
		/**
		 * Returns the default #GSettingsBackend. It is possible to override
		 * the default by setting the `GSETTINGS_BACKEND` environment variable
		 * to the name of a settings backend.
		 * 
		 * The user gets a reference to the backend.
		 * @returns the default #GSettingsBackend,
		 *     which will be a dummy (memory) settings backend if no other settings
		 *     backend is available.
		 */
		public static get_default(): SettingsBackend;
	}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link SimpleAction} instead.
	 */
	interface ISimpleAction {
		/**
		 * If #action is currently enabled.
		 * 
		 * If the action is disabled then calls to {@link G.action_activate} and
		 * g_action_change_state() have no effect.
		 */
		enabled: boolean;
		/**
		 * The name of the action. This is mostly meaningful for identifying
		 * the action once it has been added to a #GSimpleActionGroup.
		 */
		name: string;
		/**
		 * The type of the parameter that must be given when activating the
		 * action.
		 */
		parameter_type: GLib.VariantType;
		/**
		 * The state of the action, or %NULL if the action is stateless.
		 */
		state: GLib.Variant;
		/**
		 * The #GVariantType of the state that the action has, or %NULL if the
		 * action is stateless.
		 */
		readonly state_type: GLib.VariantType;
		/**
		 * Sets the action as enabled or not.
		 * 
		 * An action must be enabled in order to be activated or in order to
		 * have its state changed from outside callers.
		 * 
		 * This should only be called by the implementor of the action.  Users
		 * of the action should not attempt to modify its enabled flag.
		 * @param enabled whether the action is enabled
		 */
		set_enabled(enabled: boolean): void;
		/**
		 * Sets the state of the action.
		 * 
		 * This directly updates the 'state' property to the given value.
		 * 
		 * This should only be called by the implementor of the action.  Users
		 * of the action should not attempt to directly modify the 'state'
		 * property.  Instead, they should call {@link G.action_change_state} to
		 * request the change.
		 * 
		 * If the #value GVariant is floating, it is consumed.
		 * @param value the new #GVariant for the state
		 */
		set_state(value: GLib.Variant): void;
		/**
		 * Sets the state hint for the action.
		 * 
		 * See {@link G.action_get_state_hint} for more information about
		 * action state hints.
		 * @param state_hint a #GVariant representing the state hint
		 */
		set_state_hint(state_hint?: GLib.Variant | null): void;
		/**
		 * Indicates that the action was just activated.
		 * 
		 * #parameter will always be of the expected type, i.e. the parameter type
		 * specified when the action was created. If an incorrect type is given when
		 * activating the action, this signal is not emitted.
		 * 
		 * Since GLib 2.40, if no handler is connected to this signal then the
		 * default behaviour for boolean-stated actions with a %NULL parameter
		 * type is to toggle them via the #GSimpleAction::change-state signal.
		 * For stateful actions where the state type is equal to the parameter
		 * type, the default is to forward them directly to
		 * #GSimpleAction::change-state.  This should allow almost all users
		 * of #GSimpleAction to connect only one handler or the other.
		 * @param signal 
		 * @param callback Callback function
		 *  - owner: owner of the emitted event 
		 *  - parameter: the parameter to the activation, or %NULL if it has
		 *   no parameter 
		 * 
		 * @returns Callback ID
		 */
		connect(signal: "activate", callback: (owner: this, parameter: GLib.Variant | null) => void): number;
		/**
		 * Indicates that the action just received a request to change its
		 * state.
		 * 
		 * #value will always be of the correct state type, i.e. the type of the
		 * initial state passed to {@link G.simple_action_new_stateful}. If an incorrect
		 * type is given when requesting to change the state, this signal is not
		 * emitted.
		 * 
		 * If no handler is connected to this signal then the default
		 * behaviour is to call g_simple_action_set_state() to set the state
		 * to the requested value. If you connect a signal handler then no
		 * default action is taken. If the state should change then you must
		 * call g_simple_action_set_state() from the handler.
		 * 
		 * An example of a 'change-state' handler:
		 * |[<!-- language="C" -->
		 * static void
		 * change_volume_state (GSimpleAction *action,
		 *                      GVariant      *value,
		 *                      gpointer       user_data)
		 * {
		 *   gint requested;
		 * 
		 *   requested = g_variant_get_int32 (value);
		 * 
		 *   // Volume only goes from 0 to 10
		 *   if (0 <= requested && requested <= 10)
		 *     g_simple_action_set_state (action, value);
		 * }
		 * ]|
		 * 
		 * The handler need not set the state to the requested value.
		 * It could set it to any value at all, or take some other action.
		 * @param signal 
		 * @param callback Callback function
		 *  - owner: owner of the emitted event 
		 *  - value: the requested value for the state 
		 * 
		 * @returns Callback ID
		 */
		connect(signal: "change-state", callback: (owner: this, value: GLib.Variant | null) => void): number;

		connect(signal: "notify::enabled", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::name", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::parameter-type", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::state", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::state-type", callback: (owner: this, ...args: any) => void): number;

	}

	type SimpleActionInitOptionsMixin = GObject.ObjectInitOptions & ActionInitOptions & 
	Pick<ISimpleAction,
		"enabled" |
		"name" |
		"parameter_type" |
		"state">;

	export interface SimpleActionInitOptions extends SimpleActionInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link SimpleAction} instead.
	 */
	type SimpleActionMixin = ISimpleAction & GObject.Object & Action;

	/**
	 * A #GSimpleAction is the obvious simple implementation of the #GAction
	 * interface. This is the easiest way to create an action for purposes of
	 * adding it to a #GSimpleActionGroup.
	 * 
	 * See also #GtkAction.
	 */
	interface SimpleAction extends SimpleActionMixin {}

	class SimpleAction {
		public constructor(options?: Partial<SimpleActionInitOptions>);
		/**
		 * Creates a new action.
		 * 
		 * The created action is stateless. See {@link G.simple_action_new_stateful} to create
		 * an action that has state.
		 * @param name the name of the action
		 * @param parameter_type the type of parameter that will be passed to
		 *   handlers for the #GSimpleAction::activate signal, or %NULL for no parameter
		 * @returns a new #GSimpleAction
		 */
		public static new(name: string, parameter_type?: GLib.VariantType | null): SimpleAction;
		/**
		 * Creates a new stateful action.
		 * 
		 * All future state values must have the same #GVariantType as the initial
		 * #state.
		 * 
		 * If the #state #GVariant is floating, it is consumed.
		 * @param name the name of the action
		 * @param parameter_type the type of the parameter that will be passed to
		 *   handlers for the #GSimpleAction::activate signal, or %NULL for no parameter
		 * @param state the initial state of the action
		 * @returns a new #GSimpleAction
		 */
		public static new_stateful(name: string, parameter_type: GLib.VariantType | null, state: GLib.Variant): SimpleAction;
	}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link SimpleActionGroup} instead.
	 */
	interface ISimpleActionGroup {
		/**
		 * @deprecated
		 * Use {@link G.action_map_add_action_entries}
		 * 
		 * A convenience function for creating multiple #GSimpleAction instances
		 * and adding them to the action group.
		 * @param entries a pointer to the first item in
		 *           an array of #GActionEntry structs
		 * @param user_data the user data for signal connections
		 */
		add_entries(entries: ActionEntry[], user_data?: any | null): void;
		/**
		 * @deprecated
		 * Use {@link G.action_map_add_action}
		 * 
		 * Adds an action to the action group.
		 * 
		 * If the action group already contains an action with the same name as
		 * #action then the old action is dropped from the group.
		 * 
		 * The action group takes its own reference on #action.
		 * @param action a #GAction
		 */
		insert(action: Action): void;
		/**
		 * @deprecated
		 * Use {@link G.action_map_lookup_action}
		 * 
		 * Looks up the action with the name #action_name in the group.
		 * 
		 * If no such action exists, returns %NULL.
		 * @param action_name the name of an action
		 * @returns a #GAction, or %NULL
		 */
		lookup(action_name: string): Action;
		/**
		 * @deprecated
		 * Use {@link G.action_map_remove_action}
		 * 
		 * Removes the named action from the action group.
		 * 
		 * If no action of this name is in the group then nothing happens.
		 * @param action_name the name of the action
		 */
		remove(action_name: string): void;
	}

	type SimpleActionGroupInitOptionsMixin = GObject.ObjectInitOptions & ActionGroupInitOptions & ActionMapInitOptions
	export interface SimpleActionGroupInitOptions extends SimpleActionGroupInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link SimpleActionGroup} instead.
	 */
	type SimpleActionGroupMixin = ISimpleActionGroup & GObject.Object & ActionGroup & ActionMap;

	/**
	 * #GSimpleActionGroup is a hash table filled with #GAction objects,
	 * implementing the #GActionGroup and #GActionMap interfaces.
	 */
	interface SimpleActionGroup extends SimpleActionGroupMixin {}

	class SimpleActionGroup {
		public constructor(options?: Partial<SimpleActionGroupInitOptions>);
		/**
		 * Creates a new, empty, #GSimpleActionGroup.
		 * @returns a new #GSimpleActionGroup
		 */
		public static new(): SimpleActionGroup;
	}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link SimpleAsyncResult} instead.
	 */
	interface ISimpleAsyncResult {
		/**
		 * @deprecated
		 * Use #GTask instead.
		 * 
		 * Completes an asynchronous I/O job immediately. Must be called in
		 * the thread where the asynchronous result was to be delivered, as it
		 * invokes the callback directly. If you are in a different thread use
		 * {@link G.simple_async_result_complete_in_idle}.
		 * 
		 * Calling this function takes a reference to #simple for as long as
		 * is needed to complete the call.
		 */
		complete(): void;
		/**
		 * @deprecated
		 * Use #GTask instead.
		 * 
		 * Completes an asynchronous function in an idle handler in the
		 * [thread-default main context][g-main-context-push-thread-default]
		 * of the thread that #simple was initially created in
		 * (and re-pushes that context around the invocation of the callback).
		 * 
		 * Calling this function takes a reference to #simple for as long as
		 * is needed to complete the call.
		 */
		complete_in_idle(): void;
		/**
		 * @deprecated
		 * Use #GTask and {@link G.task_propagate_boolean} instead.
		 * 
		 * Gets the operation result boolean from within the asynchronous result.
		 * @returns %TRUE if the operation's result was %TRUE, %FALSE
		 *     if the operation's result was %FALSE.
		 */
		get_op_res_gboolean(): boolean;
		/**
		 * @deprecated
		 * Use #GTask and {@link G.task_propagate_pointer} instead.
		 * 
		 * Gets a pointer result as returned by the asynchronous function.
		 * @returns a pointer from the result.
		 */
		get_op_res_gpointer(): any | null;
		/**
		 * @deprecated
		 * Use #GTask and {@link G.task_propagate_int} instead.
		 * 
		 * Gets a gssize from the asynchronous result.
		 * @returns a gssize returned from the asynchronous function.
		 */
		get_op_res_gssize(): number;
		/**
		 * @deprecated
		 * Use #GTask and {@link G.task_get_source_tag} instead.
		 * 
		 * Gets the source tag for the #GSimpleAsyncResult.
		 * @returns a #gpointer to the source object for the #GSimpleAsyncResult.
		 */
		get_source_tag(): any | null;
		/**
		 * @deprecated
		 * Use #GTask instead.
		 * 
		 * Propagates an error from within the simple asynchronous result to
		 * a given destination.
		 * 
		 * If the #GCancellable given to a prior call to
		 * {@link G.simple_async_result_set_check_cancellable} is cancelled then this
		 * function will return %TRUE with #dest set appropriately.
		 * @returns %TRUE if the error was propagated to #dest. %FALSE otherwise.
		 */
		propagate_error(): boolean;
		/**
		 * @deprecated
		 * Use #GTask and {@link G.task_run_in_thread} instead.
		 * 
		 * Runs the asynchronous job in a separate thread and then calls
		 * {@link G.simple_async_result_complete_in_idle} on #simple to return
		 * the result to the appropriate main loop.
		 * 
		 * Calling this function takes a reference to #simple for as long as
		 * is needed to run the job and report its completion.
		 * @param func a #GSimpleAsyncThreadFunc.
		 * @param io_priority the io priority of the request.
		 * @param cancellable optional #GCancellable object, %NULL to ignore.
		 */
		run_in_thread(func: SimpleAsyncThreadFunc, io_priority: number, cancellable?: Cancellable | null): void;
		/**
		 * @deprecated
		 * Use #GTask instead.
		 * 
		 * Sets a #GCancellable to check before dispatching results.
		 * 
		 * This function has one very specific purpose: the provided cancellable
		 * is checked at the time of {@link G.simple_async_result_propagate_error} If
		 * it is cancelled, these functions will return an "Operation was
		 * cancelled" error (%G_IO_ERROR_CANCELLED).
		 * 
		 * Implementors of cancellable asynchronous functions should use this in
		 * order to provide a guarantee to their callers that cancelling an
		 * async operation will reliably result in an error being returned for
		 * that operation (even if a positive result for the operation has
		 * already been sent as an idle to the main context to be dispatched).
		 * 
		 * The checking described above is done regardless of any call to the
		 * unrelated g_simple_async_result_set_handle_cancellation() function.
		 * @param check_cancellable a #GCancellable to check, or %NULL to unset
		 */
		set_check_cancellable(check_cancellable?: Cancellable | null): void;
		/**
		 * @deprecated
		 * Use #GTask and {@link G.task_return_new_error} instead.
		 * 
		 * Sets an error within the asynchronous result without a #GError.
		 * @param domain a #GQuark (usually #G_IO_ERROR).
		 * @param code an error code.
		 * @param format a formatted error reporting string.
		 */
		set_error(domain: GLib.Quark, code: number, format: string): void;
		/**
		 * @deprecated
		 * Use #GTask and {@link G.task_return_error} instead.
		 * 
		 * Sets an error within the asynchronous result without a #GError.
		 * Unless writing a binding, see {@link G.simple_async_result_set_error}.
		 * @param domain a #GQuark (usually #G_IO_ERROR).
		 * @param code an error code.
		 * @param format a formatted error reporting string.
		 * @param args va_list of arguments.
		 */
		set_error_va(domain: GLib.Quark, code: number, format: string, args: any[]): void;
		/**
		 * @deprecated
		 * Use #GTask and {@link G.task_return_error} instead.
		 * 
		 * Sets the result from a #GError.
		 * @param error #GError.
		 */
		set_from_error(error: GLib.Error): void;
		/**
		 * Sets whether to handle cancellation within the asynchronous operation.
		 * 
		 * This function has nothing to do with
		 * {@link G.simple_async_result_set_check_cancellable}.  It only refers to the
		 * #GCancellable passed to g_simple_async_result_run_in_thread().
		 * @param handle_cancellation a #gboolean.
		 */
		set_handle_cancellation(handle_cancellation: boolean): void;
		/**
		 * @deprecated
		 * Use #GTask and {@link G.task_return_boolean} instead.
		 * 
		 * Sets the operation result to a boolean within the asynchronous result.
		 * @param op_res a #gboolean.
		 */
		set_op_res_gboolean(op_res: boolean): void;
		/**
		 * @deprecated
		 * Use #GTask and {@link G.task_return_pointer} instead.
		 * 
		 * Sets the operation result within the asynchronous result to a pointer.
		 * @param op_res a pointer result from an asynchronous function.
		 */
		set_op_res_gpointer(op_res?: any | null): void;
		/**
		 * @deprecated
		 * Use #GTask and {@link G.task_return_int} instead.
		 * 
		 * Sets the operation result within the asynchronous result to
		 * the given #op_res.
		 * @param op_res a #gssize.
		 */
		set_op_res_gssize(op_res: number): void;
		/**
		 * @deprecated
		 * Use #GTask and {@link G.task_return_error} instead.
		 * 
		 * Sets the result from #error, and takes over the caller's ownership
		 * of #error, so the caller does not need to free it any more.
		 * @param error a #GError
		 */
		take_error(error: GLib.Error): void;
	}

	type SimpleAsyncResultInitOptionsMixin = GObject.ObjectInitOptions & AsyncResultInitOptions
	export interface SimpleAsyncResultInitOptions extends SimpleAsyncResultInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link SimpleAsyncResult} instead.
	 */
	type SimpleAsyncResultMixin = ISimpleAsyncResult & GObject.Object & AsyncResult;

	/**
	 * As of GLib 2.46, #GSimpleAsyncResult is deprecated in favor of
	 * #GTask, which provides a simpler API.
	 * 
	 * #GSimpleAsyncResult implements #GAsyncResult.
	 * 
	 * GSimpleAsyncResult handles #GAsyncReadyCallbacks, error
	 * reporting, operation cancellation and the final state of an operation,
	 * completely transparent to the application. Results can be returned
	 * as a pointer e.g. for functions that return data that is collected
	 * asynchronously, a boolean value for checking the success or failure
	 * of an operation, or a #gssize for operations which return the number
	 * of bytes modified by the operation; all of the simple return cases
	 * are covered.
	 * 
	 * Most of the time, an application will not need to know of the details
	 * of this API; it is handled transparently, and any necessary operations
	 * are handled by #GAsyncResult's interface. However, if implementing a
	 * new GIO module, for writing language bindings, or for complex
	 * applications that need better control of how asynchronous operations
	 * are completed, it is important to understand this functionality.
	 * 
	 * GSimpleAsyncResults are tagged with the calling function to ensure
	 * that asynchronous functions and their finishing functions are used
	 * together correctly.
	 * 
	 * To create a new #GSimpleAsyncResult, call {@link G.simple_async_result_new}.
	 * If the result needs to be created for a #GError, use
	 * g_simple_async_result_new_from_error() or
	 * g_simple_async_result_new_take_error(). If a #GError is not available
	 * (e.g. the asynchronous operation's doesn't take a #GError argument),
	 * but the result still needs to be created for an error condition, use
	 * g_simple_async_result_new_error() (or g_simple_async_result_set_error_va()
	 * if your application or binding requires passing a variable argument list
	 * directly), and the error can then be propagated through the use of
	 * g_simple_async_result_propagate_error().
	 * 
	 * An asynchronous operation can be made to ignore a cancellation event by
	 * calling g_simple_async_result_set_handle_cancellation() with a
	 * #GSimpleAsyncResult for the operation and %FALSE. This is useful for
	 * operations that are dangerous to cancel, such as close (which would
	 * cause a leak if cancelled before being run).
	 * 
	 * GSimpleAsyncResult can integrate into GLib's event loop, #GMainLoop,
	 * or it can use #GThreads.
	 * g_simple_async_result_complete() will finish an I/O task directly
	 * from the point where it is called. g_simple_async_result_complete_in_idle()
	 * will finish it from an idle handler in the
	 * [thread-default main context][g-main-context-push-thread-default]
	 * where the #GSimpleAsyncResult was created.
	 * g_simple_async_result_run_in_thread() will run the job in a
	 * separate thread and then use
	 * g_simple_async_result_complete_in_idle() to deliver the result.
	 * 
	 * To set the results of an asynchronous function,
	 * g_simple_async_result_set_op_res_gpointer(),
	 * g_simple_async_result_set_op_res_gboolean(), and
	 * g_simple_async_result_set_op_res_gssize()
	 * are provided, setting the operation's result to a gpointer, gboolean, or
	 * gssize, respectively.
	 * 
	 * Likewise, to get the result of an asynchronous function,
	 * g_simple_async_result_get_op_res_gpointer(),
	 * g_simple_async_result_get_op_res_gboolean(), and
	 * g_simple_async_result_get_op_res_gssize() are
	 * provided, getting the operation's result as a gpointer, gboolean, and
	 * gssize, respectively.
	 * 
	 * For the details of the requirements implementations must respect, see
	 * #GAsyncResult.  A typical implementation of an asynchronous operation
	 * using GSimpleAsyncResult looks something like this:
	 * 
	 * |[<!-- language="C" -->
	 * static void
	 * baked_cb (Cake    *cake,
	 *           gpointer user_data)
	 * {
	 *   // In this example, this callback is not given a reference to the cake,
	 *   // so the GSimpleAsyncResult has to take a reference to it.
	 *   GSimpleAsyncResult *result = user_data;
	 * 
	 *   if (cake == NULL)
	 *     g_simple_async_result_set_error (result,
	 *                                      BAKER_ERRORS,
	 *                                      BAKER_ERROR_NO_FLOUR,
	 *                                      "Go to the supermarket");
	 *   else
	 *     g_simple_async_result_set_op_res_gpointer (result,
	 *                                                g_object_ref (cake),
	 *                                                g_object_unref);
	 * 
	 * 
	 *   // In this example, we assume that baked_cb is called as a callback from
	 *   // the mainloop, so it's safe to complete the operation synchronously here.
	 *   // If, however, _baker_prepare_cake () might call its callback without
	 *   // first returning to the mainloop — inadvisable, but some APIs do so —
	 *   // we would need to use g_simple_async_result_complete_in_idle().
	 *   g_simple_async_result_complete (result);
	 *   g_object_unref (result);
	 * }
	 * 
	 * void
	 * baker_bake_cake_async (Baker              *self,
	 *                        guint               radius,
	 *                        GAsyncReadyCallback callback,
	 *                        gpointer            user_data)
	 * {
	 *   GSimpleAsyncResult *simple;
	 *   Cake               *cake;
	 * 
	 *   if (radius < 3)
	 *     {
	 *       g_simple_async_report_error_in_idle (G_OBJECT (self),
	 *                                            callback,
	 *                                            user_data,
	 *                                            BAKER_ERRORS,
	 *                                            BAKER_ERROR_TOO_SMALL,
	 *                                            "%ucm radius cakes are silly",
	 *                                            radius);
	 *       return;
	 *     }
	 * 
	 *   simple = g_simple_async_result_new (G_OBJECT (self),
	 *                                       callback,
	 *                                       user_data,
	 *                                       baker_bake_cake_async);
	 *   cake = _baker_get_cached_cake (self, radius);
	 * 
	 *   if (cake != NULL)
	 *     {
	 *       g_simple_async_result_set_op_res_gpointer (simple,
	 *                                                  g_object_ref (cake),
	 *                                                  g_object_unref);
	 *       g_simple_async_result_complete_in_idle (simple);
	 *       g_object_unref (simple);
	 *       // Drop the reference returned by _baker_get_cached_cake();
	 *       // the GSimpleAsyncResult has taken its own reference.
	 *       g_object_unref (cake);
	 *       return;
	 *     }
	 * 
	 *   _baker_prepare_cake (self, radius, baked_cb, simple);
	 * }
	 * 
	 * Cake *
	 * baker_bake_cake_finish (Baker        *self,
	 *                         GAsyncResult *result,
	 *                         GError      **error)
	 * {
	 *   GSimpleAsyncResult *simple;
	 *   Cake               *cake;
	 * 
	 *   g_return_val_if_fail (g_simple_async_result_is_valid (result,
	 *                                                         G_OBJECT (self),
	 *                                                         baker_bake_cake_async),
	 *                         NULL);
	 * 
	 *   simple = (GSimpleAsyncResult *) result;
	 * 
	 *   if (g_simple_async_result_propagate_error (simple, error))
	 *     return NULL;
	 * 
	 *   cake = CAKE (g_simple_async_result_get_op_res_gpointer (simple));
	 *   return g_object_ref (cake);
	 * }
	 * ]|
	 */
	interface SimpleAsyncResult extends SimpleAsyncResultMixin {}

	class SimpleAsyncResult {
		public constructor(options?: Partial<SimpleAsyncResultInitOptions>);
		/**
		 * @deprecated
		 * Use {@link G.task_new} instead.
		 * 
		 * Creates a #GSimpleAsyncResult.
		 * 
		 * The common convention is to create the #GSimpleAsyncResult in the
		 * function that starts the asynchronous operation and use that same
		 * function as the #source_tag.
		 * 
		 * If your operation supports cancellation with #GCancellable (which it
		 * probably should) then you should provide the user's cancellable to
		 * {@link G.simple_async_result_set_check_cancellable} immediately after
		 * this function returns.
		 * @param source_object a #GObject, or %NULL.
		 * @param callback a #GAsyncReadyCallback.
		 * @param source_tag the asynchronous function.
		 * @returns a #GSimpleAsyncResult.
		 */
		public static new(source_object?: GObject.Object | null, callback?: AsyncReadyCallback | null, source_tag?: any | null): SimpleAsyncResult;
		/**
		 * @deprecated
		 * Use {@link G.task_new} and g_task_return_new_error() instead.
		 * 
		 * Creates a new #GSimpleAsyncResult with a set error.
		 * @param source_object a #GObject, or %NULL.
		 * @param callback a #GAsyncReadyCallback.
		 * @param domain a #GQuark.
		 * @param code an error code.
		 * @param format a string with format characters.
		 * @returns a #GSimpleAsyncResult.
		 */
		public static new_error(source_object: GObject.Object | null, callback: AsyncReadyCallback | null, domain: GLib.Quark, code: number, format: string): SimpleAsyncResult;
		/**
		 * @deprecated
		 * Use {@link G.task_new} and g_task_return_error() instead.
		 * 
		 * Creates a #GSimpleAsyncResult from an error condition.
		 * @param source_object a #GObject, or %NULL.
		 * @param callback a #GAsyncReadyCallback.
		 * @param error a #GError
		 * @returns a #GSimpleAsyncResult.
		 */
		public static new_from_error(source_object: GObject.Object | null, callback: AsyncReadyCallback | null, error: GLib.Error): SimpleAsyncResult;
		/**
		 * @deprecated
		 * Use {@link G.task_new} and g_task_return_error() instead.
		 * 
		 * Creates a #GSimpleAsyncResult from an error condition, and takes over the
		 * caller's ownership of #error, so the caller does not need to free it anymore.
		 * @param source_object a #GObject, or %NULL
		 * @param callback a #GAsyncReadyCallback
		 * @param error a #GError
		 * @returns a #GSimpleAsyncResult
		 */
		public static new_take_error(source_object: GObject.Object | null, callback: AsyncReadyCallback | null, error: GLib.Error): SimpleAsyncResult;
		/**
		 * @deprecated
		 * Use #GTask and {@link G.task_is_valid} instead.
		 * 
		 * Ensures that the data passed to the _finish function of an async
		 * operation is consistent.  Three checks are performed.
		 * 
		 * First, #result is checked to ensure that it is really a
		 * #GSimpleAsyncResult.  Second, #source is checked to ensure that it
		 * matches the source object of #result.  Third, #source_tag is
		 * checked to ensure that it is equal to the #source_tag argument given
		 * to {@link G.simple_async_result_new} (which, by convention, is a pointer
		 * to the _async function corresponding to the _finish function from
		 * which this function is called).  (Alternatively, if either
		 * #source_tag or #result's source tag is %NULL, then the source tag
		 * check is skipped.)
		 * @param result the #GAsyncResult passed to the _finish function.
		 * @param source the #GObject passed to the _finish function.
		 * @param source_tag the asynchronous function.
		 * @returns #TRUE if all checks passed or #FALSE if any failed.
		 */
		public static is_valid(result: AsyncResult, source?: GObject.Object | null, source_tag?: any | null): boolean;
	}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link SimpleIOStream} instead.
	 */
	interface ISimpleIOStream {
		input_stream: InputStream;
		output_stream: OutputStream;

		connect(signal: "notify::input-stream", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::output-stream", callback: (owner: this, ...args: any) => void): number;

	}

	type SimpleIOStreamInitOptionsMixin = IOStreamInitOptions & 
	Pick<ISimpleIOStream,
		"input_stream" |
		"output_stream">;

	export interface SimpleIOStreamInitOptions extends SimpleIOStreamInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link SimpleIOStream} instead.
	 */
	type SimpleIOStreamMixin = ISimpleIOStream & IOStream;

	/**
	 * GSimpleIOStream creates a #GIOStream from an arbitrary #GInputStream and
	 * #GOutputStream. This allows any pair of input and output streams to be used
	 * with #GIOStream methods.
	 * 
	 * This is useful when you obtained a #GInputStream and a #GOutputStream
	 * by other means, for instance creating them with platform specific methods as
	 * {@link G.unix_input_stream_new} or g_win32_input_stream_new(), and you want
	 * to take advantage of the methods provided by #GIOStream.
	 */
	interface SimpleIOStream extends SimpleIOStreamMixin {}

	class SimpleIOStream {
		public constructor(options?: Partial<SimpleIOStreamInitOptions>);
		/**
		 * Creates a new #GSimpleIOStream wrapping #input_stream and #output_stream.
		 * See also #GIOStream.
		 * @param input_stream a #GInputStream.
		 * @param output_stream a #GOutputStream.
		 * @returns a new #GSimpleIOStream instance.
		 */
		public static new(input_stream: InputStream, output_stream: OutputStream): IOStream;
	}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link SimplePermission} instead.
	 */
	interface ISimplePermission {

	}

	type SimplePermissionInitOptionsMixin = PermissionInitOptions
	export interface SimplePermissionInitOptions extends SimplePermissionInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link SimplePermission} instead.
	 */
	type SimplePermissionMixin = ISimplePermission & Permission;

	/**
	 * #GSimplePermission is a trivial implementation of #GPermission that
	 * represents a permission that is either always or never allowed.  The
	 * value is given at construction and doesn't change.
	 * 
	 * Calling request or release will result in errors.
	 */
	interface SimplePermission extends SimplePermissionMixin {}

	class SimplePermission {
		public constructor(options?: Partial<SimplePermissionInitOptions>);
		/**
		 * Creates a new #GPermission instance that represents an action that is
		 * either always or never allowed.
		 * @param allowed %TRUE if the action is allowed
		 * @returns the #GSimplePermission, as a #GPermission
		 */
		public static new(allowed: boolean): Permission;
	}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link SimpleProxyResolver} instead.
	 */
	interface ISimpleProxyResolver {
		/**
		 * The default proxy URI that will be used for any URI that doesn't
		 * match #GSimpleProxyResolver:ignore-hosts, and doesn't match any
		 * of the schemes set with {@link G.simple_proxy_resolver_set_uri_proxy}.
		 * 
		 * Note that as a special case, if this URI starts with
		 * "socks://", #GSimpleProxyResolver will treat it as referring
		 * to all three of the socks5, socks4a, and socks4 proxy types.
		 */
		default_proxy: string;
		/**
		 * A list of hostnames and IP addresses that the resolver should
		 * allow direct connections to.
		 * 
		 * Entries can be in one of 4 formats:
		 * 
		 * - A hostname, such as "example.com", ".example.com", or
		 *   "*.example.com", any of which match "example.com" or
		 *   any subdomain of it.
		 * 
		 * - An IPv4 or IPv6 address, such as "192.168.1.1",
		 *   which matches only that address.
		 * 
		 * - A hostname or IP address followed by a port, such as
		 *   "example.com:80", which matches whatever the hostname or IP
		 *   address would match, but only for URLs with the (explicitly)
		 *   indicated port. In the case of an IPv6 address, the address
		 *   part must appear in brackets: "[::1]:443"
		 * 
		 * - An IP address range, given by a base address and prefix length,
		 *   such as "fe80::/10", which matches any address in that range.
		 * 
		 * Note that when dealing with Unicode hostnames, the matching is
		 * done against the ASCII form of the name.
		 * 
		 * Also note that hostname exclusions apply only to connections made
		 * to hosts identified by name, and IP address exclusions apply only
		 * to connections made to hosts identified by address. That is, if
		 * example.com has an address of 192.168.1.1, and the :ignore-hosts list
		 * contains only "192.168.1.1", then a connection to "example.com"
		 * (eg, via a #GNetworkAddress) will use the proxy, and a connection to
		 * "192.168.1.1" (eg, via a #GInetSocketAddress) will not.
		 * 
		 * These rules match the "ignore-hosts"/"noproxy" rules most
		 * commonly used by other applications.
		 */
		ignore_hosts: string[];
		/**
		 * Sets the default proxy on #resolver, to be used for any URIs that
		 * don't match #GSimpleProxyResolver:ignore-hosts or a proxy set
		 * via {@link G.simple_proxy_resolver_set_uri_proxy}.
		 * 
		 * If #default_proxy starts with "socks://",
		 * #GSimpleProxyResolver will treat it as referring to all three of
		 * the socks5, socks4a, and socks4 proxy types.
		 * @param default_proxy the default proxy to use
		 */
		set_default_proxy(default_proxy: string): void;
		/**
		 * Sets the list of ignored hosts.
		 * 
		 * See #GSimpleProxyResolver:ignore-hosts for more details on how the
		 * #ignore_hosts argument is interpreted.
		 * @param ignore_hosts %NULL-terminated list of hosts/IP addresses
		 *     to not use a proxy for
		 */
		set_ignore_hosts(ignore_hosts: string): void;
		/**
		 * Adds a URI-scheme-specific proxy to #resolver; URIs whose scheme
		 * matches #uri_scheme (and which don't match
		 * #GSimpleProxyResolver:ignore-hosts) will be proxied via #proxy.
		 * 
		 * As with #GSimpleProxyResolver:default-proxy, if #proxy starts with
		 * "socks://", #GSimpleProxyResolver will treat it
		 * as referring to all three of the socks5, socks4a, and socks4 proxy
		 * types.
		 * @param uri_scheme the URI scheme to add a proxy for
		 * @param proxy the proxy to use for #uri_scheme
		 */
		set_uri_proxy(uri_scheme: string, proxy: string): void;
		connect(signal: "notify::default-proxy", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::ignore-hosts", callback: (owner: this, ...args: any) => void): number;

	}

	type SimpleProxyResolverInitOptionsMixin = GObject.ObjectInitOptions & ProxyResolverInitOptions & 
	Pick<ISimpleProxyResolver,
		"default_proxy" |
		"ignore_hosts">;

	export interface SimpleProxyResolverInitOptions extends SimpleProxyResolverInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link SimpleProxyResolver} instead.
	 */
	type SimpleProxyResolverMixin = ISimpleProxyResolver & GObject.Object & ProxyResolver;

	/**
	 * #GSimpleProxyResolver is a simple #GProxyResolver implementation
	 * that handles a single default proxy, multiple URI-scheme-specific
	 * proxies, and a list of hosts that proxies should not be used for.
	 * 
	 * #GSimpleProxyResolver is never the default proxy resolver, but it
	 * can be used as the base class for another proxy resolver
	 * implementation, or it can be created and used manually, such as
	 * with {@link G.socket_client_set_proxy_resolver}.
	 */
	interface SimpleProxyResolver extends SimpleProxyResolverMixin {}

	class SimpleProxyResolver {
		public constructor(options?: Partial<SimpleProxyResolverInitOptions>);
		/**
		 * Creates a new #GSimpleProxyResolver. See
		 * #GSimpleProxyResolver:default-proxy and
		 * #GSimpleProxyResolver:ignore-hosts for more details on how the
		 * arguments are interpreted.
		 * @param default_proxy the default proxy to use, eg
		 *     "socks://192.168.1.1"
		 * @param ignore_hosts an optional list of hosts/IP addresses
		 *     to not use a proxy for.
		 * @returns a new #GSimpleProxyResolver
		 */
		public static new(default_proxy?: string | null, ignore_hosts?: string | null): ProxyResolver;
	}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link Socket} instead.
	 */
	interface ISocket {
		blocking: boolean;
		/**
		 * Whether the socket should allow sending to broadcast addresses.
		 */
		broadcast: boolean;
		family: SocketFamily;
		fd: number;
		keepalive: boolean;
		listen_backlog: number;
		readonly local_address: SocketAddress;
		/**
		 * Whether outgoing multicast packets loop back to the local host.
		 */
		multicast_loopback: boolean;
		/**
		 * Time-to-live out outgoing multicast packets
		 */
		multicast_ttl: number;
		protocol: SocketProtocol;
		readonly remote_address: SocketAddress;
		/**
		 * The timeout in seconds on socket I/O
		 */
		timeout: number;
		/**
		 * Time-to-live for outgoing unicast packets
		 */
		ttl: number;
		type: SocketType;
		/**
		 * Accept incoming connections on a connection-based socket. This removes
		 * the first outstanding connection request from the listening socket and
		 * creates a #GSocket object for it.
		 * 
		 * The #socket must be bound to a local address with {@link G.socket_bind} and
		 * must be listening for incoming connections (g_socket_listen()).
		 * 
		 * If there are no outstanding connections then the operation will block
		 * or return %G_IO_ERROR_WOULD_BLOCK if non-blocking I/O is enabled.
		 * To be notified of an incoming connection, wait for the %G_IO_IN condition.
		 * @param cancellable a %GCancellable or %NULL
		 * @returns a new #GSocket, or %NULL on error.
		 *     Free the returned object with {@link GObject.unref}.
		 */
		accept(cancellable?: Cancellable | null): Socket;
		/**
		 * When a socket is created it is attached to an address family, but it
		 * doesn't have an address in this family. {@link G.socket_bind} assigns the
		 * address (sometimes called name) of the socket.
		 * 
		 * It is generally required to bind to a local address before you can
		 * receive connections. (See g_socket_listen() and g_socket_accept() ).
		 * In certain situations, you may also want to bind a socket that will be
		 * used to initiate connections, though this is not normally required.
		 * 
		 * If #socket is a TCP socket, then #allow_reuse controls the setting
		 * of the `SO_REUSEADDR` socket option; normally it should be %TRUE for
		 * server sockets (sockets that you will eventually call
		 * g_socket_accept() on), and %FALSE for client sockets. (Failing to
		 * set this flag on a server socket may cause g_socket_bind() to return
		 * %G_IO_ERROR_ADDRESS_IN_USE if the server program is stopped and then
		 * immediately restarted.)
		 * 
		 * If #socket is a UDP socket, then #allow_reuse determines whether or
		 * not other UDP sockets can be bound to the same address at the same
		 * time. In particular, you can have several UDP sockets bound to the
		 * same address, and they will all receive all of the multicast and
		 * broadcast packets sent to that address. (The behavior of unicast
		 * UDP packets to an address with multiple listeners is not defined.)
		 * @param address a #GSocketAddress specifying the local address.
		 * @param allow_reuse whether to allow reusing this address
		 * @returns %TRUE on success, %FALSE on error.
		 */
		bind(address: SocketAddress, allow_reuse: boolean): boolean;
		/**
		 * Checks and resets the pending connect error for the socket.
		 * This is used to check for errors when {@link G.socket_connect} is
		 * used in non-blocking mode.
		 * @returns %TRUE if no error, %FALSE otherwise, setting #error to the error
		 */
		check_connect_result(): boolean;
		/**
		 * Closes the socket, shutting down any active connection.
		 * 
		 * Closing a socket does not wait for all outstanding I/O operations
		 * to finish, so the caller should not rely on them to be guaranteed
		 * to complete even if the close returns with no error.
		 * 
		 * Once the socket is closed, all other operations will return
		 * %G_IO_ERROR_CLOSED. Closing a socket multiple times will not
		 * return an error.
		 * 
		 * Sockets will be automatically closed when the last reference
		 * is dropped, but you might want to call this function to make sure
		 * resources are released as early as possible.
		 * 
		 * Beware that due to the way that TCP works, it is possible for
		 * recently-sent data to be lost if either you close a socket while the
		 * %G_IO_IN condition is set, or else if the remote connection tries to
		 * send something to you after you close the socket but before it has
		 * finished reading all of the data you sent. There is no easy generic
		 * way to avoid this problem; the easiest fix is to design the network
		 * protocol such that the client will never send data "out of turn".
		 * Another solution is for the server to half-close the connection by
		 * calling {@link G.socket_shutdown} with only the #shutdown_write flag set,
		 * and then wait for the client to notice this and close its side of the
		 * connection, after which the server can safely call g_socket_close().
		 * (This is what #GTcpConnection does if you call
		 * g_tcp_connection_set_graceful_disconnect(). But of course, this
		 * only works if the client will close its connection after the server
		 * does.)
		 * @returns %TRUE on success, %FALSE on error
		 */
		close(): boolean;
		/**
		 * Checks on the readiness of #socket to perform operations.
		 * The operations specified in #condition are checked for and masked
		 * against the currently-satisfied conditions on #socket. The result
		 * is returned.
		 * 
		 * Note that on Windows, it is possible for an operation to return
		 * %G_IO_ERROR_WOULD_BLOCK even immediately after
		 * {@link G.socket_condition_check} has claimed that the socket is ready for
		 * writing. Rather than calling g_socket_condition_check() and then
		 * writing to the socket if it succeeds, it is generally better to
		 * simply try writing to the socket right away, and try again later if
		 * the initial attempt returns %G_IO_ERROR_WOULD_BLOCK.
		 * 
		 * It is meaningless to specify %G_IO_ERR or %G_IO_HUP in condition;
		 * these conditions will always be set in the output if they are true.
		 * 
		 * This call never blocks.
		 * @param condition a #GIOCondition mask to check
		 * @returns the #GIOCondition mask of the current state
		 */
		condition_check(condition: GLib.IOCondition): GLib.IOCondition;
		/**
		 * Waits for up to #timeout_us microseconds for #condition to become true
		 * on #socket. If the condition is met, %TRUE is returned.
		 * 
		 * If #cancellable is cancelled before the condition is met, or if
		 * #timeout_us (or the socket's #GSocket:timeout) is reached before the
		 * condition is met, then %FALSE is returned and #error, if non-%NULL,
		 * is set to the appropriate value (%G_IO_ERROR_CANCELLED or
		 * %G_IO_ERROR_TIMED_OUT).
		 * 
		 * If you don't want a timeout, use {@link G.socket_condition_wait}.
		 * (Alternatively, you can pass -1 for #timeout_us.)
		 * 
		 * Note that although #timeout_us is in microseconds for consistency with
		 * other GLib APIs, this function actually only has millisecond
		 * resolution, and the behavior is undefined if #timeout_us is not an
		 * exact number of milliseconds.
		 * @param condition a #GIOCondition mask to wait for
		 * @param timeout_us the maximum time (in microseconds) to wait, or -1
		 * @param cancellable a #GCancellable, or %NULL
		 * @returns %TRUE if the condition was met, %FALSE otherwise
		 */
		condition_timed_wait(condition: GLib.IOCondition, timeout_us: number, cancellable?: Cancellable | null): boolean;
		/**
		 * Waits for #condition to become true on #socket. When the condition
		 * is met, %TRUE is returned.
		 * 
		 * If #cancellable is cancelled before the condition is met, or if the
		 * socket has a timeout set and it is reached before the condition is
		 * met, then %FALSE is returned and #error, if non-%NULL, is set to
		 * the appropriate value (%G_IO_ERROR_CANCELLED or
		 * %G_IO_ERROR_TIMED_OUT).
		 * 
		 * See also {@link G.socket_condition_timed_wait}.
		 * @param condition a #GIOCondition mask to wait for
		 * @param cancellable a #GCancellable, or %NULL
		 * @returns %TRUE if the condition was met, %FALSE otherwise
		 */
		condition_wait(condition: GLib.IOCondition, cancellable?: Cancellable | null): boolean;
		/**
		 * Connect the socket to the specified remote address.
		 * 
		 * For connection oriented socket this generally means we attempt to make
		 * a connection to the #address. For a connection-less socket it sets
		 * the default address for {@link G.socket_send} and discards all incoming datagrams
		 * from other sources.
		 * 
		 * Generally connection oriented sockets can only connect once, but
		 * connection-less sockets can connect multiple times to change the
		 * default address.
		 * 
		 * If the connect call needs to do network I/O it will block, unless
		 * non-blocking I/O is enabled. Then %G_IO_ERROR_PENDING is returned
		 * and the user can be notified of the connection finishing by waiting
		 * for the G_IO_OUT condition. The result of the connection must then be
		 * checked with g_socket_check_connect_result().
		 * @param address a #GSocketAddress specifying the remote address.
		 * @param cancellable a %GCancellable or %NULL
		 * @returns %TRUE if connected, %FALSE on error.
		 */
		connect(address: SocketAddress, cancellable?: Cancellable | null): boolean;
		/**
		 * Creates a #GSocketConnection subclass of the right type for
		 * #socket.
		 * @returns a #GSocketConnection
		 */
		connection_factory_create_connection(): SocketConnection;
		/**
		 * Creates a #GSource that can be attached to a %GMainContext to monitor
		 * for the availability of the specified #condition on the socket. The #GSource
		 * keeps a reference to the #socket.
		 * 
		 * The callback on the source is of the #GSocketSourceFunc type.
		 * 
		 * It is meaningless to specify %G_IO_ERR or %G_IO_HUP in #condition;
		 * these conditions will always be reported output if they are true.
		 * 
		 * #cancellable if not %NULL can be used to cancel the source, which will
		 * cause the source to trigger, reporting the current condition (which
		 * is likely 0 unless cancellation happened at the same time as a
		 * condition change). You can check for this in the callback using
		 * {@link G.cancellable_is_cancelled}.
		 * 
		 * If #socket has a timeout set, and it is reached before #condition
		 * occurs, the source will then trigger anyway, reporting %G_IO_IN or
		 * %G_IO_OUT depending on #condition. However, #socket will have been
		 * marked as having had a timeout, and so the next #GSocket I/O method
		 * you call will then fail with a %G_IO_ERROR_TIMED_OUT.
		 * @param condition a #GIOCondition mask to monitor
		 * @param cancellable a %GCancellable or %NULL
		 * @returns a newly allocated %GSource, free with {@link G.source_unref}.
		 */
		create_source(condition: GLib.IOCondition, cancellable?: Cancellable | null): GLib.Source;
		/**
		 * Get the amount of data pending in the OS input buffer, without blocking.
		 * 
		 * If #socket is a UDP or SCTP socket, this will return the size of
		 * just the next packet, even if additional packets are buffered after
		 * that one.
		 * 
		 * Note that on Windows, this function is rather inefficient in the
		 * UDP case, and so if you know any plausible upper bound on the size
		 * of the incoming packet, it is better to just do a
		 * {@link G.socket_receive} with a buffer of that size, rather than calling
		 * g_socket_get_available_bytes() first and then doing a receive of
		 * exactly the right size.
		 * @returns the number of bytes that can be read from the socket
		 * without blocking or truncating, or -1 on error.
		 */
		get_available_bytes(): number;
		/**
		 * Gets the blocking mode of the socket. For details on blocking I/O,
		 * see {@link G.socket_set_blocking}.
		 * @returns %TRUE if blocking I/O is used, %FALSE otherwise.
		 */
		get_blocking(): boolean;
		/**
		 * Gets the broadcast setting on #socket; if %TRUE,
		 * it is possible to send packets to broadcast
		 * addresses.
		 * @returns the broadcast setting on #socket
		 */
		get_broadcast(): boolean;
		/**
		 * Returns the credentials of the foreign process connected to this
		 * socket, if any (e.g. it is only supported for %G_SOCKET_FAMILY_UNIX
		 * sockets).
		 * 
		 * If this operation isn't supported on the OS, the method fails with
		 * the %G_IO_ERROR_NOT_SUPPORTED error. On Linux this is implemented
		 * by reading the %SO_PEERCRED option on the underlying socket.
		 * 
		 * This method can be expected to be available on the following platforms:
		 * 
		 * - Linux since GLib 2.26
		 * - OpenBSD since GLib 2.30
		 * - Solaris, Illumos and OpenSolaris since GLib 2.40
		 * - NetBSD since GLib 2.42
		 * - macOS, tvOS, iOS since GLib 2.66
		 * 
		 * Other ways to obtain credentials from a foreign peer includes the
		 * #GUnixCredentialsMessage type and
		 * {@link G.unix_connection_send_credentials} /
		 * g_unix_connection_receive_credentials() functions.
		 * @returns %NULL if #error is set, otherwise a #GCredentials object
		 * that must be freed with {@link GObject.unref}.
		 */
		get_credentials(): Credentials;
		/**
		 * Gets the socket family of the socket.
		 * @returns a #GSocketFamily
		 */
		get_family(): SocketFamily;
		/**
		 * Returns the underlying OS socket object. On unix this
		 * is a socket file descriptor, and on Windows this is
		 * a Winsock2 SOCKET handle. This may be useful for
		 * doing platform specific or otherwise unusual operations
		 * on the socket.
		 * @returns the file descriptor of the socket.
		 */
		get_fd(): number;
		/**
		 * Gets the keepalive mode of the socket. For details on this,
		 * see {@link G.socket_set_keepalive}.
		 * @returns %TRUE if keepalive is active, %FALSE otherwise.
		 */
		get_keepalive(): boolean;
		/**
		 * Gets the listen backlog setting of the socket. For details on this,
		 * see {@link G.socket_set_listen_backlog}.
		 * @returns the maximum number of pending connections.
		 */
		get_listen_backlog(): number;
		/**
		 * Try to get the local address of a bound socket. This is only
		 * useful if the socket has been bound to a local address,
		 * either explicitly or implicitly when connecting.
		 * @returns a #GSocketAddress or %NULL on error.
		 *     Free the returned object with {@link GObject.unref}.
		 */
		get_local_address(): SocketAddress;
		/**
		 * Gets the multicast loopback setting on #socket; if %TRUE (the
		 * default), outgoing multicast packets will be looped back to
		 * multicast listeners on the same host.
		 * @returns the multicast loopback setting on #socket
		 */
		get_multicast_loopback(): boolean;
		/**
		 * Gets the multicast time-to-live setting on #socket; see
		 * {@link G.socket_set_multicast_ttl} for more details.
		 * @returns the multicast time-to-live setting on #socket
		 */
		get_multicast_ttl(): number;
		/**
		 * Gets the value of an integer-valued option on #socket, as with
		 * getsockopt(). (If you need to fetch a  non-integer-valued option,
		 * you will need to call getsockopt() directly.)
		 * 
		 * The [<gio/gnetworking.h>][gio-gnetworking.h]
		 * header pulls in system headers that will define most of the
		 * standard/portable socket options. For unusual socket protocols or
		 * platform-dependent options, you may need to include additional
		 * headers.
		 * 
		 * Note that even for socket options that are a single byte in size,
		 * #value is still a pointer to a #gint variable, not a #guchar;
		 * g_socket_get_option() will handle the conversion internally.
		 * @param level the "API level" of the option (eg, `SOL_SOCKET`)
		 * @param optname the "name" of the option (eg, `SO_BROADCAST`)
		 * @returns success or failure. On failure, #error will be set, and
		 *   the system error value (`errno` or WSAGetLastError()) will still
		 *   be set to the result of the getsockopt() call.
		 * 
		 * return location for the option value
		 */
		get_option(level: number, optname: number): [ boolean, number ];
		/**
		 * Gets the socket protocol id the socket was created with.
		 * In case the protocol is unknown, -1 is returned.
		 * @returns a protocol id, or -1 if unknown
		 */
		get_protocol(): SocketProtocol;
		/**
		 * Try to get the remote address of a connected socket. This is only
		 * useful for connection oriented sockets that have been connected.
		 * @returns a #GSocketAddress or %NULL on error.
		 *     Free the returned object with {@link GObject.unref}.
		 */
		get_remote_address(): SocketAddress;
		/**
		 * Gets the socket type of the socket.
		 * @returns a #GSocketType
		 */
		get_socket_type(): SocketType;
		/**
		 * Gets the timeout setting of the socket. For details on this, see
		 * {@link G.socket_set_timeout}.
		 * @returns the timeout in seconds
		 */
		get_timeout(): number;
		/**
		 * Gets the unicast time-to-live setting on #socket; see
		 * {@link G.socket_set_ttl} for more details.
		 * @returns the time-to-live setting on #socket
		 */
		get_ttl(): number;
		/**
		 * Checks whether a socket is closed.
		 * @returns %TRUE if socket is closed, %FALSE otherwise
		 */
		is_closed(): boolean;
		/**
		 * Check whether the socket is connected. This is only useful for
		 * connection-oriented sockets.
		 * 
		 * If using {@link G.socket_shutdown}, this function will return %TRUE until the
		 * socket has been shut down for reading and writing. If you do a non-blocking
		 * connect, this function will not return %TRUE until after you call
		 * g_socket_check_connect_result().
		 * @returns %TRUE if socket is connected, %FALSE otherwise.
		 */
		is_connected(): boolean;
		/**
		 * Registers #socket to receive multicast messages sent to #group.
		 * #socket must be a %G_SOCKET_TYPE_DATAGRAM socket, and must have
		 * been bound to an appropriate interface and port with
		 * {@link G.socket_bind}.
		 * 
		 * If #iface is %NULL, the system will automatically pick an interface
		 * to bind to based on #group.
		 * 
		 * If #source_specific is %TRUE, source-specific multicast as defined
		 * in RFC 4604 is used. Note that on older platforms this may fail
		 * with a %G_IO_ERROR_NOT_SUPPORTED error.
		 * 
		 * To bind to a given source-specific multicast address, use
		 * g_socket_join_multicast_group_ssm() instead.
		 * @param group a #GInetAddress specifying the group address to join.
		 * @param source_specific %TRUE if source-specific multicast should be used
		 * @param iface Name of the interface to use, or %NULL
		 * @returns %TRUE on success, %FALSE on error.
		 */
		join_multicast_group(group: InetAddress, source_specific: boolean, iface?: string | null): boolean;
		/**
		 * Registers #socket to receive multicast messages sent to #group.
		 * #socket must be a %G_SOCKET_TYPE_DATAGRAM socket, and must have
		 * been bound to an appropriate interface and port with
		 * {@link G.socket_bind}.
		 * 
		 * If #iface is %NULL, the system will automatically pick an interface
		 * to bind to based on #group.
		 * 
		 * If #source_specific is not %NULL, use source-specific multicast as
		 * defined in RFC 4604. Note that on older platforms this may fail
		 * with a %G_IO_ERROR_NOT_SUPPORTED error.
		 * 
		 * Note that this function can be called multiple times for the same
		 * #group with different #source_specific in order to receive multicast
		 * packets from more than one source.
		 * @param group a #GInetAddress specifying the group address to join.
		 * @param source_specific a #GInetAddress specifying the
		 * source-specific multicast address or %NULL to ignore.
		 * @param iface Name of the interface to use, or %NULL
		 * @returns %TRUE on success, %FALSE on error.
		 */
		join_multicast_group_ssm(group: InetAddress, source_specific?: InetAddress | null, iface?: string | null): boolean;
		/**
		 * Removes #socket from the multicast group defined by #group, #iface,
		 * and #source_specific (which must all have the same values they had
		 * when you joined the group).
		 * 
		 * #socket remains bound to its address and port, and can still receive
		 * unicast messages after calling this.
		 * 
		 * To unbind to a given source-specific multicast address, use
		 * {@link G.socket_leave_multicast_group_ssm} instead.
		 * @param group a #GInetAddress specifying the group address to leave.
		 * @param source_specific %TRUE if source-specific multicast was used
		 * @param iface Interface used
		 * @returns %TRUE on success, %FALSE on error.
		 */
		leave_multicast_group(group: InetAddress, source_specific: boolean, iface?: string | null): boolean;
		/**
		 * Removes #socket from the multicast group defined by #group, #iface,
		 * and #source_specific (which must all have the same values they had
		 * when you joined the group).
		 * 
		 * #socket remains bound to its address and port, and can still receive
		 * unicast messages after calling this.
		 * @param group a #GInetAddress specifying the group address to leave.
		 * @param source_specific a #GInetAddress specifying the
		 * source-specific multicast address or %NULL to ignore.
		 * @param iface Name of the interface to use, or %NULL
		 * @returns %TRUE on success, %FALSE on error.
		 */
		leave_multicast_group_ssm(group: InetAddress, source_specific?: InetAddress | null, iface?: string | null): boolean;
		/**
		 * Marks the socket as a server socket, i.e. a socket that is used
		 * to accept incoming requests using {@link G.socket_accept}.
		 * 
		 * Before calling this the socket must be bound to a local address using
		 * g_socket_bind().
		 * 
		 * To set the maximum amount of outstanding clients, use
		 * g_socket_set_listen_backlog().
		 * @returns %TRUE on success, %FALSE on error.
		 */
		listen(): boolean;
		/**
		 * Receive data (up to #size bytes) from a socket. This is mainly used by
		 * connection-oriented sockets; it is identical to {@link G.socket_receive_from}
		 * with #address set to %NULL.
		 * 
		 * For %G_SOCKET_TYPE_DATAGRAM and %G_SOCKET_TYPE_SEQPACKET sockets,
		 * g_socket_receive() will always read either 0 or 1 complete messages from
		 * the socket. If the received message is too large to fit in #buffer, then
		 * the data beyond #size bytes will be discarded, without any explicit
		 * indication that this has occurred.
		 * 
		 * For %G_SOCKET_TYPE_STREAM sockets, g_socket_receive() can return any
		 * number of bytes, up to #size. If more than #size bytes have been
		 * received, the additional data will be returned in future calls to
		 * g_socket_receive().
		 * 
		 * If the socket is in blocking mode the call will block until there
		 * is some data to receive, the connection is closed, or there is an
		 * error. If there is no data available and the socket is in
		 * non-blocking mode, a %G_IO_ERROR_WOULD_BLOCK error will be
		 * returned. To be notified when data is available, wait for the
		 * %G_IO_IN condition.
		 * 
		 * On error -1 is returned and #error is set accordingly.
		 * @param cancellable a %GCancellable or %NULL
		 * @returns Number of bytes read, or 0 if the connection was closed by
		 * the peer, or -1 on error
		 * 
		 * 
		 *     a buffer to read data into (which should be at least #size bytes long).
		 */
		receive(cancellable?: Cancellable | null): [ number, number[] ];
		/**
		 * Receive data (up to #size bytes) from a socket.
		 * 
		 * If #address is non-%NULL then #address will be set equal to the
		 * source address of the received packet.
		 * #address is owned by the caller.
		 * 
		 * See {@link G.socket_receive} for additional information.
		 * @param cancellable a %GCancellable or %NULL
		 * @returns Number of bytes read, or 0 if the connection was closed by
		 * the peer, or -1 on error
		 * 
		 * a pointer to a #GSocketAddress
		 *     pointer, or %NULL
		 * 
		 * 
		 *     a buffer to read data into (which should be at least #size bytes long).
		 */
		receive_from(cancellable?: Cancellable | null): [ number, SocketAddress | null, number[] ];
		/**
		 * Receive data from a socket.  For receiving multiple messages, see
		 * {@link G.socket_receive_messages}; for easier use, see
		 * g_socket_receive() and g_socket_receive_from().
		 * 
		 * If #address is non-%NULL then #address will be set equal to the
		 * source address of the received packet.
		 * #address is owned by the caller.
		 * 
		 * #vector must point to an array of #GInputVector structs and
		 * #num_vectors must be the length of this array.  These structs
		 * describe the buffers that received data will be scattered into.
		 * If #num_vectors is -1, then #vectors is assumed to be terminated
		 * by a #GInputVector with a %NULL buffer pointer.
		 * 
		 * As a special case, if #num_vectors is 0 (in which case, #vectors
		 * may of course be %NULL), then a single byte is received and
		 * discarded. This is to facilitate the common practice of sending a
		 * single '\0' byte for the purposes of transferring ancillary data.
		 * 
		 * #messages, if non-%NULL, will be set to point to a newly-allocated
		 * array of #GSocketControlMessage instances or %NULL if no such
		 * messages was received. These correspond to the control messages
		 * received from the kernel, one #GSocketControlMessage per message
		 * from the kernel. This array is %NULL-terminated and must be freed
		 * by the caller using g_free() after calling g_object_unref() on each
		 * element. If #messages is %NULL, any control messages received will
		 * be discarded.
		 * 
		 * #num_messages, if non-%NULL, will be set to the number of control
		 * messages received.
		 * 
		 * If both #messages and #num_messages are non-%NULL, then
		 * #num_messages gives the number of #GSocketControlMessage instances
		 * in #messages (ie: not including the %NULL terminator).
		 * 
		 * #flags is an in/out parameter. The commonly available arguments
		 * for this are available in the #GSocketMsgFlags enum, but the
		 * values there are the same as the system values, and the flags
		 * are passed in as-is, so you can pass in system-specific flags too
		 * (and g_socket_receive_message() may pass system-specific flags out).
		 * Flags passed in to the parameter affect the receive operation; flags returned
		 * out of it are relevant to the specific returned message.
		 * 
		 * As with g_socket_receive(), data may be discarded if #socket is
		 * %G_SOCKET_TYPE_DATAGRAM or %G_SOCKET_TYPE_SEQPACKET and you do not
		 * provide enough buffer space to read a complete message. You can pass
		 * %G_SOCKET_MSG_PEEK in #flags to peek at the current message without
		 * removing it from the receive queue, but there is no portable way to find
		 * out the length of the message other than by reading it into a
		 * sufficiently-large buffer.
		 * 
		 * If the socket is in blocking mode the call will block until there
		 * is some data to receive, the connection is closed, or there is an
		 * error. If there is no data available and the socket is in
		 * non-blocking mode, a %G_IO_ERROR_WOULD_BLOCK error will be
		 * returned. To be notified when data is available, wait for the
		 * %G_IO_IN condition.
		 * 
		 * On error -1 is returned and #error is set accordingly.
		 * @param vectors an array of #GInputVector structs
		 * @param cancellable a %GCancellable or %NULL
		 * @returns Number of bytes read, or 0 if the connection was closed by
		 * the peer, or -1 on error
		 * 
		 * a pointer to a #GSocketAddress
		 *     pointer, or %NULL
		 * 
		 * a pointer
		 *    which may be filled with an array of #GSocketControlMessages, or %NULL
		 */
		receive_message(vectors: InputVector[], cancellable?: Cancellable | null): [ number, SocketAddress | null, SocketControlMessage[] | null ];
		/**
		 * Receive multiple data messages from #socket in one go.  This is the most
		 * complicated and fully-featured version of this call. For easier use, see
		 * {@link G.socket_receive}, g_socket_receive_from(), and g_socket_receive_message().
		 * 
		 * #messages must point to an array of #GInputMessage structs and
		 * #num_messages must be the length of this array. Each #GInputMessage
		 * contains a pointer to an array of #GInputVector structs describing the
		 * buffers that the data received in each message will be written to. Using
		 * multiple #GInputVectors is more memory-efficient than manually copying data
		 * out of a single buffer to multiple sources, and more system-call-efficient
		 * than making multiple calls to g_socket_receive(), such as in scenarios where
		 * a lot of data packets need to be received (e.g. high-bandwidth video
		 * streaming over RTP/UDP).
		 * 
		 * #flags modify how all messages are received. The commonly available
		 * arguments for this are available in the #GSocketMsgFlags enum, but the
		 * values there are the same as the system values, and the flags
		 * are passed in as-is, so you can pass in system-specific flags too. These
		 * flags affect the overall receive operation. Flags affecting individual
		 * messages are returned in #GInputMessage.flags.
		 * 
		 * The other members of #GInputMessage are treated as described in its
		 * documentation.
		 * 
		 * If #GSocket:blocking is %TRUE the call will block until #num_messages have
		 * been received, or the end of the stream is reached.
		 * 
		 * If #GSocket:blocking is %FALSE the call will return up to #num_messages
		 * without blocking, or %G_IO_ERROR_WOULD_BLOCK if no messages are queued in the
		 * operating system to be received.
		 * 
		 * In blocking mode, if #GSocket:timeout is positive and is reached before any
		 * messages are received, %G_IO_ERROR_TIMED_OUT is returned, otherwise up to
		 * #num_messages are returned. (Note: This is effectively the
		 * behaviour of `MSG_WAITFORONE` with recvmmsg().)
		 * 
		 * To be notified when messages are available, wait for the
		 * %G_IO_IN condition. Note though that you may still receive
		 * %G_IO_ERROR_WOULD_BLOCK from g_socket_receive_messages() even if you were
		 * previously notified of a %G_IO_IN condition.
		 * 
		 * If the remote peer closes the connection, any messages queued in the
		 * operating system will be returned, and subsequent calls to
		 * g_socket_receive_messages() will return 0 (with no error set).
		 * 
		 * On error -1 is returned and #error is set accordingly. An error will only
		 * be returned if zero messages could be received; otherwise the number of
		 * messages successfully received before the error will be returned.
		 * @param messages an array of #GInputMessage structs
		 * @param flags an int containing #GSocketMsgFlags flags for the overall operation,
		 *    which may additionally contain
		 *    [other platform specific flags](http://man7.org/linux/man-pages/man2/recv.2.html)
		 * @param cancellable a %GCancellable or %NULL
		 * @returns number of messages received, or -1 on error. Note that the number
		 *     of messages received may be smaller than #num_messages if in non-blocking
		 *     mode, if the peer closed the connection, or if #num_messages
		 *     was larger than `UIO_MAXIOV` (1024), in which case the caller may re-try
		 *     to receive the remaining messages.
		 */
		receive_messages(messages: InputMessage[], flags: number, cancellable?: Cancellable | null): number;
		/**
		 * This behaves exactly the same as {@link G.socket_receive}, except that
		 * the choice of blocking or non-blocking behavior is determined by
		 * the #blocking argument rather than by #socket's properties.
		 * @param blocking whether to do blocking or non-blocking I/O
		 * @param cancellable a %GCancellable or %NULL
		 * @returns Number of bytes read, or 0 if the connection was closed by
		 * the peer, or -1 on error
		 * 
		 * 
		 *     a buffer to read data into (which should be at least #size bytes long).
		 */
		receive_with_blocking(blocking: boolean, cancellable?: Cancellable | null): [ number, number[] ];
		/**
		 * Tries to send #size bytes from #buffer on the socket. This is
		 * mainly used by connection-oriented sockets; it is identical to
		 * {@link G.socket_send_to} with #address set to %NULL.
		 * 
		 * If the socket is in blocking mode the call will block until there is
		 * space for the data in the socket queue. If there is no space available
		 * and the socket is in non-blocking mode a %G_IO_ERROR_WOULD_BLOCK error
		 * will be returned. To be notified when space is available, wait for the
		 * %G_IO_OUT condition. Note though that you may still receive
		 * %G_IO_ERROR_WOULD_BLOCK from g_socket_send() even if you were previously
		 * notified of a %G_IO_OUT condition. (On Windows in particular, this is
		 * very common due to the way the underlying APIs work.)
		 * 
		 * On error -1 is returned and #error is set accordingly.
		 * @param buffer the buffer
		 *     containing the data to send.
		 * @param cancellable a %GCancellable or %NULL
		 * @returns Number of bytes written (which may be less than #size), or -1
		 * on error
		 */
		send(buffer: number[], cancellable?: Cancellable | null): number;
		/**
		 * Send data to #address on #socket.  For sending multiple messages see
		 * {@link G.socket_send_messages}; for easier use, see
		 * g_socket_send() and g_socket_send_to().
		 * 
		 * If #address is %NULL then the message is sent to the default receiver
		 * (set by g_socket_connect()).
		 * 
		 * #vectors must point to an array of #GOutputVector structs and
		 * #num_vectors must be the length of this array. (If #num_vectors is -1,
		 * then #vectors is assumed to be terminated by a #GOutputVector with a
		 * %NULL buffer pointer.) The #GOutputVector structs describe the buffers
		 * that the sent data will be gathered from. Using multiple
		 * #GOutputVectors is more memory-efficient than manually copying
		 * data from multiple sources into a single buffer, and more
		 * network-efficient than making multiple calls to g_socket_send().
		 * 
		 * #messages, if non-%NULL, is taken to point to an array of #num_messages
		 * #GSocketControlMessage instances. These correspond to the control
		 * messages to be sent on the socket.
		 * If #num_messages is -1 then #messages is treated as a %NULL-terminated
		 * array.
		 * 
		 * #flags modify how the message is sent. The commonly available arguments
		 * for this are available in the #GSocketMsgFlags enum, but the
		 * values there are the same as the system values, and the flags
		 * are passed in as-is, so you can pass in system-specific flags too.
		 * 
		 * If the socket is in blocking mode the call will block until there is
		 * space for the data in the socket queue. If there is no space available
		 * and the socket is in non-blocking mode a %G_IO_ERROR_WOULD_BLOCK error
		 * will be returned. To be notified when space is available, wait for the
		 * %G_IO_OUT condition. Note though that you may still receive
		 * %G_IO_ERROR_WOULD_BLOCK from g_socket_send() even if you were previously
		 * notified of a %G_IO_OUT condition. (On Windows in particular, this is
		 * very common due to the way the underlying APIs work.)
		 * 
		 * The sum of the sizes of each #GOutputVector in vectors must not be
		 * greater than %G_MAXSSIZE. If the message can be larger than this,
		 * then it is mandatory to use the g_socket_send_message_with_timeout()
		 * function.
		 * 
		 * On error -1 is returned and #error is set accordingly.
		 * @param address a #GSocketAddress, or %NULL
		 * @param vectors an array of #GOutputVector structs
		 * @param messages a pointer to an
		 *   array of #GSocketControlMessages, or %NULL.
		 * @param flags an int containing #GSocketMsgFlags flags, which may additionally
		 *    contain [other platform specific flags](http://man7.org/linux/man-pages/man2/recv.2.html)
		 * @param cancellable a %GCancellable or %NULL
		 * @returns Number of bytes written (which may be less than #size), or -1
		 * on error
		 */
		send_message(address: SocketAddress | null, vectors: OutputVector[], messages: SocketControlMessage[] | null, flags: number, cancellable?: Cancellable | null): number;
		/**
		 * This behaves exactly the same as {@link G.socket_send_message}, except that
		 * the choice of timeout behavior is determined by the #timeout_us argument
		 * rather than by #socket's properties.
		 * 
		 * On error %G_POLLABLE_RETURN_FAILED is returned and #error is set accordingly, or
		 * if the socket is currently not writable %G_POLLABLE_RETURN_WOULD_BLOCK is
		 * returned. #bytes_written will contain 0 in both cases.
		 * @param address a #GSocketAddress, or %NULL
		 * @param vectors an array of #GOutputVector structs
		 * @param messages a pointer to an
		 *   array of #GSocketControlMessages, or %NULL.
		 * @param flags an int containing #GSocketMsgFlags flags, which may additionally
		 *    contain [other platform specific flags](http://man7.org/linux/man-pages/man2/recv.2.html)
		 * @param timeout_us the maximum time (in microseconds) to wait, or -1
		 * @param cancellable a %GCancellable or %NULL
		 * @returns %G_POLLABLE_RETURN_OK if all data was successfully written,
		 * %G_POLLABLE_RETURN_WOULD_BLOCK if the socket is currently not writable, or
		 * %G_POLLABLE_RETURN_FAILED if an error happened and #error is set.
		 * 
		 * location to store the number of bytes that were written to the socket
		 */
		send_message_with_timeout(address: SocketAddress | null, vectors: OutputVector[], messages: SocketControlMessage[] | null, flags: number, timeout_us: number, cancellable?: Cancellable | null): [ PollableReturn, number | null ];
		/**
		 * Send multiple data messages from #socket in one go.  This is the most
		 * complicated and fully-featured version of this call. For easier use, see
		 * {@link G.socket_send}, g_socket_send_to(), and g_socket_send_message().
		 * 
		 * #messages must point to an array of #GOutputMessage structs and
		 * #num_messages must be the length of this array. Each #GOutputMessage
		 * contains an address to send the data to, and a pointer to an array of
		 * #GOutputVector structs to describe the buffers that the data to be sent
		 * for each message will be gathered from. Using multiple #GOutputVectors is
		 * more memory-efficient than manually copying data from multiple sources
		 * into a single buffer, and more network-efficient than making multiple
		 * calls to g_socket_send(). Sending multiple messages in one go avoids the
		 * overhead of making a lot of syscalls in scenarios where a lot of data
		 * packets need to be sent (e.g. high-bandwidth video streaming over RTP/UDP),
		 * or where the same data needs to be sent to multiple recipients.
		 * 
		 * #flags modify how the message is sent. The commonly available arguments
		 * for this are available in the #GSocketMsgFlags enum, but the
		 * values there are the same as the system values, and the flags
		 * are passed in as-is, so you can pass in system-specific flags too.
		 * 
		 * If the socket is in blocking mode the call will block until there is
		 * space for all the data in the socket queue. If there is no space available
		 * and the socket is in non-blocking mode a %G_IO_ERROR_WOULD_BLOCK error
		 * will be returned if no data was written at all, otherwise the number of
		 * messages sent will be returned. To be notified when space is available,
		 * wait for the %G_IO_OUT condition. Note though that you may still receive
		 * %G_IO_ERROR_WOULD_BLOCK from g_socket_send() even if you were previously
		 * notified of a %G_IO_OUT condition. (On Windows in particular, this is
		 * very common due to the way the underlying APIs work.)
		 * 
		 * On error -1 is returned and #error is set accordingly. An error will only
		 * be returned if zero messages could be sent; otherwise the number of messages
		 * successfully sent before the error will be returned.
		 * @param messages an array of #GOutputMessage structs
		 * @param flags an int containing #GSocketMsgFlags flags, which may additionally
		 *    contain [other platform specific flags](http://man7.org/linux/man-pages/man2/recv.2.html)
		 * @param cancellable a %GCancellable or %NULL
		 * @returns number of messages sent, or -1 on error. Note that the number of
		 *     messages sent may be smaller than #num_messages if the socket is
		 *     non-blocking or if #num_messages was larger than UIO_MAXIOV (1024),
		 *     in which case the caller may re-try to send the remaining messages.
		 */
		send_messages(messages: OutputMessage[], flags: number, cancellable?: Cancellable | null): number;
		/**
		 * Tries to send #size bytes from #buffer to #address. If #address is
		 * %NULL then the message is sent to the default receiver (set by
		 * {@link G.socket_connect}).
		 * 
		 * See g_socket_send() for additional information.
		 * @param address a #GSocketAddress, or %NULL
		 * @param buffer the buffer
		 *     containing the data to send.
		 * @param cancellable a %GCancellable or %NULL
		 * @returns Number of bytes written (which may be less than #size), or -1
		 * on error
		 */
		send_to(address: SocketAddress | null, buffer: number[], cancellable?: Cancellable | null): number;
		/**
		 * This behaves exactly the same as {@link G.socket_send}, except that
		 * the choice of blocking or non-blocking behavior is determined by
		 * the #blocking argument rather than by #socket's properties.
		 * @param buffer the buffer
		 *     containing the data to send.
		 * @param blocking whether to do blocking or non-blocking I/O
		 * @param cancellable a %GCancellable or %NULL
		 * @returns Number of bytes written (which may be less than #size), or -1
		 * on error
		 */
		send_with_blocking(buffer: number[], blocking: boolean, cancellable?: Cancellable | null): number;
		/**
		 * Sets the blocking mode of the socket. In blocking mode
		 * all operations (which don’t take an explicit blocking parameter) block until
		 * they succeed or there is an error. In
		 * non-blocking mode all functions return results immediately or
		 * with a %G_IO_ERROR_WOULD_BLOCK error.
		 * 
		 * All sockets are created in blocking mode. However, note that the
		 * platform level socket is always non-blocking, and blocking mode
		 * is a GSocket level feature.
		 * @param blocking Whether to use blocking I/O or not.
		 */
		set_blocking(blocking: boolean): void;
		/**
		 * Sets whether #socket should allow sending to broadcast addresses.
		 * This is %FALSE by default.
		 * @param broadcast whether #socket should allow sending to broadcast
		 *     addresses
		 */
		set_broadcast(broadcast: boolean): void;
		/**
		 * Sets or unsets the %SO_KEEPALIVE flag on the underlying socket. When
		 * this flag is set on a socket, the system will attempt to verify that the
		 * remote socket endpoint is still present if a sufficiently long period of
		 * time passes with no data being exchanged. If the system is unable to
		 * verify the presence of the remote endpoint, it will automatically close
		 * the connection.
		 * 
		 * This option is only functional on certain kinds of sockets. (Notably,
		 * %G_SOCKET_PROTOCOL_TCP sockets.)
		 * 
		 * The exact time between pings is system- and protocol-dependent, but will
		 * normally be at least two hours. Most commonly, you would set this flag
		 * on a server socket if you want to allow clients to remain idle for long
		 * periods of time, but also want to ensure that connections are eventually
		 * garbage-collected if clients crash or become unreachable.
		 * @param keepalive Value for the keepalive flag
		 */
		set_keepalive(keepalive: boolean): void;
		/**
		 * Sets the maximum number of outstanding connections allowed
		 * when listening on this socket. If more clients than this are
		 * connecting to the socket and the application is not handling them
		 * on time then the new connections will be refused.
		 * 
		 * Note that this must be called before {@link G.socket_listen} and has no
		 * effect if called after that.
		 * @param backlog the maximum number of pending connections.
		 */
		set_listen_backlog(backlog: number): void;
		/**
		 * Sets whether outgoing multicast packets will be received by sockets
		 * listening on that multicast address on the same host. This is %TRUE
		 * by default.
		 * @param loopback whether #socket should receive messages sent to its
		 *   multicast groups from the local host
		 */
		set_multicast_loopback(loopback: boolean): void;
		/**
		 * Sets the time-to-live for outgoing multicast datagrams on #socket.
		 * By default, this is 1, meaning that multicast packets will not leave
		 * the local network.
		 * @param ttl the time-to-live value for all multicast datagrams on #socket
		 */
		set_multicast_ttl(ttl: number): void;
		/**
		 * Sets the value of an integer-valued option on #socket, as with
		 * setsockopt(). (If you need to set a non-integer-valued option,
		 * you will need to call setsockopt() directly.)
		 * 
		 * The [<gio/gnetworking.h>][gio-gnetworking.h]
		 * header pulls in system headers that will define most of the
		 * standard/portable socket options. For unusual socket protocols or
		 * platform-dependent options, you may need to include additional
		 * headers.
		 * @param level the "API level" of the option (eg, `SOL_SOCKET`)
		 * @param optname the "name" of the option (eg, `SO_BROADCAST`)
		 * @param value the value to set the option to
		 * @returns success or failure. On failure, #error will be set, and
		 *   the system error value (`errno` or WSAGetLastError()) will still
		 *   be set to the result of the setsockopt() call.
		 */
		set_option(level: number, optname: number, value: number): boolean;
		/**
		 * Sets the time in seconds after which I/O operations on #socket will
		 * time out if they have not yet completed.
		 * 
		 * On a blocking socket, this means that any blocking #GSocket
		 * operation will time out after #timeout seconds of inactivity,
		 * returning %G_IO_ERROR_TIMED_OUT.
		 * 
		 * On a non-blocking socket, calls to {@link G.socket_condition_wait} will
		 * also fail with %G_IO_ERROR_TIMED_OUT after the given time. Sources
		 * created with g_socket_create_source() will trigger after
		 * #timeout seconds of inactivity, with the requested condition
		 * set, at which point calling g_socket_receive(), g_socket_send(),
		 * g_socket_check_connect_result(), etc, will fail with
		 * %G_IO_ERROR_TIMED_OUT.
		 * 
		 * If #timeout is 0 (the default), operations will never time out
		 * on their own.
		 * 
		 * Note that if an I/O operation is interrupted by a signal, this may
		 * cause the timeout to be reset.
		 * @param timeout the timeout for #socket, in seconds, or 0 for none
		 */
		set_timeout(timeout: number): void;
		/**
		 * Sets the time-to-live for outgoing unicast packets on #socket.
		 * By default the platform-specific default value is used.
		 * @param ttl the time-to-live value for all unicast packets on #socket
		 */
		set_ttl(ttl: number): void;
		/**
		 * Shut down part or all of a full-duplex connection.
		 * 
		 * If #shutdown_read is %TRUE then the receiving side of the connection
		 * is shut down, and further reading is disallowed.
		 * 
		 * If #shutdown_write is %TRUE then the sending side of the connection
		 * is shut down, and further writing is disallowed.
		 * 
		 * It is allowed for both #shutdown_read and #shutdown_write to be %TRUE.
		 * 
		 * One example where it is useful to shut down only one side of a connection is
		 * graceful disconnect for TCP connections where you close the sending side,
		 * then wait for the other side to close the connection, thus ensuring that the
		 * other side saw all sent data.
		 * @param shutdown_read whether to shut down the read side
		 * @param shutdown_write whether to shut down the write side
		 * @returns %TRUE on success, %FALSE on error
		 */
		shutdown(shutdown_read: boolean, shutdown_write: boolean): boolean;
		/**
		 * Checks if a socket is capable of speaking IPv4.
		 * 
		 * IPv4 sockets are capable of speaking IPv4.  On some operating systems
		 * and under some combinations of circumstances IPv6 sockets are also
		 * capable of speaking IPv4.  See RFC 3493 section 3.7 for more
		 * information.
		 * 
		 * No other types of sockets are currently considered as being capable
		 * of speaking IPv4.
		 * @returns %TRUE if this socket can be used with IPv4.
		 */
		speaks_ipv4(): boolean;
		connect(signal: "notify::blocking", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::broadcast", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::family", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::fd", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::keepalive", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::listen-backlog", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::local-address", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::multicast-loopback", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::multicast-ttl", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::protocol", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::remote-address", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::timeout", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::ttl", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::type", callback: (owner: this, ...args: any) => void): number;

	}

	type SocketInitOptionsMixin = GObject.ObjectInitOptions & DatagramBasedInitOptions & InitableInitOptions & 
	Pick<ISocket,
		"blocking" |
		"broadcast" |
		"family" |
		"fd" |
		"keepalive" |
		"listen_backlog" |
		"multicast_loopback" |
		"multicast_ttl" |
		"protocol" |
		"timeout" |
		"ttl" |
		"type">;

	export interface SocketInitOptions extends SocketInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link Socket} instead.
	 */
	type SocketMixin = ISocket & GObject.Object & DatagramBased & Initable;

	/**
	 * A #GSocket is a low-level networking primitive. It is a more or less
	 * direct mapping of the BSD socket API in a portable GObject based API.
	 * It supports both the UNIX socket implementations and winsock2 on Windows.
	 * 
	 * #GSocket is the platform independent base upon which the higher level
	 * network primitives are based. Applications are not typically meant to
	 * use it directly, but rather through classes like #GSocketClient,
	 * #GSocketService and #GSocketConnection. However there may be cases where
	 * direct use of #GSocket is useful.
	 * 
	 * #GSocket implements the #GInitable interface, so if it is manually constructed
	 * by e.g. {@link GObject.new} you must call g_initable_init() and check the
	 * results before using the object. This is done automatically in
	 * g_socket_new() and g_socket_new_from_fd(), so these functions can return
	 * %NULL.
	 * 
	 * Sockets operate in two general modes, blocking or non-blocking. When
	 * in blocking mode all operations (which don’t take an explicit blocking
	 * parameter) block until the requested operation
	 * is finished or there is an error. In non-blocking mode all calls that
	 * would block return immediately with a %G_IO_ERROR_WOULD_BLOCK error.
	 * To know when a call would successfully run you can call g_socket_condition_check(),
	 * or g_socket_condition_wait(). You can also use g_socket_create_source() and
	 * attach it to a #GMainContext to get callbacks when I/O is possible.
	 * Note that all sockets are always set to non blocking mode in the system, and
	 * blocking mode is emulated in GSocket.
	 * 
	 * When working in non-blocking mode applications should always be able to
	 * handle getting a %G_IO_ERROR_WOULD_BLOCK error even when some other
	 * function said that I/O was possible. This can easily happen in case
	 * of a race condition in the application, but it can also happen for other
	 * reasons. For instance, on Windows a socket is always seen as writable
	 * until a write returns %G_IO_ERROR_WOULD_BLOCK.
	 * 
	 * #GSockets can be either connection oriented or datagram based.
	 * For connection oriented types you must first establish a connection by
	 * either connecting to an address or accepting a connection from another
	 * address. For connectionless socket types the target/source address is
	 * specified or received in each I/O operation.
	 * 
	 * All socket file descriptors are set to be close-on-exec.
	 * 
	 * Note that creating a #GSocket causes the signal %SIGPIPE to be
	 * ignored for the remainder of the program. If you are writing a
	 * command-line utility that uses #GSocket, you may need to take into
	 * account the fact that your program will not automatically be killed
	 * if it tries to write to %stdout after it has been closed.
	 * 
	 * Like most other APIs in GLib, #GSocket is not inherently thread safe. To use
	 * a #GSocket concurrently from multiple threads, you must implement your own
	 * locking.
	 */
	interface Socket extends SocketMixin {}

	class Socket {
		public constructor(options?: Partial<SocketInitOptions>);
		/**
		 * Creates a new #GSocket with the defined family, type and protocol.
		 * If #protocol is 0 (%G_SOCKET_PROTOCOL_DEFAULT) the default protocol type
		 * for the family and type is used.
		 * 
		 * The #protocol is a family and type specific int that specifies what
		 * kind of protocol to use. #GSocketProtocol lists several common ones.
		 * Many families only support one protocol, and use 0 for this, others
		 * support several and using 0 means to use the default protocol for
		 * the family and type.
		 * 
		 * The protocol id is passed directly to the operating
		 * system, so you can use protocols not listed in #GSocketProtocol if you
		 * know the protocol number used for it.
		 * @param family the socket family to use, e.g. %G_SOCKET_FAMILY_IPV4.
		 * @param type the socket type to use.
		 * @param protocol the id of the protocol to use, or 0 for default.
		 * @returns a #GSocket or %NULL on error.
		 *     Free the returned object with {@link GObject.unref}.
		 */
		public static new(family: SocketFamily, type: SocketType, protocol: SocketProtocol): Socket;
		/**
		 * Creates a new #GSocket from a native file descriptor
		 * or winsock SOCKET handle.
		 * 
		 * This reads all the settings from the file descriptor so that
		 * all properties should work. Note that the file descriptor
		 * will be set to non-blocking mode, independent on the blocking
		 * mode of the #GSocket.
		 * 
		 * On success, the returned #GSocket takes ownership of #fd. On failure, the
		 * caller must close #fd themselves.
		 * 
		 * Since GLib 2.46, it is no longer a fatal error to call this on a non-socket
		 * descriptor.  Instead, a GError will be set with code %G_IO_ERROR_FAILED
		 * @param fd a native socket file descriptor.
		 * @returns a #GSocket or %NULL on error.
		 *     Free the returned object with {@link GObject.unref}.
		 */
		public static new_from_fd(fd: number): Socket;
	}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link SocketAddress} instead.
	 */
	interface ISocketAddress {
		readonly family: SocketFamily;
		/**
		 * Gets the socket family type of #address.
		 * @returns the socket family type of #address
		 */
		get_family(): SocketFamily;
		/**
		 * Gets the size of #address's native struct sockaddr.
		 * You can use this to allocate memory to pass to
		 * {@link G.socket_address_to_native}.
		 * @returns the size of the native struct sockaddr that
		 *     #address represents
		 */
		get_native_size(): number;
		/**
		 * Converts a #GSocketAddress to a native struct sockaddr, which can
		 * be passed to low-level functions like connect() or bind().
		 * 
		 * If not enough space is available, a %G_IO_ERROR_NO_SPACE error
		 * is returned. If the address type is not known on the system
		 * then a %G_IO_ERROR_NOT_SUPPORTED error is returned.
		 * @param dest a pointer to a memory location that will contain the native
		 * struct sockaddr
		 * @param destlen the size of #dest. Must be at least as large as
		 *     {@link G.socket_address_get_native_size}
		 * @returns %TRUE if #dest was filled in, %FALSE on error
		 */
		to_native(dest: any | null, destlen: number): boolean;
		connect(signal: "notify::family", callback: (owner: this, ...args: any) => void): number;

	}

	type SocketAddressInitOptionsMixin = GObject.ObjectInitOptions & SocketConnectableInitOptions
	export interface SocketAddressInitOptions extends SocketAddressInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link SocketAddress} instead.
	 */
	type SocketAddressMixin = ISocketAddress & GObject.Object & SocketConnectable;

	/**
	 * #GSocketAddress is the equivalent of struct sockaddr in the BSD
	 * sockets API. This is an abstract class; use #GInetSocketAddress
	 * for internet sockets, or #GUnixSocketAddress for UNIX domain sockets.
	 */
	interface SocketAddress extends SocketAddressMixin {}

	class SocketAddress {
		public constructor(options?: Partial<SocketAddressInitOptions>);
		/**
		 * Creates a #GSocketAddress subclass corresponding to the native
		 * struct sockaddr #native.
		 * @param _native a pointer to a struct sockaddr
		 * @param len the size of the memory location pointed to by #native
		 * @returns a new #GSocketAddress if #native could successfully
		 *     be converted, otherwise %NULL
		 */
		public static new_from_native(_native: any, len: number): SocketAddress;
	}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link SocketAddressEnumerator} instead.
	 */
	interface ISocketAddressEnumerator {
		/**
		 * Retrieves the next #GSocketAddress from #enumerator. Note that this
		 * may block for some amount of time. (Eg, a #GNetworkAddress may need
		 * to do a DNS lookup before it can return an address.) Use
		 * {@link G.socket_address_enumerator_next_async} if you need to avoid
		 * blocking.
		 * 
		 * If #enumerator is expected to yield addresses, but for some reason
		 * is unable to (eg, because of a DNS error), then the first call to
		 * g_socket_address_enumerator_next() will return an appropriate error
		 * in *#error. However, if the first call to
		 * g_socket_address_enumerator_next() succeeds, then any further
		 * internal errors (other than #cancellable being triggered) will be
		 * ignored.
		 * @param cancellable optional #GCancellable object, %NULL to ignore.
		 * @returns a #GSocketAddress (owned by the caller), or %NULL on
		 *     error (in which case *#error will be set) or if there are no
		 *     more addresses.
		 */
		next(cancellable?: Cancellable | null): SocketAddress;
		/**
		 * Asynchronously retrieves the next #GSocketAddress from #enumerator
		 * and then calls #callback, which must call
		 * {@link G.socket_address_enumerator_next_finish} to get the result.
		 * 
		 * It is an error to call this multiple times before the previous callback has finished.
		 * @param cancellable optional #GCancellable object, %NULL to ignore.
		 * @param callback a #GAsyncReadyCallback to call when the request
		 *     is satisfied
		 */
		next_async(cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;
		/**
		 * Retrieves the result of a completed call to
		 * {@link G.socket_address_enumerator_next_async}. See
		 * g_socket_address_enumerator_next() for more information about
		 * error handling.
		 * @param result a #GAsyncResult
		 * @returns a #GSocketAddress (owned by the caller), or %NULL on
		 *     error (in which case *#error will be set) or if there are no
		 *     more addresses.
		 */
		next_finish(result: AsyncResult): SocketAddress;
	}

	type SocketAddressEnumeratorInitOptionsMixin = GObject.ObjectInitOptions
	export interface SocketAddressEnumeratorInitOptions extends SocketAddressEnumeratorInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link SocketAddressEnumerator} instead.
	 */
	type SocketAddressEnumeratorMixin = ISocketAddressEnumerator & GObject.Object;

	/**
	 * #GSocketAddressEnumerator is an enumerator type for #GSocketAddress
	 * instances. It is returned by enumeration functions such as
	 * {@link G.socket_connectable_enumerate}, which returns a #GSocketAddressEnumerator
	 * to list each #GSocketAddress which could be used to connect to that
	 * #GSocketConnectable.
	 * 
	 * Enumeration is typically a blocking operation, so the asynchronous methods
	 * g_socket_address_enumerator_next_async() and
	 * g_socket_address_enumerator_next_finish() should be used where possible.
	 * 
	 * Each #GSocketAddressEnumerator can only be enumerated once. Once
	 * g_socket_address_enumerator_next() has returned %NULL, further
	 * enumeration with that #GSocketAddressEnumerator is not possible, and it can
	 * be unreffed.
	 */
	interface SocketAddressEnumerator extends SocketAddressEnumeratorMixin {}

	class SocketAddressEnumerator {
		public constructor(options?: Partial<SocketAddressEnumeratorInitOptions>);
	}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link SocketClient} instead.
	 */
	interface ISocketClient {
		enable_proxy: boolean;
		family: SocketFamily;
		local_address: SocketAddress;
		protocol: SocketProtocol;
		/**
		 * The proxy resolver to use
		 */
		proxy_resolver: ProxyResolver;
		timeout: number;
		tls: boolean;
		tls_validation_flags: TlsCertificateFlags;
		type: SocketType;
		/**
		 * Enable proxy protocols to be handled by the application. When the
		 * indicated proxy protocol is returned by the #GProxyResolver,
		 * #GSocketClient will consider this protocol as supported but will
		 * not try to find a #GProxy instance to handle handshaking. The
		 * application must check for this case by calling
		 * {@link G.socket_connection_get_remote_address} on the returned
		 * #GSocketConnection, and seeing if it's a #GProxyAddress of the
		 * appropriate type, to determine whether or not it needs to handle
		 * the proxy handshaking itself.
		 * 
		 * This should be used for proxy protocols that are dialects of
		 * another protocol such as HTTP proxy. It also allows cohabitation of
		 * proxy protocols that are reused between protocols. A good example
		 * is HTTP. It can be used to proxy HTTP, FTP and Gopher and can also
		 * be use as generic socket proxy through the HTTP CONNECT method.
		 * 
		 * When the proxy is detected as being an application proxy, TLS handshake
		 * will be skipped. This is required to let the application do the proxy
		 * specific handshake.
		 * @param protocol The proxy protocol
		 */
		add_application_proxy(protocol: string): void;
		/**
		 * Tries to resolve the #connectable and make a network connection to it.
		 * 
		 * Upon a successful connection, a new #GSocketConnection is constructed
		 * and returned.  The caller owns this new object and must drop their
		 * reference to it when finished with it.
		 * 
		 * The type of the #GSocketConnection object returned depends on the type of
		 * the underlying socket that is used. For instance, for a TCP/IP connection
		 * it will be a #GTcpConnection.
		 * 
		 * The socket created will be the same family as the address that the
		 * #connectable resolves to, unless family is set with {@link G.socket_client_set_family}
		 * or indirectly via g_socket_client_set_local_address(). The socket type
		 * defaults to %G_SOCKET_TYPE_STREAM but can be set with
		 * g_socket_client_set_socket_type().
		 * 
		 * If a local address is specified with g_socket_client_set_local_address() the
		 * socket will be bound to this address before connecting.
		 * @param connectable a #GSocketConnectable specifying the remote address.
		 * @param cancellable optional #GCancellable object, %NULL to ignore.
		 * @returns a #GSocketConnection on success, %NULL on error.
		 */
		connect(connectable: SocketConnectable, cancellable?: Cancellable | null): SocketConnection;
		/**
		 * This is the asynchronous version of {@link G.socket_client_connect}.
		 * 
		 * You may wish to prefer the asynchronous version even in synchronous
		 * command line programs because, since 2.60, it implements
		 * [RFC 8305](https://tools.ietf.org/html/rfc8305) "Happy Eyeballs"
		 * recommendations to work around long connection timeouts in networks
		 * where IPv6 is broken by performing an IPv4 connection simultaneously
		 * without waiting for IPv6 to time out, which is not supported by the
		 * synchronous call. (This is not an API guarantee, and may change in
		 * the future.)
		 * 
		 * When the operation is finished #callback will be
		 * called. You can then call g_socket_client_connect_finish() to get
		 * the result of the operation.
		 * @param connectable a #GSocketConnectable specifying the remote address.
		 * @param cancellable a #GCancellable, or %NULL
		 * @param callback a #GAsyncReadyCallback
		 */
		connect_async(connectable: SocketConnectable, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;
		/**
		 * Finishes an async connect operation. See {@link G.socket_client_connect_async}
		 * @param result a #GAsyncResult.
		 * @returns a #GSocketConnection on success, %NULL on error.
		 */
		connect_finish(result: AsyncResult): SocketConnection;
		/**
		 * This is a helper function for {@link G.socket_client_connect}.
		 * 
		 * Attempts to create a TCP connection to the named host.
		 * 
		 * #host_and_port may be in any of a number of recognized formats; an IPv6
		 * address, an IPv4 address, or a domain name (in which case a DNS
		 * lookup is performed).  Quoting with [] is supported for all address
		 * types.  A port override may be specified in the usual way with a
		 * colon.  Ports may be given as decimal numbers or symbolic names (in
		 * which case an /etc/services lookup is performed).
		 * 
		 * If no port override is given in #host_and_port then #default_port will be
		 * used as the port number to connect to.
		 * 
		 * In general, #host_and_port is expected to be provided by the user (allowing
		 * them to give the hostname, and a port override if necessary) and
		 * #default_port is expected to be provided by the application.
		 * 
		 * In the case that an IP address is given, a single connection
		 * attempt is made.  In the case that a name is given, multiple
		 * connection attempts may be made, in turn and according to the
		 * number of address records in DNS, until a connection succeeds.
		 * 
		 * Upon a successful connection, a new #GSocketConnection is constructed
		 * and returned.  The caller owns this new object and must drop their
		 * reference to it when finished with it.
		 * 
		 * In the event of any failure (DNS error, service not found, no hosts
		 * connectable) %NULL is returned and #error (if non-%NULL) is set
		 * accordingly.
		 * @param host_and_port the name and optionally port of the host to connect to
		 * @param default_port the default port to connect to
		 * @param cancellable a #GCancellable, or %NULL
		 * @returns a #GSocketConnection on success, %NULL on error.
		 */
		connect_to_host(host_and_port: string, default_port: number, cancellable?: Cancellable | null): SocketConnection;
		/**
		 * This is the asynchronous version of {@link G.socket_client_connect_to_host}.
		 * 
		 * When the operation is finished #callback will be
		 * called. You can then call g_socket_client_connect_to_host_finish() to get
		 * the result of the operation.
		 * @param host_and_port the name and optionally the port of the host to connect to
		 * @param default_port the default port to connect to
		 * @param cancellable a #GCancellable, or %NULL
		 * @param callback a #GAsyncReadyCallback
		 */
		connect_to_host_async(host_and_port: string, default_port: number, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;
		/**
		 * Finishes an async connect operation. See {@link G.socket_client_connect_to_host_async}
		 * @param result a #GAsyncResult.
		 * @returns a #GSocketConnection on success, %NULL on error.
		 */
		connect_to_host_finish(result: AsyncResult): SocketConnection;
		/**
		 * Attempts to create a TCP connection to a service.
		 * 
		 * This call looks up the SRV record for #service at #domain for the
		 * "tcp" protocol.  It then attempts to connect, in turn, to each of
		 * the hosts providing the service until either a connection succeeds
		 * or there are no hosts remaining.
		 * 
		 * Upon a successful connection, a new #GSocketConnection is constructed
		 * and returned.  The caller owns this new object and must drop their
		 * reference to it when finished with it.
		 * 
		 * In the event of any failure (DNS error, service not found, no hosts
		 * connectable) %NULL is returned and #error (if non-%NULL) is set
		 * accordingly.
		 * @param domain a domain name
		 * @param service the name of the service to connect to
		 * @param cancellable a #GCancellable, or %NULL
		 * @returns a #GSocketConnection if successful, or %NULL on error
		 */
		connect_to_service(domain: string, service: string, cancellable?: Cancellable | null): SocketConnection;
		/**
		 * This is the asynchronous version of
		 * {@link G.socket_client_connect_to_service}.
		 * @param domain a domain name
		 * @param service the name of the service to connect to
		 * @param cancellable a #GCancellable, or %NULL
		 * @param callback a #GAsyncReadyCallback
		 */
		connect_to_service_async(domain: string, service: string, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;
		/**
		 * Finishes an async connect operation. See {@link G.socket_client_connect_to_service_async}
		 * @param result a #GAsyncResult.
		 * @returns a #GSocketConnection on success, %NULL on error.
		 */
		connect_to_service_finish(result: AsyncResult): SocketConnection;
		/**
		 * This is a helper function for {@link G.socket_client_connect}.
		 * 
		 * Attempts to create a TCP connection with a network URI.
		 * 
		 * #uri may be any valid URI containing an "authority" (hostname/port)
		 * component. If a port is not specified in the URI, #default_port
		 * will be used. TLS will be negotiated if #GSocketClient:tls is %TRUE.
		 * (#GSocketClient does not know to automatically assume TLS for
		 * certain URI schemes.)
		 * 
		 * Using this rather than g_socket_client_connect() or
		 * g_socket_client_connect_to_host() allows #GSocketClient to
		 * determine when to use application-specific proxy protocols.
		 * 
		 * Upon a successful connection, a new #GSocketConnection is constructed
		 * and returned.  The caller owns this new object and must drop their
		 * reference to it when finished with it.
		 * 
		 * In the event of any failure (DNS error, service not found, no hosts
		 * connectable) %NULL is returned and #error (if non-%NULL) is set
		 * accordingly.
		 * @param uri A network URI
		 * @param default_port the default port to connect to
		 * @param cancellable a #GCancellable, or %NULL
		 * @returns a #GSocketConnection on success, %NULL on error.
		 */
		connect_to_uri(uri: string, default_port: number, cancellable?: Cancellable | null): SocketConnection;
		/**
		 * This is the asynchronous version of {@link G.socket_client_connect_to_uri}.
		 * 
		 * When the operation is finished #callback will be
		 * called. You can then call g_socket_client_connect_to_uri_finish() to get
		 * the result of the operation.
		 * @param uri a network uri
		 * @param default_port the default port to connect to
		 * @param cancellable a #GCancellable, or %NULL
		 * @param callback a #GAsyncReadyCallback
		 */
		connect_to_uri_async(uri: string, default_port: number, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;
		/**
		 * Finishes an async connect operation. See {@link G.socket_client_connect_to_uri_async}
		 * @param result a #GAsyncResult.
		 * @returns a #GSocketConnection on success, %NULL on error.
		 */
		connect_to_uri_finish(result: AsyncResult): SocketConnection;
		/**
		 * Gets the proxy enable state; see {@link G.socket_client_set_enable_proxy}
		 * @returns whether proxying is enabled
		 */
		get_enable_proxy(): boolean;
		/**
		 * Gets the socket family of the socket client.
		 * 
		 * See {@link G.socket_client_set_family} for details.
		 * @returns a #GSocketFamily
		 */
		get_family(): SocketFamily;
		/**
		 * Gets the local address of the socket client.
		 * 
		 * See {@link G.socket_client_set_local_address} for details.
		 * @returns a #GSocketAddress or %NULL. Do not free.
		 */
		get_local_address(): SocketAddress | null;
		/**
		 * Gets the protocol name type of the socket client.
		 * 
		 * See {@link G.socket_client_set_protocol} for details.
		 * @returns a #GSocketProtocol
		 */
		get_protocol(): SocketProtocol;
		/**
		 * Gets the #GProxyResolver being used by #client. Normally, this will
		 * be the resolver returned by {@link G.proxy_resolver_get_default}, but you
		 * can override it with g_socket_client_set_proxy_resolver().
		 * @returns The #GProxyResolver being used by
		 *   #client.
		 */
		get_proxy_resolver(): ProxyResolver;
		/**
		 * Gets the socket type of the socket client.
		 * 
		 * See {@link G.socket_client_set_socket_type} for details.
		 * @returns a #GSocketFamily
		 */
		get_socket_type(): SocketType;
		/**
		 * Gets the I/O timeout time for sockets created by #client.
		 * 
		 * See {@link G.socket_client_set_timeout} for details.
		 * @returns the timeout in seconds
		 */
		get_timeout(): number;
		/**
		 * Gets whether #client creates TLS connections. See
		 * {@link G.socket_client_set_tls} for details.
		 * @returns whether #client uses TLS
		 */
		get_tls(): boolean;
		/**
		 * Gets the TLS validation flags used creating TLS connections via
		 * #client.
		 * @returns the TLS validation flags
		 */
		get_tls_validation_flags(): TlsCertificateFlags;
		/**
		 * Sets whether or not #client attempts to make connections via a
		 * proxy server. When enabled (the default), #GSocketClient will use a
		 * #GProxyResolver to determine if a proxy protocol such as SOCKS is
		 * needed, and automatically do the necessary proxy negotiation.
		 * 
		 * See also {@link G.socket_client_set_proxy_resolver}.
		 * @param enable whether to enable proxies
		 */
		set_enable_proxy(enable: boolean): void;
		/**
		 * Sets the socket family of the socket client.
		 * If this is set to something other than %G_SOCKET_FAMILY_INVALID
		 * then the sockets created by this object will be of the specified
		 * family.
		 * 
		 * This might be useful for instance if you want to force the local
		 * connection to be an ipv4 socket, even though the address might
		 * be an ipv6 mapped to ipv4 address.
		 * @param family a #GSocketFamily
		 */
		set_family(family: SocketFamily): void;
		/**
		 * Sets the local address of the socket client.
		 * The sockets created by this object will bound to the
		 * specified address (if not %NULL) before connecting.
		 * 
		 * This is useful if you want to ensure that the local
		 * side of the connection is on a specific port, or on
		 * a specific interface.
		 * @param address a #GSocketAddress, or %NULL
		 */
		set_local_address(address?: SocketAddress | null): void;
		/**
		 * Sets the protocol of the socket client.
		 * The sockets created by this object will use of the specified
		 * protocol.
		 * 
		 * If #protocol is %G_SOCKET_PROTOCOL_DEFAULT that means to use the default
		 * protocol for the socket family and type.
		 * @param protocol a #GSocketProtocol
		 */
		set_protocol(protocol: SocketProtocol): void;
		/**
		 * Overrides the #GProxyResolver used by #client. You can call this if
		 * you want to use specific proxies, rather than using the system
		 * default proxy settings.
		 * 
		 * Note that whether or not the proxy resolver is actually used
		 * depends on the setting of #GSocketClient:enable-proxy, which is not
		 * changed by this function (but which is %TRUE by default)
		 * @param proxy_resolver a #GProxyResolver, or %NULL for the
		 *   default.
		 */
		set_proxy_resolver(proxy_resolver?: ProxyResolver | null): void;
		/**
		 * Sets the socket type of the socket client.
		 * The sockets created by this object will be of the specified
		 * type.
		 * 
		 * It doesn't make sense to specify a type of %G_SOCKET_TYPE_DATAGRAM,
		 * as GSocketClient is used for connection oriented services.
		 * @param type a #GSocketType
		 */
		set_socket_type(type: SocketType): void;
		/**
		 * Sets the I/O timeout for sockets created by #client. #timeout is a
		 * time in seconds, or 0 for no timeout (the default).
		 * 
		 * The timeout value affects the initial connection attempt as well,
		 * so setting this may cause calls to {@link G.socket_client_connect}, etc,
		 * to fail with %G_IO_ERROR_TIMED_OUT.
		 * @param timeout the timeout
		 */
		set_timeout(timeout: number): void;
		/**
		 * Sets whether #client creates TLS (aka SSL) connections. If #tls is
		 * %TRUE, #client will wrap its connections in a #GTlsClientConnection
		 * and perform a TLS handshake when connecting.
		 * 
		 * Note that since #GSocketClient must return a #GSocketConnection,
		 * but #GTlsClientConnection is not a #GSocketConnection, this
		 * actually wraps the resulting #GTlsClientConnection in a
		 * #GTcpWrapperConnection when returning it. You can use
		 * {@link G.tcp_wrapper_connection_get_base_io_stream} on the return value
		 * to extract the #GTlsClientConnection.
		 * 
		 * If you need to modify the behavior of the TLS handshake (eg, by
		 * setting a client-side certificate to use, or connecting to the
		 * #GTlsConnection::accept-certificate signal), you can connect to
		 * #client's #GSocketClient::event signal and wait for it to be
		 * emitted with %G_SOCKET_CLIENT_TLS_HANDSHAKING, which will give you
		 * a chance to see the #GTlsClientConnection before the handshake
		 * starts.
		 * @param tls whether to use TLS
		 */
		set_tls(tls: boolean): void;
		/**
		 * Sets the TLS validation flags used when creating TLS connections
		 * via #client. The default value is %G_TLS_CERTIFICATE_VALIDATE_ALL.
		 * @param flags the validation flags
		 */
		set_tls_validation_flags(flags: TlsCertificateFlags): void;
		/**
		 * Emitted when #client's activity on #connectable changes state.
		 * Among other things, this can be used to provide progress
		 * information about a network connection in the UI. The meanings of
		 * the different #event values are as follows:
		 * 
		 * - %G_SOCKET_CLIENT_RESOLVING: #client is about to look up #connectable
		 *   in DNS. #connection will be %NULL.
		 * 
		 * - %G_SOCKET_CLIENT_RESOLVED:  #client has successfully resolved
		 *   #connectable in DNS. #connection will be %NULL.
		 * 
		 * - %G_SOCKET_CLIENT_CONNECTING: #client is about to make a connection
		 *   to a remote host; either a proxy server or the destination server
		 *   itself. #connection is the #GSocketConnection, which is not yet
		 *   connected.  Since GLib 2.40, you can access the remote
		 *   address via {@link G.socket_connection_get_remote_address}.
		 * 
		 * - %G_SOCKET_CLIENT_CONNECTED: #client has successfully connected
		 *   to a remote host. #connection is the connected #GSocketConnection.
		 * 
		 * - %G_SOCKET_CLIENT_PROXY_NEGOTIATING: #client is about to negotiate
		 *   with a proxy to get it to connect to #connectable. #connection is
		 *   the #GSocketConnection to the proxy server.
		 * 
		 * - %G_SOCKET_CLIENT_PROXY_NEGOTIATED: #client has negotiated a
		 *   connection to #connectable through a proxy server. #connection is
		 *   the stream returned from g_proxy_connect(), which may or may not
		 *   be a #GSocketConnection.
		 * 
		 * - %G_SOCKET_CLIENT_TLS_HANDSHAKING: #client is about to begin a TLS
		 *   handshake. #connection is a #GTlsClientConnection.
		 * 
		 * - %G_SOCKET_CLIENT_TLS_HANDSHAKED: #client has successfully completed
		 *   the TLS handshake. #connection is a #GTlsClientConnection.
		 * 
		 * - %G_SOCKET_CLIENT_COMPLETE: #client has either successfully connected
		 *   to #connectable (in which case #connection is the #GSocketConnection
		 *   that it will be returning to the caller) or has failed (in which
		 *   case #connection is %NULL and the client is about to return an error).
		 * 
		 * Each event except %G_SOCKET_CLIENT_COMPLETE may be emitted
		 * multiple times (or not at all) for a given connectable (in
		 * particular, if #client ends up attempting to connect to more than
		 * one address). However, if #client emits the #GSocketClient::event
		 * signal at all for a given connectable, then it will always emit
		 * it with %G_SOCKET_CLIENT_COMPLETE when it is done.
		 * 
		 * Note that there may be additional #GSocketClientEvent values in
		 * the future; unrecognized #event values should be ignored.
		 * @param signal 
		 * @param callback Callback function
		 *  - owner: owner of the emitted event 
		 *  - event: the event that is occurring 
		 *  - connectable: the #GSocketConnectable that #event is occurring on 
		 *  - connection: the current representation of the connection 
		 * 
		 * @returns Callback ID
		 */
		connect(signal: "event", callback: (owner: this, event: SocketClientEvent, connectable: SocketConnectable, connection: IOStream | null) => void): number;

		connect(signal: "notify::enable-proxy", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::family", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::local-address", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::protocol", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::proxy-resolver", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::timeout", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::tls", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::tls-validation-flags", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::type", callback: (owner: this, ...args: any) => void): number;

	}

	type SocketClientInitOptionsMixin = GObject.ObjectInitOptions & 
	Pick<ISocketClient,
		"enable_proxy" |
		"family" |
		"local_address" |
		"protocol" |
		"proxy_resolver" |
		"timeout" |
		"tls" |
		"tls_validation_flags" |
		"type">;

	export interface SocketClientInitOptions extends SocketClientInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link SocketClient} instead.
	 */
	type SocketClientMixin = ISocketClient & GObject.Object;

	/**
	 * #GSocketClient is a lightweight high-level utility class for connecting to
	 * a network host using a connection oriented socket type.
	 * 
	 * You create a #GSocketClient object, set any options you want, and then
	 * call a sync or async connect operation, which returns a #GSocketConnection
	 * subclass on success.
	 * 
	 * The type of the #GSocketConnection object returned depends on the type of
	 * the underlying socket that is in use. For instance, for a TCP/IP connection
	 * it will be a #GTcpConnection.
	 * 
	 * As #GSocketClient is a lightweight object, you don't need to cache it. You
	 * can just create a new one any time you need one.
	 */
	interface SocketClient extends SocketClientMixin {}

	class SocketClient {
		public constructor(options?: Partial<SocketClientInitOptions>);
		/**
		 * Creates a new #GSocketClient with the default options.
		 * @returns a #GSocketClient.
		 *     Free the returned object with {@link GObject.unref}.
		 */
		public static new(): SocketClient;
	}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link SocketConnection} instead.
	 */
	interface ISocketConnection {
		socket: Socket;
		/**
		 * Connect #connection to the specified remote address.
		 * @param address a #GSocketAddress specifying the remote address.
		 * @param cancellable a %GCancellable or %NULL
		 * @returns %TRUE if the connection succeeded, %FALSE on error
		 */
		connect(address: SocketAddress, cancellable?: Cancellable | null): boolean;
		/**
		 * Asynchronously connect #connection to the specified remote address.
		 * 
		 * This clears the #GSocket:blocking flag on #connection's underlying
		 * socket if it is currently set.
		 * 
		 * Use {@link G.socket_connection_connect_finish} to retrieve the result.
		 * @param address a #GSocketAddress specifying the remote address.
		 * @param cancellable a %GCancellable or %NULL
		 * @param callback a #GAsyncReadyCallback
		 */
		connect_async(address: SocketAddress, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;
		/**
		 * Gets the result of a {@link G.socket_connection_connect_async} call.
		 * @param result the #GAsyncResult
		 * @returns %TRUE if the connection succeeded, %FALSE on error
		 */
		connect_finish(result: AsyncResult): boolean;
		/**
		 * Try to get the local address of a socket connection.
		 * @returns a #GSocketAddress or %NULL on error.
		 *     Free the returned object with {@link GObject.unref}.
		 */
		get_local_address(): SocketAddress;
		/**
		 * Try to get the remote address of a socket connection.
		 * 
		 * Since GLib 2.40, when used with {@link G.socket_client_connect} or
		 * g_socket_client_connect_async(), during emission of
		 * %G_SOCKET_CLIENT_CONNECTING, this function will return the remote
		 * address that will be used for the connection.  This allows
		 * applications to print e.g. "Connecting to example.com
		 * (10.42.77.3)...".
		 * @returns a #GSocketAddress or %NULL on error.
		 *     Free the returned object with {@link GObject.unref}.
		 */
		get_remote_address(): SocketAddress;
		/**
		 * Gets the underlying #GSocket object of the connection.
		 * This can be useful if you want to do something unusual on it
		 * not supported by the #GSocketConnection APIs.
		 * @returns a #GSocket or %NULL on error.
		 */
		get_socket(): Socket;
		/**
		 * Checks if #connection is connected. This is equivalent to calling
		 * {@link G.socket_is_connected} on #connection's underlying #GSocket.
		 * @returns whether #connection is connected
		 */
		is_connected(): boolean;
		connect(signal: "notify::socket", callback: (owner: this, ...args: any) => void): number;

	}

	type SocketConnectionInitOptionsMixin = IOStreamInitOptions & 
	Pick<ISocketConnection,
		"socket">;

	export interface SocketConnectionInitOptions extends SocketConnectionInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link SocketConnection} instead.
	 */
	type SocketConnectionMixin = ISocketConnection & IOStream;

	/**
	 * #GSocketConnection is a #GIOStream for a connected socket. They
	 * can be created either by #GSocketClient when connecting to a host,
	 * or by #GSocketListener when accepting a new client.
	 * 
	 * The type of the #GSocketConnection object returned from these calls
	 * depends on the type of the underlying socket that is in use. For
	 * instance, for a TCP/IP connection it will be a #GTcpConnection.
	 * 
	 * Choosing what type of object to construct is done with the socket
	 * connection factory, and it is possible for 3rd parties to register
	 * custom socket connection types for specific combination of socket
	 * family/type/protocol using {@link G.socket_connection_factory_register_type}.
	 * 
	 * To close a #GSocketConnection, use g_io_stream_close(). Closing both
	 * substreams of the #GIOStream separately will not close the underlying
	 * #GSocket.
	 */
	interface SocketConnection extends SocketConnectionMixin {}

	class SocketConnection {
		public constructor(options?: Partial<SocketConnectionInitOptions>);
		/**
		 * Looks up the #GType to be used when creating socket connections on
		 * sockets with the specified #family, #type and #protocol_id.
		 * 
		 * If no type is registered, the #GSocketConnection base type is returned.
		 * @param family a #GSocketFamily
		 * @param type a #GSocketType
		 * @param protocol_id a protocol id
		 * @returns a #GType
		 */
		public static factory_lookup_type(family: SocketFamily, type: SocketType, protocol_id: number): GObject.Type;
		/**
		 * Looks up the #GType to be used when creating socket connections on
		 * sockets with the specified #family, #type and #protocol.
		 * 
		 * If no type is registered, the #GSocketConnection base type is returned.
		 * @param g_type a #GType, inheriting from %G_TYPE_SOCKET_CONNECTION
		 * @param family a #GSocketFamily
		 * @param type a #GSocketType
		 * @param protocol a protocol id
		 */
		public static factory_register_type(g_type: GObject.Type, family: SocketFamily, type: SocketType, protocol: number): void;
	}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link SocketControlMessage} instead.
	 */
	interface ISocketControlMessage {
		/**
		 * Returns the "level" (i.e. the originating protocol) of the control message.
		 * This is often SOL_SOCKET.
		 * @returns an integer describing the level
		 */
		get_level(): number;
		/**
		 * Returns the protocol specific type of the control message.
		 * For instance, for UNIX fd passing this would be SCM_RIGHTS.
		 * @returns an integer describing the type of control message
		 */
		get_msg_type(): number;
		/**
		 * Returns the space required for the control message, not including
		 * headers or alignment.
		 * @returns The number of bytes required.
		 */
		get_size(): number;
		/**
		 * Converts the data in the message to bytes placed in the
		 * message.
		 * 
		 * #data is guaranteed to have enough space to fit the size
		 * returned by {@link G.socket_control_message_get_size} on this
		 * object.
		 * @param data A buffer to write data to
		 */
		serialize(data: any): void;
	}

	type SocketControlMessageInitOptionsMixin = GObject.ObjectInitOptions
	export interface SocketControlMessageInitOptions extends SocketControlMessageInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link SocketControlMessage} instead.
	 */
	type SocketControlMessageMixin = ISocketControlMessage & GObject.Object;

	/**
	 * A #GSocketControlMessage is a special-purpose utility message that
	 * can be sent to or received from a #GSocket. These types of
	 * messages are often called "ancillary data".
	 * 
	 * The message can represent some sort of special instruction to or
	 * information from the socket or can represent a special kind of
	 * transfer to the peer (for example, sending a file descriptor over
	 * a UNIX socket).
	 * 
	 * These messages are sent with {@link G.socket_send_message} and received
	 * with g_socket_receive_message().
	 * 
	 * To extend the set of control message that can be sent, subclass this
	 * class and override the get_size, get_level, get_type and serialize
	 * methods.
	 * 
	 * To extend the set of control messages that can be received, subclass
	 * this class and implement the deserialize method. Also, make sure your
	 * class is registered with the GType typesystem before calling
	 * g_socket_receive_message() to read such a message.
	 */
	interface SocketControlMessage extends SocketControlMessageMixin {}

	class SocketControlMessage {
		public constructor(options?: Partial<SocketControlMessageInitOptions>);
		/**
		 * Tries to deserialize a socket control message of a given
		 * #level and #type. This will ask all known (to GType) subclasses
		 * of #GSocketControlMessage if they can understand this kind
		 * of message and if so deserialize it into a #GSocketControlMessage.
		 * 
		 * If there is no implementation for this kind of control message, %NULL
		 * will be returned.
		 * @param level a socket level
		 * @param type a socket control message type for the given #level
		 * @param data pointer to the message data
		 * @returns the deserialized message or %NULL
		 */
		public static deserialize(level: number, type: number, data: number[]): SocketControlMessage;
	}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link SocketListener} instead.
	 */
	interface ISocketListener {
		listen_backlog: number;
		/**
		 * Blocks waiting for a client to connect to any of the sockets added
		 * to the listener. Returns a #GSocketConnection for the socket that was
		 * accepted.
		 * 
		 * If #source_object is not %NULL it will be filled out with the source
		 * object specified when the corresponding socket or address was added
		 * to the listener.
		 * 
		 * If #cancellable is not %NULL, then the operation can be cancelled by
		 * triggering the cancellable object from another thread. If the operation
		 * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
		 * @param cancellable optional #GCancellable object, %NULL to ignore.
		 * @returns a #GSocketConnection on success, %NULL on error.
		 * 
		 * location where #GObject pointer will be stored, or %NULL
		 */
		accept(cancellable?: Cancellable | null): [ SocketConnection, GObject.Object | null ];
		/**
		 * This is the asynchronous version of {@link G.socket_listener_accept}.
		 * 
		 * When the operation is finished #callback will be
		 * called. You can then call g_socket_listener_accept_finish()
		 * to get the result of the operation.
		 * @param cancellable a #GCancellable, or %NULL
		 * @param callback a #GAsyncReadyCallback
		 */
		accept_async(cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;
		/**
		 * Finishes an async accept operation. See {@link G.socket_listener_accept_async}
		 * @param result a #GAsyncResult.
		 * @returns a #GSocketConnection on success, %NULL on error.
		 * 
		 * Optional #GObject identifying this source
		 */
		accept_finish(result: AsyncResult): [ SocketConnection, GObject.Object | null ];
		/**
		 * Blocks waiting for a client to connect to any of the sockets added
		 * to the listener. Returns the #GSocket that was accepted.
		 * 
		 * If you want to accept the high-level #GSocketConnection, not a #GSocket,
		 * which is often the case, then you should use {@link G.socket_listener_accept}
		 * instead.
		 * 
		 * If #source_object is not %NULL it will be filled out with the source
		 * object specified when the corresponding socket or address was added
		 * to the listener.
		 * 
		 * If #cancellable is not %NULL, then the operation can be cancelled by
		 * triggering the cancellable object from another thread. If the operation
		 * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
		 * @param cancellable optional #GCancellable object, %NULL to ignore.
		 * @returns a #GSocket on success, %NULL on error.
		 * 
		 * location where #GObject pointer will be stored, or %NULL.
		 */
		accept_socket(cancellable?: Cancellable | null): [ Socket, GObject.Object | null ];
		/**
		 * This is the asynchronous version of {@link G.socket_listener_accept_socket}.
		 * 
		 * When the operation is finished #callback will be
		 * called. You can then call g_socket_listener_accept_socket_finish()
		 * to get the result of the operation.
		 * @param cancellable a #GCancellable, or %NULL
		 * @param callback a #GAsyncReadyCallback
		 */
		accept_socket_async(cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;
		/**
		 * Finishes an async accept operation. See {@link G.socket_listener_accept_socket_async}
		 * @param result a #GAsyncResult.
		 * @returns a #GSocket on success, %NULL on error.
		 * 
		 * Optional #GObject identifying this source
		 */
		accept_socket_finish(result: AsyncResult): [ Socket, GObject.Object | null ];
		/**
		 * Creates a socket of type #type and protocol #protocol, binds
		 * it to #address and adds it to the set of sockets we're accepting
		 * sockets from.
		 * 
		 * Note that adding an IPv6 address, depending on the platform,
		 * may or may not result in a listener that also accepts IPv4
		 * connections.  For more deterministic behavior, see
		 * {@link G.socket_listener_add_inet_port}.
		 * 
		 * #source_object will be passed out in the various calls
		 * to accept to identify this particular source, which is
		 * useful if you're listening on multiple addresses and do
		 * different things depending on what address is connected to.
		 * 
		 * If successful and #effective_address is non-%NULL then it will
		 * be set to the address that the binding actually occurred at.  This
		 * is helpful for determining the port number that was used for when
		 * requesting a binding to port 0 (ie: "any port").  This address, if
		 * requested, belongs to the caller and must be freed.
		 * 
		 * Call g_socket_listener_close() to stop listening on #address; this will not
		 * be done automatically when you drop your final reference to #listener, as
		 * references may be held internally.
		 * @param address a #GSocketAddress
		 * @param type a #GSocketType
		 * @param protocol a #GSocketProtocol
		 * @param source_object Optional #GObject identifying this source
		 * @returns %TRUE on success, %FALSE on error.
		 * 
		 * location to store the address that was bound to, or %NULL.
		 */
		add_address(address: SocketAddress, type: SocketType, protocol: SocketProtocol, source_object?: GObject.Object | null): [ boolean, SocketAddress | null ];
		/**
		 * Listens for TCP connections on any available port number for both
		 * IPv6 and IPv4 (if each is available).
		 * 
		 * This is useful if you need to have a socket for incoming connections
		 * but don't care about the specific port number.
		 * 
		 * #source_object will be passed out in the various calls
		 * to accept to identify this particular source, which is
		 * useful if you're listening on multiple addresses and do
		 * different things depending on what address is connected to.
		 * @param source_object Optional #GObject identifying this source
		 * @returns the port number, or 0 in case of failure.
		 */
		add_any_inet_port(source_object?: GObject.Object | null): number;
		/**
		 * Helper function for {@link G.socket_listener_add_address} that
		 * creates a TCP/IP socket listening on IPv4 and IPv6 (if
		 * supported) on the specified port on all interfaces.
		 * 
		 * #source_object will be passed out in the various calls
		 * to accept to identify this particular source, which is
		 * useful if you're listening on multiple addresses and do
		 * different things depending on what address is connected to.
		 * 
		 * Call g_socket_listener_close() to stop listening on #port; this will not
		 * be done automatically when you drop your final reference to #listener, as
		 * references may be held internally.
		 * @param port an IP port number (non-zero)
		 * @param source_object Optional #GObject identifying this source
		 * @returns %TRUE on success, %FALSE on error.
		 */
		add_inet_port(port: number, source_object?: GObject.Object | null): boolean;
		/**
		 * Adds #socket to the set of sockets that we try to accept
		 * new clients from. The socket must be bound to a local
		 * address and listened to.
		 * 
		 * #source_object will be passed out in the various calls
		 * to accept to identify this particular source, which is
		 * useful if you're listening on multiple addresses and do
		 * different things depending on what address is connected to.
		 * 
		 * The #socket will not be automatically closed when the #listener is finalized
		 * unless the listener held the final reference to the socket. Before GLib 2.42,
		 * the #socket was automatically closed on finalization of the #listener, even
		 * if references to it were held elsewhere.
		 * @param socket a listening #GSocket
		 * @param source_object Optional #GObject identifying this source
		 * @returns %TRUE on success, %FALSE on error.
		 */
		add_socket(socket: Socket, source_object?: GObject.Object | null): boolean;
		/**
		 * Closes all the sockets in the listener.
		 */
		close(): void;
		/**
		 * Sets the listen backlog on the sockets in the listener. This must be called
		 * before adding any sockets, addresses or ports to the #GSocketListener (for
		 * example, by calling {@link G.socket_listener_add_inet_port}) to be effective.
		 * 
		 * See g_socket_set_listen_backlog() for details
		 * @param listen_backlog an integer
		 */
		set_backlog(listen_backlog: number): void;
		/**
		 * Emitted when #listener's activity on #socket changes state.
		 * Note that when #listener is used to listen on both IPv4 and
		 * IPv6, a separate set of signals will be emitted for each, and
		 * the order they happen in is undefined.
		 * @param signal 
		 * @param callback Callback function
		 *  - owner: owner of the emitted event 
		 *  - event: the event that is occurring 
		 *  - socket: the #GSocket the event is occurring on 
		 * 
		 * @returns Callback ID
		 */
		connect(signal: "event", callback: (owner: this, event: SocketListenerEvent, socket: Socket) => void): number;

		connect(signal: "notify::listen-backlog", callback: (owner: this, ...args: any) => void): number;

	}

	type SocketListenerInitOptionsMixin = GObject.ObjectInitOptions & 
	Pick<ISocketListener,
		"listen_backlog">;

	export interface SocketListenerInitOptions extends SocketListenerInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link SocketListener} instead.
	 */
	type SocketListenerMixin = ISocketListener & GObject.Object;

	/**
	 * A #GSocketListener is an object that keeps track of a set
	 * of server sockets and helps you accept sockets from any of the
	 * socket, either sync or async.
	 * 
	 * Add addresses and ports to listen on using {@link G.socket_listener_add_address}
	 * and g_socket_listener_add_inet_port(). These will be listened on until
	 * g_socket_listener_close() is called. Dropping your final reference to the
	 * #GSocketListener will not cause g_socket_listener_close() to be called
	 * implicitly, as some references to the #GSocketListener may be held
	 * internally.
	 * 
	 * If you want to implement a network server, also look at #GSocketService
	 * and #GThreadedSocketService which are subclasses of #GSocketListener
	 * that make this even easier.
	 */
	interface SocketListener extends SocketListenerMixin {}

	class SocketListener {
		public constructor(options?: Partial<SocketListenerInitOptions>);
		/**
		 * Creates a new #GSocketListener with no sockets to listen for.
		 * New listeners can be added with e.g. {@link G.socket_listener_add_address}
		 * or g_socket_listener_add_inet_port().
		 * @returns a new #GSocketListener.
		 */
		public static new(): SocketListener;
	}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link SocketService} instead.
	 */
	interface ISocketService {
		/**
		 * Whether the service is currently accepting connections.
		 */
		active: boolean;
		/**
		 * Check whether the service is active or not. An active
		 * service will accept new clients that connect, while
		 * a non-active service will let connecting clients queue
		 * up until the service is started.
		 * @returns %TRUE if the service is active, %FALSE otherwise
		 */
		is_active(): boolean;
		/**
		 * Restarts the service, i.e. start accepting connections
		 * from the added sockets when the mainloop runs. This only needs
		 * to be called after the service has been stopped from
		 * {@link G.socket_service_stop}.
		 * 
		 * This call is thread-safe, so it may be called from a thread
		 * handling an incoming client request.
		 */
		start(): void;
		/**
		 * Stops the service, i.e. stops accepting connections
		 * from the added sockets when the mainloop runs.
		 * 
		 * This call is thread-safe, so it may be called from a thread
		 * handling an incoming client request.
		 * 
		 * Note that this only stops accepting new connections; it does not
		 * close the listening sockets, and you can call
		 * {@link G.socket_service_start} again later to begin listening again. To
		 * close the listening sockets, call g_socket_listener_close(). (This
		 * will happen automatically when the #GSocketService is finalized.)
		 * 
		 * This must be called before calling g_socket_listener_close() as
		 * the socket service will start accepting connections immediately
		 * when a new socket is added.
		 */
		stop(): void;
		/**
		 * The ::incoming signal is emitted when a new incoming connection
		 * to #service needs to be handled. The handler must initiate the
		 * handling of #connection, but may not block; in essence,
		 * asynchronous operations must be used.
		 * 
		 * #connection will be unreffed once the signal handler returns,
		 * so you need to ref it yourself if you are planning to use it.
		 * @param signal 
		 * @param callback Callback function
		 *  - owner: owner of the emitted event 
		 *  - connection: a new #GSocketConnection object 
		 *  - source_object: the source_object passed to
		 *     {@link G.socket_listener_add_address} 
		 *  - returns %TRUE to stop other handlers from being called 
		 * 
		 * @returns Callback ID
		 */
		connect(signal: "incoming", callback: (owner: this, connection: SocketConnection, source_object: GObject.Object | null) => boolean): number;

		connect(signal: "notify::active", callback: (owner: this, ...args: any) => void): number;

	}

	type SocketServiceInitOptionsMixin = SocketListenerInitOptions & 
	Pick<ISocketService,
		"active">;

	export interface SocketServiceInitOptions extends SocketServiceInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link SocketService} instead.
	 */
	type SocketServiceMixin = ISocketService & SocketListener;

	/**
	 * A #GSocketService is an object that represents a service that
	 * is provided to the network or over local sockets.  When a new
	 * connection is made to the service the #GSocketService::incoming
	 * signal is emitted.
	 * 
	 * A #GSocketService is a subclass of #GSocketListener and you need
	 * to add the addresses you want to accept connections on with the
	 * #GSocketListener APIs.
	 * 
	 * There are two options for implementing a network service based on
	 * #GSocketService. The first is to create the service using
	 * {@link G.socket_service_new} and to connect to the #GSocketService::incoming
	 * signal. The second is to subclass #GSocketService and override the
	 * default signal handler implementation.
	 * 
	 * In either case, the handler must immediately return, or else it
	 * will block additional incoming connections from being serviced.
	 * If you are interested in writing connection handlers that contain
	 * blocking code then see #GThreadedSocketService.
	 * 
	 * The socket service runs on the main loop of the
	 * [thread-default context][g-main-context-push-thread-default-context]
	 * of the thread it is created in, and is not
	 * threadsafe in general. However, the calls to start and stop the
	 * service are thread-safe so these can be used from threads that
	 * handle incoming clients.
	 */
	interface SocketService extends SocketServiceMixin {}

	class SocketService {
		public constructor(options?: Partial<SocketServiceInitOptions>);
		/**
		 * Creates a new #GSocketService with no sockets to listen for.
		 * New listeners can be added with e.g. {@link G.socket_listener_add_address}
		 * or g_socket_listener_add_inet_port().
		 * 
		 * New services are created active, there is no need to call
		 * g_socket_service_start(), unless g_socket_service_stop() has been
		 * called before.
		 * @returns a new #GSocketService.
		 */
		public static new(): SocketService;
	}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link Subprocess} instead.
	 */
	interface ISubprocess {
		/**
		 * Communicate with the subprocess until it terminates, and all input
		 * and output has been completed.
		 * 
		 * If #stdin_buf is given, the subprocess must have been created with
		 * %G_SUBPROCESS_FLAGS_STDIN_PIPE.  The given data is fed to the
		 * stdin of the subprocess and the pipe is closed (ie: EOF).
		 * 
		 * At the same time (as not to cause blocking when dealing with large
		 * amounts of data), if %G_SUBPROCESS_FLAGS_STDOUT_PIPE or
		 * %G_SUBPROCESS_FLAGS_STDERR_PIPE were used, reads from those
		 * streams.  The data that was read is returned in #stdout and/or
		 * the #stderr.
		 * 
		 * If the subprocess was created with %G_SUBPROCESS_FLAGS_STDOUT_PIPE,
		 * #stdout_buf will contain the data read from stdout.  Otherwise, for
		 * subprocesses not created with %G_SUBPROCESS_FLAGS_STDOUT_PIPE,
		 * #stdout_buf will be set to %NULL.  Similar provisions apply to
		 * #stderr_buf and %G_SUBPROCESS_FLAGS_STDERR_PIPE.
		 * 
		 * As usual, any output variable may be given as %NULL to ignore it.
		 * 
		 * If you desire the stdout and stderr data to be interleaved, create
		 * the subprocess with %G_SUBPROCESS_FLAGS_STDOUT_PIPE and
		 * %G_SUBPROCESS_FLAGS_STDERR_MERGE.  The merged result will be returned
		 * in #stdout_buf and #stderr_buf will be set to %NULL.
		 * 
		 * In case of any error (including cancellation), %FALSE will be
		 * returned with #error set.  Some or all of the stdin data may have
		 * been written.  Any stdout or stderr data that has been read will be
		 * discarded. None of the out variables (aside from #error) will have
		 * been set to anything in particular and should not be inspected.
		 * 
		 * In the case that %TRUE is returned, the subprocess has exited and the
		 * exit status inspection APIs (eg: {@link G.subprocess_get_if_exited},
		 * g_subprocess_get_exit_status()) may be used.
		 * 
		 * You should not attempt to use any of the subprocess pipes after
		 * starting this function, since they may be left in strange states,
		 * even if the operation was cancelled.  You should especially not
		 * attempt to interact with the pipes while the operation is in progress
		 * (either from another thread or if using the asynchronous version).
		 * @param stdin_buf data to send to the stdin of the subprocess, or %NULL
		 * @param cancellable a #GCancellable
		 * @returns %TRUE if successful
		 * 
		 * data read from the subprocess stdout
		 * 
		 * data read from the subprocess stderr
		 */
		communicate(stdin_buf?: GLib.Bytes | null, cancellable?: Cancellable | null): [ boolean, GLib.Bytes | null, GLib.Bytes | null ];
		/**
		 * Asynchronous version of {@link G.subprocess_communicate}.  Complete
		 * invocation with g_subprocess_communicate_finish().
		 * @param stdin_buf Input data, or %NULL
		 * @param cancellable Cancellable
		 * @param callback Callback
		 */
		communicate_async(stdin_buf?: GLib.Bytes | null, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;
		/**
		 * Complete an invocation of {@link G.subprocess_communicate_async}.
		 * @param result Result
		 * @returns 
		 * 
		 * Return location for stdout data
		 * 
		 * Return location for stderr data
		 */
		communicate_finish(result: AsyncResult): [ boolean, GLib.Bytes | null, GLib.Bytes | null ];
		/**
		 * Like {@link G.subprocess_communicate}, but validates the output of the
		 * process as UTF-8, and returns it as a regular NUL terminated string.
		 * 
		 * On error, #stdout_buf and #stderr_buf will be set to undefined values and
		 * should not be used.
		 * @param stdin_buf data to send to the stdin of the subprocess, or %NULL
		 * @param cancellable a #GCancellable
		 * @returns 
		 * 
		 * data read from the subprocess stdout
		 * 
		 * data read from the subprocess stderr
		 */
		communicate_utf8(stdin_buf?: string | null, cancellable?: Cancellable | null): [ boolean, string | null, string | null ];
		/**
		 * Asynchronous version of {@link G.subprocess_communicate_utf8}.  Complete
		 * invocation with g_subprocess_communicate_utf8_finish().
		 * @param stdin_buf Input data, or %NULL
		 * @param cancellable Cancellable
		 * @param callback Callback
		 */
		communicate_utf8_async(stdin_buf?: string | null, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;
		/**
		 * Complete an invocation of {@link G.subprocess_communicate_utf8_async}.
		 * @param result Result
		 * @returns 
		 * 
		 * Return location for stdout data
		 * 
		 * Return location for stderr data
		 */
		communicate_utf8_finish(result: AsyncResult): [ boolean, string | null, string | null ];
		/**
		 * Use an operating-system specific method to attempt an immediate,
		 * forceful termination of the process.  There is no mechanism to
		 * determine whether or not the request itself was successful;
		 * however, you can use {@link G.subprocess_wait} to monitor the status of
		 * the process after calling this function.
		 * 
		 * On Unix, this function sends %SIGKILL.
		 */
		force_exit(): void;
		/**
		 * Check the exit status of the subprocess, given that it exited
		 * normally.  This is the value passed to the exit() system call or the
		 * return value from main.
		 * 
		 * This is equivalent to the system WEXITSTATUS macro.
		 * 
		 * It is an error to call this function before g_subprocess_wait() and
		 * unless g_subprocess_get_if_exited() returned %TRUE.
		 * @returns the exit status
		 */
		get_exit_status(): number;
		/**
		 * On UNIX, returns the process ID as a decimal string.
		 * On Windows, returns the result of GetProcessId() also as a string.
		 * If the subprocess has terminated, this will return %NULL.
		 * @returns the subprocess identifier, or %NULL if the subprocess
		 *    has terminated
		 */
		get_identifier(): string | null;
		/**
		 * Check if the given subprocess exited normally (ie: by way of exit()
		 * or return from main()).
		 * 
		 * This is equivalent to the system WIFEXITED macro.
		 * 
		 * It is an error to call this function before g_subprocess_wait() has
		 * returned.
		 * @returns %TRUE if the case of a normal exit
		 */
		get_if_exited(): boolean;
		/**
		 * Check if the given subprocess terminated in response to a signal.
		 * 
		 * This is equivalent to the system WIFSIGNALED macro.
		 * 
		 * It is an error to call this function before {@link G.subprocess_wait} has
		 * returned.
		 * @returns %TRUE if the case of termination due to a signal
		 */
		get_if_signaled(): boolean;
		/**
		 * Gets the raw status code of the process, as from waitpid().
		 * 
		 * This value has no particular meaning, but it can be used with the
		 * macros defined by the system headers such as WIFEXITED.  It can also
		 * be used with g_spawn_check_wait_status().
		 * 
		 * It is more likely that you want to use g_subprocess_get_if_exited()
		 * followed by g_subprocess_get_exit_status().
		 * 
		 * It is an error to call this function before g_subprocess_wait() has
		 * returned.
		 * @returns the (meaningless) waitpid() exit status from the kernel
		 */
		get_status(): number;
		/**
		 * Gets the #GInputStream from which to read the stderr output of
		 * #subprocess.
		 * 
		 * The process must have been created with %G_SUBPROCESS_FLAGS_STDERR_PIPE,
		 * otherwise %NULL will be returned.
		 * @returns the stderr pipe
		 */
		get_stderr_pipe(): InputStream | null;
		/**
		 * Gets the #GOutputStream that you can write to in order to give data
		 * to the stdin of #subprocess.
		 * 
		 * The process must have been created with %G_SUBPROCESS_FLAGS_STDIN_PIPE and
		 * not %G_SUBPROCESS_FLAGS_STDIN_INHERIT, otherwise %NULL will be returned.
		 * @returns the stdout pipe
		 */
		get_stdin_pipe(): OutputStream | null;
		/**
		 * Gets the #GInputStream from which to read the stdout output of
		 * #subprocess.
		 * 
		 * The process must have been created with %G_SUBPROCESS_FLAGS_STDOUT_PIPE,
		 * otherwise %NULL will be returned.
		 * @returns the stdout pipe
		 */
		get_stdout_pipe(): InputStream | null;
		/**
		 * Checks if the process was "successful".  A process is considered
		 * successful if it exited cleanly with an exit status of 0, either by
		 * way of the exit() system call or return from main().
		 * 
		 * It is an error to call this function before g_subprocess_wait() has
		 * returned.
		 * @returns %TRUE if the process exited cleanly with a exit status of 0
		 */
		get_successful(): boolean;
		/**
		 * Get the signal number that caused the subprocess to terminate, given
		 * that it terminated due to a signal.
		 * 
		 * This is equivalent to the system WTERMSIG macro.
		 * 
		 * It is an error to call this function before {@link G.subprocess_wait} and
		 * unless g_subprocess_get_if_signaled() returned %TRUE.
		 * @returns the signal causing termination
		 */
		get_term_sig(): number;
		/**
		 * Sends the UNIX signal #signal_num to the subprocess, if it is still
		 * running.
		 * 
		 * This API is race-free.  If the subprocess has terminated, it will not
		 * be signalled.
		 * 
		 * This API is not available on Windows.
		 * @param signal_num the signal number to send
		 */
		send_signal(signal_num: number): void;
		/**
		 * Synchronously wait for the subprocess to terminate.
		 * 
		 * After the process terminates you can query its exit status with
		 * functions such as {@link G.subprocess_get_if_exited} and
		 * g_subprocess_get_exit_status().
		 * 
		 * This function does not fail in the case of the subprocess having
		 * abnormal termination.  See g_subprocess_wait_check() for that.
		 * 
		 * Cancelling #cancellable doesn't kill the subprocess.  Call
		 * g_subprocess_force_exit() if it is desirable.
		 * @param cancellable a #GCancellable
		 * @returns %TRUE on success, %FALSE if #cancellable was cancelled
		 */
		wait(cancellable?: Cancellable | null): boolean;
		/**
		 * Wait for the subprocess to terminate.
		 * 
		 * This is the asynchronous version of {@link G.subprocess_wait}.
		 * @param cancellable a #GCancellable, or %NULL
		 * @param callback a #GAsyncReadyCallback to call when the operation is complete
		 */
		wait_async(cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;
		/**
		 * Combines {@link G.subprocess_wait} with g_spawn_check_wait_status().
		 * @param cancellable a #GCancellable
		 * @returns %TRUE on success, %FALSE if process exited abnormally, or
		 * #cancellable was cancelled
		 */
		wait_check(cancellable?: Cancellable | null): boolean;
		/**
		 * Combines {@link G.subprocess_wait_async} with g_spawn_check_wait_status().
		 * 
		 * This is the asynchronous version of g_subprocess_wait_check().
		 * @param cancellable a #GCancellable, or %NULL
		 * @param callback a #GAsyncReadyCallback to call when the operation is complete
		 */
		wait_check_async(cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;
		/**
		 * Collects the result of a previous call to
		 * {@link G.subprocess_wait_check_async}.
		 * @param result the #GAsyncResult passed to your #GAsyncReadyCallback
		 * @returns %TRUE if successful, or %FALSE with #error set
		 */
		wait_check_finish(result: AsyncResult): boolean;
		/**
		 * Collects the result of a previous call to
		 * {@link G.subprocess_wait_async}.
		 * @param result the #GAsyncResult passed to your #GAsyncReadyCallback
		 * @returns %TRUE if successful, or %FALSE with #error set
		 */
		wait_finish(result: AsyncResult): boolean;
	}

	type SubprocessInitOptionsMixin = GObject.ObjectInitOptions & InitableInitOptions
	export interface SubprocessInitOptions extends SubprocessInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link Subprocess} instead.
	 */
	type SubprocessMixin = ISubprocess & GObject.Object & Initable;

	/**
	 * #GSubprocess allows the creation of and interaction with child
	 * processes.
	 * 
	 * Processes can be communicated with using standard GIO-style APIs (ie:
	 * #GInputStream, #GOutputStream).  There are GIO-style APIs to wait for
	 * process termination (ie: cancellable and with an asynchronous
	 * variant).
	 * 
	 * There is an API to force a process to terminate, as well as a
	 * race-free API for sending UNIX signals to a subprocess.
	 * 
	 * One major advantage that GIO brings over the core GLib library is
	 * comprehensive API for asynchronous I/O, such
	 * {@link G.output_stream_splice_async}.  This makes GSubprocess
	 * significantly more powerful and flexible than equivalent APIs in
	 * some other languages such as the `subprocess.py`
	 * included with Python.  For example, using #GSubprocess one could
	 * create two child processes, reading standard output from the first,
	 * processing it, and writing to the input stream of the second, all
	 * without blocking the main loop.
	 * 
	 * A powerful g_subprocess_communicate() API is provided similar to the
	 * `communicate()` method of `subprocess.py`. This enables very easy
	 * interaction with a subprocess that has been opened with pipes.
	 * 
	 * #GSubprocess defaults to tight control over the file descriptors open
	 * in the child process, avoiding dangling-fd issues that are caused by
	 * a simple fork()/exec().  The only open file descriptors in the
	 * spawned process are ones that were explicitly specified by the
	 * #GSubprocess API (unless %G_SUBPROCESS_FLAGS_INHERIT_FDS was
	 * specified).
	 * 
	 * #GSubprocess will quickly reap all child processes as they exit,
	 * avoiding "zombie processes" remaining around for long periods of
	 * time.  g_subprocess_wait() can be used to wait for this to happen,
	 * but it will happen even without the call being explicitly made.
	 * 
	 * As a matter of principle, #GSubprocess has no API that accepts
	 * shell-style space-separated strings.  It will, however, match the
	 * typical shell behaviour of searching the PATH for executables that do
	 * not contain a directory separator in their name.
	 * 
	 * #GSubprocess attempts to have a very simple API for most uses (ie:
	 * spawning a subprocess with arguments and support for most typical
	 * kinds of input and output redirection).  See g_subprocess_new(). The
	 * #GSubprocessLauncher API is provided for more complicated cases
	 * (advanced types of redirection, environment variable manipulation,
	 * change of working directory, child setup functions, etc).
	 * 
	 * A typical use of #GSubprocess will involve calling
	 * g_subprocess_new(), followed by g_subprocess_wait_async() or
	 * g_subprocess_wait().  After the process exits, the status can be
	 * checked using functions such as g_subprocess_get_if_exited() (which
	 * are similar to the familiar WIFEXITED-style POSIX macros).
	 */
	interface Subprocess extends SubprocessMixin {}

	class Subprocess {
		public constructor(options?: Partial<SubprocessInitOptions>);
		/**
		 * Create a new process with the given flags and argument list.
		 * 
		 * The argument list is expected to be %NULL-terminated.
		 * @param argv commandline arguments for the subprocess
		 * @param flags flags that define the behaviour of the subprocess
		 * @returns A newly created #GSubprocess, or %NULL on error (and #error
		 *   will be set)
		 */
		public static new(argv: string[], flags: SubprocessFlags): Subprocess;
	}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link SubprocessLauncher} instead.
	 */
	interface ISubprocessLauncher {
		/**
		 * Closes all the file descriptors previously passed to the object with
		 * {@link G.subprocess_launcher_take_fd}, g_subprocess_launcher_take_stderr_fd(), etc.
		 * 
		 * After calling this method, any subsequent calls to g_subprocess_launcher_spawn() or g_subprocess_launcher_spawnv() will
		 * return %G_IO_ERROR_CLOSED. This method is idempotent if
		 * called more than once.
		 * 
		 * This function is called automatically when the #GSubprocessLauncher
		 * is disposed, but is provided separately so that garbage collected
		 * language bindings can call it earlier to guarantee when FDs are closed.
		 */
		close(): void;
		/**
		 * Returns the value of the environment variable #variable in the
		 * environment of processes launched from this launcher.
		 * 
		 * On UNIX, the returned string can be an arbitrary byte string.
		 * On Windows, it will be UTF-8.
		 * @param variable the environment variable to get
		 * @returns the value of the environment variable,
		 *     %NULL if unset
		 */
		getenv(variable: string): string | null;
		/**
		 * Sets up a child setup function.
		 * 
		 * The child setup function will be called after fork() but before
		 * exec() on the child's side.
		 * 
		 * #destroy_notify will not be automatically called on the child's side
		 * of the fork().  It will only be called when the last reference on the
		 * #GSubprocessLauncher is dropped or when a new child setup function is
		 * given.
		 * 
		 * %NULL can be given as #child_setup to disable the functionality.
		 * 
		 * Child setup functions are only available on UNIX.
		 * @param child_setup a #GSpawnChildSetupFunc to use as the child setup function
		 */
		set_child_setup(child_setup: GLib.SpawnChildSetupFunc): void;
		/**
		 * Sets the current working directory that processes will be launched
		 * with.
		 * 
		 * By default processes are launched with the current working directory
		 * of the launching process at the time of launch.
		 * @param cwd the cwd for launched processes
		 */
		set_cwd(cwd: string): void;
		/**
		 * Replace the entire environment of processes launched from this
		 * launcher with the given 'environ' variable.
		 * 
		 * Typically you will build this variable by using {@link G.listenv} to copy
		 * the process 'environ' and using the functions g_environ_setenv(),
		 * g_environ_unsetenv(), etc.
		 * 
		 * As an alternative, you can use g_subprocess_launcher_setenv(),
		 * g_subprocess_launcher_unsetenv(), etc.
		 * 
		 * Pass an empty array to set an empty environment. Pass %NULL to inherit the
		 * parent process’ environment. As of GLib 2.54, the parent process’ environment
		 * will be copied when g_subprocess_launcher_set_environ() is called.
		 * Previously, it was copied when the subprocess was executed. This means the
		 * copied environment may now be modified (using g_subprocess_launcher_setenv(),
		 * etc.) before launching the subprocess.
		 * 
		 * On UNIX, all strings in this array can be arbitrary byte strings.
		 * On Windows, they should be in UTF-8.
		 * @param env 
		 *     the replacement environment
		 */
		set_environ(env: string[]): void;
		/**
		 * Sets the flags on the launcher.
		 * 
		 * The default flags are %G_SUBPROCESS_FLAGS_NONE.
		 * 
		 * You may not set flags that specify conflicting options for how to
		 * handle a particular stdio stream (eg: specifying both
		 * %G_SUBPROCESS_FLAGS_STDIN_PIPE and
		 * %G_SUBPROCESS_FLAGS_STDIN_INHERIT).
		 * 
		 * You may also not set a flag that conflicts with a previous call to a
		 * function like {@link G.subprocess_launcher_set_stdin_file_path} or
		 * g_subprocess_launcher_take_stdout_fd().
		 * @param flags #GSubprocessFlags
		 */
		set_flags(flags: SubprocessFlags): void;
		/**
		 * Sets the file path to use as the stderr for spawned processes.
		 * 
		 * If #path is %NULL then any previously given path is unset.
		 * 
		 * The file will be created or truncated when the process is spawned, as
		 * would be the case if using '2>' at the shell.
		 * 
		 * If you want to send both stdout and stderr to the same file then use
		 * %G_SUBPROCESS_FLAGS_STDERR_MERGE.
		 * 
		 * You may not set a stderr file path if a stderr fd is already set or
		 * if the launcher flags contain any flags directing stderr elsewhere.
		 * 
		 * This feature is only available on UNIX.
		 * @param path a filename or %NULL
		 */
		set_stderr_file_path(path?: string | null): void;
		/**
		 * Sets the file path to use as the stdin for spawned processes.
		 * 
		 * If #path is %NULL then any previously given path is unset.
		 * 
		 * The file must exist or spawning the process will fail.
		 * 
		 * You may not set a stdin file path if a stdin fd is already set or if
		 * the launcher flags contain any flags directing stdin elsewhere.
		 * 
		 * This feature is only available on UNIX.
		 * @param path
		 */
		set_stdin_file_path(path: string): void;
		/**
		 * Sets the file path to use as the stdout for spawned processes.
		 * 
		 * If #path is %NULL then any previously given path is unset.
		 * 
		 * The file will be created or truncated when the process is spawned, as
		 * would be the case if using '>' at the shell.
		 * 
		 * You may not set a stdout file path if a stdout fd is already set or
		 * if the launcher flags contain any flags directing stdout elsewhere.
		 * 
		 * This feature is only available on UNIX.
		 * @param path a filename or %NULL
		 */
		set_stdout_file_path(path?: string | null): void;
		/**
		 * Sets the environment variable #variable in the environment of
		 * processes launched from this launcher.
		 * 
		 * On UNIX, both the variable's name and value can be arbitrary byte
		 * strings, except that the variable's name cannot contain '='.
		 * On Windows, they should be in UTF-8.
		 * @param variable the environment variable to set,
		 *     must not contain '='
		 * @param value the new value for the variable
		 * @param overwrite whether to change the variable if it already exists
		 */
		setenv(variable: string, value: string, overwrite: boolean): void;
		/**
		 * Creates a #GSubprocess given a provided varargs list of arguments.
		 * @param error Error
		 * @param argv0 Command line arguments
		 * @returns A new #GSubprocess, or %NULL on error (and #error will be set)
		 */
		spawn(error: GLib.Error, argv0: string): Subprocess;
		/**
		 * Creates a #GSubprocess given a provided array of arguments.
		 * @param argv Command line arguments
		 * @returns A new #GSubprocess, or %NULL on error (and #error will be set)
		 */
		spawnv(argv: string[]): Subprocess;
		/**
		 * Transfer an arbitrary file descriptor from parent process to the
		 * child.  This function takes ownership of the #source_fd; it will be closed
		 * in the parent when #self is freed.
		 * 
		 * By default, all file descriptors from the parent will be closed.
		 * This function allows you to create (for example) a custom `pipe()` or
		 * `socketpair()` before launching the process, and choose the target
		 * descriptor in the child.
		 * 
		 * An example use case is GNUPG, which has a command line argument
		 * `--passphrase-fd` providing a file descriptor number where it expects
		 * the passphrase to be written.
		 * @param source_fd File descriptor in parent process
		 * @param target_fd Target descriptor for child process
		 */
		take_fd(source_fd: number, target_fd: number): void;
		/**
		 * Sets the file descriptor to use as the stderr for spawned processes.
		 * 
		 * If #fd is -1 then any previously given fd is unset.
		 * 
		 * Note that the default behaviour is to pass stderr through to the
		 * stderr of the parent process.
		 * 
		 * The passed #fd belongs to the #GSubprocessLauncher.  It will be
		 * automatically closed when the launcher is finalized.  The file
		 * descriptor will also be closed on the child side when executing the
		 * spawned process.
		 * 
		 * You may not set a stderr fd if a stderr file path is already set or
		 * if the launcher flags contain any flags directing stderr elsewhere.
		 * 
		 * This feature is only available on UNIX.
		 * @param fd a file descriptor, or -1
		 */
		take_stderr_fd(fd: number): void;
		/**
		 * Sets the file descriptor to use as the stdin for spawned processes.
		 * 
		 * If #fd is -1 then any previously given fd is unset.
		 * 
		 * Note that if your intention is to have the stdin of the calling
		 * process inherited by the child then %G_SUBPROCESS_FLAGS_STDIN_INHERIT
		 * is a better way to go about doing that.
		 * 
		 * The passed #fd is noted but will not be touched in the current
		 * process.  It is therefore necessary that it be kept open by the
		 * caller until the subprocess is spawned.  The file descriptor will
		 * also not be explicitly closed on the child side, so it must be marked
		 * O_CLOEXEC if that's what you want.
		 * 
		 * You may not set a stdin fd if a stdin file path is already set or if
		 * the launcher flags contain any flags directing stdin elsewhere.
		 * 
		 * This feature is only available on UNIX.
		 * @param fd a file descriptor, or -1
		 */
		take_stdin_fd(fd: number): void;
		/**
		 * Sets the file descriptor to use as the stdout for spawned processes.
		 * 
		 * If #fd is -1 then any previously given fd is unset.
		 * 
		 * Note that the default behaviour is to pass stdout through to the
		 * stdout of the parent process.
		 * 
		 * The passed #fd is noted but will not be touched in the current
		 * process.  It is therefore necessary that it be kept open by the
		 * caller until the subprocess is spawned.  The file descriptor will
		 * also not be explicitly closed on the child side, so it must be marked
		 * O_CLOEXEC if that's what you want.
		 * 
		 * You may not set a stdout fd if a stdout file path is already set or
		 * if the launcher flags contain any flags directing stdout elsewhere.
		 * 
		 * This feature is only available on UNIX.
		 * @param fd a file descriptor, or -1
		 */
		take_stdout_fd(fd: number): void;
		/**
		 * Removes the environment variable #variable from the environment of
		 * processes launched from this launcher.
		 * 
		 * On UNIX, the variable's name can be an arbitrary byte string not
		 * containing '='. On Windows, it should be in UTF-8.
		 * @param variable the environment variable to unset,
		 *     must not contain '='
		 */
		unsetenv(variable: string): void;
	}

	type SubprocessLauncherInitOptionsMixin = GObject.ObjectInitOptions
	export interface SubprocessLauncherInitOptions extends SubprocessLauncherInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link SubprocessLauncher} instead.
	 */
	type SubprocessLauncherMixin = ISubprocessLauncher & GObject.Object;

	/**
	 * This class contains a set of options for launching child processes,
	 * such as where its standard input and output will be directed, the
	 * argument list, the environment, and more.
	 * 
	 * While the #GSubprocess class has high level functions covering
	 * popular cases, use of this class allows access to more advanced
	 * options.  It can also be used to launch multiple subprocesses with
	 * a similar configuration.
	 */
	interface SubprocessLauncher extends SubprocessLauncherMixin {}

	class SubprocessLauncher {
		public constructor(options?: Partial<SubprocessLauncherInitOptions>);
		/**
		 * Creates a new #GSubprocessLauncher.
		 * 
		 * The launcher is created with the default options.  A copy of the
		 * environment of the calling process is made at the time of this call
		 * and will be used as the environment that the process is launched in.
		 * @param flags #GSubprocessFlags
		 * @returns 
		 */
		public static new(flags: SubprocessFlags): SubprocessLauncher;
	}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link Task} instead.
	 */
	interface ITask {
		/**
		 * Whether the task has completed, meaning its callback (if set) has been
		 * invoked. This can only happen after {@link G.task_return_pointer},
		 * g_task_return_error() or one of the other return functions have been called
		 * on the task.
		 * 
		 * This property is guaranteed to change from %FALSE to %TRUE exactly once.
		 * 
		 * The #GObject::notify signal for this change is emitted in the same main
		 * context as the task’s callback, immediately after that callback is invoked.
		 */
		readonly completed: boolean;
		/**
		 * A utility function for dealing with async operations where you need
		 * to wait for a #GSource to trigger. Attaches #source to #task's
		 * #GMainContext with #task's [priority][io-priority], and sets #source's
		 * callback to #callback, with #task as the callback's `user_data`.
		 * 
		 * It will set the #source’s name to the task’s name (as set with
		 * {@link G.task_set_name}), if one has been set.
		 * 
		 * This takes a reference on #task until #source is destroyed.
		 * @param source the source to attach
		 * @param callback the callback to invoke when #source triggers
		 */
		attach_source(source: GLib.Source, callback: GLib.SourceFunc): void;
		/**
		 * Gets #task's #GCancellable
		 * @returns #task's #GCancellable
		 */
		get_cancellable(): Cancellable;
		/**
		 * Gets #task's check-cancellable flag. See
		 * {@link G.task_set_check_cancellable} for more details.
		 * @returns 
		 */
		get_check_cancellable(): boolean;
		/**
		 * Gets the value of #GTask:completed. This changes from %FALSE to %TRUE after
		 * the task’s callback is invoked, and will return %FALSE if called from inside
		 * the callback.
		 * @returns %TRUE if the task has completed, %FALSE otherwise.
		 */
		get_completed(): boolean;
		/**
		 * Gets the #GMainContext that #task will return its result in (that
		 * is, the context that was the
		 * [thread-default main context][g-main-context-push-thread-default]
		 * at the point when #task was created).
		 * 
		 * This will always return a non-%NULL value, even if the task's
		 * context is the default #GMainContext.
		 * @returns #task's #GMainContext
		 */
		get_context(): GLib.MainContext;
		/**
		 * Gets #task’s name. See {@link G.task_set_name}.
		 * @returns #task’s name, or %NULL
		 */
		get_name(): string | null;
		/**
		 * Gets #task's priority
		 * @returns #task's priority
		 */
		get_priority(): number;
		/**
		 * Gets #task's return-on-cancel flag. See
		 * {@link G.task_set_return_on_cancel} for more details.
		 * @returns 
		 */
		get_return_on_cancel(): boolean;
		/**
		 * Gets the source object from #task. Like
		 * {@link G.async_result_get_source_object}, but does not ref the object.
		 * @returns #task's source object, or %NULL
		 */
		get_source_object(): GObject.Object | null;
		/**
		 * Gets #task's source tag. See {@link G.task_set_source_tag}.
		 * @returns #task's source tag
		 */
		get_source_tag(): any | null;
		/**
		 * Gets #task's `task_data`.
		 * @returns #task's `task_data`.
		 */
		get_task_data(): any | null;
		/**
		 * Tests if #task resulted in an error.
		 * @returns %TRUE if the task resulted in an error, %FALSE otherwise.
		 */
		had_error(): boolean;
		/**
		 * Gets the result of #task as a #gboolean.
		 * 
		 * If the task resulted in an error, or was cancelled, then this will
		 * instead return %FALSE and set #error.
		 * 
		 * Since this method transfers ownership of the return value (or
		 * error) to the caller, you may only call it once.
		 * @returns the task result, or %FALSE on error
		 */
		propagate_boolean(): boolean;
		/**
		 * Gets the result of #task as an integer (#gssize).
		 * 
		 * If the task resulted in an error, or was cancelled, then this will
		 * instead return -1 and set #error.
		 * 
		 * Since this method transfers ownership of the return value (or
		 * error) to the caller, you may only call it once.
		 * @returns the task result, or -1 on error
		 */
		propagate_int(): number;
		/**
		 * Gets the result of #task as a pointer, and transfers ownership
		 * of that value to the caller.
		 * 
		 * If the task resulted in an error, or was cancelled, then this will
		 * instead return %NULL and set #error.
		 * 
		 * Since this method transfers ownership of the return value (or
		 * error) to the caller, you may only call it once.
		 * @returns the task result, or %NULL on error
		 */
		propagate_pointer(): any | null;
		/**
		 * Gets the result of #task as a #GValue, and transfers ownership of
		 * that value to the caller. As with {@link G.task_return_value}, this is
		 * a generic low-level method; g_task_propagate_pointer() and the like
		 * will usually be more useful for C code.
		 * 
		 * If the task resulted in an error, or was cancelled, then this will
		 * instead set #error and return %FALSE.
		 * 
		 * Since this method transfers ownership of the return value (or
		 * error) to the caller, you may only call it once.
		 * @returns %TRUE if #task succeeded, %FALSE on error.
		 * 
		 * return location for the #GValue
		 */
		propagate_value(): [ boolean, GObject.Value ];
		/**
		 * Sets #task's result to #result and completes the task (see
		 * {@link G.task_return_pointer} for more discussion of exactly what this
		 * means).
		 * @param result the #gboolean result of a task function.
		 */
		return_boolean(result: boolean): void;
		/**
		 * Sets #task's result to #error (which #task assumes ownership of)
		 * and completes the task (see {@link G.task_return_pointer} for more
		 * discussion of exactly what this means).
		 * 
		 * Note that since the task takes ownership of #error, and since the
		 * task may be completed before returning from g_task_return_error(),
		 * you cannot assume that #error is still valid after calling this.
		 * Call g_error_copy() on the error if you need to keep a local copy
		 * as well.
		 * 
		 * See also g_task_return_new_error().
		 * @param error the #GError result of a task function.
		 */
		return_error(error: GLib.Error): void;
		/**
		 * Checks if #task's #GCancellable has been cancelled, and if so, sets
		 * #task's error accordingly and completes the task (see
		 * {@link G.task_return_pointer} for more discussion of exactly what this
		 * means).
		 * @returns %TRUE if #task has been cancelled, %FALSE if not
		 */
		return_error_if_cancelled(): boolean;
		/**
		 * Sets #task's result to #result and completes the task (see
		 * {@link G.task_return_pointer} for more discussion of exactly what this
		 * means).
		 * @param result the integer (#gssize) result of a task function.
		 */
		return_int(result: number): void;
		/**
		 * Sets #task's result to a new #GError created from #domain, #code,
		 * #format, and the remaining arguments, and completes the task (see
		 * {@link G.task_return_pointer} for more discussion of exactly what this
		 * means).
		 * 
		 * See also g_task_return_error().
		 * @param domain a #GQuark.
		 * @param code an error code.
		 * @param format a string with format characters.
		 */
		return_new_error(domain: GLib.Quark, code: number, format: string): void;
		/**
		 * Sets #task's result to #result and completes the task. If #result
		 * is not %NULL, then #result_destroy will be used to free #result if
		 * the caller does not take ownership of it with
		 * {@link G.task_propagate_pointer}.
		 * 
		 * "Completes the task" means that for an ordinary asynchronous task
		 * it will either invoke the task's callback, or else queue that
		 * callback to be invoked in the proper #GMainContext, or in the next
		 * iteration of the current #GMainContext. For a task run via
		 * g_task_run_in_thread() or g_task_run_in_thread_sync(), calling this
		 * method will save #result to be returned to the caller later, but
		 * the task will not actually be completed until the #GTaskThreadFunc
		 * exits.
		 * 
		 * Note that since the task may be completed before returning from
		 * g_task_return_pointer(), you cannot assume that #result is still
		 * valid after calling this, unless you are still holding another
		 * reference on it.
		 * @param result the pointer result of a task
		 *     function
		 */
		return_pointer(result?: any | null): void;
		/**
		 * Sets #task's result to #result (by copying it) and completes the task.
		 * 
		 * If #result is %NULL then a #GValue of type #G_TYPE_POINTER
		 * with a value of %NULL will be used for the result.
		 * 
		 * This is a very generic low-level method intended primarily for use
		 * by language bindings; for C code, {@link G.task_return_pointer} and the
		 * like will normally be much easier to use.
		 * @param result the #GValue result of
		 *                                      a task function
		 */
		return_value(result?: GObject.Value | null): void;
		/**
		 * Runs #task_func in another thread. When #task_func returns, #task's
		 * #GAsyncReadyCallback will be invoked in #task's #GMainContext.
		 * 
		 * This takes a ref on #task until the task completes.
		 * 
		 * See #GTaskThreadFunc for more details about how #task_func is handled.
		 * 
		 * Although GLib currently rate-limits the tasks queued via
		 * {@link G.task_run_in_thread}, you should not assume that it will always
		 * do this. If you have a very large number of tasks to run (several tens of
		 * tasks), but don't want them to all run at once, you should only queue a
		 * limited number of them (around ten) at a time.
		 * @param task_func a #GTaskThreadFunc
		 */
		run_in_thread(task_func: TaskThreadFunc): void;
		/**
		 * Runs #task_func in another thread, and waits for it to return or be
		 * cancelled. You can use {@link G.task_propagate_pointer}, etc, afterward
		 * to get the result of #task_func.
		 * 
		 * See #GTaskThreadFunc for more details about how #task_func is handled.
		 * 
		 * Normally this is used with tasks created with a %NULL
		 * `callback`, but note that even if the task does
		 * have a callback, it will not be invoked when #task_func returns.
		 * #GTask:completed will be set to %TRUE just before this function returns.
		 * 
		 * Although GLib currently rate-limits the tasks queued via
		 * g_task_run_in_thread_sync(), you should not assume that it will
		 * always do this. If you have a very large number of tasks to run,
		 * but don't want them to all run at once, you should only queue a
		 * limited number of them at a time.
		 * @param task_func a #GTaskThreadFunc
		 */
		run_in_thread_sync(task_func: TaskThreadFunc): void;
		/**
		 * Sets or clears #task's check-cancellable flag. If this is %TRUE
		 * (the default), then {@link G.task_propagate_pointer}, etc, and
		 * g_task_had_error() will check the task's #GCancellable first, and
		 * if it has been cancelled, then they will consider the task to have
		 * returned an "Operation was cancelled" error
		 * (%G_IO_ERROR_CANCELLED), regardless of any other error or return
		 * value the task may have had.
		 * 
		 * If #check_cancellable is %FALSE, then the #GTask will not check the
		 * cancellable itself, and it is up to #task's owner to do this (eg,
		 * via g_task_return_error_if_cancelled()).
		 * 
		 * If you are using g_task_set_return_on_cancel() as well, then
		 * you must leave check-cancellable set %TRUE.
		 * @param check_cancellable whether #GTask will check the state of
		 *   its #GCancellable for you.
		 */
		set_check_cancellable(check_cancellable: boolean): void;
		/**
		 * Sets #task’s name, used in debugging and profiling. The name defaults to
		 * %NULL.
		 * 
		 * The task name should describe in a human readable way what the task does.
		 * For example, ‘Open file’ or ‘Connect to network host’. It is used to set the
		 * name of the #GSource used for idle completion of the task.
		 * 
		 * This function may only be called before the #task is first used in a thread
		 * other than the one it was constructed in.
		 * @param name a human readable name for the task, or %NULL to unset it
		 */
		set_name(name?: string | null): void;
		/**
		 * Sets #task's priority. If you do not call this, it will default to
		 * %G_PRIORITY_DEFAULT.
		 * 
		 * This will affect the priority of #GSources created with
		 * {@link G.task_attach_source} and the scheduling of tasks run in threads,
		 * and can also be explicitly retrieved later via
		 * g_task_get_priority().
		 * @param priority the [priority][io-priority] of the request
		 */
		set_priority(priority: number): void;
		/**
		 * Sets or clears #task's return-on-cancel flag. This is only
		 * meaningful for tasks run via {@link G.task_run_in_thread} or
		 * g_task_run_in_thread_sync().
		 * 
		 * If #return_on_cancel is %TRUE, then cancelling #task's
		 * #GCancellable will immediately cause it to return, as though the
		 * task's #GTaskThreadFunc had called
		 * g_task_return_error_if_cancelled() and then returned.
		 * 
		 * This allows you to create a cancellable wrapper around an
		 * uninterruptible function. The #GTaskThreadFunc just needs to be
		 * careful that it does not modify any externally-visible state after
		 * it has been cancelled. To do that, the thread should call
		 * g_task_set_return_on_cancel() again to (atomically) set
		 * return-on-cancel %FALSE before making externally-visible changes;
		 * if the task gets cancelled before the return-on-cancel flag could
		 * be changed, g_task_set_return_on_cancel() will indicate this by
		 * returning %FALSE.
		 * 
		 * You can disable and re-enable this flag multiple times if you wish.
		 * If the task's #GCancellable is cancelled while return-on-cancel is
		 * %FALSE, then calling g_task_set_return_on_cancel() to set it %TRUE
		 * again will cause the task to be cancelled at that point.
		 * 
		 * If the task's #GCancellable is already cancelled before you call
		 * g_task_run_in_thread()/g_task_run_in_thread_sync(), then the
		 * #GTaskThreadFunc will still be run (for consistency), but the task
		 * will also be completed right away.
		 * @param return_on_cancel whether the task returns automatically when
		 *   it is cancelled.
		 * @returns %TRUE if #task's return-on-cancel flag was changed to
		 *   match #return_on_cancel. %FALSE if #task has already been
		 *   cancelled.
		 */
		set_return_on_cancel(return_on_cancel: boolean): boolean;
		/**
		 * Sets #task's source tag. You can use this to tag a task return
		 * value with a particular pointer (usually a pointer to the function
		 * doing the tagging) and then later check it using
		 * {@link G.task_get_source_tag} (or g_async_result_is_tagged()) in the
		 * task's "finish" function, to figure out if the response came from a
		 * particular place.
		 * @param source_tag an opaque pointer indicating the source of this task
		 */
		set_source_tag(source_tag?: any | null): void;
		/**
		 * Sets #task's task data (freeing the existing task data, if any).
		 * @param task_data task-specific data
		 */
		set_task_data(task_data?: any | null): void;
		connect(signal: "notify::completed", callback: (owner: this, ...args: any) => void): number;

	}

	type TaskInitOptionsMixin = GObject.ObjectInitOptions & AsyncResultInitOptions
	export interface TaskInitOptions extends TaskInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link Task} instead.
	 */
	type TaskMixin = ITask & GObject.Object & AsyncResult;

	/**
	 * A #GTask represents and manages a cancellable "task".
	 * 
	 * ## Asynchronous operations
	 * 
	 * The most common usage of #GTask is as a #GAsyncResult, to
	 * manage data during an asynchronous operation. You call
	 * {@link G.task_new} in the "start" method, followed by
	 * g_task_set_task_data() and the like if you need to keep some
	 * additional data associated with the task, and then pass the
	 * task object around through your asynchronous operation.
	 * Eventually, you will call a method such as
	 * g_task_return_pointer() or g_task_return_error(), which will
	 * save the value you give it and then invoke the task's callback
	 * function in the
	 * [thread-default main context][g-main-context-push-thread-default]
	 * where it was created (waiting until the next iteration of the main
	 * loop first, if necessary). The caller will pass the #GTask back to
	 * the operation's finish function (as a #GAsyncResult), and you can
	 * use g_task_propagate_pointer() or the like to extract the
	 * return value.
	 * 
	 * Here is an example for using GTask as a GAsyncResult:
	 * |[<!-- language="C" -->
	 *     typedef struct {
	 *       CakeFrostingType frosting;
	 *       char *message;
	 *     } DecorationData;
	 * 
	 *     static void
	 *     decoration_data_free (DecorationData *decoration)
	 *     {
	 *       g_free (decoration->message);
	 *       g_slice_free (DecorationData, decoration);
	 *     }
	 * 
	 *     static void
	 *     baked_cb (Cake     *cake,
	 *               gpointer  user_data)
	 *     {
	 *       GTask *task = user_data;
	 *       DecorationData *decoration = g_task_get_task_data (task);
	 *       GError *error = NULL;
	 * 
	 *       if (cake == NULL)
	 *         {
	 *           g_task_return_new_error (task, BAKER_ERROR, BAKER_ERROR_NO_FLOUR,
	 *                                    "Go to the supermarket");
	 *           g_object_unref (task);
	 *           return;
	 *         }
	 * 
	 *       if (!cake_decorate (cake, decoration->frosting, decoration->message, &error))
	 *         {
	 *           g_object_unref (cake);
	 *           // g_task_return_error() takes ownership of error
	 *           g_task_return_error (task, error);
	 *           g_object_unref (task);
	 *           return;
	 *         }
	 * 
	 *       g_task_return_pointer (task, cake, g_object_unref);
	 *       g_object_unref (task);
	 *     }
	 * 
	 *     void
	 *     baker_bake_cake_async (Baker               *self,
	 *                            guint                radius,
	 *                            CakeFlavor           flavor,
	 *                            CakeFrostingType     frosting,
	 *                            const char          *message,
	 *                            GCancellable        *cancellable,
	 *                            GAsyncReadyCallback  callback,
	 *                            gpointer             user_data)
	 *     {
	 *       GTask *task;
	 *       DecorationData *decoration;
	 *       Cake  *cake;
	 * 
	 *       task = g_task_new (self, cancellable, callback, user_data);
	 *       if (radius < 3)
	 *         {
	 *           g_task_return_new_error (task, BAKER_ERROR, BAKER_ERROR_TOO_SMALL,
	 *                                    "%ucm radius cakes are silly",
	 *                                    radius);
	 *           g_object_unref (task);
	 *           return;
	 *         }
	 * 
	 *       cake = _baker_get_cached_cake (self, radius, flavor, frosting, message);
	 *       if (cake != NULL)
	 *         {
	 *           // _baker_get_cached_cake() returns a reffed cake
	 *           g_task_return_pointer (task, cake, g_object_unref);
	 *           g_object_unref (task);
	 *           return;
	 *         }
	 * 
	 *       decoration = g_slice_new (DecorationData);
	 *       decoration->frosting = frosting;
	 *       decoration->message = g_strdup (message);
	 *       g_task_set_task_data (task, decoration, (GDestroyNotify) decoration_data_free);
	 * 
	 *       _baker_begin_cake (self, radius, flavor, cancellable, baked_cb, task);
	 *     }
	 * 
	 *     Cake *
	 *     baker_bake_cake_finish (Baker         *self,
	 *                             GAsyncResult  *result,
	 *                             GError       **error)
	 *     {
	 *       g_return_val_if_fail (g_task_is_valid (result, self), NULL);
	 * 
	 *       return g_task_propagate_pointer (G_TASK (result), error);
	 *     }
	 * ]|
	 * 
	 * ## Chained asynchronous operations
	 * 
	 * #GTask also tries to simplify asynchronous operations that
	 * internally chain together several smaller asynchronous
	 * operations. g_task_get_cancellable(), g_task_get_context(),
	 * and g_task_get_priority() allow you to get back the task's
	 * #GCancellable, #GMainContext, and [I/O priority][io-priority]
	 * when starting a new subtask, so you don't have to keep track
	 * of them yourself. g_task_attach_source() simplifies the case
	 * of waiting for a source to fire (automatically using the correct
	 * #GMainContext and priority).
	 * 
	 * Here is an example for chained asynchronous operations:
	 *   |[<!-- language="C" -->
	 *     typedef struct {
	 *       Cake *cake;
	 *       CakeFrostingType frosting;
	 *       char *message;
	 *     } BakingData;
	 * 
	 *     static void
	 *     decoration_data_free (BakingData *bd)
	 *     {
	 *       if (bd->cake)
	 *         g_object_unref (bd->cake);
	 *       g_free (bd->message);
	 *       g_slice_free (BakingData, bd);
	 *     }
	 * 
	 *     static void
	 *     decorated_cb (Cake         *cake,
	 *                   GAsyncResult *result,
	 *                   gpointer      user_data)
	 *     {
	 *       GTask *task = user_data;
	 *       GError *error = NULL;
	 * 
	 *       if (!cake_decorate_finish (cake, result, &error))
	 *         {
	 *           g_object_unref (cake);
	 *           g_task_return_error (task, error);
	 *           g_object_unref (task);
	 *           return;
	 *         }
	 * 
	 *       // baking_data_free() will drop its ref on the cake, so we have to
	 *       // take another here to give to the caller.
	 *       g_task_return_pointer (task, g_object_ref (cake), g_object_unref);
	 *       g_object_unref (task);
	 *     }
	 * 
	 *     static gboolean
	 *     decorator_ready (gpointer user_data)
	 *     {
	 *       GTask *task = user_data;
	 *       BakingData *bd = g_task_get_task_data (task);
	 * 
	 *       cake_decorate_async (bd->cake, bd->frosting, bd->message,
	 *                            g_task_get_cancellable (task),
	 *                            decorated_cb, task);
	 * 
	 *       return G_SOURCE_REMOVE;
	 *     }
	 * 
	 *     static void
	 *     baked_cb (Cake     *cake,
	 *               gpointer  user_data)
	 *     {
	 *       GTask *task = user_data;
	 *       BakingData *bd = g_task_get_task_data (task);
	 *       GError *error = NULL;
	 * 
	 *       if (cake == NULL)
	 *         {
	 *           g_task_return_new_error (task, BAKER_ERROR, BAKER_ERROR_NO_FLOUR,
	 *                                    "Go to the supermarket");
	 *           g_object_unref (task);
	 *           return;
	 *         }
	 * 
	 *       bd->cake = cake;
	 * 
	 *       // Bail out now if the user has already cancelled
	 *       if (g_task_return_error_if_cancelled (task))
	 *         {
	 *           g_object_unref (task);
	 *           return;
	 *         }
	 * 
	 *       if (cake_decorator_available (cake))
	 *         decorator_ready (task);
	 *       else
	 *         {
	 *           GSource *source;
	 * 
	 *           source = cake_decorator_wait_source_new (cake);
	 *           // Attach #source to #task's GMainContext and have it call
	 *           // decorator_ready() when it is ready.
	 *           g_task_attach_source (task, source, decorator_ready);
	 *           g_source_unref (source);
	 *         }
	 *     }
	 * 
	 *     void
	 *     baker_bake_cake_async (Baker               *self,
	 *                            guint                radius,
	 *                            CakeFlavor           flavor,
	 *                            CakeFrostingType     frosting,
	 *                            const char          *message,
	 *                            gint                 priority,
	 *                            GCancellable        *cancellable,
	 *                            GAsyncReadyCallback  callback,
	 *                            gpointer             user_data)
	 *     {
	 *       GTask *task;
	 *       BakingData *bd;
	 * 
	 *       task = g_task_new (self, cancellable, callback, user_data);
	 *       g_task_set_priority (task, priority);
	 * 
	 *       bd = g_slice_new0 (BakingData);
	 *       bd->frosting = frosting;
	 *       bd->message = g_strdup (message);
	 *       g_task_set_task_data (task, bd, (GDestroyNotify) baking_data_free);
	 * 
	 *       _baker_begin_cake (self, radius, flavor, cancellable, baked_cb, task);
	 *     }
	 * 
	 *     Cake *
	 *     baker_bake_cake_finish (Baker         *self,
	 *                             GAsyncResult  *result,
	 *                             GError       **error)
	 *     {
	 *       g_return_val_if_fail (g_task_is_valid (result, self), NULL);
	 * 
	 *       return g_task_propagate_pointer (G_TASK (result), error);
	 *     }
	 * ]|
	 * 
	 * ## Asynchronous operations from synchronous ones
	 * 
	 * You can use g_task_run_in_thread() to turn a synchronous
	 * operation into an asynchronous one, by running it in a thread.
	 * When it completes, the result will be dispatched to the
	 * [thread-default main context][g-main-context-push-thread-default]
	 * where the #GTask was created.
	 * 
	 * Running a task in a thread:
	 *   |[<!-- language="C" -->
	 *     typedef struct {
	 *       guint radius;
	 *       CakeFlavor flavor;
	 *       CakeFrostingType frosting;
	 *       char *message;
	 *     } CakeData;
	 * 
	 *     static void
	 *     cake_data_free (CakeData *cake_data)
	 *     {
	 *       g_free (cake_data->message);
	 *       g_slice_free (CakeData, cake_data);
	 *     }
	 * 
	 *     static void
	 *     bake_cake_thread (GTask         *task,
	 *                       gpointer       source_object,
	 *                       gpointer       task_data,
	 *                       GCancellable  *cancellable)
	 *     {
	 *       Baker *self = source_object;
	 *       CakeData *cake_data = task_data;
	 *       Cake *cake;
	 *       GError *error = NULL;
	 * 
	 *       cake = bake_cake (baker, cake_data->radius, cake_data->flavor,
	 *                         cake_data->frosting, cake_data->message,
	 *                         cancellable, &error);
	 *       if (cake)
	 *         g_task_return_pointer (task, cake, g_object_unref);
	 *       else
	 *         g_task_return_error (task, error);
	 *     }
	 * 
	 *     void
	 *     baker_bake_cake_async (Baker               *self,
	 *                            guint                radius,
	 *                            CakeFlavor           flavor,
	 *                            CakeFrostingType     frosting,
	 *                            const char          *message,
	 *                            GCancellable        *cancellable,
	 *                            GAsyncReadyCallback  callback,
	 *                            gpointer             user_data)
	 *     {
	 *       CakeData *cake_data;
	 *       GTask *task;
	 * 
	 *       cake_data = g_slice_new (CakeData);
	 *       cake_data->radius = radius;
	 *       cake_data->flavor = flavor;
	 *       cake_data->frosting = frosting;
	 *       cake_data->message = g_strdup (message);
	 *       task = g_task_new (self, cancellable, callback, user_data);
	 *       g_task_set_task_data (task, cake_data, (GDestroyNotify) cake_data_free);
	 *       g_task_run_in_thread (task, bake_cake_thread);
	 *       g_object_unref (task);
	 *     }
	 * 
	 *     Cake *
	 *     baker_bake_cake_finish (Baker         *self,
	 *                             GAsyncResult  *result,
	 *                             GError       **error)
	 *     {
	 *       g_return_val_if_fail (g_task_is_valid (result, self), NULL);
	 * 
	 *       return g_task_propagate_pointer (G_TASK (result), error);
	 *     }
	 * ]|
	 * 
	 * ## Adding cancellability to uncancellable tasks
	 * 
	 * Finally, g_task_run_in_thread() and g_task_run_in_thread_sync()
	 * can be used to turn an uncancellable operation into a
	 * cancellable one. If you call g_task_set_return_on_cancel(),
	 * passing %TRUE, then if the task's #GCancellable is cancelled,
	 * it will return control back to the caller immediately, while
	 * allowing the task thread to continue running in the background
	 * (and simply discarding its result when it finally does finish).
	 * Provided that the task thread is careful about how it uses
	 * locks and other externally-visible resources, this allows you
	 * to make "GLib-friendly" asynchronous and cancellable
	 * synchronous variants of blocking APIs.
	 * 
	 * Cancelling a task:
	 *   |[<!-- language="C" -->
	 *     static void
	 *     bake_cake_thread (GTask         *task,
	 *                       gpointer       source_object,
	 *                       gpointer       task_data,
	 *                       GCancellable  *cancellable)
	 *     {
	 *       Baker *self = source_object;
	 *       CakeData *cake_data = task_data;
	 *       Cake *cake;
	 *       GError *error = NULL;
	 * 
	 *       cake = bake_cake (baker, cake_data->radius, cake_data->flavor,
	 *                         cake_data->frosting, cake_data->message,
	 *                         &error);
	 *       if (error)
	 *         {
	 *           g_task_return_error (task, error);
	 *           return;
	 *         }
	 * 
	 *       // If the task has already been cancelled, then we don't want to add
	 *       // the cake to the cake cache. Likewise, we don't  want to have the
	 *       // task get cancelled in the middle of updating the cache.
	 *       // g_task_set_return_on_cancel() will return %TRUE here if it managed
	 *       // to disable return-on-cancel, or %FALSE if the task was cancelled
	 *       // before it could.
	 *       if (g_task_set_return_on_cancel (task, FALSE))
	 *         {
	 *           // If the caller cancels at this point, their
	 *           // GAsyncReadyCallback won't be invoked until we return,
	 *           // so we don't have to worry that this code will run at
	 *           // the same time as that code does. But if there were
	 *           // other functions that might look at the cake cache,
	 *           // then we'd probably need a GMutex here as well.
	 *           baker_add_cake_to_cache (baker, cake);
	 *           g_task_return_pointer (task, cake, g_object_unref);
	 *         }
	 *     }
	 * 
	 *     void
	 *     baker_bake_cake_async (Baker               *self,
	 *                            guint                radius,
	 *                            CakeFlavor           flavor,
	 *                            CakeFrostingType     frosting,
	 *                            const char          *message,
	 *                            GCancellable        *cancellable,
	 *                            GAsyncReadyCallback  callback,
	 *                            gpointer             user_data)
	 *     {
	 *       CakeData *cake_data;
	 *       GTask *task;
	 * 
	 *       cake_data = g_slice_new (CakeData);
	 * 
	 *       ...
	 * 
	 *       task = g_task_new (self, cancellable, callback, user_data);
	 *       g_task_set_task_data (task, cake_data, (GDestroyNotify) cake_data_free);
	 *       g_task_set_return_on_cancel (task, TRUE);
	 *       g_task_run_in_thread (task, bake_cake_thread);
	 *     }
	 * 
	 *     Cake *
	 *     baker_bake_cake_sync (Baker               *self,
	 *                           guint                radius,
	 *                           CakeFlavor           flavor,
	 *                           CakeFrostingType     frosting,
	 *                           const char          *message,
	 *                           GCancellable        *cancellable,
	 *                           GError             **error)
	 *     {
	 *       CakeData *cake_data;
	 *       GTask *task;
	 *       Cake *cake;
	 * 
	 *       cake_data = g_slice_new (CakeData);
	 * 
	 *       ...
	 * 
	 *       task = g_task_new (self, cancellable, NULL, NULL);
	 *       g_task_set_task_data (task, cake_data, (GDestroyNotify) cake_data_free);
	 *       g_task_set_return_on_cancel (task, TRUE);
	 *       g_task_run_in_thread_sync (task, bake_cake_thread);
	 * 
	 *       cake = g_task_propagate_pointer (task, error);
	 *       g_object_unref (task);
	 *       return cake;
	 *     }
	 * ]|
	 * 
	 * ## Porting from GSimpleAsyncResult
	 * 
	 * #GTask's API attempts to be simpler than #GSimpleAsyncResult's
	 * in several ways:
	 * - You can save task-specific data with g_task_set_task_data(), and
	 *   retrieve it later with g_task_get_task_data(). This replaces the
	 *   abuse of g_simple_async_result_set_op_res_gpointer() for the same
	 *   purpose with #GSimpleAsyncResult.
	 * - In addition to the task data, #GTask also keeps track of the
	 *   [priority][io-priority], #GCancellable, and
	 *   #GMainContext associated with the task, so tasks that consist of
	 *   a chain of simpler asynchronous operations will have easy access
	 *   to those values when starting each sub-task.
	 * - g_task_return_error_if_cancelled() provides simplified
	 *   handling for cancellation. In addition, cancellation
	 *   overrides any other #GTask return value by default, like
	 *   #GSimpleAsyncResult does when
	 *   g_simple_async_result_set_check_cancellable() is called.
	 *   (You can use g_task_set_check_cancellable() to turn off that
	 *   behavior.) On the other hand, g_task_run_in_thread()
	 *   guarantees that it will always run your
	 *   `task_func`, even if the task's #GCancellable
	 *   is already cancelled before the task gets a chance to run;
	 *   you can start your `task_func` with a
	 *   g_task_return_error_if_cancelled() check if you need the
	 *   old behavior.
	 * - The "return" methods (eg, g_task_return_pointer())
	 *   automatically cause the task to be "completed" as well, and
	 *   there is no need to worry about the "complete" vs "complete
	 *   in idle" distinction. (#GTask automatically figures out
	 *   whether the task's callback can be invoked directly, or
	 *   if it needs to be sent to another #GMainContext, or delayed
	 *   until the next iteration of the current #GMainContext.)
	 * - The "finish" functions for #GTask based operations are generally
	 *   much simpler than #GSimpleAsyncResult ones, normally consisting
	 *   of only a single call to g_task_propagate_pointer() or the like.
	 *   Since g_task_propagate_pointer() "steals" the return value from
	 *   the #GTask, it is not necessary to juggle pointers around to
	 *   prevent it from being freed twice.
	 * - With #GSimpleAsyncResult, it was common to call
	 *   g_simple_async_result_propagate_error() from the
	 *   `_finish()` wrapper function, and have
	 *   virtual method implementations only deal with successful
	 *   returns. This behavior is deprecated, because it makes it
	 *   difficult for a subclass to chain to a parent class's async
	 *   methods. Instead, the wrapper function should just be a
	 *   simple wrapper, and the virtual method should call an
	 *   appropriate `g_task_propagate_` function.
	 *   Note that wrapper methods can now use
	 *   g_async_result_legacy_propagate_error() to do old-style
	 *   #GSimpleAsyncResult error-returning behavior, and
	 *   g_async_result_is_tagged() to check if a result is tagged as
	 *   having come from the `_async()` wrapper
	 *   function (for "short-circuit" results, such as when passing
	 *   0 to g_input_stream_read_async()).
	 */
	interface Task extends TaskMixin {}

	class Task {
		public constructor(options?: Partial<TaskInitOptions>);
		/**
		 * Creates a #GTask acting on #source_object, which will eventually be
		 * used to invoke #callback in the current
		 * [thread-default main context][g-main-context-push-thread-default].
		 * 
		 * Call this in the "start" method of your asynchronous method, and
		 * pass the #GTask around throughout the asynchronous operation. You
		 * can use {@link G.task_set_task_data} to attach task-specific data to the
		 * object, which you can retrieve later via g_task_get_task_data().
		 * 
		 * By default, if #cancellable is cancelled, then the return value of
		 * the task will always be %G_IO_ERROR_CANCELLED, even if the task had
		 * already completed before the cancellation. This allows for
		 * simplified handling in cases where cancellation may imply that
		 * other objects that the task depends on have been destroyed. If you
		 * do not want this behavior, you can use
		 * g_task_set_check_cancellable() to change it.
		 * @param source_object the #GObject that owns
		 *   this task, or %NULL.
		 * @param cancellable optional #GCancellable object, %NULL to ignore.
		 * @param callback a #GAsyncReadyCallback.
		 * @returns a #GTask.
		 */
		public static new(source_object?: GObject.Object | null, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): Task;
		/**
		 * Checks that #result is a #GTask, and that #source_object is its
		 * source object (or that #source_object is %NULL and #result has no
		 * source object). This can be used in {@link G.return_if_fail} checks.
		 * @param result A #GAsyncResult
		 * @param source_object the source object
		 *   expected to be associated with the task
		 * @returns %TRUE if #result and #source_object are valid, %FALSE
		 * if not
		 */
		public static is_valid(result: AsyncResult, source_object?: GObject.Object | null): boolean;
		/**
		 * Creates a #GTask and then immediately calls {@link G.task_return_error}
		 * on it. Use this in the wrapper function of an asynchronous method
		 * when you want to avoid even calling the virtual method. You can
		 * then use g_async_result_is_tagged() in the finish method wrapper to
		 * check if the result there is tagged as having been created by the
		 * wrapper method, and deal with it appropriately if so.
		 * 
		 * See also g_task_report_new_error().
		 * @param source_object the #GObject that owns
		 *   this task, or %NULL.
		 * @param callback a #GAsyncReadyCallback.
		 * @param source_tag an opaque pointer indicating the source of this task
		 * @param error error to report
		 */
		public static report_error(source_object: GObject.Object | null, callback: AsyncReadyCallback | null, source_tag: any | null, error: GLib.Error): void;
		/**
		 * Creates a #GTask and then immediately calls
		 * {@link G.task_return_new_error} on it. Use this in the wrapper function
		 * of an asynchronous method when you want to avoid even calling the
		 * virtual method. You can then use g_async_result_is_tagged() in the
		 * finish method wrapper to check if the result there is tagged as
		 * having been created by the wrapper method, and deal with it
		 * appropriately if so.
		 * 
		 * See also g_task_report_error().
		 * @param source_object the #GObject that owns
		 *   this task, or %NULL.
		 * @param callback a #GAsyncReadyCallback.
		 * @param source_tag an opaque pointer indicating the source of this task
		 * @param domain a #GQuark.
		 * @param code an error code.
		 * @param format a string with format characters.
		 */
		public static report_new_error(source_object: GObject.Object | null, callback: AsyncReadyCallback | null, source_tag: any | null, domain: GLib.Quark, code: number, format: string): void;
	}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link TcpConnection} instead.
	 */
	interface ITcpConnection {
		graceful_disconnect: boolean;
		/**
		 * Checks if graceful disconnects are used. See
		 * {@link G.tcp_connection_set_graceful_disconnect}.
		 * @returns %TRUE if graceful disconnect is used on close, %FALSE otherwise
		 */
		get_graceful_disconnect(): boolean;
		/**
		 * This enables graceful disconnects on close. A graceful disconnect
		 * means that we signal the receiving end that the connection is terminated
		 * and wait for it to close the connection before closing the connection.
		 * 
		 * A graceful disconnect means that we can be sure that we successfully sent
		 * all the outstanding data to the other end, or get an error reported.
		 * However, it also means we have to wait for all the data to reach the
		 * other side and for it to acknowledge this by closing the socket, which may
		 * take a while. For this reason it is disabled by default.
		 * @param graceful_disconnect Whether to do graceful disconnects or not
		 */
		set_graceful_disconnect(graceful_disconnect: boolean): void;
		connect(signal: "notify::graceful-disconnect", callback: (owner: this, ...args: any) => void): number;

	}

	type TcpConnectionInitOptionsMixin = SocketConnectionInitOptions & 
	Pick<ITcpConnection,
		"graceful_disconnect">;

	export interface TcpConnectionInitOptions extends TcpConnectionInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link TcpConnection} instead.
	 */
	type TcpConnectionMixin = ITcpConnection & SocketConnection;

	/**
	 * This is the subclass of #GSocketConnection that is created
	 * for TCP/IP sockets.
	 */
	interface TcpConnection extends TcpConnectionMixin {}

	class TcpConnection {
		public constructor(options?: Partial<TcpConnectionInitOptions>);
	}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link TcpWrapperConnection} instead.
	 */
	interface ITcpWrapperConnection {
		base_io_stream: IOStream;
		/**
		 * Gets #conn's base #GIOStream
		 * @returns #conn's base #GIOStream
		 */
		get_base_io_stream(): IOStream;
		connect(signal: "notify::base-io-stream", callback: (owner: this, ...args: any) => void): number;

	}

	type TcpWrapperConnectionInitOptionsMixin = TcpConnectionInitOptions & 
	Pick<ITcpWrapperConnection,
		"base_io_stream">;

	export interface TcpWrapperConnectionInitOptions extends TcpWrapperConnectionInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link TcpWrapperConnection} instead.
	 */
	type TcpWrapperConnectionMixin = ITcpWrapperConnection & TcpConnection;

	/**
	 * A #GTcpWrapperConnection can be used to wrap a #GIOStream that is
	 * based on a #GSocket, but which is not actually a
	 * #GSocketConnection. This is used by #GSocketClient so that it can
	 * always return a #GSocketConnection, even when the connection it has
	 * actually created is not directly a #GSocketConnection.
	 */
	interface TcpWrapperConnection extends TcpWrapperConnectionMixin {}

	class TcpWrapperConnection {
		public constructor(options?: Partial<TcpWrapperConnectionInitOptions>);
		/**
		 * Wraps #base_io_stream and #socket together as a #GSocketConnection.
		 * @param base_io_stream the #GIOStream to wrap
		 * @param socket the #GSocket associated with #base_io_stream
		 * @returns the new #GSocketConnection.
		 */
		public static new(base_io_stream: IOStream, socket: Socket): SocketConnection;
	}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link TestDBus} instead.
	 */
	interface ITestDBus {
		/**
		 * #GTestDBusFlags specifying the behaviour of the D-Bus session.
		 */
		flags: TestDBusFlags;
		/**
		 * Add a path where dbus-daemon will look up .service files. This can't be
		 * called after {@link G.test_dbus_up}.
		 * @param path path to a directory containing .service files
		 */
		add_service_dir(path: string): void;
		/**
		 * Stop the session bus started by {@link G.test_dbus_up}.
		 * 
		 * This will wait for the singleton returned by g_bus_get() or g_bus_get_sync()
		 * to be destroyed. This is done to ensure that the next unit test won't get a
		 * leaked singleton from this test.
		 */
		down(): void;
		/**
		 * Get the address on which dbus-daemon is running. If {@link G.test_dbus_up} has not
		 * been called yet, %NULL is returned. This can be used with
		 * g_dbus_connection_new_for_address().
		 * @returns the address of the bus, or %NULL.
		 */
		get_bus_address(): string | null;
		/**
		 * Get the flags of the #GTestDBus object.
		 * @returns the value of #GTestDBus:flags property
		 */
		get_flags(): TestDBusFlags;
		/**
		 * Stop the session bus started by {@link G.test_dbus_up}.
		 * 
		 * Unlike g_test_dbus_down(), this won't verify the #GDBusConnection
		 * singleton returned by g_bus_get() or g_bus_get_sync() is destroyed. Unit
		 * tests wanting to verify behaviour after the session bus has been stopped
		 * can use this function but should still call g_test_dbus_down() when done.
		 */
		stop(): void;
		/**
		 * Start a dbus-daemon instance and set DBUS_SESSION_BUS_ADDRESS. After this
		 * call, it is safe for unit tests to start sending messages on the session bus.
		 * 
		 * If this function is called from setup callback of {@link G.test_add},
		 * g_test_dbus_down() must be called in its teardown callback.
		 * 
		 * If this function is called from unit test's main(), then g_test_dbus_down()
		 * must be called after g_test_run().
		 */
		up(): void;
		connect(signal: "notify::flags", callback: (owner: this, ...args: any) => void): number;

	}

	type TestDBusInitOptionsMixin = GObject.ObjectInitOptions & 
	Pick<ITestDBus,
		"flags">;

	export interface TestDBusInitOptions extends TestDBusInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link TestDBus} instead.
	 */
	type TestDBusMixin = ITestDBus & GObject.Object;

	/**
	 * A helper class for testing code which uses D-Bus without touching the user's
	 * session bus.
	 * 
	 * Note that #GTestDBus modifies the user’s environment, calling setenv().
	 * This is not thread-safe, so all #GTestDBus calls should be completed before
	 * threads are spawned, or should have appropriate locking to ensure no access
	 * conflicts to environment variables shared between #GTestDBus and other
	 * threads.
	 * 
	 * ## Creating unit tests using GTestDBus
	 * 
	 * Testing of D-Bus services can be tricky because normally we only ever run
	 * D-Bus services over an existing instance of the D-Bus daemon thus we
	 * usually don't activate D-Bus services that are not yet installed into the
	 * target system. The #GTestDBus object makes this easier for us by taking care
	 * of the lower level tasks such as running a private D-Bus daemon and looking
	 * up uninstalled services in customizable locations, typically in your source
	 * code tree.
	 * 
	 * The first thing you will need is a separate service description file for the
	 * D-Bus daemon. Typically a `services` subdirectory of your `tests` directory
	 * is a good place to put this file.
	 * 
	 * The service file should list your service along with an absolute path to the
	 * uninstalled service executable in your source tree. Using autotools we would
	 * achieve this by adding a file such as `my-server.service.in` in the services
	 * directory and have it processed by configure.
	 * |[
	 *     [D-BUS Service]
	 *     Name=org.gtk.GDBus.Examples.ObjectManager
	 *     Exec=#abs_top_builddir#/gio/tests/gdbus-example-objectmanager-server
	 * ]|
	 * You will also need to indicate this service directory in your test
	 * fixtures, so you will need to pass the path while compiling your
	 * test cases. Typically this is done with autotools with an added
	 * preprocessor flag specified to compile your tests such as:
	 * |[
	 *     -DTEST_SERVICES=\""$(abs_top_builddir)/tests/services"\"
	 * ]|
	 *     Once you have a service definition file which is local to your source tree,
	 * you can proceed to set up a GTest fixture using the #GTestDBus scaffolding.
	 * 
	 * An example of a test fixture for D-Bus services can be found
	 * here:
	 * [gdbus-test-fixture.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gdbus-test-fixture.c)
	 * 
	 * Note that these examples only deal with isolating the D-Bus aspect of your
	 * service. To successfully run isolated unit tests on your service you may need
	 * some additional modifications to your test case fixture. For example; if your
	 * service uses GSettings and installs a schema then it is important that your test service
	 * not load the schema in the ordinary installed location (chances are that your service
	 * and schema files are not yet installed, or worse; there is an older version of the
	 * schema file sitting in the install location).
	 * 
	 * Most of the time we can work around these obstacles using the
	 * environment. Since the environment is inherited by the D-Bus daemon
	 * created by #GTestDBus and then in turn inherited by any services the
	 * D-Bus daemon activates, using the setup routine for your fixture is
	 * a practical place to help sandbox your runtime environment. For the
	 * rather typical GSettings case we can work around this by setting
	 * `GSETTINGS_SCHEMA_DIR` to the in tree directory holding your schemas
	 * in the above fixture_setup() routine.
	 * 
	 * The GSettings schemas need to be locally pre-compiled for this to work. This can be achieved
	 * by compiling the schemas locally as a step before running test cases, an autotools setup might
	 * do the following in the directory holding schemas:
	 * |[
	 *     all-am:
	 *             $(GLIB_COMPILE_SCHEMAS) .
	 * 
	 *     CLEANFILES += gschemas.compiled
	 * ]|
	 */
	interface TestDBus extends TestDBusMixin {}

	class TestDBus {
		public constructor(options?: Partial<TestDBusInitOptions>);
		/**
		 * Create a new #GTestDBus object.
		 * @param flags a #GTestDBusFlags
		 * @returns a new #GTestDBus.
		 */
		public static new(flags: TestDBusFlags): TestDBus;
		/**
		 * Unset DISPLAY and DBUS_SESSION_BUS_ADDRESS env variables to ensure the test
		 * won't use user's session bus.
		 * 
		 * This is useful for unit tests that want to verify behaviour when no session
		 * bus is running. It is not necessary to call this if unit test already calls
		 * {@link G.test_dbus_up} before acquiring the session bus.
		 */
		public static unset(): void;
	}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link ThemedIcon} instead.
	 */
	interface IThemedIcon {
		/**
		 * A %NULL-terminated array of icon names.
		 */
		names: string[];
		/**
		 * Whether to use the default fallbacks found by shortening the icon name
		 * at '-' characters. If the "names" array has more than one element,
		 * ignores any past the first.
		 * 
		 * For example, if the icon name was "gnome-dev-cdrom-audio", the array
		 * would become
		 * |[<!-- language="C" -->
		 * {
		 *   "gnome-dev-cdrom-audio",
		 *   "gnome-dev-cdrom",
		 *   "gnome-dev",
		 *   "gnome",
		 *   NULL
		 * };
		 * ]|
		 */
		use_default_fallbacks: boolean;
		/**
		 * Append a name to the list of icons from within #icon.
		 * 
		 * Note that doing so invalidates the hash computed by prior calls
		 * to {@link G.icon_hash}.
		 * @param iconname name of icon to append to list of icons from within #icon.
		 */
		append_name(iconname: string): void;
		/**
		 * Gets the names of icons from within #icon.
		 * @returns a list of icon names.
		 */
		get_names(): string[];
		/**
		 * Prepend a name to the list of icons from within #icon.
		 * 
		 * Note that doing so invalidates the hash computed by prior calls
		 * to {@link G.icon_hash}.
		 * @param iconname name of icon to prepend to list of icons from within #icon.
		 */
		prepend_name(iconname: string): void;
		connect(signal: "notify::names", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::use-default-fallbacks", callback: (owner: this, ...args: any) => void): number;

	}

	type ThemedIconInitOptionsMixin = GObject.ObjectInitOptions & IconInitOptions & 
	Pick<IThemedIcon,
		"names" |
		"use_default_fallbacks">;

	export interface ThemedIconInitOptions extends ThemedIconInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link ThemedIcon} instead.
	 */
	type ThemedIconMixin = IThemedIcon & GObject.Object & Icon;

	/**
	 * #GThemedIcon is an implementation of #GIcon that supports icon themes.
	 * #GThemedIcon contains a list of all of the icons present in an icon
	 * theme, so that icons can be looked up quickly. #GThemedIcon does
	 * not provide actual pixmaps for icons, just the icon names.
	 * Ideally something like {@link Gtk.IconTheme.choose_icon} should be used to
	 * resolve the list of names so that fallback icons work nicely with
	 * themes that inherit other themes.
	 */
	interface ThemedIcon extends ThemedIconMixin {}

	class ThemedIcon {
		public constructor(options?: Partial<ThemedIconInitOptions>);
		/**
		 * Creates a new themed icon for #iconname.
		 * @param iconname a string containing an icon name.
		 * @returns a new #GThemedIcon.
		 */
		public static new(iconname: string): ThemedIcon;
		/**
		 * Creates a new themed icon for #iconnames.
		 * @param iconnames an array of strings containing icon names.
		 * @returns a new #GThemedIcon
		 */
		public static new_from_names(iconnames: string[]): ThemedIcon;
		/**
		 * Creates a new themed icon for #iconname, and all the names
		 * that can be created by shortening #iconname at '-' characters.
		 * 
		 * In the following example, #icon1 and #icon2 are equivalent:
		 * |[<!-- language="C" -->
		 * const char *names[] = {
		 *   "gnome-dev-cdrom-audio",
		 *   "gnome-dev-cdrom",
		 *   "gnome-dev",
		 *   "gnome"
		 * };
		 * 
		 * icon1 = g_themed_icon_new_from_names (names, 4);
		 * icon2 = g_themed_icon_new_with_default_fallbacks ("gnome-dev-cdrom-audio");
		 * ]|
		 * @param iconname a string containing an icon name
		 * @returns a new #GThemedIcon.
		 */
		public static new_with_default_fallbacks(iconname: string): ThemedIcon;
	}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link ThreadedSocketService} instead.
	 */
	interface IThreadedSocketService {
		max_threads: number;

		/**
		 * The ::run signal is emitted in a worker thread in response to an
		 * incoming connection. This thread is dedicated to handling
		 * #connection and may perform blocking IO. The signal handler need
		 * not return until the connection is closed.
		 * @param signal 
		 * @param callback Callback function
		 *  - owner: owner of the emitted event 
		 *  - connection: a new #GSocketConnection object. 
		 *  - source_object: the source_object passed to {@link G.socket_listener_add_address}. 
		 *  - returns %TRUE to stop further signal handlers from being called 
		 * 
		 * @returns Callback ID
		 */
		connect(signal: "run", callback: (owner: this, connection: SocketConnection, source_object: GObject.Object | null) => boolean): number;

		connect(signal: "notify::max-threads", callback: (owner: this, ...args: any) => void): number;

	}

	type ThreadedSocketServiceInitOptionsMixin = SocketServiceInitOptions & 
	Pick<IThreadedSocketService,
		"max_threads">;

	export interface ThreadedSocketServiceInitOptions extends ThreadedSocketServiceInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link ThreadedSocketService} instead.
	 */
	type ThreadedSocketServiceMixin = IThreadedSocketService & SocketService;

	/**
	 * A #GThreadedSocketService is a simple subclass of #GSocketService
	 * that handles incoming connections by creating a worker thread and
	 * dispatching the connection to it by emitting the
	 * #GThreadedSocketService::run signal in the new thread.
	 * 
	 * The signal handler may perform blocking IO and need not return
	 * until the connection is closed.
	 * 
	 * The service is implemented using a thread pool, so there is a
	 * limited amount of threads available to serve incoming requests.
	 * The service automatically stops the #GSocketService from accepting
	 * new connections when all threads are busy.
	 * 
	 * As with #GSocketService, you may connect to #GThreadedSocketService::run,
	 * or subclass and override the default handler.
	 */
	interface ThreadedSocketService extends ThreadedSocketServiceMixin {}

	class ThreadedSocketService {
		public constructor(options?: Partial<ThreadedSocketServiceInitOptions>);
		/**
		 * Creates a new #GThreadedSocketService with no listeners. Listeners
		 * must be added with one of the #GSocketListener "add" methods.
		 * @param max_threads the maximal number of threads to execute concurrently
		 *   handling incoming clients, -1 means no limit
		 * @returns a new #GSocketService.
		 */
		public static new(max_threads: number): SocketService;
	}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link TlsCertificate} instead.
	 */
	interface ITlsCertificate {
		/**
		 * The DER (binary) encoded representation of the certificate.
		 * This property and the #GTlsCertificate:certificate-pem property
		 * represent the same data, just in different forms.
		 */
		certificate: number[];
		/**
		 * The PEM (ASCII) encoded representation of the certificate.
		 * This property and the #GTlsCertificate:certificate
		 * property represent the same data, just in different forms.
		 */
		certificate_pem: string;
		/**
		 * The DNS names from the certificate's Subject Alternative Names (SANs),
		 * %NULL if unavailable.
		 */
		readonly dns_names: any[];
		/**
		 * The IP addresses from the certificate's Subject Alternative Names (SANs),
		 * %NULL if unavailable.
		 */
		readonly ip_addresses: any[];
		/**
		 * A #GTlsCertificate representing the entity that issued this
		 * certificate. If %NULL, this means that the certificate is either
		 * self-signed, or else the certificate of the issuer is not
		 * available.
		 * 
		 * Beware the issuer certificate may not be the same as the
		 * certificate that would actually be used to construct a valid
		 * certification path during certificate verification.
		 * [RFC 4158](https://datatracker.ietf.org/doc/html/rfc4158) explains
		 * why an issuer certificate cannot be naively assumed to be part of the
		 * the certification path (though GLib's TLS backends may not follow the
		 * path building strategies outlined in this RFC). Due to the complexity
		 * of certification path building, GLib does not provide any way to know
		 * which certification path will actually be used. Accordingly, this
		 * property cannot be used to make security-related decisions. Only
		 * GLib itself should make security decisions about TLS certificates.
		 */
		issuer: TlsCertificate;
		/**
		 * The issuer from the certificate,
		 * %NULL if unavailable.
		 */
		readonly issuer_name: string;
		/**
		 * The time at which this cert is no longer valid,
		 * %NULL if unavailable.
		 */
		readonly not_valid_after: GLib.DateTime;
		/**
		 * The time at which this cert is considered to be valid,
		 * %NULL if unavailable.
		 */
		readonly not_valid_before: GLib.DateTime;
		/**
		 * A URI referencing the [PKCS \#11](https://docs.oasis-open.org/pkcs11/pkcs11-base/v3.0/os/pkcs11-base-v3.0-os.html)
		 * objects containing an X.509 certificate and optionally a private key.
		 * 
		 * If %NULL, the certificate is either not backed by PKCS \#11 or the
		 * #GTlsBackend does not support PKCS \#11.
		 */
		pkcs11_uri: string;
		/**
		 * The DER (binary) encoded representation of the certificate's
		 * private key, in either [PKCS \#1 format](https://datatracker.ietf.org/doc/html/rfc8017)
		 * or unencrypted [PKCS \#8 format.](https://datatracker.ietf.org/doc/html/rfc5208)
		 * PKCS \#8 format is supported since 2.32; earlier releases only
		 * support PKCS \#1. You can use the `openssl rsa` tool to convert
		 * PKCS \#8 keys to PKCS \#1.
		 * 
		 * This property (or the #GTlsCertificate:private-key-pem property)
		 * can be set when constructing a key (for example, from a file).
		 * Since GLib 2.70, it is now also readable; however, be aware that if
		 * the private key is backed by a PKCS \#11 URI – for example, if it
		 * is stored on a smartcard – then this property will be %NULL. If so,
		 * the private key must be referenced via its PKCS \#11 URI,
		 * #GTlsCertificate:private-key-pkcs11-uri. You must check both
		 * properties to see if the certificate really has a private key.
		 * When this property is read, the output format will be unencrypted
		 * PKCS \#8.
		 */
		private_key: number[];
		/**
		 * The PEM (ASCII) encoded representation of the certificate's
		 * private key in either [PKCS \#1 format](https://datatracker.ietf.org/doc/html/rfc8017)
		 * ("`BEGIN RSA PRIVATE KEY`") or unencrypted
		 * [PKCS \#8 format](https://datatracker.ietf.org/doc/html/rfc5208)
		 * ("`BEGIN PRIVATE KEY`"). PKCS \#8 format is supported since 2.32;
		 * earlier releases only support PKCS \#1. You can use the `openssl rsa`
		 * tool to convert PKCS \#8 keys to PKCS \#1.
		 * 
		 * This property (or the #GTlsCertificate:private-key property)
		 * can be set when constructing a key (for example, from a file).
		 * Since GLib 2.70, it is now also readable; however, be aware that if
		 * the private key is backed by a PKCS \#11 URI - for example, if it
		 * is stored on a smartcard - then this property will be %NULL. If so,
		 * the private key must be referenced via its PKCS \#11 URI,
		 * #GTlsCertificate:private-key-pkcs11-uri. You must check both
		 * properties to see if the certificate really has a private key.
		 * When this property is read, the output format will be unencrypted
		 * PKCS \#8.
		 */
		private_key_pem: string;
		/**
		 * A URI referencing a [PKCS \#11](https://docs.oasis-open.org/pkcs11/pkcs11-base/v3.0/os/pkcs11-base-v3.0-os.html)
		 * object containing a private key.
		 */
		private_key_pkcs11_uri: string;
		/**
		 * The subject from the cert,
		 * %NULL if unavailable.
		 */
		readonly subject_name: string;
		/**
		 * Gets the value of #GTlsCertificate:dns-names.
		 * @returns A #GPtrArray of
		 * #GBytes elements, or %NULL if it's not available.
		 */
		get_dns_names(): GLib.Bytes[] | null;
		/**
		 * Gets the value of #GTlsCertificate:ip-addresses.
		 * @returns A #GPtrArray
		 * of #GInetAddress elements, or %NULL if it's not available.
		 */
		get_ip_addresses(): InetAddress[] | null;
		/**
		 * Gets the #GTlsCertificate representing #cert's issuer, if known
		 * @returns The certificate of #cert's issuer,
		 * or %NULL if #cert is self-signed or signed with an unknown
		 * certificate.
		 */
		get_issuer(): TlsCertificate | null;
		/**
		 * Returns the issuer name from the certificate.
		 * @returns The issuer name, or %NULL if it's not available.
		 */
		get_issuer_name(): string | null;
		/**
		 * Returns the time at which the certificate became or will become invalid.
		 * @returns The not-valid-after date, or %NULL if it's not available.
		 */
		get_not_valid_after(): GLib.DateTime | null;
		/**
		 * Returns the time at which the certificate became or will become valid.
		 * @returns The not-valid-before date, or %NULL if it's not available.
		 */
		get_not_valid_before(): GLib.DateTime | null;
		/**
		 * Returns the subject name from the certificate.
		 * @returns The subject name, or %NULL if it's not available.
		 */
		get_subject_name(): string | null;
		/**
		 * Check if two #GTlsCertificate objects represent the same certificate.
		 * The raw DER byte data of the two certificates are checked for equality.
		 * This has the effect that two certificates may compare equal even if
		 * their #GTlsCertificate:issuer, #GTlsCertificate:private-key, or
		 * #GTlsCertificate:private-key-pem properties differ.
		 * @param cert_two second certificate to compare
		 * @returns whether the same or not
		 */
		is_same(cert_two: TlsCertificate): boolean;
		/**
		 * This verifies #cert and returns a set of #GTlsCertificateFlags
		 * indicating any problems found with it. This can be used to verify a
		 * certificate outside the context of making a connection, or to
		 * check a certificate against a CA that is not part of the system
		 * CA database.
		 * 
		 * If #identity is not %NULL, #cert's name(s) will be compared against
		 * it, and %G_TLS_CERTIFICATE_BAD_IDENTITY will be set in the return
		 * value if it does not match. If #identity is %NULL, that bit will
		 * never be set in the return value.
		 * 
		 * If #trusted_ca is not %NULL, then #cert (or one of the certificates
		 * in its chain) must be signed by it, or else
		 * %G_TLS_CERTIFICATE_UNKNOWN_CA will be set in the return value. If
		 * #trusted_ca is %NULL, that bit will never be set in the return
		 * value.
		 * 
		 * (All other #GTlsCertificateFlags values will always be set or unset
		 * as appropriate.)
		 * 
		 * Because TLS session context is not used, #GTlsCertificate may not
		 * perform as many checks on the certificates as #GTlsConnection would.
		 * For example, certificate constraints cannot be honored, and some
		 * revocation checks cannot be performed. The best way to verify TLS
		 * certificates used by a TLS connection is to let #GTlsConnection
		 * handle the verification.
		 * @param identity the expected peer identity
		 * @param trusted_ca the certificate of a trusted authority
		 * @returns the appropriate #GTlsCertificateFlags
		 */
		verify(identity?: SocketConnectable | null, trusted_ca?: TlsCertificate | null): TlsCertificateFlags;
		connect(signal: "notify::certificate", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::certificate-pem", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::dns-names", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::ip-addresses", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::issuer", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::issuer-name", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::not-valid-after", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::not-valid-before", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::pkcs11-uri", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::private-key", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::private-key-pem", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::private-key-pkcs11-uri", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::subject-name", callback: (owner: this, ...args: any) => void): number;

	}

	type TlsCertificateInitOptionsMixin = GObject.ObjectInitOptions & 
	Pick<ITlsCertificate,
		"certificate" |
		"certificate_pem" |
		"issuer" |
		"pkcs11_uri" |
		"private_key" |
		"private_key_pem" |
		"private_key_pkcs11_uri">;

	export interface TlsCertificateInitOptions extends TlsCertificateInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link TlsCertificate} instead.
	 */
	type TlsCertificateMixin = ITlsCertificate & GObject.Object;

	/**
	 * A certificate used for TLS authentication and encryption.
	 * This can represent either a certificate only (eg, the certificate
	 * received by a client from a server), or the combination of
	 * a certificate and a private key (which is needed when acting as a
	 * #GTlsServerConnection).
	 */
	interface TlsCertificate extends TlsCertificateMixin {}

	class TlsCertificate {
		public constructor(options?: Partial<TlsCertificateInitOptions>);
		/**
		 * Creates a #GTlsCertificate from the PEM-encoded data in #file. The
		 * returned certificate will be the first certificate found in #file. As
		 * of GLib 2.44, if #file contains more certificates it will try to load
		 * a certificate chain. All certificates will be verified in the order
		 * found (top-level certificate should be the last one in the file) and
		 * the #GTlsCertificate:issuer property of each certificate will be set
		 * accordingly if the verification succeeds. If any certificate in the
		 * chain cannot be verified, the first certificate in the file will
		 * still be returned.
		 * 
		 * If #file cannot be read or parsed, the function will return %NULL and
		 * set #error. Otherwise, this behaves like
		 * {@link G.tls_certificate_new_from_pem}.
		 * @param file file containing a PEM-encoded certificate to import
		 * @returns the new certificate, or %NULL on error
		 */
		public static new_from_file(file: string): TlsCertificate;
		/**
		 * Creates a #GTlsCertificate from the PEM-encoded data in #cert_file
		 * and #key_file. The returned certificate will be the first certificate
		 * found in #cert_file. As of GLib 2.44, if #cert_file contains more
		 * certificates it will try to load a certificate chain. All
		 * certificates will be verified in the order found (top-level
		 * certificate should be the last one in the file) and the
		 * #GTlsCertificate:issuer property of each certificate will be set
		 * accordingly if the verification succeeds. If any certificate in the
		 * chain cannot be verified, the first certificate in the file will
		 * still be returned.
		 * 
		 * If either file cannot be read or parsed, the function will return
		 * %NULL and set #error. Otherwise, this behaves like
		 * {@link G.tls_certificate_new_from_pem}.
		 * @param cert_file file containing one or more PEM-encoded
		 *     certificates to import
		 * @param key_file file containing a PEM-encoded private key
		 *     to import
		 * @returns the new certificate, or %NULL on error
		 */
		public static new_from_files(cert_file: string, key_file: string): TlsCertificate;
		/**
		 * Creates a #GTlsCertificate from the PEM-encoded data in #data. If
		 * #data includes both a certificate and a private key, then the
		 * returned certificate will include the private key data as well. (See
		 * the #GTlsCertificate:private-key-pem property for information about
		 * supported formats.)
		 * 
		 * The returned certificate will be the first certificate found in
		 * #data. As of GLib 2.44, if #data contains more certificates it will
		 * try to load a certificate chain. All certificates will be verified in
		 * the order found (top-level certificate should be the last one in the
		 * file) and the #GTlsCertificate:issuer property of each certificate
		 * will be set accordingly if the verification succeeds. If any
		 * certificate in the chain cannot be verified, the first certificate in
		 * the file will still be returned.
		 * @param data PEM-encoded certificate data
		 * @param length the length of #data, or -1 if it's 0-terminated.
		 * @returns the new certificate, or %NULL if #data is invalid
		 */
		public static new_from_pem(data: string, length: number): TlsCertificate;
		/**
		 * Creates a #GTlsCertificate from a
		 * [PKCS \#11](https://docs.oasis-open.org/pkcs11/pkcs11-base/v3.0/os/pkcs11-base-v3.0-os.html) URI.
		 * 
		 * An example #pkcs11_uri would be `pkcs11:model=Model;manufacturer=Manufacture;serial=1;token=My%20Client%20Certificate;id=%01`
		 * 
		 * Where the token’s layout is:
		 * 
		 * |[
		 * Object 0:
		 *   URL: pkcs11:model=Model;manufacturer=Manufacture;serial=1;token=My%20Client%20Certificate;id=%01;object=private%20key;type=private
		 *   Type: Private key (RSA-2048)
		 *   ID: 01
		 * 
		 * Object 1:
		 *   URL: pkcs11:model=Model;manufacturer=Manufacture;serial=1;token=My%20Client%20Certificate;id=%01;object=Certificate%20for%20Authentication;type=cert
		 *   Type: X.509 Certificate (RSA-2048)
		 *   ID: 01
		 * ]|
		 * 
		 * In this case the certificate and private key would both be detected and used as expected.
		 * #pkcs_uri may also just reference an X.509 certificate object and then optionally
		 * #private_key_pkcs11_uri allows using a private key exposed under a different URI.
		 * 
		 * Note that the private key is not accessed until usage and may fail or require a PIN later.
		 * @param pkcs11_uri A PKCS \#11 URI
		 * @param private_key_pkcs11_uri A PKCS \#11 URI
		 * @returns the new certificate, or %NULL on error
		 */
		public static new_from_pkcs11_uris(pkcs11_uri: string, private_key_pkcs11_uri?: string | null): TlsCertificate;
		/**
		 * Creates one or more #GTlsCertificates from the PEM-encoded
		 * data in #file. If #file cannot be read or parsed, the function will
		 * return %NULL and set #error. If #file does not contain any
		 * PEM-encoded certificates, this will return an empty list and not
		 * set #error.
		 * @param file file containing PEM-encoded certificates to import
		 * @returns a
		 * #GList containing #GTlsCertificate objects. You must free the list
		 * and its contents when you are done with it.
		 */
		public static list_new_from_file(file: string): TlsCertificate[];
	}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link TlsConnection} instead.
	 */
	interface ITlsConnection {
		/**
		 * The list of application-layer protocols that the connection
		 * advertises that it is willing to speak. See
		 * {@link G.tls_connection_set_advertised_protocols}.
		 */
		advertised_protocols: string[];
		/**
		 * The #GIOStream that the connection wraps. The connection holds a reference
		 * to this stream, and may run operations on the stream from other threads
		 * throughout its lifetime. Consequently, after the #GIOStream has been
		 * constructed, application code may only run its own operations on this
		 * stream when no #GIOStream operations are running.
		 */
		base_io_stream: IOStream;
		/**
		 * The connection's certificate; see
		 * {@link G.tls_connection_set_certificate}.
		 */
		certificate: TlsCertificate;
		/**
		 * The name of the TLS ciphersuite in use. See {@link G.tls_connection_get_ciphersuite_name}.
		 */
		readonly ciphersuite_name: string;
		/**
		 * The certificate database to use when verifying this TLS connection.
		 * If no certificate database is set, then the default database will be
		 * used. See {@link G.tls_backend_get_default_database}.
		 */
		database: TlsDatabase;
		/**
		 * A #GTlsInteraction object to be used when the connection or certificate
		 * database need to interact with the user. This will be used to prompt the
		 * user for passwords where necessary.
		 */
		interaction: TlsInteraction;
		/**
		 * The application-layer protocol negotiated during the TLS
		 * handshake. See {@link G.tls_connection_get_negotiated_protocol}.
		 */
		readonly negotiated_protocol: string;
		/**
		 * The connection's peer's certificate, after the TLS handshake has
		 * completed or failed. Note in particular that this is not yet set
		 * during the emission of #GTlsConnection::accept-certificate.
		 * 
		 * (You can watch for a #GObject::notify signal on this property to
		 * detect when a handshake has occurred.)
		 */
		readonly peer_certificate: TlsCertificate;
		/**
		 * The errors noticed while verifying
		 * #GTlsConnection:peer-certificate. Normally this should be 0, but
		 * it may not be if #GTlsClientConnection:validation-flags is not
		 * %G_TLS_CERTIFICATE_VALIDATE_ALL, or if
		 * #GTlsConnection::accept-certificate overrode the default
		 * behavior.
		 */
		readonly peer_certificate_errors: TlsCertificateFlags;
		/**
		 * The TLS protocol version in use. See {@link G.tls_connection_get_protocol_version}.
		 */
		readonly protocol_version: TlsProtocolVersion;
		/**
		 * @deprecated
		 * The rehandshake mode is ignored.
		 * 
		 * The rehandshaking mode. See
		 * {@link G.tls_connection_set_rehandshake_mode}.
		 */
		rehandshake_mode: TlsRehandshakeMode;
		/**
		 * Whether or not proper TLS close notification is required.
		 * See {@link G.tls_connection_set_require_close_notify}.
		 */
		require_close_notify: boolean;
		/**
		 * @deprecated
		 * Use GTlsConnection:database instead
		 * 
		 * Whether or not the system certificate database will be used to
		 * verify peer certificates. See
		 * {@link G.tls_connection_set_use_system_certdb}.
		 */
		use_system_certdb: boolean;
		/**
		 * Used by #GTlsConnection implementations to emit the
		 * #GTlsConnection::accept-certificate signal.
		 * @param peer_cert the peer's #GTlsCertificate
		 * @param errors the problems with #peer_cert
		 * @returns %TRUE if one of the signal handlers has returned
		 *     %TRUE to accept #peer_cert
		 */
		emit_accept_certificate(peer_cert: TlsCertificate, errors: TlsCertificateFlags): boolean;
		/**
		 * Gets #conn's certificate, as set by
		 * {@link G.tls_connection_set_certificate}.
		 * @returns #conn's certificate, or %NULL
		 */
		get_certificate(): TlsCertificate | null;
		/**
		 * Query the TLS backend for TLS channel binding data of #type for #conn.
		 * 
		 * This call retrieves TLS channel binding data as specified in RFC
		 * [5056](https://tools.ietf.org/html/rfc5056), RFC
		 * [5929](https://tools.ietf.org/html/rfc5929), and related RFCs.  The
		 * binding data is returned in #data.  The #data is resized by the callee
		 * using #GByteArray buffer management and will be freed when the #data
		 * is destroyed by {@link G.byte_array_unref}. If #data is %NULL, it will only
		 * check whether TLS backend is able to fetch the data (e.g. whether #type
		 * is supported by the TLS backend). It does not guarantee that the data
		 * will be available though.  That could happen if TLS connection does not
		 * support #type or the binding data is not available yet due to additional
		 * negotiation or input required.
		 * @param type #GTlsChannelBindingType type of data to fetch
		 * @returns %TRUE on success, %FALSE otherwise
		 * 
		 * #GByteArray is
		 *        filled with the binding data, or %NULL
		 */
		get_channel_binding_data(type: TlsChannelBindingType): [ boolean, number[] | null ];
		/**
		 * Returns the name of the current TLS ciphersuite, or %NULL if the
		 * connection has not handshaked or has been closed. Beware that the TLS
		 * backend may use any of multiple different naming conventions, because
		 * OpenSSL and GnuTLS have their own ciphersuite naming conventions that
		 * are different from each other and different from the standard, IANA-
		 * registered ciphersuite names. The ciphersuite name is intended to be
		 * displayed to the user for informative purposes only, and parsing it
		 * is not recommended.
		 * @returns The name of the current TLS ciphersuite, or %NULL
		 */
		get_ciphersuite_name(): string | null;
		/**
		 * Gets the certificate database that #conn uses to verify
		 * peer certificates. See {@link G.tls_connection_set_database}.
		 * @returns the certificate database that #conn uses or %NULL
		 */
		get_database(): TlsDatabase | null;
		/**
		 * Get the object that will be used to interact with the user. It will be used
		 * for things like prompting the user for passwords. If %NULL is returned, then
		 * no user interaction will occur for this connection.
		 * @returns The interaction object.
		 */
		get_interaction(): TlsInteraction | null;
		/**
		 * Gets the name of the application-layer protocol negotiated during
		 * the handshake.
		 * 
		 * If the peer did not use the ALPN extension, or did not advertise a
		 * protocol that matched one of #conn's protocols, or the TLS backend
		 * does not support ALPN, then this will be %NULL. See
		 * {@link G.tls_connection_set_advertised_protocols}.
		 * @returns the negotiated protocol, or %NULL
		 */
		get_negotiated_protocol(): string | null;
		/**
		 * Gets #conn's peer's certificate after the handshake has completed
		 * or failed. (It is not set during the emission of
		 * #GTlsConnection::accept-certificate.)
		 * @returns #conn's peer's certificate, or %NULL
		 */
		get_peer_certificate(): TlsCertificate | null;
		/**
		 * Gets the errors associated with validating #conn's peer's
		 * certificate, after the handshake has completed or failed. (It is
		 * not set during the emission of #GTlsConnection::accept-certificate.)
		 * @returns #conn's peer's certificate errors
		 */
		get_peer_certificate_errors(): TlsCertificateFlags;
		/**
		 * Returns the current TLS protocol version, which may be
		 * %G_TLS_PROTOCOL_VERSION_UNKNOWN if the connection has not handshaked, or
		 * has been closed, or if the TLS backend has implemented a protocol version
		 * that is not a recognized #GTlsProtocolVersion.
		 * @returns The current TLS protocol version
		 */
		get_protocol_version(): TlsProtocolVersion;
		/**
		 * @deprecated
		 * Changing the rehandshake mode is no longer
		 *   required for compatibility. Also, rehandshaking has been removed
		 *   from the TLS protocol in TLS 1.3.
		 * 
		 * Gets #conn rehandshaking mode. See
		 * {@link G.tls_connection_set_rehandshake_mode} for details.
		 * @returns %G_TLS_REHANDSHAKE_SAFELY
		 */
		get_rehandshake_mode(): TlsRehandshakeMode;
		/**
		 * Tests whether or not #conn expects a proper TLS close notification
		 * when the connection is closed. See
		 * {@link G.tls_connection_set_require_close_notify} for details.
		 * @returns %TRUE if #conn requires a proper TLS close
		 * notification.
		 */
		get_require_close_notify(): boolean;
		/**
		 * @deprecated
		 * Use {@link G.tls_connection_get_database} instead
		 * 
		 * Gets whether #conn uses the system certificate database to verify
		 * peer certificates. See {@link G.tls_connection_set_use_system_certdb}.
		 * @returns whether #conn uses the system certificate database
		 */
		get_use_system_certdb(): boolean;
		/**
		 * Attempts a TLS handshake on #conn.
		 * 
		 * On the client side, it is never necessary to call this method;
		 * although the connection needs to perform a handshake after
		 * connecting (or after sending a "STARTTLS"-type command),
		 * #GTlsConnection will handle this for you automatically when you try
		 * to send or receive data on the connection. You can call
		 * {@link G.tls_connection_handshake} manually if you want to know whether
		 * the initial handshake succeeded or failed (as opposed to just
		 * immediately trying to use #conn to read or write, in which case,
		 * if it fails, it may not be possible to tell if it failed before or
		 * after completing the handshake), but beware that servers may reject
		 * client authentication after the handshake has completed, so a
		 * successful handshake does not indicate the connection will be usable.
		 * 
		 * Likewise, on the server side, although a handshake is necessary at
		 * the beginning of the communication, you do not need to call this
		 * function explicitly unless you want clearer error reporting.
		 * 
		 * Previously, calling g_tls_connection_handshake() after the initial
		 * handshake would trigger a rehandshake; however, this usage was
		 * deprecated in GLib 2.60 because rehandshaking was removed from the
		 * TLS protocol in TLS 1.3. Since GLib 2.64, calling this function after
		 * the initial handshake will no longer do anything.
		 * 
		 * When using a #GTlsConnection created by #GSocketClient, the
		 * #GSocketClient performs the initial handshake, so calling this
		 * function manually is not recommended.
		 * 
		 * #GTlsConnection::accept_certificate may be emitted during the
		 * handshake.
		 * @param cancellable a #GCancellable, or %NULL
		 * @returns success or failure
		 */
		handshake(cancellable?: Cancellable | null): boolean;
		/**
		 * Asynchronously performs a TLS handshake on #conn. See
		 * {@link G.tls_connection_handshake} for more information.
		 * @param io_priority the [I/O priority][io-priority] of the request
		 * @param cancellable a #GCancellable, or %NULL
		 * @param callback callback to call when the handshake is complete
		 */
		handshake_async(io_priority: number, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;
		/**
		 * Finish an asynchronous TLS handshake operation. See
		 * {@link G.tls_connection_handshake} for more information.
		 * @param result a #GAsyncResult.
		 * @returns %TRUE on success, %FALSE on failure, in which
		 * case #error will be set.
		 */
		handshake_finish(result: AsyncResult): boolean;
		/**
		 * Sets the list of application-layer protocols to advertise that the
		 * caller is willing to speak on this connection. The
		 * Application-Layer Protocol Negotiation (ALPN) extension will be
		 * used to negotiate a compatible protocol with the peer; use
		 * {@link G.tls_connection_get_negotiated_protocol} to find the negotiated
		 * protocol after the handshake.  Specifying %NULL for the the value
		 * of #protocols will disable ALPN negotiation.
		 * 
		 * See [IANA TLS ALPN Protocol IDs](https://www.iana.org/assignments/tls-extensiontype-values/tls-extensiontype-values.xhtml#alpn-protocol-ids)
		 * for a list of registered protocol IDs.
		 * @param protocols a %NULL-terminated
		 *   array of ALPN protocol names (eg, "http/1.1", "h2"), or %NULL
		 */
		set_advertised_protocols(protocols?: string[] | null): void;
		/**
		 * This sets the certificate that #conn will present to its peer
		 * during the TLS handshake. For a #GTlsServerConnection, it is
		 * mandatory to set this, and that will normally be done at construct
		 * time.
		 * 
		 * For a #GTlsClientConnection, this is optional. If a handshake fails
		 * with %G_TLS_ERROR_CERTIFICATE_REQUIRED, that means that the server
		 * requires a certificate, and if you try connecting again, you should
		 * call this method first. You can call
		 * {@link G.tls_client_connection_get_accepted_cas} on the failed connection
		 * to get a list of Certificate Authorities that the server will
		 * accept certificates from.
		 * 
		 * (It is also possible that a server will allow the connection with
		 * or without a certificate; in that case, if you don't provide a
		 * certificate, you can tell that the server requested one by the fact
		 * that g_tls_client_connection_get_accepted_cas() will return
		 * non-%NULL.)
		 * @param certificate the certificate to use for #conn
		 */
		set_certificate(certificate: TlsCertificate): void;
		/**
		 * Sets the certificate database that is used to verify peer certificates.
		 * This is set to the default database by default. See
		 * {@link G.tls_backend_get_default_database}. If set to %NULL, then
		 * peer certificate validation will always set the
		 * %G_TLS_CERTIFICATE_UNKNOWN_CA error (meaning
		 * #GTlsConnection::accept-certificate will always be emitted on
		 * client-side connections, unless that bit is not set in
		 * #GTlsClientConnection:validation-flags).
		 * @param database a #GTlsDatabase
		 */
		set_database(database?: TlsDatabase | null): void;
		/**
		 * Set the object that will be used to interact with the user. It will be used
		 * for things like prompting the user for passwords.
		 * 
		 * The #interaction argument will normally be a derived subclass of
		 * #GTlsInteraction. %NULL can also be provided if no user interaction
		 * should occur for this connection.
		 * @param interaction an interaction object, or %NULL
		 */
		set_interaction(interaction?: TlsInteraction | null): void;
		/**
		 * @deprecated
		 * Changing the rehandshake mode is no longer
		 *   required for compatibility. Also, rehandshaking has been removed
		 *   from the TLS protocol in TLS 1.3.
		 * 
		 * Since GLib 2.64, changing the rehandshake mode is no longer supported
		 * and will have no effect. With TLS 1.3, rehandshaking has been removed from
		 * the TLS protocol, replaced by separate post-handshake authentication and
		 * rekey operations.
		 * @param mode the rehandshaking mode
		 */
		set_rehandshake_mode(mode: TlsRehandshakeMode): void;
		/**
		 * Sets whether or not #conn expects a proper TLS close notification
		 * before the connection is closed. If this is %TRUE (the default),
		 * then #conn will expect to receive a TLS close notification from its
		 * peer before the connection is closed, and will return a
		 * %G_TLS_ERROR_EOF error if the connection is closed without proper
		 * notification (since this may indicate a network error, or
		 * man-in-the-middle attack).
		 * 
		 * In some protocols, the application will know whether or not the
		 * connection was closed cleanly based on application-level data
		 * (because the application-level data includes a length field, or is
		 * somehow self-delimiting); in this case, the close notify is
		 * redundant and sometimes omitted. (TLS 1.1 explicitly allows this;
		 * in TLS 1.0 it is technically an error, but often done anyway.) You
		 * can use {@link G.tls_connection_set_require_close_notify} to tell #conn
		 * to allow an "unannounced" connection close, in which case the close
		 * will show up as a 0-length read, as in a non-TLS
		 * #GSocketConnection, and it is up to the application to check that
		 * the data has been fully received.
		 * 
		 * Note that this only affects the behavior when the peer closes the
		 * connection; when the application calls g_io_stream_close() itself
		 * on #conn, this will send a close notification regardless of the
		 * setting of this property. If you explicitly want to do an unclean
		 * close, you can close #conn's #GTlsConnection:base-io-stream rather
		 * than closing #conn itself, but note that this may only be done when no other
		 * operations are pending on #conn or the base I/O stream.
		 * @param require_close_notify whether or not to require close notification
		 */
		set_require_close_notify(require_close_notify: boolean): void;
		/**
		 * @deprecated
		 * Use {@link G.tls_connection_set_database} instead
		 * 
		 * Sets whether #conn uses the system certificate database to verify
		 * peer certificates. This is %TRUE by default. If set to %FALSE, then
		 * peer certificate validation will always set the
		 * %G_TLS_CERTIFICATE_UNKNOWN_CA error (meaning
		 * #GTlsConnection::accept-certificate will always be emitted on
		 * client-side connections, unless that bit is not set in
		 * #GTlsClientConnection:validation-flags).
		 * @param use_system_certdb whether to use the system certificate database
		 */
		set_use_system_certdb(use_system_certdb: boolean): void;
		/**
		 * Emitted during the TLS handshake after the peer certificate has
		 * been received. You can examine #peer_cert's certification path by
		 * calling {@link G.tls_certificate_get_issuer} on it.
		 * 
		 * For a client-side connection, #peer_cert is the server's
		 * certificate, and the signal will only be emitted if the
		 * certificate was not acceptable according to #conn's
		 * #GTlsClientConnection:validation_flags. If you would like the
		 * certificate to be accepted despite #errors, return %TRUE from the
		 * signal handler. Otherwise, if no handler accepts the certificate,
		 * the handshake will fail with %G_TLS_ERROR_BAD_CERTIFICATE.
		 * 
		 * For a server-side connection, #peer_cert is the certificate
		 * presented by the client, if this was requested via the server's
		 * #GTlsServerConnection:authentication_mode. On the server side,
		 * the signal is always emitted when the client presents a
		 * certificate, and the certificate will only be accepted if a
		 * handler returns %TRUE.
		 * 
		 * Note that if this signal is emitted as part of asynchronous I/O
		 * in the main thread, then you should not attempt to interact with
		 * the user before returning from the signal handler. If you want to
		 * let the user decide whether or not to accept the certificate, you
		 * would have to return %FALSE from the signal handler on the first
		 * attempt, and then after the connection attempt returns a
		 * %G_TLS_ERROR_BAD_CERTIFICATE, you can interact with the user, and
		 * if the user decides to accept the certificate, remember that fact,
		 * create a new connection, and return %TRUE from the signal handler
		 * the next time.
		 * 
		 * If you are doing I/O in another thread, you do not
		 * need to worry about this, and can simply block in the signal
		 * handler until the UI thread returns an answer.
		 * @param signal 
		 * @param callback Callback function
		 *  - owner: owner of the emitted event 
		 *  - peer_cert: the peer's #GTlsCertificate 
		 *  - errors: the problems with #peer_cert. 
		 *  - returns %TRUE to accept #peer_cert (which will also
		 * immediately end the signal emission). %FALSE to allow the signal
		 * emission to continue, which will cause the handshake to fail if
		 * no one else overrides it. 
		 * 
		 * @returns Callback ID
		 */
		connect(signal: "accept-certificate", callback: (owner: this, peer_cert: TlsCertificate, errors: TlsCertificateFlags) => boolean): number;

		connect(signal: "notify::advertised-protocols", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::base-io-stream", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::certificate", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::ciphersuite-name", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::database", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::interaction", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::negotiated-protocol", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::peer-certificate", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::peer-certificate-errors", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::protocol-version", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::rehandshake-mode", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::require-close-notify", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::use-system-certdb", callback: (owner: this, ...args: any) => void): number;

	}

	type TlsConnectionInitOptionsMixin = IOStreamInitOptions & 
	Pick<ITlsConnection,
		"advertised_protocols" |
		"base_io_stream" |
		"certificate" |
		"database" |
		"interaction" |
		"rehandshake_mode" |
		"require_close_notify" |
		"use_system_certdb">;

	export interface TlsConnectionInitOptions extends TlsConnectionInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link TlsConnection} instead.
	 */
	type TlsConnectionMixin = ITlsConnection & IOStream;

	/**
	 * #GTlsConnection is the base TLS connection class type, which wraps
	 * a #GIOStream and provides TLS encryption on top of it. Its
	 * subclasses, #GTlsClientConnection and #GTlsServerConnection,
	 * implement client-side and server-side TLS, respectively.
	 * 
	 * For DTLS (Datagram TLS) support, see #GDtlsConnection.
	 */
	interface TlsConnection extends TlsConnectionMixin {}

	class TlsConnection {
		public constructor(options?: Partial<TlsConnectionInitOptions>);
	}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link TlsDatabase} instead.
	 */
	interface ITlsDatabase {
		/**
		 * Create a handle string for the certificate. The database will only be able
		 * to create a handle for certificates that originate from the database. In
		 * cases where the database cannot create a handle for a certificate, %NULL
		 * will be returned.
		 * 
		 * This handle should be stable across various instances of the application,
		 * and between applications. If a certificate is modified in the database,
		 * then it is not guaranteed that this handle will continue to point to it.
		 * @param certificate certificate for which to create a handle.
		 * @returns a newly allocated string containing the
		 * handle.
		 */
		create_certificate_handle(certificate: TlsCertificate): string | null;
		/**
		 * Look up a certificate by its handle.
		 * 
		 * The handle should have been created by calling
		 * {@link G.tls_database_create_certificate_handle} on a #GTlsDatabase object of
		 * the same TLS backend. The handle is designed to remain valid across
		 * instantiations of the database.
		 * 
		 * If the handle is no longer valid, or does not point to a certificate in
		 * this database, then %NULL will be returned.
		 * 
		 * This function can block, use g_tls_database_lookup_certificate_for_handle_async() to perform
		 * the lookup operation asynchronously.
		 * @param handle a certificate handle
		 * @param interaction used to interact with the user if necessary
		 * @param flags Flags which affect the lookup.
		 * @param cancellable a #GCancellable, or %NULL
		 * @returns a newly allocated
		 * #GTlsCertificate, or %NULL. Use {@link GObject.unref} to release the certificate.
		 */
		lookup_certificate_for_handle(handle: string, interaction: TlsInteraction | null, flags: TlsDatabaseLookupFlags, cancellable?: Cancellable | null): TlsCertificate | null;
		/**
		 * Asynchronously look up a certificate by its handle in the database. See
		 * {@link G.tls_database_lookup_certificate_for_handle} for more information.
		 * @param handle a certificate handle
		 * @param interaction used to interact with the user if necessary
		 * @param flags Flags which affect the lookup.
		 * @param cancellable a #GCancellable, or %NULL
		 * @param callback callback to call when the operation completes
		 */
		lookup_certificate_for_handle_async(handle: string, interaction: TlsInteraction | null, flags: TlsDatabaseLookupFlags, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;
		/**
		 * Finish an asynchronous lookup of a certificate by its handle. See
		 * {@link G.tls_database_lookup_certificate_for_handle} for more information.
		 * 
		 * If the handle is no longer valid, or does not point to a certificate in
		 * this database, then %NULL will be returned.
		 * @param result a #GAsyncResult.
		 * @returns a newly allocated #GTlsCertificate object.
		 * Use {@link GObject.unref} to release the certificate.
		 */
		lookup_certificate_for_handle_finish(result: AsyncResult): TlsCertificate;
		/**
		 * Look up the issuer of #certificate in the database. The
		 * #GTlsCertificate:issuer property of #certificate is not modified, and
		 * the two certificates are not hooked into a chain.
		 * 
		 * This function can block. Use {@link G.tls_database_lookup_certificate_issuer_async}
		 * to perform the lookup operation asynchronously.
		 * 
		 * Beware this function cannot be used to build certification paths. The
		 * issuer certificate returned by this function may not be the same as
		 * the certificate that would actually be used to construct a valid
		 * certification path during certificate verification.
		 * [RFC 4158](https://datatracker.ietf.org/doc/html/rfc4158) explains
		 * why an issuer certificate cannot be naively assumed to be part of the
		 * the certification path (though GLib's TLS backends may not follow the
		 * path building strategies outlined in this RFC). Due to the complexity
		 * of certification path building, GLib does not provide any way to know
		 * which certification path will actually be used when verifying a TLS
		 * certificate. Accordingly, this function cannot be used to make
		 * security-related decisions. Only GLib itself should make security
		 * decisions about TLS certificates.
		 * @param certificate a #GTlsCertificate
		 * @param interaction used to interact with the user if necessary
		 * @param flags flags which affect the lookup operation
		 * @param cancellable a #GCancellable, or %NULL
		 * @returns a newly allocated issuer #GTlsCertificate,
		 * or %NULL. Use {@link GObject.unref} to release the certificate.
		 */
		lookup_certificate_issuer(certificate: TlsCertificate, interaction: TlsInteraction | null, flags: TlsDatabaseLookupFlags, cancellable?: Cancellable | null): TlsCertificate;
		/**
		 * Asynchronously look up the issuer of #certificate in the database. See
		 * {@link G.tls_database_lookup_certificate_issuer} for more information.
		 * @param certificate a #GTlsCertificate
		 * @param interaction used to interact with the user if necessary
		 * @param flags flags which affect the lookup operation
		 * @param cancellable a #GCancellable, or %NULL
		 * @param callback callback to call when the operation completes
		 */
		lookup_certificate_issuer_async(certificate: TlsCertificate, interaction: TlsInteraction | null, flags: TlsDatabaseLookupFlags, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;
		/**
		 * Finish an asynchronous lookup issuer operation. See
		 * {@link G.tls_database_lookup_certificate_issuer} for more information.
		 * @param result a #GAsyncResult.
		 * @returns a newly allocated issuer #GTlsCertificate,
		 * or %NULL. Use {@link GObject.unref} to release the certificate.
		 */
		lookup_certificate_issuer_finish(result: AsyncResult): TlsCertificate;
		/**
		 * Look up certificates issued by this issuer in the database.
		 * 
		 * This function can block, use {@link G.tls_database_lookup_certificates_issued_by_async} to perform
		 * the lookup operation asynchronously.
		 * @param issuer_raw_dn a #GByteArray which holds the DER encoded issuer DN.
		 * @param interaction used to interact with the user if necessary
		 * @param flags Flags which affect the lookup operation.
		 * @param cancellable a #GCancellable, or %NULL
		 * @returns a newly allocated list of #GTlsCertificate
		 * objects. Use {@link GObject.unref} on each certificate, and g_list_free() on the release the list.
		 */
		lookup_certificates_issued_by(issuer_raw_dn: number[], interaction: TlsInteraction | null, flags: TlsDatabaseLookupFlags, cancellable?: Cancellable | null): TlsCertificate[];
		/**
		 * Asynchronously look up certificates issued by this issuer in the database. See
		 * {@link G.tls_database_lookup_certificates_issued_by} for more information.
		 * 
		 * The database may choose to hold a reference to the issuer byte array for the duration
		 * of of this asynchronous operation. The byte array should not be modified during
		 * this time.
		 * @param issuer_raw_dn a #GByteArray which holds the DER encoded issuer DN.
		 * @param interaction used to interact with the user if necessary
		 * @param flags Flags which affect the lookup operation.
		 * @param cancellable a #GCancellable, or %NULL
		 * @param callback callback to call when the operation completes
		 */
		lookup_certificates_issued_by_async(issuer_raw_dn: number[], interaction: TlsInteraction | null, flags: TlsDatabaseLookupFlags, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;
		/**
		 * Finish an asynchronous lookup of certificates. See
		 * {@link G.tls_database_lookup_certificates_issued_by} for more information.
		 * @param result a #GAsyncResult.
		 * @returns a newly allocated list of #GTlsCertificate
		 * objects. Use {@link GObject.unref} on each certificate, and g_list_free() on the release the list.
		 */
		lookup_certificates_issued_by_finish(result: AsyncResult): TlsCertificate[];
		/**
		 * Determines the validity of a certificate chain, outside the context
		 * of a TLS session.
		 * 
		 * #chain is a chain of #GTlsCertificate objects each pointing to the next
		 * certificate in the chain by its #GTlsCertificate:issuer property.
		 * 
		 * #purpose describes the purpose (or usage) for which the certificate
		 * is being used. Typically #purpose will be set to #G_TLS_DATABASE_PURPOSE_AUTHENTICATE_SERVER
		 * which means that the certificate is being used to authenticate a server
		 * (and we are acting as the client).
		 * 
		 * The #identity is used to ensure the server certificate is valid for
		 * the expected peer identity. If the identity does not match the
		 * certificate, %G_TLS_CERTIFICATE_BAD_IDENTITY will be set in the
		 * return value. If #identity is %NULL, that bit will never be set in
		 * the return value. The peer identity may also be used to check for
		 * pinned certificates (trust exceptions) in the database. These may
		 * override the normal verification process on a host-by-host basis.
		 * 
		 * Currently there are no #flags, and %G_TLS_DATABASE_VERIFY_NONE should be
		 * used.
		 * 
		 * If #chain is found to be valid, then the return value will be 0. If
		 * #chain is found to be invalid, then the return value will indicate
		 * the problems found. If the function is unable to determine whether
		 * #chain is valid or not (eg, because #cancellable is triggered
		 * before it completes) then the return value will be
		 * %G_TLS_CERTIFICATE_GENERIC_ERROR and #error will be set
		 * accordingly. #error is not set when #chain is successfully analyzed
		 * but found to be invalid.
		 * 
		 * Prior to GLib 2.48, GLib's default TLS backend modified #chain to
		 * represent the certification path built by #GTlsDatabase during
		 * certificate verification by adjusting the #GTlsCertificate:issuer
		 * property of each certificate in #chain. Since GLib 2.48, this no
		 * longer occurs, so you cannot rely on #GTlsCertificate:issuer to
		 * represent the actual certification path used during certificate
		 * verification.
		 * 
		 * Because TLS session context is not used, #GTlsDatabase may not
		 * perform as many checks on the certificates as #GTlsConnection would.
		 * For example, certificate constraints cannot be honored, and some
		 * revocation checks cannot be performed. The best way to verify TLS
		 * certificates used by a TLS connection is to let #GTlsConnection
		 * handle the verification.
		 * 
		 * The TLS backend may attempt to look up and add missing certificates
		 * to the chain. Since GLib 2.70, this may involve HTTP requests to
		 * download missing certificates.
		 * 
		 * This function can block. Use {@link G.tls_database_verify_chain_async} to
		 * perform the verification operation asynchronously.
		 * @param chain a #GTlsCertificate chain
		 * @param purpose the purpose that this certificate chain will be used for.
		 * @param identity the expected peer identity
		 * @param interaction used to interact with the user if necessary
		 * @param flags additional verify flags
		 * @param cancellable a #GCancellable, or %NULL
		 * @returns the appropriate #GTlsCertificateFlags which represents the
		 * result of verification.
		 */
		verify_chain(chain: TlsCertificate, purpose: string, identity: SocketConnectable | null, interaction: TlsInteraction | null, flags: TlsDatabaseVerifyFlags, cancellable?: Cancellable | null): TlsCertificateFlags;
		/**
		 * Asynchronously determines the validity of a certificate chain after
		 * looking up and adding any missing certificates to the chain. See
		 * {@link G.tls_database_verify_chain} for more information.
		 * @param chain a #GTlsCertificate chain
		 * @param purpose the purpose that this certificate chain will be used for.
		 * @param identity the expected peer identity
		 * @param interaction used to interact with the user if necessary
		 * @param flags additional verify flags
		 * @param cancellable a #GCancellable, or %NULL
		 * @param callback callback to call when the operation completes
		 */
		verify_chain_async(chain: TlsCertificate, purpose: string, identity: SocketConnectable | null, interaction: TlsInteraction | null, flags: TlsDatabaseVerifyFlags, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;
		/**
		 * Finish an asynchronous verify chain operation. See
		 * {@link G.tls_database_verify_chain} for more information.
		 * 
		 * If #chain is found to be valid, then the return value will be 0. If
		 * #chain is found to be invalid, then the return value will indicate
		 * the problems found. If the function is unable to determine whether
		 * #chain is valid or not (eg, because #cancellable is triggered
		 * before it completes) then the return value will be
		 * %G_TLS_CERTIFICATE_GENERIC_ERROR and #error will be set
		 * accordingly. #error is not set when #chain is successfully analyzed
		 * but found to be invalid.
		 * @param result a #GAsyncResult.
		 * @returns the appropriate #GTlsCertificateFlags which represents the
		 * result of verification.
		 */
		verify_chain_finish(result: AsyncResult): TlsCertificateFlags;
	}

	type TlsDatabaseInitOptionsMixin = GObject.ObjectInitOptions
	export interface TlsDatabaseInitOptions extends TlsDatabaseInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link TlsDatabase} instead.
	 */
	type TlsDatabaseMixin = ITlsDatabase & GObject.Object;

	/**
	 * #GTlsDatabase is used to look up certificates and other information
	 * from a certificate or key store. It is an abstract base class which
	 * TLS library specific subtypes override.
	 * 
	 * A #GTlsDatabase may be accessed from multiple threads by the TLS backend.
	 * All implementations are required to be fully thread-safe.
	 * 
	 * Most common client applications will not directly interact with
	 * #GTlsDatabase. It is used internally by #GTlsConnection.
	 */
	interface TlsDatabase extends TlsDatabaseMixin {}

	class TlsDatabase {
		public constructor(options?: Partial<TlsDatabaseInitOptions>);
	}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link TlsInteraction} instead.
	 */
	interface ITlsInteraction {
		/**
		 * Run synchronous interaction to ask the user for a password. In general,
		 * {@link G.tls_interaction_invoke_ask_password} should be used instead of this
		 * function.
		 * 
		 * Derived subclasses usually implement a password prompt, although they may
		 * also choose to provide a password from elsewhere. The #password value will
		 * be filled in and then #callback will be called. Alternatively the user may
		 * abort this password request, which will usually abort the TLS connection.
		 * 
		 * If the interaction is cancelled by the cancellation object, or by the
		 * user then %G_TLS_INTERACTION_FAILED will be returned with an error that
		 * contains a %G_IO_ERROR_CANCELLED error code. Certain implementations may
		 * not support immediate cancellation.
		 * @param password a #GTlsPassword object
		 * @param cancellable an optional #GCancellable cancellation object
		 * @returns The status of the ask password interaction.
		 */
		ask_password(password: TlsPassword, cancellable?: Cancellable | null): TlsInteractionResult;
		/**
		 * Run asynchronous interaction to ask the user for a password. In general,
		 * {@link G.tls_interaction_invoke_ask_password} should be used instead of this
		 * function.
		 * 
		 * Derived subclasses usually implement a password prompt, although they may
		 * also choose to provide a password from elsewhere. The #password value will
		 * be filled in and then #callback will be called. Alternatively the user may
		 * abort this password request, which will usually abort the TLS connection.
		 * 
		 * If the interaction is cancelled by the cancellation object, or by the
		 * user then %G_TLS_INTERACTION_FAILED will be returned with an error that
		 * contains a %G_IO_ERROR_CANCELLED error code. Certain implementations may
		 * not support immediate cancellation.
		 * 
		 * Certain implementations may not support immediate cancellation.
		 * @param password a #GTlsPassword object
		 * @param cancellable an optional #GCancellable cancellation object
		 * @param callback will be called when the interaction completes
		 */
		ask_password_async(password: TlsPassword, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;
		/**
		 * Complete an ask password user interaction request. This should be once
		 * the {@link G.tls_interaction_ask_password_async} completion callback is called.
		 * 
		 * If %G_TLS_INTERACTION_HANDLED is returned, then the #GTlsPassword passed
		 * to g_tls_interaction_ask_password() will have its password filled in.
		 * 
		 * If the interaction is cancelled by the cancellation object, or by the
		 * user then %G_TLS_INTERACTION_FAILED will be returned with an error that
		 * contains a %G_IO_ERROR_CANCELLED error code.
		 * @param result the result passed to the callback
		 * @returns The status of the ask password interaction.
		 */
		ask_password_finish(result: AsyncResult): TlsInteractionResult;
		/**
		 * Invoke the interaction to ask the user for a password. It invokes this
		 * interaction in the main loop, specifically the #GMainContext returned by
		 * {@link G.main_context_get_thread_default} when the interaction is created. This
		 * is called by called by #GTlsConnection or #GTlsDatabase to ask the user
		 * for a password.
		 * 
		 * Derived subclasses usually implement a password prompt, although they may
		 * also choose to provide a password from elsewhere. The #password value will
		 * be filled in and then #callback will be called. Alternatively the user may
		 * abort this password request, which will usually abort the TLS connection.
		 * 
		 * The implementation can either be a synchronous (eg: modal dialog) or an
		 * asynchronous one (eg: modeless dialog). This function will take care of
		 * calling which ever one correctly.
		 * 
		 * If the interaction is cancelled by the cancellation object, or by the
		 * user then %G_TLS_INTERACTION_FAILED will be returned with an error that
		 * contains a %G_IO_ERROR_CANCELLED error code. Certain implementations may
		 * not support immediate cancellation.
		 * @param password a #GTlsPassword object
		 * @param cancellable an optional #GCancellable cancellation object
		 * @returns The status of the ask password interaction.
		 */
		invoke_ask_password(password: TlsPassword, cancellable?: Cancellable | null): TlsInteractionResult;
		/**
		 * Invoke the interaction to ask the user to choose a certificate to
		 * use with the connection. It invokes this interaction in the main
		 * loop, specifically the #GMainContext returned by
		 * {@link G.main_context_get_thread_default} when the interaction is
		 * created. This is called by called by #GTlsConnection when the peer
		 * requests a certificate during the handshake.
		 * 
		 * Derived subclasses usually implement a certificate selector,
		 * although they may also choose to provide a certificate from
		 * elsewhere. Alternatively the user may abort this certificate
		 * request, which may or may not abort the TLS connection.
		 * 
		 * The implementation can either be a synchronous (eg: modal dialog) or an
		 * asynchronous one (eg: modeless dialog). This function will take care of
		 * calling which ever one correctly.
		 * 
		 * If the interaction is cancelled by the cancellation object, or by the
		 * user then %G_TLS_INTERACTION_FAILED will be returned with an error that
		 * contains a %G_IO_ERROR_CANCELLED error code. Certain implementations may
		 * not support immediate cancellation.
		 * @param connection a #GTlsConnection object
		 * @param flags flags providing more information about the request
		 * @param cancellable an optional #GCancellable cancellation object
		 * @returns The status of the certificate request interaction.
		 */
		invoke_request_certificate(connection: TlsConnection, flags: TlsCertificateRequestFlags, cancellable?: Cancellable | null): TlsInteractionResult;
		/**
		 * Run synchronous interaction to ask the user to choose a certificate to use
		 * with the connection. In general, {@link G.tls_interaction_invoke_request_certificate}
		 * should be used instead of this function.
		 * 
		 * Derived subclasses usually implement a certificate selector, although they may
		 * also choose to provide a certificate from elsewhere. Alternatively the user may
		 * abort this certificate request, which will usually abort the TLS connection.
		 * 
		 * If %G_TLS_INTERACTION_HANDLED is returned, then the #GTlsConnection
		 * passed to g_tls_interaction_request_certificate() will have had its
		 * #GTlsConnection:certificate filled in.
		 * 
		 * If the interaction is cancelled by the cancellation object, or by the
		 * user then %G_TLS_INTERACTION_FAILED will be returned with an error that
		 * contains a %G_IO_ERROR_CANCELLED error code. Certain implementations may
		 * not support immediate cancellation.
		 * @param connection a #GTlsConnection object
		 * @param flags flags providing more information about the request
		 * @param cancellable an optional #GCancellable cancellation object
		 * @returns The status of the request certificate interaction.
		 */
		request_certificate(connection: TlsConnection, flags: TlsCertificateRequestFlags, cancellable?: Cancellable | null): TlsInteractionResult;
		/**
		 * Run asynchronous interaction to ask the user for a certificate to use with
		 * the connection. In general, {@link G.tls_interaction_invoke_request_certificate} should
		 * be used instead of this function.
		 * 
		 * Derived subclasses usually implement a certificate selector, although they may
		 * also choose to provide a certificate from elsewhere. #callback will be called
		 * when the operation completes. Alternatively the user may abort this certificate
		 * request, which will usually abort the TLS connection.
		 * @param connection a #GTlsConnection object
		 * @param flags flags providing more information about the request
		 * @param cancellable an optional #GCancellable cancellation object
		 * @param callback will be called when the interaction completes
		 */
		request_certificate_async(connection: TlsConnection, flags: TlsCertificateRequestFlags, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;
		/**
		 * Complete a request certificate user interaction request. This should be once
		 * the {@link G.tls_interaction_request_certificate_async} completion callback is called.
		 * 
		 * If %G_TLS_INTERACTION_HANDLED is returned, then the #GTlsConnection
		 * passed to g_tls_interaction_request_certificate_async() will have had its
		 * #GTlsConnection:certificate filled in.
		 * 
		 * If the interaction is cancelled by the cancellation object, or by the
		 * user then %G_TLS_INTERACTION_FAILED will be returned with an error that
		 * contains a %G_IO_ERROR_CANCELLED error code.
		 * @param result the result passed to the callback
		 * @returns The status of the request certificate interaction.
		 */
		request_certificate_finish(result: AsyncResult): TlsInteractionResult;
	}

	type TlsInteractionInitOptionsMixin = GObject.ObjectInitOptions
	export interface TlsInteractionInitOptions extends TlsInteractionInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link TlsInteraction} instead.
	 */
	type TlsInteractionMixin = ITlsInteraction & GObject.Object;

	/**
	 * #GTlsInteraction provides a mechanism for the TLS connection and database
	 * code to interact with the user. It can be used to ask the user for passwords.
	 * 
	 * To use a #GTlsInteraction with a TLS connection use
	 * {@link G.tls_connection_set_interaction}.
	 * 
	 * Callers should instantiate a derived class that implements the various
	 * interaction methods to show the required dialogs.
	 * 
	 * Callers should use the 'invoke' functions like
	 * g_tls_interaction_invoke_ask_password() to run interaction methods. These
	 * functions make sure that the interaction is invoked in the main loop
	 * and not in the current thread, if the current thread is not running the
	 * main loop.
	 * 
	 * Derived classes can choose to implement whichever interactions methods they'd
	 * like to support by overriding those virtual methods in their class
	 * initialization function. Any interactions not implemented will return
	 * %G_TLS_INTERACTION_UNHANDLED. If a derived class implements an async method,
	 * it must also implement the corresponding finish method.
	 */
	interface TlsInteraction extends TlsInteractionMixin {}

	class TlsInteraction {
		public constructor(options?: Partial<TlsInteractionInitOptions>);
	}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link TlsPassword} instead.
	 */
	interface ITlsPassword {
		description: string;
		flags: TlsPasswordFlags;
		warning: string;
		/**
		 * Get a description string about what the password will be used for.
		 * @returns The description of the password.
		 */
		get_description(): string;
		/**
		 * Get flags about the password.
		 * @returns The flags about the password.
		 */
		get_flags(): TlsPasswordFlags;
		/**
		 * Get the password value. If #length is not %NULL then it will be
		 * filled in with the length of the password value. (Note that the
		 * password value is not nul-terminated, so you can only pass %NULL
		 * for #length in contexts where you know the password will have a
		 * certain fixed length.)
		 * @returns The password value (owned by the password object).
		 * 
		 * location to place the length of the password.
		 */
		get_value(): [ number[], number ];
		/**
		 * Get a user readable translated warning. Usually this warning is a
		 * representation of the password flags returned from
		 * {@link G.tls_password_get_flags}.
		 * @returns The warning.
		 */
		get_warning(): string;
		/**
		 * Set a description string about what the password will be used for.
		 * @param description The description of the password
		 */
		set_description(description: string): void;
		/**
		 * Set flags about the password.
		 * @param flags The flags about the password
		 */
		set_flags(flags: TlsPasswordFlags): void;
		/**
		 * Set the value for this password. The #value will be copied by the password
		 * object.
		 * 
		 * Specify the #length, for a non-nul-terminated password. Pass -1 as
		 * #length if using a nul-terminated password, and #length will be
		 * calculated automatically. (Note that the terminating nul is not
		 * considered part of the password in this case.)
		 * @param value the new password value
		 */
		set_value(value: number[]): void;
		/**
		 * Provide the value for this password.
		 * 
		 * The #value will be owned by the password object, and later freed using
		 * the #destroy function callback.
		 * 
		 * Specify the #length, for a non-nul-terminated password. Pass -1 as
		 * #length if using a nul-terminated password, and #length will be
		 * calculated automatically. (Note that the terminating nul is not
		 * considered part of the password in this case.)
		 * @param value the value for the password
		 */
		set_value_full(value: number[]): void;
		/**
		 * Set a user readable translated warning. Usually this warning is a
		 * representation of the password flags returned from
		 * {@link G.tls_password_get_flags}.
		 * @param warning The user readable warning
		 */
		set_warning(warning: string): void;
		connect(signal: "notify::description", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::flags", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::warning", callback: (owner: this, ...args: any) => void): number;

	}

	type TlsPasswordInitOptionsMixin = GObject.ObjectInitOptions & 
	Pick<ITlsPassword,
		"description" |
		"flags" |
		"warning">;

	export interface TlsPasswordInitOptions extends TlsPasswordInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link TlsPassword} instead.
	 */
	type TlsPasswordMixin = ITlsPassword & GObject.Object;

	/**
	 * Holds a password used in TLS.
	 */
	interface TlsPassword extends TlsPasswordMixin {}

	class TlsPassword {
		public constructor(options?: Partial<TlsPasswordInitOptions>);
		/**
		 * Create a new #GTlsPassword object.
		 * @param flags the password flags
		 * @param description description of what the password is for
		 * @returns The newly allocated password object
		 */
		public static new(flags: TlsPasswordFlags, description: string): TlsPassword;
	}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link UnixConnection} instead.
	 */
	interface IUnixConnection {
		/**
		 * Receives credentials from the sending end of the connection.  The
		 * sending end has to call {@link G.unix_connection_send_credentials} (or
		 * similar) for this to work.
		 * 
		 * As well as reading the credentials this also reads (and discards) a
		 * single byte from the stream, as this is required for credentials
		 * passing to work on some implementations.
		 * 
		 * This method can be expected to be available on the following platforms:
		 * 
		 * - Linux since GLib 2.26
		 * - FreeBSD since GLib 2.26
		 * - GNU/kFreeBSD since GLib 2.36
		 * - Solaris, Illumos and OpenSolaris since GLib 2.40
		 * - GNU/Hurd since GLib 2.40
		 * 
		 * Other ways to exchange credentials with a foreign peer includes the
		 * #GUnixCredentialsMessage type and g_socket_get_credentials() function.
		 * @param cancellable A #GCancellable or %NULL.
		 * @returns Received credentials on success (free with
		 * {@link GObject.unref}), %NULL if #error is set.
		 */
		receive_credentials(cancellable?: Cancellable | null): Credentials;
		/**
		 * Asynchronously receive credentials.
		 * 
		 * For more details, see {@link G.unix_connection_receive_credentials} which is
		 * the synchronous version of this call.
		 * 
		 * When the operation is finished, #callback will be called. You can then call
		 * g_unix_connection_receive_credentials_finish() to get the result of the operation.
		 * @param cancellable optional #GCancellable object, %NULL to ignore.
		 * @param callback a #GAsyncReadyCallback to call when the request is satisfied
		 */
		receive_credentials_async(cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;
		/**
		 * Finishes an asynchronous receive credentials operation started with
		 * {@link G.unix_connection_receive_credentials_async}.
		 * @param result a #GAsyncResult.
		 * @returns a #GCredentials, or %NULL on error.
		 *     Free the returned object with {@link GObject.unref}.
		 */
		receive_credentials_finish(result: AsyncResult): Credentials;
		/**
		 * Receives a file descriptor from the sending end of the connection.
		 * The sending end has to call {@link G.unix_connection_send_fd} for this
		 * to work.
		 * 
		 * As well as reading the fd this also reads a single byte from the
		 * stream, as this is required for fd passing to work on some
		 * implementations.
		 * @param cancellable optional #GCancellable object, %NULL to ignore
		 * @returns a file descriptor on success, -1 on error.
		 */
		receive_fd(cancellable?: Cancellable | null): number;
		/**
		 * Passes the credentials of the current user the receiving side
		 * of the connection. The receiving end has to call
		 * {@link G.unix_connection_receive_credentials} (or similar) to accept the
		 * credentials.
		 * 
		 * As well as sending the credentials this also writes a single NUL
		 * byte to the stream, as this is required for credentials passing to
		 * work on some implementations.
		 * 
		 * This method can be expected to be available on the following platforms:
		 * 
		 * - Linux since GLib 2.26
		 * - FreeBSD since GLib 2.26
		 * - GNU/kFreeBSD since GLib 2.36
		 * - Solaris, Illumos and OpenSolaris since GLib 2.40
		 * - GNU/Hurd since GLib 2.40
		 * 
		 * Other ways to exchange credentials with a foreign peer includes the
		 * #GUnixCredentialsMessage type and g_socket_get_credentials() function.
		 * @param cancellable A #GCancellable or %NULL.
		 * @returns %TRUE on success, %FALSE if #error is set.
		 */
		send_credentials(cancellable?: Cancellable | null): boolean;
		/**
		 * Asynchronously send credentials.
		 * 
		 * For more details, see {@link G.unix_connection_send_credentials} which is
		 * the synchronous version of this call.
		 * 
		 * When the operation is finished, #callback will be called. You can then call
		 * g_unix_connection_send_credentials_finish() to get the result of the operation.
		 * @param cancellable optional #GCancellable object, %NULL to ignore.
		 * @param callback a #GAsyncReadyCallback to call when the request is satisfied
		 */
		send_credentials_async(cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;
		/**
		 * Finishes an asynchronous send credentials operation started with
		 * {@link G.unix_connection_send_credentials_async}.
		 * @param result a #GAsyncResult.
		 * @returns %TRUE if the operation was successful, otherwise %FALSE.
		 */
		send_credentials_finish(result: AsyncResult): boolean;
		/**
		 * Passes a file descriptor to the receiving side of the
		 * connection. The receiving end has to call {@link G.unix_connection_receive_fd}
		 * to accept the file descriptor.
		 * 
		 * As well as sending the fd this also writes a single byte to the
		 * stream, as this is required for fd passing to work on some
		 * implementations.
		 * @param fd a file descriptor
		 * @param cancellable optional #GCancellable object, %NULL to ignore.
		 * @returns a %TRUE on success, %NULL on error.
		 */
		send_fd(fd: number, cancellable?: Cancellable | null): boolean;
	}

	type UnixConnectionInitOptionsMixin = SocketConnectionInitOptions
	export interface UnixConnectionInitOptions extends UnixConnectionInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link UnixConnection} instead.
	 */
	type UnixConnectionMixin = IUnixConnection & SocketConnection;

	/**
	 * This is the subclass of #GSocketConnection that is created
	 * for UNIX domain sockets.
	 * 
	 * It contains functions to do some of the UNIX socket specific
	 * functionality like passing file descriptors.
	 * 
	 * Note that `<gio/gunixconnection.h>` belongs to the UNIX-specific
	 * GIO interfaces, thus you have to use the `gio-unix-2.0.pc`
	 * pkg-config file when using it.
	 */
	interface UnixConnection extends UnixConnectionMixin {}

	class UnixConnection {
		public constructor(options?: Partial<UnixConnectionInitOptions>);
	}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link UnixCredentialsMessage} instead.
	 */
	interface IUnixCredentialsMessage {
		/**
		 * The credentials stored in the message.
		 */
		credentials: Credentials;
		/**
		 * Gets the credentials stored in #message.
		 * @returns A #GCredentials instance. Do not free, it is owned by #message.
		 */
		get_credentials(): Credentials;
		connect(signal: "notify::credentials", callback: (owner: this, ...args: any) => void): number;

	}

	type UnixCredentialsMessageInitOptionsMixin = SocketControlMessageInitOptions & 
	Pick<IUnixCredentialsMessage,
		"credentials">;

	export interface UnixCredentialsMessageInitOptions extends UnixCredentialsMessageInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link UnixCredentialsMessage} instead.
	 */
	type UnixCredentialsMessageMixin = IUnixCredentialsMessage & SocketControlMessage;

	/**
	 * This #GSocketControlMessage contains a #GCredentials instance.  It
	 * may be sent using {@link G.socket_send_message} and received using
	 * g_socket_receive_message() over UNIX sockets (ie: sockets in the
	 * %G_SOCKET_FAMILY_UNIX family).
	 * 
	 * For an easier way to send and receive credentials over
	 * stream-oriented UNIX sockets, see
	 * g_unix_connection_send_credentials() and
	 * g_unix_connection_receive_credentials(). To receive credentials of
	 * a foreign process connected to a socket, use
	 * g_socket_get_credentials().
	 */
	interface UnixCredentialsMessage extends UnixCredentialsMessageMixin {}

	class UnixCredentialsMessage {
		public constructor(options?: Partial<UnixCredentialsMessageInitOptions>);
		/**
		 * Creates a new #GUnixCredentialsMessage with credentials matching the current processes.
		 * @returns a new #GUnixCredentialsMessage
		 */
		public static new(): SocketControlMessage;
		/**
		 * Creates a new #GUnixCredentialsMessage holding #credentials.
		 * @param credentials A #GCredentials object.
		 * @returns a new #GUnixCredentialsMessage
		 */
		public static new_with_credentials(credentials: Credentials): SocketControlMessage;
		/**
		 * Checks if passing #GCredentials on a #GSocket is supported on this platform.
		 * @returns %TRUE if supported, %FALSE otherwise
		 */
		public static is_supported(): boolean;
	}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link UnixFDList} instead.
	 */
	interface IUnixFDList {
		/**
		 * Adds a file descriptor to #list.
		 * 
		 * The file descriptor is duplicated using dup(). You keep your copy
		 * of the descriptor and the copy contained in #list will be closed
		 * when #list is finalized.
		 * 
		 * A possible cause of failure is exceeding the per-process or
		 * system-wide file descriptor limit.
		 * 
		 * The index of the file descriptor in the list is returned.  If you use
		 * this index with g_unix_fd_list_get() then you will receive back a
		 * duplicated copy of the same file descriptor.
		 * @param fd a valid open file descriptor
		 * @returns the index of the appended fd in case of success, else -1
		 *          (and #error is set)
		 */
		append(fd: number): number;
		/**
		 * Gets a file descriptor out of #list.
		 * 
		 * #index_ specifies the index of the file descriptor to get.  It is a
		 * programmer error for #index_ to be out of range; see
		 * {@link G.unix_fd_list_get_length}.
		 * 
		 * The file descriptor is duplicated using dup() and set as
		 * close-on-exec before being returned.  You must call close() on it
		 * when you are done.
		 * 
		 * A possible cause of failure is exceeding the per-process or
		 * system-wide file descriptor limit.
		 * @param index_ the index into the list
		 * @returns the file descriptor, or -1 in case of error
		 */
		get(index_: number): number;
		/**
		 * Gets the length of #list (ie: the number of file descriptors
		 * contained within).
		 * @returns the length of #list
		 */
		get_length(): number;
		/**
		 * Returns the array of file descriptors that is contained in this
		 * object.
		 * 
		 * After this call, the descriptors remain the property of #list.  The
		 * caller must not close them and must not free the array.  The array is
		 * valid only until #list is changed in any way.
		 * 
		 * If #length is non-%NULL then it is set to the number of file
		 * descriptors in the returned array. The returned array is also
		 * terminated with -1.
		 * 
		 * This function never returns %NULL. In case there are no file
		 * descriptors contained in #list, an empty array is returned.
		 * @returns an array of file
		 *     descriptors
		 * 
		 * pointer to the length of the returned
		 *     array, or %NULL
		 */
		peek_fds(): [ number[], number | null ];
		/**
		 * Returns the array of file descriptors that is contained in this
		 * object.
		 * 
		 * After this call, the descriptors are no longer contained in
		 * #list. Further calls will return an empty list (unless more
		 * descriptors have been added).
		 * 
		 * The return result of this function must be freed with {@link G.free}.
		 * The caller is also responsible for closing all of the file
		 * descriptors.  The file descriptors in the array are set to
		 * close-on-exec.
		 * 
		 * If #length is non-%NULL then it is set to the number of file
		 * descriptors in the returned array. The returned array is also
		 * terminated with -1.
		 * 
		 * This function never returns %NULL. In case there are no file
		 * descriptors contained in #list, an empty array is returned.
		 * @returns an array of file
		 *     descriptors
		 * 
		 * pointer to the length of the returned
		 *     array, or %NULL
		 */
		steal_fds(): [ number[], number | null ];
	}

	type UnixFDListInitOptionsMixin = GObject.ObjectInitOptions
	export interface UnixFDListInitOptions extends UnixFDListInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link UnixFDList} instead.
	 */
	type UnixFDListMixin = IUnixFDList & GObject.Object;

	/**
	 * A #GUnixFDList contains a list of file descriptors.  It owns the file
	 * descriptors that it contains, closing them when finalized.
	 * 
	 * It may be wrapped in a #GUnixFDMessage and sent over a #GSocket in
	 * the %G_SOCKET_FAMILY_UNIX family by using {@link G.socket_send_message}
	 * and received using g_socket_receive_message().
	 * 
	 * Note that `<gio/gunixfdlist.h>` belongs to the UNIX-specific GIO
	 * interfaces, thus you have to use the `gio-unix-2.0.pc` pkg-config
	 * file when using it.
	 */
	interface UnixFDList extends UnixFDListMixin {}

	class UnixFDList {
		public constructor(options?: Partial<UnixFDListInitOptions>);
		/**
		 * Creates a new #GUnixFDList containing no file descriptors.
		 * @returns a new #GUnixFDList
		 */
		public static new(): UnixFDList;
		/**
		 * Creates a new #GUnixFDList containing the file descriptors given in
		 * #fds.  The file descriptors become the property of the new list and
		 * may no longer be used by the caller.  The array itself is owned by
		 * the caller.
		 * 
		 * Each file descriptor in the array should be set to close-on-exec.
		 * 
		 * If #n_fds is -1 then #fds must be terminated with -1.
		 * @param fds the initial list of file descriptors
		 * @returns a new #GUnixFDList
		 */
		public static new_from_array(fds: number[]): UnixFDList;
	}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link UnixFDMessage} instead.
	 */
	interface IUnixFDMessage {
		fd_list: UnixFDList;
		/**
		 * Adds a file descriptor to #message.
		 * 
		 * The file descriptor is duplicated using dup(). You keep your copy
		 * of the descriptor and the copy contained in #message will be closed
		 * when #message is finalized.
		 * 
		 * A possible cause of failure is exceeding the per-process or
		 * system-wide file descriptor limit.
		 * @param fd a valid open file descriptor
		 * @returns %TRUE in case of success, else %FALSE (and #error is set)
		 */
		append_fd(fd: number): boolean;
		/**
		 * Gets the #GUnixFDList contained in #message.  This function does not
		 * return a reference to the caller, but the returned list is valid for
		 * the lifetime of #message.
		 * @returns the #GUnixFDList from #message
		 */
		get_fd_list(): UnixFDList;
		/**
		 * Returns the array of file descriptors that is contained in this
		 * object.
		 * 
		 * After this call, the descriptors are no longer contained in
		 * #message. Further calls will return an empty list (unless more
		 * descriptors have been added).
		 * 
		 * The return result of this function must be freed with {@link G.free}.
		 * The caller is also responsible for closing all of the file
		 * descriptors.
		 * 
		 * If #length is non-%NULL then it is set to the number of file
		 * descriptors in the returned array. The returned array is also
		 * terminated with -1.
		 * 
		 * This function never returns %NULL. In case there are no file
		 * descriptors contained in #message, an empty array is returned.
		 * @returns an array of file
		 *     descriptors
		 * 
		 * pointer to the length of the returned
		 *     array, or %NULL
		 */
		steal_fds(): [ number[], number | null ];
		connect(signal: "notify::fd-list", callback: (owner: this, ...args: any) => void): number;

	}

	type UnixFDMessageInitOptionsMixin = SocketControlMessageInitOptions & 
	Pick<IUnixFDMessage,
		"fd_list">;

	export interface UnixFDMessageInitOptions extends UnixFDMessageInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link UnixFDMessage} instead.
	 */
	type UnixFDMessageMixin = IUnixFDMessage & SocketControlMessage;

	/**
	 * This #GSocketControlMessage contains a #GUnixFDList.
	 * It may be sent using {@link G.socket_send_message} and received using
	 * g_socket_receive_message() over UNIX sockets (ie: sockets in the
	 * %G_SOCKET_FAMILY_UNIX family). The file descriptors are copied
	 * between processes by the kernel.
	 * 
	 * For an easier way to send and receive file descriptors over
	 * stream-oriented UNIX sockets, see g_unix_connection_send_fd() and
	 * g_unix_connection_receive_fd().
	 * 
	 * Note that `<gio/gunixfdmessage.h>` belongs to the UNIX-specific GIO
	 * interfaces, thus you have to use the `gio-unix-2.0.pc` pkg-config
	 * file when using it.
	 */
	interface UnixFDMessage extends UnixFDMessageMixin {}

	class UnixFDMessage {
		public constructor(options?: Partial<UnixFDMessageInitOptions>);
		/**
		 * Creates a new #GUnixFDMessage containing an empty file descriptor
		 * list.
		 * @returns a new #GUnixFDMessage
		 */
		public static new(): SocketControlMessage;
		/**
		 * Creates a new #GUnixFDMessage containing #list.
		 * @param fd_list a #GUnixFDList
		 * @returns a new #GUnixFDMessage
		 */
		public static new_with_fd_list(fd_list: UnixFDList): SocketControlMessage;
	}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link UnixInputStream} instead.
	 */
	interface IUnixInputStream {
		/**
		 * Whether to close the file descriptor when the stream is closed.
		 */
		close_fd: boolean;
		/**
		 * The file descriptor that the stream reads from.
		 */
		fd: number;
		/**
		 * Returns whether the file descriptor of #stream will be
		 * closed when the stream is closed.
		 * @returns %TRUE if the file descriptor is closed when done
		 */
		get_close_fd(): boolean;
		/**
		 * Return the UNIX file descriptor that the stream reads from.
		 * @returns The file descriptor of #stream
		 */
		get_fd(): number;
		/**
		 * Sets whether the file descriptor of #stream shall be closed
		 * when the stream is closed.
		 * @param close_fd %TRUE to close the file descriptor when done
		 */
		set_close_fd(close_fd: boolean): void;
		connect(signal: "notify::close-fd", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::fd", callback: (owner: this, ...args: any) => void): number;

	}

	type UnixInputStreamInitOptionsMixin = InputStreamInitOptions & FileDescriptorBasedInitOptions & PollableInputStreamInitOptions & 
	Pick<IUnixInputStream,
		"close_fd" |
		"fd">;

	export interface UnixInputStreamInitOptions extends UnixInputStreamInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link UnixInputStream} instead.
	 */
	type UnixInputStreamMixin = IUnixInputStream & InputStream & FileDescriptorBased & PollableInputStream;

	/**
	 * #GUnixInputStream implements #GInputStream for reading from a UNIX
	 * file descriptor, including asynchronous operations. (If the file
	 * descriptor refers to a socket or pipe, this will use poll() to do
	 * asynchronous I/O. If it refers to a regular file, it will fall back
	 * to doing asynchronous I/O in another thread.)
	 * 
	 * Note that `<gio/gunixinputstream.h>` belongs to the UNIX-specific GIO
	 * interfaces, thus you have to use the `gio-unix-2.0.pc` pkg-config
	 * file when using it.
	 */
	interface UnixInputStream extends UnixInputStreamMixin {}

	class UnixInputStream {
		public constructor(options?: Partial<UnixInputStreamInitOptions>);
		/**
		 * Creates a new #GUnixInputStream for the given #fd.
		 * 
		 * If #close_fd is %TRUE, the file descriptor will be closed
		 * when the stream is closed.
		 * @param fd a UNIX file descriptor
		 * @param close_fd %TRUE to close the file descriptor when done
		 * @returns a new #GUnixInputStream
		 */
		public static new(fd: number, close_fd: boolean): InputStream;
	}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link UnixMountMonitor} instead.
	 */
	interface IUnixMountMonitor {
		/**
		 * @deprecated
		 * This function does nothing.  Don't call it.
		 * 
		 * This function does nothing.
		 * 
		 * Before 2.44, this was a partially-effective way of controlling the
		 * rate at which events would be reported under some uncommon
		 * circumstances.  Since #mount_monitor is a singleton, it also meant
		 * that calling this function would have side effects for other users of
		 * the monitor.
		 * @param limit_msec a integer with the limit in milliseconds to
		 *     poll for changes.
		 */
		set_rate_limit(limit_msec: number): void;
		/**
		 * Emitted when the unix mount points have changed.
		 * @param signal 
		 * @param callback Callback function
		 *  - owner: owner of the emitted event 
		 * 
		 * @returns Callback ID
		 */
		connect(signal: "mountpoints-changed", callback: (owner: this) => void): number;
		/**
		 * Emitted when the unix mounts have changed.
		 * @param signal 
		 * @param callback Callback function
		 *  - owner: owner of the emitted event 
		 * 
		 * @returns Callback ID
		 */
		connect(signal: "mounts-changed", callback: (owner: this) => void): number;

	}

	type UnixMountMonitorInitOptionsMixin = GObject.ObjectInitOptions
	export interface UnixMountMonitorInitOptions extends UnixMountMonitorInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link UnixMountMonitor} instead.
	 */
	type UnixMountMonitorMixin = IUnixMountMonitor & GObject.Object;

	/**
	 * Watches #GUnixMounts for changes.
	 */
	interface UnixMountMonitor extends UnixMountMonitorMixin {}

	class UnixMountMonitor {
		public constructor(options?: Partial<UnixMountMonitorInitOptions>);
		/**
		 * @deprecated
		 * Use {@link G.unix_mount_monitor_get} instead.
		 * 
		 * Deprecated alias for {@link G.unix_mount_monitor_get}.
		 * 
		 * This function was never a true constructor, which is why it was
		 * renamed.
		 * @returns a #GUnixMountMonitor.
		 */
		public static new(): UnixMountMonitor;
		/**
		 * Gets the #GUnixMountMonitor for the current thread-default main
		 * context.
		 * 
		 * The mount monitor can be used to monitor for changes to the list of
		 * mounted filesystems as well as the list of mount points (ie: fstab
		 * entries).
		 * 
		 * You must only call {@link GObject.unref} on the return value from under
		 * the same main context as you called this function.
		 * @returns the #GUnixMountMonitor.
		 */
		public static get(): UnixMountMonitor;
	}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link UnixOutputStream} instead.
	 */
	interface IUnixOutputStream {
		/**
		 * Whether to close the file descriptor when the stream is closed.
		 */
		close_fd: boolean;
		/**
		 * The file descriptor that the stream writes to.
		 */
		fd: number;
		/**
		 * Returns whether the file descriptor of #stream will be
		 * closed when the stream is closed.
		 * @returns %TRUE if the file descriptor is closed when done
		 */
		get_close_fd(): boolean;
		/**
		 * Return the UNIX file descriptor that the stream writes to.
		 * @returns The file descriptor of #stream
		 */
		get_fd(): number;
		/**
		 * Sets whether the file descriptor of #stream shall be closed
		 * when the stream is closed.
		 * @param close_fd %TRUE to close the file descriptor when done
		 */
		set_close_fd(close_fd: boolean): void;
		connect(signal: "notify::close-fd", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::fd", callback: (owner: this, ...args: any) => void): number;

	}

	type UnixOutputStreamInitOptionsMixin = OutputStreamInitOptions & FileDescriptorBasedInitOptions & PollableOutputStreamInitOptions & 
	Pick<IUnixOutputStream,
		"close_fd" |
		"fd">;

	export interface UnixOutputStreamInitOptions extends UnixOutputStreamInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link UnixOutputStream} instead.
	 */
	type UnixOutputStreamMixin = IUnixOutputStream & OutputStream & FileDescriptorBased & PollableOutputStream;

	/**
	 * #GUnixOutputStream implements #GOutputStream for writing to a UNIX
	 * file descriptor, including asynchronous operations. (If the file
	 * descriptor refers to a socket or pipe, this will use poll() to do
	 * asynchronous I/O. If it refers to a regular file, it will fall back
	 * to doing asynchronous I/O in another thread.)
	 * 
	 * Note that `<gio/gunixoutputstream.h>` belongs to the UNIX-specific GIO
	 * interfaces, thus you have to use the `gio-unix-2.0.pc` pkg-config file
	 * when using it.
	 */
	interface UnixOutputStream extends UnixOutputStreamMixin {}

	class UnixOutputStream {
		public constructor(options?: Partial<UnixOutputStreamInitOptions>);
		/**
		 * Creates a new #GUnixOutputStream for the given #fd.
		 * 
		 * If #close_fd, is %TRUE, the file descriptor will be closed when
		 * the output stream is destroyed.
		 * @param fd a UNIX file descriptor
		 * @param close_fd %TRUE to close the file descriptor when done
		 * @returns a new #GOutputStream
		 */
		public static new(fd: number, close_fd: boolean): OutputStream;
	}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link UnixSocketAddress} instead.
	 */
	interface IUnixSocketAddress {
		/**
		 * @deprecated
		 * Use #GUnixSocketAddress:address-type, which
		 * distinguishes between zero-padded and non-zero-padded
		 * abstract addresses.
		 * 
		 * Whether or not this is an abstract address
		 */
		abstract: boolean;
		address_type: UnixSocketAddressType;
		path: string;
		path_as_array: number[];
		/**
		 * Gets #address's type.
		 * @returns a #GUnixSocketAddressType
		 */
		get_address_type(): UnixSocketAddressType;
		/**
		 * @deprecated
		 * Use {@link G.unix_socket_address_get_address_type}
		 * 
		 * Tests if #address is abstract.
		 * @returns %TRUE if the address is abstract, %FALSE otherwise
		 */
		get_is_abstract(): boolean;
		/**
		 * Gets #address's path, or for abstract sockets the "name".
		 * 
		 * Guaranteed to be zero-terminated, but an abstract socket
		 * may contain embedded zeros, and thus you should use
		 * {@link G.unix_socket_address_get_path_len} to get the true length
		 * of this string.
		 * @returns the path for #address
		 */
		get_path(): string;
		/**
		 * Gets the length of #address's path.
		 * 
		 * For details, see {@link G.unix_socket_address_get_path}.
		 * @returns the length of the path
		 */
		get_path_len(): number;
		connect(signal: "notify::abstract", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::address-type", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::path", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::path-as-array", callback: (owner: this, ...args: any) => void): number;

	}

	type UnixSocketAddressInitOptionsMixin = SocketAddressInitOptions & SocketConnectableInitOptions & 
	Pick<IUnixSocketAddress,
		"abstract" |
		"address_type" |
		"path" |
		"path_as_array">;

	export interface UnixSocketAddressInitOptions extends UnixSocketAddressInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link UnixSocketAddress} instead.
	 */
	type UnixSocketAddressMixin = IUnixSocketAddress & SocketAddress & SocketConnectable;

	/**
	 * Support for UNIX-domain (also known as local) sockets.
	 * 
	 * UNIX domain sockets are generally visible in the filesystem.
	 * However, some systems support abstract socket names which are not
	 * visible in the filesystem and not affected by the filesystem
	 * permissions, visibility, etc. Currently this is only supported
	 * under Linux. If you attempt to use abstract sockets on other
	 * systems, function calls may return %G_IO_ERROR_NOT_SUPPORTED
	 * errors. You can use {@link G.unix_socket_address_abstract_names_supported}
	 * to see if abstract names are supported.
	 * 
	 * Note that `<gio/gunixsocketaddress.h>` belongs to the UNIX-specific GIO
	 * interfaces, thus you have to use the `gio-unix-2.0.pc` pkg-config file
	 * when using it.
	 */
	interface UnixSocketAddress extends UnixSocketAddressMixin {}

	class UnixSocketAddress {
		public constructor(options?: Partial<UnixSocketAddressInitOptions>);
		/**
		 * Creates a new #GUnixSocketAddress for #path.
		 * 
		 * To create abstract socket addresses, on systems that support that,
		 * use {@link G.unix_socket_address_new_abstract}.
		 * @param path the socket path
		 * @returns a new #GUnixSocketAddress
		 */
		public static new(path: string): SocketAddress;
		/**
		 * @deprecated
		 * Use {@link G.unix_socket_address_new_with_type}.
		 * 
		 * Creates a new %G_UNIX_SOCKET_ADDRESS_ABSTRACT_PADDED
		 * #GUnixSocketAddress for #path.
		 * @param path the abstract name
		 * @returns a new #GUnixSocketAddress
		 */
		public static new_abstract(path: string[]): SocketAddress;
		/**
		 * Creates a new #GUnixSocketAddress of type #type with name #path.
		 * 
		 * If #type is %G_UNIX_SOCKET_ADDRESS_PATH, this is equivalent to
		 * calling {@link G.unix_socket_address_new}.
		 * 
		 * If #type is %G_UNIX_SOCKET_ADDRESS_ANONYMOUS, #path and #path_len will be
		 * ignored.
		 * 
		 * If #path_type is %G_UNIX_SOCKET_ADDRESS_ABSTRACT, then #path_len
		 * bytes of #path will be copied to the socket's path, and only those
		 * bytes will be considered part of the name. (If #path_len is -1,
		 * then #path is assumed to be NUL-terminated.) For example, if #path
		 * was "test", then calling g_socket_address_get_native_size() on the
		 * returned socket would return 7 (2 bytes of overhead, 1 byte for the
		 * abstract-socket indicator byte, and 4 bytes for the name "test").
		 * 
		 * If #path_type is %G_UNIX_SOCKET_ADDRESS_ABSTRACT_PADDED, then
		 * #path_len bytes of #path will be copied to the socket's path, the
		 * rest of the path will be padded with 0 bytes, and the entire
		 * zero-padded buffer will be considered the name. (As above, if
		 * #path_len is -1, then #path is assumed to be NUL-terminated.) In
		 * this case, g_socket_address_get_native_size() will always return
		 * the full size of a `struct sockaddr_un`, although
		 * g_unix_socket_address_get_path_len() will still return just the
		 * length of #path.
		 * 
		 * %G_UNIX_SOCKET_ADDRESS_ABSTRACT is preferred over
		 * %G_UNIX_SOCKET_ADDRESS_ABSTRACT_PADDED for new programs. Of course,
		 * when connecting to a server created by another process, you must
		 * use the appropriate type corresponding to how that process created
		 * its listening socket.
		 * @param path the name
		 * @param type a #GUnixSocketAddressType
		 * @returns a new #GUnixSocketAddress
		 */
		public static new_with_type(path: string[], type: UnixSocketAddressType): SocketAddress;
		/**
		 * Checks if abstract UNIX domain socket names are supported.
		 * @returns %TRUE if supported, %FALSE otherwise
		 */
		public static abstract_names_supported(): boolean;
	}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link Vfs} instead.
	 */
	interface IVfs {
		/**
		 * Gets a #GFile for #path.
		 * @param path a string containing a VFS path.
		 * @returns a #GFile.
		 *     Free the returned object with {@link GObject.unref}.
		 */
		get_file_for_path(path: string): File;
		/**
		 * Gets a #GFile for #uri.
		 * 
		 * This operation never fails, but the returned object
		 * might not support any I/O operation if the URI
		 * is malformed or if the URI scheme is not supported.
		 * @param uri a string containing a URI
		 * @returns a #GFile.
		 *     Free the returned object with {@link GObject.unref}.
		 */
		get_file_for_uri(uri: string): File;
		/**
		 * Gets a list of URI schemes supported by #vfs.
		 * @returns a %NULL-terminated array of strings.
		 *     The returned array belongs to GIO and must
		 *     not be freed or modified.
		 */
		get_supported_uri_schemes(): string[];
		/**
		 * Checks if the VFS is active.
		 * @returns %TRUE if construction of the #vfs was successful
		 *     and it is now active.
		 */
		is_active(): boolean;
		/**
		 * This operation never fails, but the returned object might
		 * not support any I/O operations if the #parse_name cannot
		 * be parsed by the #GVfs module.
		 * @param parse_name a string to be parsed by the VFS module.
		 * @returns a #GFile for the given #parse_name.
		 *     Free the returned object with {@link GObject.unref}.
		 */
		parse_name(parse_name: string): File;
		/**
		 * Registers #uri_func and #parse_name_func as the #GFile URI and parse name
		 * lookup functions for URIs with a scheme matching #scheme.
		 * Note that #scheme is registered only within the running application, as
		 * opposed to desktop-wide as it happens with GVfs backends.
		 * 
		 * When a #GFile is requested with an URI containing #scheme (e.g. through
		 * {@link G.file_new_for_uri}), #uri_func will be called to allow a custom
		 * constructor. The implementation of #uri_func should not be blocking, and
		 * must not call g_vfs_register_uri_scheme() or g_vfs_unregister_uri_scheme().
		 * 
		 * When g_file_parse_name() is called with a parse name obtained from such file,
		 * #parse_name_func will be called to allow the #GFile to be created again. In
		 * that case, it's responsibility of #parse_name_func to make sure the parse
		 * name matches what the custom #GFile implementation returned when
		 * g_file_get_parse_name() was previously called. The implementation of
		 * #parse_name_func should not be blocking, and must not call
		 * g_vfs_register_uri_scheme() or g_vfs_unregister_uri_scheme().
		 * 
		 * It's an error to call this function twice with the same scheme. To unregister
		 * a custom URI scheme, use g_vfs_unregister_uri_scheme().
		 * @param scheme an URI scheme, e.g. "http"
		 * @param uri_func a #GVfsFileLookupFunc
		 * @param parse_name_func a #GVfsFileLookupFunc
		 * @returns %TRUE if #scheme was successfully registered, or %FALSE if a handler
		 *     for #scheme already exists.
		 */
		register_uri_scheme(scheme: string, uri_func?: VfsFileLookupFunc | null, parse_name_func?: VfsFileLookupFunc | null): boolean;
		/**
		 * Unregisters the URI handler for #scheme previously registered with
		 * {@link G.vfs_register_uri_scheme}.
		 * @param scheme an URI scheme, e.g. "http"
		 * @returns %TRUE if #scheme was successfully unregistered, or %FALSE if a
		 *     handler for #scheme does not exist.
		 */
		unregister_uri_scheme(scheme: string): boolean;
	}

	type VfsInitOptionsMixin = GObject.ObjectInitOptions
	export interface VfsInitOptions extends VfsInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link Vfs} instead.
	 */
	type VfsMixin = IVfs & GObject.Object;

	/**
	 * Entry point for using GIO functionality.
	 */
	interface Vfs extends VfsMixin {}

	class Vfs {
		public constructor(options?: Partial<VfsInitOptions>);
		/**
		 * Gets the default #GVfs for the system.
		 * @returns a #GVfs, which will be the local
		 *     file system #GVfs if no other implementation is available.
		 */
		public static get_default(): Vfs;
		/**
		 * Gets the local #GVfs for the system.
		 * @returns a #GVfs.
		 */
		public static get_local(): Vfs;
	}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link VolumeMonitor} instead.
	 */
	interface IVolumeMonitor {
		/**
		 * Gets a list of drives connected to the system.
		 * 
		 * The returned list should be freed with {@link G.list_free}, after
		 * its elements have been unreffed with g_object_unref().
		 * @returns a #GList of connected #GDrive objects.
		 */
		get_connected_drives(): Drive[];
		/**
		 * Finds a #GMount object by its UUID (see {@link G.mount_get_uuid})
		 * @param uuid the UUID to look for
		 * @returns a #GMount or %NULL if no such mount is available.
		 *     Free the returned object with {@link GObject.unref}.
		 */
		get_mount_for_uuid(uuid: string): Mount | null;
		/**
		 * Gets a list of the mounts on the system.
		 * 
		 * The returned list should be freed with {@link G.list_free}, after
		 * its elements have been unreffed with g_object_unref().
		 * @returns a #GList of #GMount objects.
		 */
		get_mounts(): Mount[];
		/**
		 * Finds a #GVolume object by its UUID (see {@link G.volume_get_uuid})
		 * @param uuid the UUID to look for
		 * @returns a #GVolume or %NULL if no such volume is available.
		 *     Free the returned object with {@link GObject.unref}.
		 */
		get_volume_for_uuid(uuid: string): Volume | null;
		/**
		 * Gets a list of the volumes on the system.
		 * 
		 * The returned list should be freed with {@link G.list_free}, after
		 * its elements have been unreffed with g_object_unref().
		 * @returns a #GList of #GVolume objects.
		 */
		get_volumes(): Volume[];
		/**
		 * Emitted when a drive changes.
		 * @param signal 
		 * @param callback Callback function
		 *  - owner: owner of the emitted event 
		 *  - drive: the drive that changed 
		 * 
		 * @returns Callback ID
		 */
		connect(signal: "drive-changed", callback: (owner: this, drive: Drive) => void): number;
		/**
		 * Emitted when a drive is connected to the system.
		 * @param signal 
		 * @param callback Callback function
		 *  - owner: owner of the emitted event 
		 *  - drive: a #GDrive that was connected. 
		 * 
		 * @returns Callback ID
		 */
		connect(signal: "drive-connected", callback: (owner: this, drive: Drive) => void): number;
		/**
		 * Emitted when a drive is disconnected from the system.
		 * @param signal 
		 * @param callback Callback function
		 *  - owner: owner of the emitted event 
		 *  - drive: a #GDrive that was disconnected. 
		 * 
		 * @returns Callback ID
		 */
		connect(signal: "drive-disconnected", callback: (owner: this, drive: Drive) => void): number;
		/**
		 * Emitted when the eject button is pressed on #drive.
		 * @param signal 
		 * @param callback Callback function
		 *  - owner: owner of the emitted event 
		 *  - drive: the drive where the eject button was pressed 
		 * 
		 * @returns Callback ID
		 */
		connect(signal: "drive-eject-button", callback: (owner: this, drive: Drive) => void): number;
		/**
		 * Emitted when the stop button is pressed on #drive.
		 * @param signal 
		 * @param callback Callback function
		 *  - owner: owner of the emitted event 
		 *  - drive: the drive where the stop button was pressed 
		 * 
		 * @returns Callback ID
		 */
		connect(signal: "drive-stop-button", callback: (owner: this, drive: Drive) => void): number;
		/**
		 * Emitted when a mount is added.
		 * @param signal 
		 * @param callback Callback function
		 *  - owner: owner of the emitted event 
		 *  - mount: a #GMount that was added. 
		 * 
		 * @returns Callback ID
		 */
		connect(signal: "mount-added", callback: (owner: this, mount: Mount) => void): number;
		/**
		 * Emitted when a mount changes.
		 * @param signal 
		 * @param callback Callback function
		 *  - owner: owner of the emitted event 
		 *  - mount: a #GMount that changed. 
		 * 
		 * @returns Callback ID
		 */
		connect(signal: "mount-changed", callback: (owner: this, mount: Mount) => void): number;
		/**
		 * May be emitted when a mount is about to be removed.
		 * 
		 * This signal depends on the backend and is only emitted if
		 * GIO was used to unmount.
		 * @param signal 
		 * @param callback Callback function
		 *  - owner: owner of the emitted event 
		 *  - mount: a #GMount that is being unmounted. 
		 * 
		 * @returns Callback ID
		 */
		connect(signal: "mount-pre-unmount", callback: (owner: this, mount: Mount) => void): number;
		/**
		 * Emitted when a mount is removed.
		 * @param signal 
		 * @param callback Callback function
		 *  - owner: owner of the emitted event 
		 *  - mount: a #GMount that was removed. 
		 * 
		 * @returns Callback ID
		 */
		connect(signal: "mount-removed", callback: (owner: this, mount: Mount) => void): number;
		/**
		 * Emitted when a mountable volume is added to the system.
		 * @param signal 
		 * @param callback Callback function
		 *  - owner: owner of the emitted event 
		 *  - volume: a #GVolume that was added. 
		 * 
		 * @returns Callback ID
		 */
		connect(signal: "volume-added", callback: (owner: this, volume: Volume) => void): number;
		/**
		 * Emitted when mountable volume is changed.
		 * @param signal 
		 * @param callback Callback function
		 *  - owner: owner of the emitted event 
		 *  - volume: a #GVolume that changed. 
		 * 
		 * @returns Callback ID
		 */
		connect(signal: "volume-changed", callback: (owner: this, volume: Volume) => void): number;
		/**
		 * Emitted when a mountable volume is removed from the system.
		 * @param signal 
		 * @param callback Callback function
		 *  - owner: owner of the emitted event 
		 *  - volume: a #GVolume that was removed. 
		 * 
		 * @returns Callback ID
		 */
		connect(signal: "volume-removed", callback: (owner: this, volume: Volume) => void): number;

	}

	type VolumeMonitorInitOptionsMixin = GObject.ObjectInitOptions
	export interface VolumeMonitorInitOptions extends VolumeMonitorInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link VolumeMonitor} instead.
	 */
	type VolumeMonitorMixin = IVolumeMonitor & GObject.Object;

	/**
	 * #GVolumeMonitor is for listing the user interesting devices and volumes
	 * on the computer. In other words, what a file selector or file manager
	 * would show in a sidebar.
	 * 
	 * #GVolumeMonitor is not
	 * [thread-default-context aware][g-main-context-push-thread-default],
	 * and so should not be used other than from the main thread, with no
	 * thread-default-context active.
	 * 
	 * In order to receive updates about volumes and mounts monitored through GVFS,
	 * a main loop must be running.
	 */
	interface VolumeMonitor extends VolumeMonitorMixin {}

	class VolumeMonitor {
		public constructor(options?: Partial<VolumeMonitorInitOptions>);
		/**
		 * @deprecated
		 * Instead of using this function, #GVolumeMonitor
		 * implementations should instead create shadow mounts with the URI of
		 * the mount they intend to adopt. See the proxy volume monitor in
		 * gvfs for an example of this. Also see {@link G.mount_is_shadowed},
		 * g_mount_shadow() and g_mount_unshadow() functions.
		 * 
		 * This function should be called by any #GVolumeMonitor
		 * implementation when a new #GMount object is created that is not
		 * associated with a #GVolume object. It must be called just before
		 * emitting the #mount_added signal.
		 * 
		 * If the return value is not %NULL, the caller must associate the
		 * returned #GVolume object with the #GMount. This involves returning
		 * it in its {@link G.mount_get_volume} implementation. The caller must
		 * also listen for the "removed" signal on the returned object
		 * and give up its reference when handling that signal
		 * 
		 * Similarly, if implementing g_volume_monitor_adopt_orphan_mount(),
		 * the implementor must take a reference to #mount and return it in
		 * its g_volume_get_mount() implemented. Also, the implementor must
		 * listen for the "unmounted" signal on #mount and give up its
		 * reference upon handling that signal.
		 * 
		 * There are two main use cases for this function.
		 * 
		 * One is when implementing a user space file system driver that reads
		 * blocks of a block device that is already represented by the native
		 * volume monitor (for example a CD Audio file system driver). Such
		 * a driver will generate its own #GMount object that needs to be
		 * associated with the #GVolume object that represents the volume.
		 * 
		 * The other is for implementing a #GVolumeMonitor whose sole purpose
		 * is to return #GVolume objects representing entries in the users
		 * "favorite servers" list or similar.
		 * @param mount a #GMount object to find a parent for
		 * @returns the #GVolume object that is the parent for #mount or %NULL
		 * if no wants to adopt the #GMount.
		 */
		public static adopt_orphan_mount(mount: Mount): Volume;
		/**
		 * Gets the volume monitor used by gio.
		 * @returns a reference to the #GVolumeMonitor used by gio. Call
		 *    {@link GObject.unref} when done with it.
		 */
		public static get(): VolumeMonitor;
	}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link ZlibCompressor} instead.
	 */
	interface IZlibCompressor {
		/**
		 * If set to a non-%NULL #GFileInfo object, and #GZlibCompressor:format is
		 * %G_ZLIB_COMPRESSOR_FORMAT_GZIP, the compressor will write the file name
		 * and modification time from the file info to the GZIP header.
		 */
		file_info: FileInfo;
		format: ZlibCompressorFormat;
		level: number;
		/**
		 * Returns the #GZlibCompressor:file-info property.
		 * @returns a #GFileInfo, or %NULL
		 */
		get_file_info(): FileInfo | null;
		/**
		 * Sets #file_info in #compressor. If non-%NULL, and #compressor's
		 * #GZlibCompressor:format property is %G_ZLIB_COMPRESSOR_FORMAT_GZIP,
		 * it will be used to set the file name and modification time in
		 * the GZIP header of the compressed data.
		 * 
		 * Note: it is an error to call this function while a compression is in
		 * progress; it may only be called immediately after creation of #compressor,
		 * or after resetting it with {@link G.converter_reset}.
		 * @param file_info a #GFileInfo
		 */
		set_file_info(file_info?: FileInfo | null): void;
		connect(signal: "notify::file-info", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::format", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::level", callback: (owner: this, ...args: any) => void): number;

	}

	type ZlibCompressorInitOptionsMixin = GObject.ObjectInitOptions & ConverterInitOptions & 
	Pick<IZlibCompressor,
		"file_info" |
		"format" |
		"level">;

	export interface ZlibCompressorInitOptions extends ZlibCompressorInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link ZlibCompressor} instead.
	 */
	type ZlibCompressorMixin = IZlibCompressor & GObject.Object & Converter;

	/**
	 * #GZlibCompressor is an implementation of #GConverter that
	 * compresses data using zlib.
	 */
	interface ZlibCompressor extends ZlibCompressorMixin {}

	class ZlibCompressor {
		public constructor(options?: Partial<ZlibCompressorInitOptions>);
		/**
		 * Creates a new #GZlibCompressor.
		 * @param format The format to use for the compressed data
		 * @param level compression level (0-9), -1 for default
		 * @returns a new #GZlibCompressor
		 */
		public static new(format: ZlibCompressorFormat, level: number): ZlibCompressor;
	}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link ZlibDecompressor} instead.
	 */
	interface IZlibDecompressor {
		/**
		 * A #GFileInfo containing the information found in the GZIP header
		 * of the data stream processed, or %NULL if the header was not yet
		 * fully processed, is not present at all, or the compressor's
		 * #GZlibDecompressor:format property is not %G_ZLIB_COMPRESSOR_FORMAT_GZIP.
		 */
		readonly file_info: FileInfo;
		format: ZlibCompressorFormat;
		/**
		 * Retrieves the #GFileInfo constructed from the GZIP header data
		 * of compressed data processed by #compressor, or %NULL if #decompressor's
		 * #GZlibDecompressor:format property is not %G_ZLIB_COMPRESSOR_FORMAT_GZIP,
		 * or the header data was not fully processed yet, or it not present in the
		 * data stream at all.
		 * @returns a #GFileInfo, or %NULL
		 */
		get_file_info(): FileInfo | null;
		connect(signal: "notify::file-info", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::format", callback: (owner: this, ...args: any) => void): number;

	}

	type ZlibDecompressorInitOptionsMixin = GObject.ObjectInitOptions & ConverterInitOptions & 
	Pick<IZlibDecompressor,
		"format">;

	export interface ZlibDecompressorInitOptions extends ZlibDecompressorInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link ZlibDecompressor} instead.
	 */
	type ZlibDecompressorMixin = IZlibDecompressor & GObject.Object & Converter;

	/**
	 * #GZlibDecompressor is an implementation of #GConverter that
	 * decompresses data compressed with zlib.
	 */
	interface ZlibDecompressor extends ZlibDecompressorMixin {}

	class ZlibDecompressor {
		public constructor(options?: Partial<ZlibDecompressorInitOptions>);
		/**
		 * Creates a new #GZlibDecompressor.
		 * @param format The format to use for the compressed data
		 * @returns a new #GZlibDecompressor
		 */
		public static new(format: ZlibCompressorFormat): ZlibDecompressor;
	}

	export interface ActionEntryInitOptions {}
	/**
	 * This struct defines a single action.  It is for use with
	 * {@link G.action_map_add_action_entries}.
	 * 
	 * The order of the items in the structure are intended to reflect
	 * frequency of use.  It is permissible to use an incomplete initialiser
	 * in order to leave some of the later values as %NULL.  All values
	 * after #name are optional.  Additional optional fields may be added in
	 * the future.
	 * 
	 * See g_action_map_add_action_entries() for an example.
	 */
	interface ActionEntry {}
	class ActionEntry {
		public constructor(options?: Partial<ActionEntryInitOptions>);
		/**
		 * the name of the action
		 */
		public name: string;
		/**
		 * the type of the parameter that must be passed to the
		 *                  activate function for this action, given as a single
		 *                  GVariant type string (or %NULL for no parameter)
		 */
		public parameter_type: string;
		/**
		 * the initial state for this action, given in
		 *         [GVariant text format][gvariant-text].  The state is parsed
		 *         with no extra type information, so type tags must be added to
		 *         the string if they are necessary.  Stateless actions should
		 *         give %NULL here.
		 */
		public state: string;
		public readonly padding: number[];
		public activate: {(action: SimpleAction, parameter: GLib.Variant): void;};
		public change_state: {(action: SimpleAction, value: GLib.Variant): void;};
	}

	export interface ActionGroupInterfaceInitOptions {}
	/**
	 * The virtual function table for #GActionGroup.
	 */
	interface ActionGroupInterface {}
	class ActionGroupInterface {
		public constructor(options?: Partial<ActionGroupInterfaceInitOptions>);
		public readonly g_iface: GObject.TypeInterface;
		public has_action: {(action_group: ActionGroup, action_name: string): boolean;};
		public list_actions: {(action_group: ActionGroup): string[];};
		public get_action_enabled: {(action_group: ActionGroup, action_name: string): boolean;};
		public get_action_parameter_type: {(action_group: ActionGroup, action_name: string): GLib.VariantType | null;};
		public get_action_state_type: {(action_group: ActionGroup, action_name: string): GLib.VariantType | null;};
		public get_action_state_hint: {(action_group: ActionGroup, action_name: string): GLib.Variant | null;};
		public get_action_state: {(action_group: ActionGroup, action_name: string): GLib.Variant | null;};
		public change_action_state: {(action_group: ActionGroup, action_name: string, value: GLib.Variant): void;};
		public activate_action: {(action_group: ActionGroup, action_name: string, parameter?: GLib.Variant | null): void;};
		public action_added: {(action_group: ActionGroup, action_name: string): void;};
		public action_removed: {(action_group: ActionGroup, action_name: string): void;};
		public action_enabled_changed: {(action_group: ActionGroup, action_name: string, enabled: boolean): void;};
		public action_state_changed: {(action_group: ActionGroup, action_name: string, state: GLib.Variant): void;};
		public query_action: {(action_group: ActionGroup, action_name: string): [ boolean, boolean, GLib.VariantType | null, GLib.VariantType | null, GLib.Variant | null, GLib.Variant | null ];};
	}

	export interface ActionInterfaceInitOptions {}
	/**
	 * The virtual function table for #GAction.
	 */
	interface ActionInterface {}
	class ActionInterface {
		public constructor(options?: Partial<ActionInterfaceInitOptions>);
		public readonly g_iface: GObject.TypeInterface;
		public get_name: {(action: Action): string;};
		public get_parameter_type: {(action: Action): GLib.VariantType | null;};
		public get_state_type: {(action: Action): GLib.VariantType | null;};
		public get_state_hint: {(action: Action): GLib.Variant | null;};
		public get_enabled: {(action: Action): boolean;};
		public get_state: {(action: Action): GLib.Variant | null;};
		public change_state: {(action: Action, value: GLib.Variant): void;};
		public activate: {(action: Action, parameter?: GLib.Variant | null): void;};
	}

	export interface ActionMapInterfaceInitOptions {}
	/**
	 * The virtual function table for #GActionMap.
	 */
	interface ActionMapInterface {}
	class ActionMapInterface {
		public constructor(options?: Partial<ActionMapInterfaceInitOptions>);
		public readonly g_iface: GObject.TypeInterface;
		public lookup_action: {(action_map: ActionMap, action_name: string): Action | null;};
		public add_action: {(action_map: ActionMap, action: Action): void;};
		public remove_action: {(action_map: ActionMap, action_name: string): void;};
	}

	export interface AppInfoIfaceInitOptions {}
	/**
	 * Application Information interface, for operating system portability.
	 */
	interface AppInfoIface {}
	class AppInfoIface {
		public constructor(options?: Partial<AppInfoIfaceInitOptions>);
		/**
		 * The parent interface.
		 */
		public readonly g_iface: GObject.TypeInterface;
		public dup: {(appinfo: AppInfo): AppInfo;};
		public equal: {(appinfo1: AppInfo, appinfo2: AppInfo): boolean;};
		public get_id: {(appinfo: AppInfo): string | null;};
		public get_name: {(appinfo: AppInfo): string;};
		public get_description: {(appinfo: AppInfo): string | null;};
		public get_executable: {(appinfo: AppInfo): string;};
		public get_icon: {(appinfo: AppInfo): Icon | null;};
		public launch: {(appinfo: AppInfo, files?: File[] | null, context?: AppLaunchContext | null): boolean;};
		public supports_uris: {(appinfo: AppInfo): boolean;};
		public supports_files: {(appinfo: AppInfo): boolean;};
		public launch_uris: {(appinfo: AppInfo, uris?: string[] | null, context?: AppLaunchContext | null): boolean;};
		public should_show: {(appinfo: AppInfo): boolean;};
		public set_as_default_for_type: {(appinfo: AppInfo, content_type: string): boolean;};
		public set_as_default_for_extension: {(appinfo: AppInfo, extension: string): boolean;};
		public add_supports_type: {(appinfo: AppInfo, content_type: string): boolean;};
		public can_remove_supports_type: {(appinfo: AppInfo): boolean;};
		public remove_supports_type: {(appinfo: AppInfo, content_type: string): boolean;};
		public can_delete: {(appinfo: AppInfo): boolean;};
		public do_delete: {(appinfo: AppInfo): boolean;};
		public get_commandline: {(appinfo: AppInfo): string | null;};
		public get_display_name: {(appinfo: AppInfo): string;};
		public set_as_last_used_for_type: {(appinfo: AppInfo, content_type: string): boolean;};
		public get_supported_types: {(appinfo: AppInfo): string[];};
		public launch_uris_async: {(appinfo: AppInfo, uris?: string[] | null, context?: AppLaunchContext | null, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;};
		public launch_uris_finish: {(appinfo: AppInfo, result: AsyncResult): boolean;};
	}

	export interface AsyncInitableIfaceInitOptions {}
	/**
	 * Provides an interface for asynchronous initializing object such that
	 * initialization may fail.
	 */
	interface AsyncInitableIface {}
	class AsyncInitableIface {
		public constructor(options?: Partial<AsyncInitableIfaceInitOptions>);
		/**
		 * The parent interface.
		 */
		public readonly g_iface: GObject.TypeInterface;
		public init_async: {(initable: AsyncInitable, io_priority: number, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;};
		public init_finish: {(initable: AsyncInitable, res: AsyncResult): boolean;};
	}

	export interface AsyncResultIfaceInitOptions {}
	/**
	 * Interface definition for #GAsyncResult.
	 */
	interface AsyncResultIface {}
	class AsyncResultIface {
		public constructor(options?: Partial<AsyncResultIfaceInitOptions>);
		/**
		 * The parent interface.
		 */
		public readonly g_iface: GObject.TypeInterface;
		public get_user_data: {(res: AsyncResult): any | null;};
		public get_source_object: {(res: AsyncResult): GObject.Object | null;};
		public is_tagged: {(res: AsyncResult, source_tag?: any | null): boolean;};
	}

	export interface ConverterIfaceInitOptions {}
	/**
	 * Provides an interface for converting data from one type
	 * to another type. The conversion can be stateful
	 * and may fail at any place.
	 */
	interface ConverterIface {}
	class ConverterIface {
		public constructor(options?: Partial<ConverterIfaceInitOptions>);
		/**
		 * The parent interface.
		 */
		public readonly g_iface: GObject.TypeInterface;
		public convert: {(converter: Converter, inbuf: number[] | null, outbuf: number[] | null, flags: ConverterFlags): [ ConverterResult, number, number ];};
		public reset: {(converter: Converter): void;};
	}

	export interface DBusAnnotationInfoInitOptions {}
	/**
	 * Information about an annotation.
	 */
	interface DBusAnnotationInfo {}
	class DBusAnnotationInfo {
		public constructor(options?: Partial<DBusAnnotationInfoInitOptions>);
		/**
		 * Looks up the value of an annotation.
		 * 
		 * The cost of this function is O(n) in number of annotations.
		 * @param annotations A %NULL-terminated array of annotations or %NULL.
		 * @param name The name of the annotation to look up.
		 * @returns The value or %NULL if not found. Do not free, it is owned by #annotations.
		 */
		public static lookup(annotations: DBusAnnotationInfo[] | null, name: string): string | null;
		/**
		 * The reference count or -1 if statically allocated.
		 */
		public ref_count: number;
		/**
		 * The name of the annotation, e.g. "org.freedesktop.DBus.Deprecated".
		 */
		public key: string;
		/**
		 * The value of the annotation.
		 */
		public value: string;
		/**
		 * A pointer to a %NULL-terminated array of pointers to #GDBusAnnotationInfo structures or %NULL if there are no annotations.
		 */
		public annotations: DBusAnnotationInfo[];
		/**
		 * If #info is statically allocated does nothing. Otherwise increases
		 * the reference count.
		 * @returns The same #info.
		 */
		public ref(): DBusAnnotationInfo;
		/**
		 * If #info is statically allocated, does nothing. Otherwise decreases
		 * the reference count of #info. When its reference count drops to 0,
		 * the memory used is freed.
		 */
		public unref(): void;
	}

	export interface DBusArgInfoInitOptions {}
	/**
	 * Information about an argument for a method or a signal.
	 */
	interface DBusArgInfo {}
	class DBusArgInfo {
		public constructor(options?: Partial<DBusArgInfoInitOptions>);
		/**
		 * The reference count or -1 if statically allocated.
		 */
		public ref_count: number;
		/**
		 * Name of the argument, e.g. #unix_user_id.
		 */
		public name: string;
		/**
		 * D-Bus signature of the argument (a single complete type).
		 */
		public signature: string;
		/**
		 * A pointer to a %NULL-terminated array of pointers to #GDBusAnnotationInfo structures or %NULL if there are no annotations.
		 */
		public annotations: DBusAnnotationInfo[];
		/**
		 * If #info is statically allocated does nothing. Otherwise increases
		 * the reference count.
		 * @returns The same #info.
		 */
		public ref(): DBusArgInfo;
		/**
		 * If #info is statically allocated, does nothing. Otherwise decreases
		 * the reference count of #info. When its reference count drops to 0,
		 * the memory used is freed.
		 */
		public unref(): void;
	}

	export interface DBusErrorEntryInitOptions {}
	/**
	 * Struct used in {@link G.dbus_error_register_error_domain}.
	 */
	interface DBusErrorEntry {}
	class DBusErrorEntry {
		public constructor(options?: Partial<DBusErrorEntryInitOptions>);
		/**
		 * An error code.
		 */
		public error_code: number;
		/**
		 * The D-Bus error name to associate with #error_code.
		 */
		public dbus_error_name: string;
	}

	export interface DBusInterfaceIfaceInitOptions {}
	/**
	 * Base type for D-Bus interfaces.
	 */
	interface DBusInterfaceIface {}
	class DBusInterfaceIface {
		public constructor(options?: Partial<DBusInterfaceIfaceInitOptions>);
		/**
		 * The parent interface.
		 */
		public readonly parent_iface: GObject.TypeInterface;
		public get_info: {(interface_: DBusInterface): DBusInterfaceInfo;};
		public get_object: {(interface_: DBusInterface): DBusObject | null;};
		public set_object: {(interface_: DBusInterface, object?: DBusObject | null): void;};
		public dup_object: {(interface_: DBusInterface): DBusObject | null;};
	}

	export interface DBusInterfaceInfoInitOptions {}
	/**
	 * Information about a D-Bus interface.
	 */
	interface DBusInterfaceInfo {}
	class DBusInterfaceInfo {
		public constructor(options?: Partial<DBusInterfaceInfoInitOptions>);
		/**
		 * The reference count or -1 if statically allocated.
		 */
		public ref_count: number;
		/**
		 * The name of the D-Bus interface, e.g. "org.freedesktop.DBus.Properties".
		 */
		public name: string;
		/**
		 * A pointer to a %NULL-terminated array of pointers to #GDBusMethodInfo structures or %NULL if there are no methods.
		 */
		public methods: DBusMethodInfo[];
		/**
		 * A pointer to a %NULL-terminated array of pointers to #GDBusSignalInfo structures or %NULL if there are no signals.
		 */
		public signals: DBusSignalInfo[];
		/**
		 * A pointer to a %NULL-terminated array of pointers to #GDBusPropertyInfo structures or %NULL if there are no properties.
		 */
		public properties: DBusPropertyInfo[];
		/**
		 * A pointer to a %NULL-terminated array of pointers to #GDBusAnnotationInfo structures or %NULL if there are no annotations.
		 */
		public annotations: DBusAnnotationInfo[];
		/**
		 * Builds a lookup-cache to speed up
		 * {@link G.dbus_interface_info_lookup_method},
		 * g_dbus_interface_info_lookup_signal() and
		 * g_dbus_interface_info_lookup_property().
		 * 
		 * If this has already been called with #info, the existing cache is
		 * used and its use count is increased.
		 * 
		 * Note that #info cannot be modified until
		 * g_dbus_interface_info_cache_release() is called.
		 */
		public cache_build(): void;
		/**
		 * Decrements the usage count for the cache for #info built by
		 * {@link G.dbus_interface_info_cache_build} (if any) and frees the
		 * resources used by the cache if the usage count drops to zero.
		 */
		public cache_release(): void;
		/**
		 * Appends an XML representation of #info (and its children) to #string_builder.
		 * 
		 * This function is typically used for generating introspection XML
		 * documents at run-time for handling the
		 * `org.freedesktop.DBus.Introspectable.Introspect`
		 * method.
		 * @param indent Indentation level.
		 * @param string_builder A #GString to to append XML data to.
		 */
		public generate_xml(indent: number, string_builder: GLib.String): void;
		/**
		 * Looks up information about a method.
		 * 
		 * The cost of this function is O(n) in number of methods unless
		 * {@link G.dbus_interface_info_cache_build} has been used on #info.
		 * @param name A D-Bus method name (typically in CamelCase)
		 * @returns A #GDBusMethodInfo or %NULL if not found. Do not free, it is owned by #info.
		 */
		public lookup_method(name: string): DBusMethodInfo | null;
		/**
		 * Looks up information about a property.
		 * 
		 * The cost of this function is O(n) in number of properties unless
		 * {@link G.dbus_interface_info_cache_build} has been used on #info.
		 * @param name A D-Bus property name (typically in CamelCase).
		 * @returns A #GDBusPropertyInfo or %NULL if not found. Do not free, it is owned by #info.
		 */
		public lookup_property(name: string): DBusPropertyInfo | null;
		/**
		 * Looks up information about a signal.
		 * 
		 * The cost of this function is O(n) in number of signals unless
		 * {@link G.dbus_interface_info_cache_build} has been used on #info.
		 * @param name A D-Bus signal name (typically in CamelCase)
		 * @returns A #GDBusSignalInfo or %NULL if not found. Do not free, it is owned by #info.
		 */
		public lookup_signal(name: string): DBusSignalInfo | null;
		/**
		 * If #info is statically allocated does nothing. Otherwise increases
		 * the reference count.
		 * @returns The same #info.
		 */
		public ref(): DBusInterfaceInfo;
		/**
		 * If #info is statically allocated, does nothing. Otherwise decreases
		 * the reference count of #info. When its reference count drops to 0,
		 * the memory used is freed.
		 */
		public unref(): void;
	}

	export interface DBusInterfaceVTableInitOptions {}
	/**
	 * Virtual table for handling properties and method calls for a D-Bus
	 * interface.
	 * 
	 * Since 2.38, if you want to handle getting/setting D-Bus properties
	 * asynchronously, give %NULL as your {@link Get.property} or set_property()
	 * function. The D-Bus call will be directed to your #method_call function,
	 * with the provided #interface_name set to "org.freedesktop.DBus.Properties".
	 * 
	 * Ownership of the #GDBusMethodInvocation object passed to the
	 * method_call() function is transferred to your handler; you must
	 * call one of the methods of #GDBusMethodInvocation to return a reply
	 * (possibly empty), or an error. These functions also take ownership
	 * of the passed-in invocation object, so unless the invocation
	 * object has otherwise been referenced, it will be then be freed.
	 * Calling one of these functions may be done within your
	 * method_call() implementation but it also can be done at a later
	 * point to handle the method asynchronously.
	 * 
	 * The usual checks on the validity of the calls is performed. For
	 * `Get` calls, an error is automatically returned if the property does
	 * not exist or the permissions do not allow access. The same checks are
	 * performed for `Set` calls, and the provided value is also checked for
	 * being the correct type.
	 * 
	 * For both `Get` and `Set` calls, the #GDBusMethodInvocation
	 * passed to the #method_call handler can be queried with
	 * g_dbus_method_invocation_get_property_info() to get a pointer
	 * to the #GDBusPropertyInfo of the property.
	 * 
	 * If you have readable properties specified in your interface info,
	 * you must ensure that you either provide a non-%NULL #get_property()
	 * function or provide implementations of both the `Get` and `GetAll`
	 * methods on org.freedesktop.DBus.Properties interface in your #method_call
	 * function. Note that the required return type of the `Get` call is
	 * `(v)`, not the type of the property. `GetAll` expects a return value
	 * of type `a{sv}`.
	 * 
	 * If you have writable properties specified in your interface info,
	 * you must ensure that you either provide a non-%NULL #set_property()
	 * function or provide an implementation of the `Set` call. If implementing
	 * the call, you must return the value of type %G_VARIANT_TYPE_UNIT.
	 */
	interface DBusInterfaceVTable {}
	class DBusInterfaceVTable {
		public constructor(options?: Partial<DBusInterfaceVTableInitOptions>);
		/**
		 * Function for handling incoming method calls.
		 */
		public method_call: DBusInterfaceMethodCallFunc;
		/**
		 * Function for getting a property.
		 */
		public get_property: DBusInterfaceGetPropertyFunc;
		/**
		 * Function for setting a property.
		 */
		public set_property: DBusInterfaceSetPropertyFunc;
		public readonly padding: any[];
	}

	export interface DBusMethodInfoInitOptions {}
	/**
	 * Information about a method on an D-Bus interface.
	 */
	interface DBusMethodInfo {}
	class DBusMethodInfo {
		public constructor(options?: Partial<DBusMethodInfoInitOptions>);
		/**
		 * The reference count or -1 if statically allocated.
		 */
		public ref_count: number;
		/**
		 * The name of the D-Bus method, e.g. #RequestName.
		 */
		public name: string;
		/**
		 * A pointer to a %NULL-terminated array of pointers to #GDBusArgInfo structures or %NULL if there are no in arguments.
		 */
		public in_args: DBusArgInfo[];
		/**
		 * A pointer to a %NULL-terminated array of pointers to #GDBusArgInfo structures or %NULL if there are no out arguments.
		 */
		public out_args: DBusArgInfo[];
		/**
		 * A pointer to a %NULL-terminated array of pointers to #GDBusAnnotationInfo structures or %NULL if there are no annotations.
		 */
		public annotations: DBusAnnotationInfo[];
		/**
		 * If #info is statically allocated does nothing. Otherwise increases
		 * the reference count.
		 * @returns The same #info.
		 */
		public ref(): DBusMethodInfo;
		/**
		 * If #info is statically allocated, does nothing. Otherwise decreases
		 * the reference count of #info. When its reference count drops to 0,
		 * the memory used is freed.
		 */
		public unref(): void;
	}

	export interface DBusNodeInfoInitOptions {}
	/**
	 * Information about nodes in a remote object hierarchy.
	 */
	interface DBusNodeInfo {}
	class DBusNodeInfo {
		public constructor(options?: Partial<DBusNodeInfoInitOptions>);
		/**
		 * Parses #xml_data and returns a #GDBusNodeInfo representing the data.
		 * 
		 * The introspection XML must contain exactly one top-level
		 * <node> element.
		 * 
		 * Note that this routine is using a
		 * [GMarkup][glib-Simple-XML-Subset-Parser.description]-based
		 * parser that only accepts a subset of valid XML documents.
		 * @param xml_data Valid D-Bus introspection XML.
		 * @returns A #GDBusNodeInfo structure or %NULL if #error is set. Free
		 * with {@link G.dbus_node_info_unref}.
		 */
		public static new_for_xml(xml_data: string): DBusNodeInfo;
		/**
		 * The reference count or -1 if statically allocated.
		 */
		public ref_count: number;
		/**
		 * The path of the node or %NULL if omitted. Note that this may be a relative path. See the D-Bus specification for more details.
		 */
		public path: string;
		/**
		 * A pointer to a %NULL-terminated array of pointers to #GDBusInterfaceInfo structures or %NULL if there are no interfaces.
		 */
		public interfaces: DBusInterfaceInfo[];
		/**
		 * A pointer to a %NULL-terminated array of pointers to #GDBusNodeInfo structures or %NULL if there are no nodes.
		 */
		public nodes: DBusNodeInfo[];
		/**
		 * A pointer to a %NULL-terminated array of pointers to #GDBusAnnotationInfo structures or %NULL if there are no annotations.
		 */
		public annotations: DBusAnnotationInfo[];
		/**
		 * Appends an XML representation of #info (and its children) to #string_builder.
		 * 
		 * This function is typically used for generating introspection XML documents at run-time for
		 * handling the `org.freedesktop.DBus.Introspectable.Introspect`  method.
		 * @param indent Indentation level.
		 * @param string_builder A #GString to to append XML data to.
		 */
		public generate_xml(indent: number, string_builder: GLib.String): void;
		/**
		 * Looks up information about an interface.
		 * 
		 * The cost of this function is O(n) in number of interfaces.
		 * @param name A D-Bus interface name.
		 * @returns A #GDBusInterfaceInfo or %NULL if not found. Do not free, it is owned by #info.
		 */
		public lookup_interface(name: string): DBusInterfaceInfo | null;
		/**
		 * If #info is statically allocated does nothing. Otherwise increases
		 * the reference count.
		 * @returns The same #info.
		 */
		public ref(): DBusNodeInfo;
		/**
		 * If #info is statically allocated, does nothing. Otherwise decreases
		 * the reference count of #info. When its reference count drops to 0,
		 * the memory used is freed.
		 */
		public unref(): void;
	}

	export interface DBusObjectIfaceInitOptions {}
	/**
	 * Base object type for D-Bus objects.
	 */
	interface DBusObjectIface {}
	class DBusObjectIface {
		public constructor(options?: Partial<DBusObjectIfaceInitOptions>);
		/**
		 * The parent interface.
		 */
		public readonly parent_iface: GObject.TypeInterface;
		public get_object_path: {(object: DBusObject): string;};
		public get_interfaces: {(object: DBusObject): DBusInterface[];};
		public get_interface: {(object: DBusObject, interface_name: string): DBusInterface | null;};
		public interface_added: {(object: DBusObject, interface_: DBusInterface): void;};
		public interface_removed: {(object: DBusObject, interface_: DBusInterface): void;};
	}

	export interface DBusObjectManagerIfaceInitOptions {}
	/**
	 * Base type for D-Bus object managers.
	 */
	interface DBusObjectManagerIface {}
	class DBusObjectManagerIface {
		public constructor(options?: Partial<DBusObjectManagerIfaceInitOptions>);
		/**
		 * The parent interface.
		 */
		public readonly parent_iface: GObject.TypeInterface;
		public get_object_path: {(manager: DBusObjectManager): string;};
		public get_objects: {(manager: DBusObjectManager): DBusObject[];};
		public get_object: {(manager: DBusObjectManager, object_path: string): DBusObject | null;};
		public get_interface: {(manager: DBusObjectManager, object_path: string, interface_name: string): DBusInterface | null;};
		public object_added: {(manager: DBusObjectManager, object: DBusObject): void;};
		public object_removed: {(manager: DBusObjectManager, object: DBusObject): void;};
		public interface_added: {(manager: DBusObjectManager, object: DBusObject, interface_: DBusInterface): void;};
		public interface_removed: {(manager: DBusObjectManager, object: DBusObject, interface_: DBusInterface): void;};
	}

	export interface DBusPropertyInfoInitOptions {}
	/**
	 * Information about a D-Bus property on a D-Bus interface.
	 */
	interface DBusPropertyInfo {}
	class DBusPropertyInfo {
		public constructor(options?: Partial<DBusPropertyInfoInitOptions>);
		/**
		 * The reference count or -1 if statically allocated.
		 */
		public ref_count: number;
		/**
		 * The name of the D-Bus property, e.g. "SupportedFilesystems".
		 */
		public name: string;
		/**
		 * The D-Bus signature of the property (a single complete type).
		 */
		public signature: string;
		/**
		 * Access control flags for the property.
		 */
		public flags: DBusPropertyInfoFlags;
		/**
		 * A pointer to a %NULL-terminated array of pointers to #GDBusAnnotationInfo structures or %NULL if there are no annotations.
		 */
		public annotations: DBusAnnotationInfo[];
		/**
		 * If #info is statically allocated does nothing. Otherwise increases
		 * the reference count.
		 * @returns The same #info.
		 */
		public ref(): DBusPropertyInfo;
		/**
		 * If #info is statically allocated, does nothing. Otherwise decreases
		 * the reference count of #info. When its reference count drops to 0,
		 * the memory used is freed.
		 */
		public unref(): void;
	}

	export interface DBusSignalInfoInitOptions {}
	/**
	 * Information about a signal on a D-Bus interface.
	 */
	interface DBusSignalInfo {}
	class DBusSignalInfo {
		public constructor(options?: Partial<DBusSignalInfoInitOptions>);
		/**
		 * The reference count or -1 if statically allocated.
		 */
		public ref_count: number;
		/**
		 * The name of the D-Bus signal, e.g. "NameOwnerChanged".
		 */
		public name: string;
		/**
		 * A pointer to a %NULL-terminated array of pointers to #GDBusArgInfo structures or %NULL if there are no arguments.
		 */
		public args: DBusArgInfo[];
		/**
		 * A pointer to a %NULL-terminated array of pointers to #GDBusAnnotationInfo structures or %NULL if there are no annotations.
		 */
		public annotations: DBusAnnotationInfo[];
		/**
		 * If #info is statically allocated does nothing. Otherwise increases
		 * the reference count.
		 * @returns The same #info.
		 */
		public ref(): DBusSignalInfo;
		/**
		 * If #info is statically allocated, does nothing. Otherwise decreases
		 * the reference count of #info. When its reference count drops to 0,
		 * the memory used is freed.
		 */
		public unref(): void;
	}

	export interface DBusSubtreeVTableInitOptions {}
	/**
	 * Virtual table for handling subtrees registered with {@link G.dbus_connection_register_subtree}.
	 */
	interface DBusSubtreeVTable {}
	class DBusSubtreeVTable {
		public constructor(options?: Partial<DBusSubtreeVTableInitOptions>);
		/**
		 * Function for enumerating child nodes.
		 */
		public enumerate: DBusSubtreeEnumerateFunc;
		/**
		 * Function for introspecting a child node.
		 */
		public introspect: DBusSubtreeIntrospectFunc;
		/**
		 * Function for dispatching a remote call on a child node.
		 */
		public dispatch: DBusSubtreeDispatchFunc;
		public readonly padding: any[];
	}

	export interface DatagramBasedInterfaceInitOptions {}
	/**
	 * Provides an interface for socket-like objects which have datagram semantics,
	 * following the Berkeley sockets API. The interface methods are thin wrappers
	 * around the corresponding virtual methods, and no pre-processing of inputs is
	 * implemented — so implementations of this API must handle all functionality
	 * documented in the interface methods.
	 */
	interface DatagramBasedInterface {}
	class DatagramBasedInterface {
		public constructor(options?: Partial<DatagramBasedInterfaceInitOptions>);
		/**
		 * The parent interface.
		 */
		public readonly g_iface: GObject.TypeInterface;
		public receive_messages: {(datagram_based: DatagramBased, messages: InputMessage[], flags: number, timeout: number, cancellable?: Cancellable | null): number;};
		public send_messages: {(datagram_based: DatagramBased, messages: OutputMessage[], flags: number, timeout: number, cancellable?: Cancellable | null): number;};
		public create_source: {(datagram_based: DatagramBased, condition: GLib.IOCondition, cancellable?: Cancellable | null): GLib.Source;};
		public condition_check: {(datagram_based: DatagramBased, condition: GLib.IOCondition): GLib.IOCondition;};
		public condition_wait: {(datagram_based: DatagramBased, condition: GLib.IOCondition, timeout: number, cancellable?: Cancellable | null): boolean;};
	}

	export interface DesktopAppInfoLookupIfaceInitOptions {}
	/**
	 * Interface that is used by backends to associate default
	 * handlers with URI schemes.
	 */
	interface DesktopAppInfoLookupIface {}
	class DesktopAppInfoLookupIface {
		public constructor(options?: Partial<DesktopAppInfoLookupIfaceInitOptions>);
		public readonly g_iface: GObject.TypeInterface;
		public get_default_for_uri_scheme: {(lookup: DesktopAppInfoLookup, uri_scheme: string): AppInfo | null;};
	}

	export interface DriveIfaceInitOptions {}
	/**
	 * Interface for creating #GDrive implementations.
	 */
	interface DriveIface {}
	class DriveIface {
		public constructor(options?: Partial<DriveIfaceInitOptions>);
		/**
		 * The parent interface.
		 */
		public readonly g_iface: GObject.TypeInterface;
		public changed: {(drive: Drive): void;};
		public disconnected: {(drive: Drive): void;};
		public eject_button: {(drive: Drive): void;};
		public get_name: {(drive: Drive): string;};
		public get_icon: {(drive: Drive): Icon;};
		public has_volumes: {(drive: Drive): boolean;};
		public get_volumes: {(drive: Drive): Volume[];};
		public is_media_removable: {(drive: Drive): boolean;};
		public has_media: {(drive: Drive): boolean;};
		public is_media_check_automatic: {(drive: Drive): boolean;};
		public can_eject: {(drive: Drive): boolean;};
		public can_poll_for_media: {(drive: Drive): boolean;};
		public eject: {(drive: Drive, flags: MountUnmountFlags, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;};
		public eject_finish: {(drive: Drive, result: AsyncResult): boolean;};
		public poll_for_media: {(drive: Drive, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;};
		public poll_for_media_finish: {(drive: Drive, result: AsyncResult): boolean;};
		public get_identifier: {(drive: Drive, kind: string): string | null;};
		public enumerate_identifiers: {(drive: Drive): string[];};
		public get_start_stop_type: {(drive: Drive): DriveStartStopType;};
		public can_start: {(drive: Drive): boolean;};
		public can_start_degraded: {(drive: Drive): boolean;};
		public start: {(drive: Drive, flags: DriveStartFlags, mount_operation?: MountOperation | null, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;};
		public start_finish: {(drive: Drive, result: AsyncResult): boolean;};
		public can_stop: {(drive: Drive): boolean;};
		public stop: {(drive: Drive, flags: MountUnmountFlags, mount_operation?: MountOperation | null, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;};
		public stop_finish: {(drive: Drive, result: AsyncResult): boolean;};
		public stop_button: {(drive: Drive): void;};
		public eject_with_operation: {(drive: Drive, flags: MountUnmountFlags, mount_operation?: MountOperation | null, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;};
		public eject_with_operation_finish: {(drive: Drive, result: AsyncResult): boolean;};
		public get_sort_key: {(drive: Drive): string | null;};
		public get_symbolic_icon: {(drive: Drive): Icon;};
		public is_removable: {(drive: Drive): boolean;};
	}

	export interface DtlsClientConnectionInterfaceInitOptions {}
	/**
	 * vtable for a #GDtlsClientConnection implementation.
	 */
	interface DtlsClientConnectionInterface {}
	class DtlsClientConnectionInterface {
		public constructor(options?: Partial<DtlsClientConnectionInterfaceInitOptions>);
		/**
		 * The parent interface.
		 */
		public readonly g_iface: GObject.TypeInterface;
	}

	export interface DtlsConnectionInterfaceInitOptions {}
	/**
	 * Virtual method table for a #GDtlsConnection implementation.
	 */
	interface DtlsConnectionInterface {}
	class DtlsConnectionInterface {
		public constructor(options?: Partial<DtlsConnectionInterfaceInitOptions>);
		/**
		 * The parent interface.
		 */
		public readonly g_iface: GObject.TypeInterface;
		public accept_certificate: {(connection: DtlsConnection, peer_cert: TlsCertificate, errors: TlsCertificateFlags): boolean;};
		public handshake: {(conn: DtlsConnection, cancellable?: Cancellable | null): boolean;};
		public handshake_async: {(conn: DtlsConnection, io_priority: number, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;};
		public handshake_finish: {(conn: DtlsConnection, result: AsyncResult): boolean;};
		public shutdown: {(conn: DtlsConnection, shutdown_read: boolean, shutdown_write: boolean, cancellable?: Cancellable | null): boolean;};
		public shutdown_async: {(conn: DtlsConnection, shutdown_read: boolean, shutdown_write: boolean, io_priority: number, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;};
		public shutdown_finish: {(conn: DtlsConnection, result: AsyncResult): boolean;};
		public set_advertised_protocols: {(conn: DtlsConnection, protocols?: string[] | null): void;};
		public get_negotiated_protocol: {(conn: DtlsConnection): string | null;};
		public get_binding_data: {(conn: DtlsConnection, type: TlsChannelBindingType, data: number[]): boolean;};
	}

	export interface DtlsServerConnectionInterfaceInitOptions {}
	/**
	 * vtable for a #GDtlsServerConnection implementation.
	 */
	interface DtlsServerConnectionInterface {}
	class DtlsServerConnectionInterface {
		public constructor(options?: Partial<DtlsServerConnectionInterfaceInitOptions>);
		/**
		 * The parent interface.
		 */
		public readonly g_iface: GObject.TypeInterface;
	}

	export interface FileAttributeInfoInitOptions {}
	/**
	 * Information about a specific attribute.
	 */
	interface FileAttributeInfo {}
	class FileAttributeInfo {
		public constructor(options?: Partial<FileAttributeInfoInitOptions>);
		/**
		 * the name of the attribute.
		 */
		public name: string;
		/**
		 * the #GFileAttributeType type of the attribute.
		 */
		public type: FileAttributeType;
		/**
		 * a set of #GFileAttributeInfoFlags.
		 */
		public flags: FileAttributeInfoFlags;
	}

	export interface FileAttributeInfoListInitOptions {}
	/**
	 * Acts as a lightweight registry for possible valid file attributes.
	 * The registry stores Key-Value pair formats as #GFileAttributeInfos.
	 */
	interface FileAttributeInfoList {}
	class FileAttributeInfoList {
		public constructor(options?: Partial<FileAttributeInfoListInitOptions>);
		/**
		 * Creates a new file attribute info list.
		 * @returns a #GFileAttributeInfoList.
		 */
		public static new(): FileAttributeInfoList;
		/**
		 * an array of #GFileAttributeInfos.
		 */
		public infos: FileAttributeInfo;
		/**
		 * the number of values in the array.
		 */
		public n_infos: number;
		/**
		 * Adds a new attribute with #name to the #list, setting
		 * its #type and #flags.
		 * @param name the name of the attribute to add.
		 * @param type the #GFileAttributeType for the attribute.
		 * @param flags #GFileAttributeInfoFlags for the attribute.
		 */
		public add(name: string, type: FileAttributeType, flags: FileAttributeInfoFlags): void;
		/**
		 * Makes a duplicate of a file attribute info list.
		 * @returns a copy of the given #list.
		 */
		public dup(): FileAttributeInfoList;
		/**
		 * Gets the file attribute with the name #name from #list.
		 * @param name the name of the attribute to look up.
		 * @returns a #GFileAttributeInfo for the #name, or %NULL if an
		 * attribute isn't found.
		 */
		public lookup(name: string): FileAttributeInfo;
		/**
		 * References a file attribute info list.
		 * @returns #GFileAttributeInfoList or %NULL on error.
		 */
		public ref(): FileAttributeInfoList;
		/**
		 * Removes a reference from the given #list. If the reference count
		 * falls to zero, the #list is deleted.
		 */
		public unref(): void;
	}

	export interface FileAttributeMatcherInitOptions {}
	/**
	 * Determines if a string matches a file attribute.
	 */
	interface FileAttributeMatcher {}
	class FileAttributeMatcher {
		public constructor(options?: Partial<FileAttributeMatcherInitOptions>);
		/**
		 * Creates a new file attribute matcher, which matches attributes
		 * against a given string. #GFileAttributeMatchers are reference
		 * counted structures, and are created with a reference count of 1. If
		 * the number of references falls to 0, the #GFileAttributeMatcher is
		 * automatically destroyed.
		 * 
		 * The #attributes string should be formatted with specific keys separated
		 * from namespaces with a double colon. Several "namespace::key" strings may be
		 * concatenated with a single comma (e.g. "standard::type,standard::is-hidden").
		 * The wildcard "*" may be used to match all keys and namespaces, or
		 * "namespace::*" will match all keys in a given namespace.
		 * 
		 * ## Examples of file attribute matcher strings and results
		 * 
		 * - `"*"`: matches all attributes.
		 * - `"standard::is-hidden"`: matches only the key is-hidden in the
		 *   standard namespace.
		 * - `"standard::type,unix::*"`: matches the type key in the standard
		 *   namespace and all keys in the unix namespace.
		 * @param attributes an attribute string to match.
		 * @returns a #GFileAttributeMatcher
		 */
		public static new(attributes: string): FileAttributeMatcher;
		/**
		 * Checks if the matcher will match all of the keys in a given namespace.
		 * This will always return %TRUE if a wildcard character is in use (e.g. if
		 * matcher was created with "standard::*" and #ns is "standard", or if matcher was created
		 * using "*" and namespace is anything.)
		 * 
		 * TODO: this is awkwardly worded.
		 * @param ns a string containing a file attribute namespace.
		 * @returns %TRUE if the matcher matches all of the entries
		 * in the given #ns, %FALSE otherwise.
		 */
		public enumerate_namespace(ns: string): boolean;
		/**
		 * Gets the next matched attribute from a #GFileAttributeMatcher.
		 * @returns a string containing the next attribute or, %NULL if
		 * no more attribute exist.
		 */
		public enumerate_next(): string | null;
		/**
		 * Checks if an attribute will be matched by an attribute matcher. If
		 * the matcher was created with the "*" matching string, this function
		 * will always return %TRUE.
		 * @param attribute a file attribute key.
		 * @returns %TRUE if #attribute matches #matcher. %FALSE otherwise.
		 */
		public matches(attribute: string): boolean;
		/**
		 * Checks if a attribute matcher only matches a given attribute. Always
		 * returns %FALSE if "*" was used when creating the matcher.
		 * @param attribute a file attribute key.
		 * @returns %TRUE if the matcher only matches #attribute. %FALSE otherwise.
		 */
		public matches_only(attribute: string): boolean;
		/**
		 * References a file attribute matcher.
		 * @returns a #GFileAttributeMatcher.
		 */
		public ref(): FileAttributeMatcher;
		/**
		 * Subtracts all attributes of #subtract from #matcher and returns
		 * a matcher that supports those attributes.
		 * 
		 * Note that currently it is not possible to remove a single
		 * attribute when the #matcher matches the whole namespace - or remove
		 * a namespace or attribute when the matcher matches everything. This
		 * is a limitation of the current implementation, but may be fixed
		 * in the future.
		 * @param subtract The matcher to subtract
		 * @returns A file attribute matcher matching all attributes of
		 *     #matcher that are not matched by #subtract
		 */
		public subtract(subtract?: FileAttributeMatcher | null): FileAttributeMatcher | null;
		/**
		 * Prints what the matcher is matching against. The format will be
		 * equal to the format passed to {@link G.file_attribute_matcher_new}.
		 * The output however, might not be identical, as the matcher may
		 * decide to use a different order or omit needless parts.
		 * @returns a string describing the attributes the matcher matches
		 *   against or %NULL if #matcher was %NULL.
		 */
		public to_string(): string;
		/**
		 * Unreferences #matcher. If the reference count falls below 1,
		 * the #matcher is automatically freed.
		 */
		public unref(): void;
	}

	export interface FileDescriptorBasedIfaceInitOptions {}
	/**
	 * An interface for file descriptor based io objects.
	 */
	interface FileDescriptorBasedIface {}
	class FileDescriptorBasedIface {
		public constructor(options?: Partial<FileDescriptorBasedIfaceInitOptions>);
		/**
		 * The parent interface.
		 */
		public readonly g_iface: GObject.TypeInterface;
		public get_fd: {(fd_based: FileDescriptorBased): number;};
	}

	export interface FileIfaceInitOptions {}
	/**
	 * An interface for writing VFS file handles.
	 */
	interface FileIface {}
	class FileIface {
		public constructor(options?: Partial<FileIfaceInitOptions>);
		/**
		 * The parent interface.
		 */
		public readonly g_iface: GObject.TypeInterface;
		/**
		 * a boolean that indicates whether the #GFile implementation supports thread-default contexts. Since 2.22.
		 */
		public readonly supports_thread_contexts: boolean;
		public dup: {(file: File): File;};
		public hash: {(file: File): number;};
		public equal: {(file1: File, file2: File): boolean;};
		public is_native: {(file: File): boolean;};
		public has_uri_scheme: {(file: File, uri_scheme: string): boolean;};
		public get_uri_scheme: {(file: File): string | null;};
		public get_basename: {(file: File): string | null;};
		public get_path: {(file: File): string | null;};
		public get_uri: {(file: File): string;};
		public get_parse_name: {(file: File): string;};
		public get_parent: {(file: File): File | null;};
		public prefix_matches: {(prefix: File, file: File): boolean;};
		public get_relative_path: {(parent: File, descendant: File): string | null;};
		public resolve_relative_path: {(file: File, relative_path: string): File;};
		public get_child_for_display_name: {(file: File, display_name: string): File;};
		public enumerate_children: {(file: File, attributes: string, flags: FileQueryInfoFlags, cancellable?: Cancellable | null): FileEnumerator;};
		public enumerate_children_async: {(file: File, attributes: string, flags: FileQueryInfoFlags, io_priority: number, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;};
		public enumerate_children_finish: {(file: File, res: AsyncResult): FileEnumerator;};
		public query_info: {(file: File, attributes: string, flags: FileQueryInfoFlags, cancellable?: Cancellable | null): FileInfo;};
		public query_info_async: {(file: File, attributes: string, flags: FileQueryInfoFlags, io_priority: number, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;};
		public query_info_finish: {(file: File, res: AsyncResult): FileInfo;};
		public query_filesystem_info: {(file: File, attributes: string, cancellable?: Cancellable | null): FileInfo;};
		public query_filesystem_info_async: {(file: File, attributes: string, io_priority: number, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;};
		public query_filesystem_info_finish: {(file: File, res: AsyncResult): FileInfo;};
		public find_enclosing_mount: {(file: File, cancellable?: Cancellable | null): Mount;};
		public find_enclosing_mount_async: {(file: File, io_priority: number, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;};
		public find_enclosing_mount_finish: {(file: File, res: AsyncResult): Mount;};
		public set_display_name: {(file: File, display_name: string, cancellable?: Cancellable | null): File;};
		public set_display_name_async: {(file: File, display_name: string, io_priority: number, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;};
		public set_display_name_finish: {(file: File, res: AsyncResult): File;};
		public query_settable_attributes: {(file: File, cancellable?: Cancellable | null): FileAttributeInfoList;};
		public _query_settable_attributes_async: {(): void;};
		public _query_settable_attributes_finish: {(): void;};
		public query_writable_namespaces: {(file: File, cancellable?: Cancellable | null): FileAttributeInfoList;};
		public _query_writable_namespaces_async: {(): void;};
		public _query_writable_namespaces_finish: {(): void;};
		public set_attribute: {(file: File, attribute: string, type: FileAttributeType, value_p: any | null, flags: FileQueryInfoFlags, cancellable?: Cancellable | null): boolean;};
		public set_attributes_from_info: {(file: File, info: FileInfo, flags: FileQueryInfoFlags, cancellable?: Cancellable | null): boolean;};
		public set_attributes_async: {(file: File, info: FileInfo, flags: FileQueryInfoFlags, io_priority: number, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;};
		public set_attributes_finish: {(file: File, result: AsyncResult): [ boolean, FileInfo ];};
		public read_fn: {(file: File, cancellable?: Cancellable | null): FileInputStream;};
		public read_async: {(file: File, io_priority: number, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;};
		public read_finish: {(file: File, res: AsyncResult): FileInputStream;};
		public append_to: {(file: File, flags: FileCreateFlags, cancellable?: Cancellable | null): FileOutputStream;};
		public append_to_async: {(file: File, flags: FileCreateFlags, io_priority: number, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;};
		public append_to_finish: {(file: File, res: AsyncResult): FileOutputStream;};
		public create: {(file: File, flags: FileCreateFlags, cancellable?: Cancellable | null): FileOutputStream;};
		public create_async: {(file: File, flags: FileCreateFlags, io_priority: number, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;};
		public create_finish: {(file: File, res: AsyncResult): FileOutputStream;};
		public replace: {(file: File, etag: string | null, make_backup: boolean, flags: FileCreateFlags, cancellable?: Cancellable | null): FileOutputStream;};
		public replace_async: {(file: File, etag: string | null, make_backup: boolean, flags: FileCreateFlags, io_priority: number, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;};
		public replace_finish: {(file: File, res: AsyncResult): FileOutputStream;};
		public delete_file: {(file: File, cancellable?: Cancellable | null): boolean;};
		public delete_file_async: {(file: File, io_priority: number, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;};
		public delete_file_finish: {(file: File, result: AsyncResult): boolean;};
		public trash: {(file: File, cancellable?: Cancellable | null): boolean;};
		public trash_async: {(file: File, io_priority: number, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;};
		public trash_finish: {(file: File, result: AsyncResult): boolean;};
		public make_directory: {(file: File, cancellable?: Cancellable | null): boolean;};
		public make_directory_async: {(file: File, io_priority: number, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;};
		public make_directory_finish: {(file: File, result: AsyncResult): boolean;};
		public make_symbolic_link: {(file: File, symlink_value: string, cancellable?: Cancellable | null): boolean;};
		public _make_symbolic_link_async: {(): void;};
		public _make_symbolic_link_finish: {(): void;};
		public copy: {(source: File, destination: File, flags: FileCopyFlags, cancellable?: Cancellable | null, progress_callback?: FileProgressCallback | null): boolean;};
		public copy_async: {(source: File, destination: File, flags: FileCopyFlags, io_priority: number, cancellable?: Cancellable | null): void;};
		public copy_finish: {(file: File, res: AsyncResult): boolean;};
		public move: {(source: File, destination: File, flags: FileCopyFlags, cancellable?: Cancellable | null, progress_callback?: FileProgressCallback | null): boolean;};
		public _move_async: {(): void;};
		public _move_finish: {(): void;};
		public mount_mountable: {(file: File, flags: MountMountFlags, mount_operation?: MountOperation | null, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;};
		public mount_mountable_finish: {(file: File, result: AsyncResult): File;};
		public unmount_mountable: {(file: File, flags: MountUnmountFlags, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;};
		public unmount_mountable_finish: {(file: File, result: AsyncResult): boolean;};
		public eject_mountable: {(file: File, flags: MountUnmountFlags, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;};
		public eject_mountable_finish: {(file: File, result: AsyncResult): boolean;};
		public mount_enclosing_volume: {(location: File, flags: MountMountFlags, mount_operation?: MountOperation | null, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;};
		public mount_enclosing_volume_finish: {(location: File, result: AsyncResult): boolean;};
		public monitor_dir: {(file: File, flags: FileMonitorFlags, cancellable?: Cancellable | null): FileMonitor;};
		public monitor_file: {(file: File, flags: FileMonitorFlags, cancellable?: Cancellable | null): FileMonitor;};
		public open_readwrite: {(file: File, cancellable?: Cancellable | null): FileIOStream;};
		public open_readwrite_async: {(file: File, io_priority: number, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;};
		public open_readwrite_finish: {(file: File, res: AsyncResult): FileIOStream;};
		public create_readwrite: {(file: File, flags: FileCreateFlags, cancellable?: Cancellable | null): FileIOStream;};
		public create_readwrite_async: {(file: File, flags: FileCreateFlags, io_priority: number, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;};
		public create_readwrite_finish: {(file: File, res: AsyncResult): FileIOStream;};
		public replace_readwrite: {(file: File, etag: string | null, make_backup: boolean, flags: FileCreateFlags, cancellable?: Cancellable | null): FileIOStream;};
		public replace_readwrite_async: {(file: File, etag: string | null, make_backup: boolean, flags: FileCreateFlags, io_priority: number, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;};
		public replace_readwrite_finish: {(file: File, res: AsyncResult): FileIOStream;};
		public start_mountable: {(file: File, flags: DriveStartFlags, start_operation?: MountOperation | null, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;};
		public start_mountable_finish: {(file: File, result: AsyncResult): boolean;};
		public stop_mountable: {(file: File, flags: MountUnmountFlags, mount_operation?: MountOperation | null, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;};
		public stop_mountable_finish: {(file: File, result: AsyncResult): boolean;};
		public unmount_mountable_with_operation: {(file: File, flags: MountUnmountFlags, mount_operation?: MountOperation | null, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;};
		public unmount_mountable_with_operation_finish: {(file: File, result: AsyncResult): boolean;};
		public eject_mountable_with_operation: {(file: File, flags: MountUnmountFlags, mount_operation?: MountOperation | null, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;};
		public eject_mountable_with_operation_finish: {(file: File, result: AsyncResult): boolean;};
		public poll_mountable: {(file: File, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;};
		public poll_mountable_finish: {(file: File, result: AsyncResult): boolean;};
		public measure_disk_usage: {(file: File, flags: FileMeasureFlags, cancellable?: Cancellable | null, progress_callback?: FileMeasureProgressCallback | null): [ boolean, number | null, number | null, number | null ];};
		public measure_disk_usage_async: {(file: File, flags: FileMeasureFlags, io_priority: number, cancellable?: Cancellable | null, progress_callback?: FileMeasureProgressCallback | null, callback?: AsyncReadyCallback | null): void;};
		public measure_disk_usage_finish: {(file: File, result: AsyncResult): [ boolean, number | null, number | null, number | null ];};
	}

	export interface IOExtensionInitOptions {}
	/**
	 * #GIOExtension is an opaque data structure and can only be accessed
	 * using the following functions.
	 */
	interface IOExtension {}
	class IOExtension {
		public constructor(options?: Partial<IOExtensionInitOptions>);
		/**
		 * Gets the name under which #extension was registered.
		 * 
		 * Note that the same type may be registered as extension
		 * for multiple extension points, under different names.
		 * @returns the name of #extension.
		 */
		public get_name(): string;
		/**
		 * Gets the priority with which #extension was registered.
		 * @returns the priority of #extension
		 */
		public get_priority(): number;
		/**
		 * Gets the type associated with #extension.
		 * @returns the type of #extension
		 */
		public get_type(): GObject.Type;
		/**
		 * Gets a reference to the class for the type that is
		 * associated with #extension.
		 * @returns the #GTypeClass for the type of #extension
		 */
		public ref_class(): GObject.TypeClass;
	}

	export interface IOExtensionPointInitOptions {}
	/**
	 * #GIOExtensionPoint is an opaque data structure and can only be accessed
	 * using the following functions.
	 */
	interface IOExtensionPoint {}
	class IOExtensionPoint {
		public constructor(options?: Partial<IOExtensionPointInitOptions>);
		/**
		 * Registers #type as extension for the extension point with name
		 * #extension_point_name.
		 * 
		 * If #type has already been registered as an extension for this
		 * extension point, the existing #GIOExtension object is returned.
		 * @param extension_point_name the name of the extension point
		 * @param type the #GType to register as extension
		 * @param extension_name the name for the extension
		 * @param priority the priority for the extension
		 * @returns a #GIOExtension object for #GType
		 */
		public static implement(extension_point_name: string, type: GObject.Type, extension_name: string, priority: number): IOExtension;
		/**
		 * Looks up an existing extension point.
		 * @param name the name of the extension point
		 * @returns the #GIOExtensionPoint, or %NULL if there
		 *    is no registered extension point with the given name.
		 */
		public static lookup(name: string): IOExtensionPoint;
		/**
		 * Registers an extension point.
		 * @param name The name of the extension point
		 * @returns the new #GIOExtensionPoint. This object is
		 *    owned by GIO and should not be freed.
		 */
		public static register(name: string): IOExtensionPoint;
		/**
		 * Finds a #GIOExtension for an extension point by name.
		 * @param name the name of the extension to get
		 * @returns the #GIOExtension for #extension_point that has the
		 *    given name, or %NULL if there is no extension with that name
		 */
		public get_extension_by_name(name: string): IOExtension;
		/**
		 * Gets a list of all extensions that implement this extension point.
		 * The list is sorted by priority, beginning with the highest priority.
		 * @returns a #GList of
		 *     #GIOExtensions. The list is owned by GIO and should not be
		 *     modified.
		 */
		public get_extensions(): IOExtension[];
		/**
		 * Gets the required type for #extension_point.
		 * @returns the #GType that all implementations must have,
		 *     or #G_TYPE_INVALID if the extension point has no required type
		 */
		public get_required_type(): GObject.Type;
		/**
		 * Sets the required type for #extension_point to #type.
		 * All implementations must henceforth have this type.
		 * @param type the #GType to require
		 */
		public set_required_type(type: GObject.Type): void;
	}

	export interface IOModuleScopeInitOptions {}
	/**
	 * Represents a scope for loading IO modules. A scope can be used for blocking
	 * duplicate modules, or blocking a module you don't want to load.
	 * 
	 * The scope can be used with {@link G.io_modules_load_all_in_directory_with_scope}
	 * or g_io_modules_scan_all_in_directory_with_scope().
	 */
	interface IOModuleScope {}
	class IOModuleScope {
		public constructor(options?: Partial<IOModuleScopeInitOptions>);
		/**
		 * Create a new scope for loading of IO modules. A scope can be used for
		 * blocking duplicate modules, or blocking a module you don't want to load.
		 * 
		 * Specify the %G_IO_MODULE_SCOPE_BLOCK_DUPLICATES flag to block modules
		 * which have the same base name as a module that has already been seen
		 * in this scope.
		 * @param flags flags for the new scope
		 * @returns the new module scope
		 */
		public static new(flags: IOModuleScopeFlags): IOModuleScope;
		/**
		 * Block modules with the given #basename from being loaded when
		 * this scope is used with {@link G.io_modules_scan_all_in_directory_with_scope}
		 * or g_io_modules_load_all_in_directory_with_scope().
		 * @param basename the basename to block
		 */
		public block(basename: string): void;
		/**
		 * Free a module scope.
		 */
		public free(): void;
	}

	export interface IOSchedulerJobInitOptions {}
	/**
	 * Opaque class for defining and scheduling IO jobs.
	 */
	interface IOSchedulerJob {}
	class IOSchedulerJob {
		public constructor(options?: Partial<IOSchedulerJobInitOptions>);
		/**
		 * @deprecated
		 * Use {@link G.main_context_invoke}.
		 * 
		 * Used from an I/O job to send a callback to be run in the thread
		 * that the job was started from, waiting for the result (and thus
		 * blocking the I/O job).
		 * @param func a #GSourceFunc callback that will be called in the original thread
		 * @returns The return value of #func
		 */
		public send_to_mainloop(func: GLib.SourceFunc): boolean;
		/**
		 * @deprecated
		 * Use {@link G.main_context_invoke}.
		 * 
		 * Used from an I/O job to send a callback to be run asynchronously in
		 * the thread that the job was started from. The callback will be run
		 * when the main loop is available, but at that time the I/O job might
		 * have finished. The return value from the callback is ignored.
		 * 
		 * Note that if you are passing the #user_data from {@link G.io_scheduler_push_job}
		 * on to this function you have to ensure that it is not freed before
		 * #func is called, either by passing %NULL as #notify to
		 * g_io_scheduler_push_job() or by using refcounting for #user_data.
		 * @param func a #GSourceFunc callback that will be called in the original thread
		 */
		public send_to_mainloop_async(func: GLib.SourceFunc): void;
	}

	export interface IOStreamAdapterInitOptions {}
	interface IOStreamAdapter {}
	class IOStreamAdapter {
		public constructor(options?: Partial<IOStreamAdapterInitOptions>);
	}

	export interface IconIfaceInitOptions {}
	/**
	 * GIconIface is used to implement GIcon types for various
	 * different systems. See #GThemedIcon and #GLoadableIcon for
	 * examples of how to implement this interface.
	 */
	interface IconIface {}
	class IconIface {
		public constructor(options?: Partial<IconIfaceInitOptions>);
		/**
		 * The parent interface.
		 */
		public readonly g_iface: GObject.TypeInterface;
		public hash: {(icon: Icon): number;};
		public equal: {(icon1?: Icon | null, icon2?: Icon | null): boolean;};
		public to_tokens: {(icon: Icon, tokens: any[], out_version: number): boolean;};
		public from_tokens: {(tokens: string, num_tokens: number, version: number): Icon;};
		public serialize: {(icon: Icon): GLib.Variant | null;};
	}

	export interface InitableIfaceInitOptions {}
	/**
	 * Provides an interface for initializing object such that initialization
	 * may fail.
	 */
	interface InitableIface {}
	class InitableIface {
		public constructor(options?: Partial<InitableIfaceInitOptions>);
		/**
		 * The parent interface.
		 */
		public readonly g_iface: GObject.TypeInterface;
		public init: {(initable: Initable, cancellable?: Cancellable | null): boolean;};
	}

	export interface InputMessageInitOptions {}
	/**
	 * Structure used for scatter/gather data input when receiving multiple
	 * messages or packets in one go. You generally pass in an array of empty
	 * #GInputVectors and the operation will use all the buffers as if they
	 * were one buffer, and will set #bytes_received to the total number of bytes
	 * received across all #GInputVectors.
	 * 
	 * This structure closely mirrors `struct mmsghdr` and `struct msghdr` from
	 * the POSIX sockets API (see `man 2 recvmmsg`).
	 * 
	 * If #address is non-%NULL then it is set to the source address the message
	 * was received from, and the caller must free it afterwards.
	 * 
	 * If #control_messages is non-%NULL then it is set to an array of control
	 * messages received with the message (if any), and the caller must free it
	 * afterwards. #num_control_messages is set to the number of elements in
	 * this array, which may be zero.
	 * 
	 * Flags relevant to this message will be returned in #flags. For example,
	 * `MSG_EOR` or `MSG_TRUNC`.
	 */
	interface InputMessage {}
	class InputMessage {
		public constructor(options?: Partial<InputMessageInitOptions>);
		/**
		 * return location
		 *   for a #GSocketAddress, or %NULL
		 */
		public address: SocketAddress;
		/**
		 * pointer to an
		 *   array of input vectors
		 */
		public vectors: InputVector[];
		/**
		 * the number of input vectors pointed to by #vectors
		 */
		public num_vectors: number;
		/**
		 * will be set to the number of bytes that have been
		 *   received
		 */
		public bytes_received: number;
		/**
		 * collection of #GSocketMsgFlags for the received message,
		 *   outputted by the call
		 */
		public flags: number;
		/**
		 * return location for a
		 *   caller-allocated array of #GSocketControlMessages, or %NULL
		 */
		public control_messages: SocketControlMessage[];
		/**
		 * return location for the number of
		 *   elements in #control_messages
		 */
		public num_control_messages: number;
	}

	export interface InputVectorInitOptions {}
	/**
	 * Structure used for scatter/gather data input.
	 * You generally pass in an array of #GInputVectors
	 * and the operation will store the read data starting in the
	 * first buffer, switching to the next as needed.
	 */
	interface InputVector {}
	class InputVector {
		public constructor(options?: Partial<InputVectorInitOptions>);
		/**
		 * Pointer to a buffer where data will be written.
		 */
		public buffer: any;
		/**
		 * the available size in #buffer.
		 */
		public size: number;
	}

	export interface ListModelInterfaceInitOptions {}
	/**
	 * The virtual function table for #GListModel.
	 */
	interface ListModelInterface {}
	class ListModelInterface {
		public constructor(options?: Partial<ListModelInterfaceInitOptions>);
		/**
		 * parent #GTypeInterface
		 */
		public readonly g_iface: GObject.TypeInterface;
		public get_item_type: {(list: ListModel): GObject.Type;};
		public get_n_items: {(list: ListModel): number;};
		public get_item: {(list: ListModel, position: number): GObject.Object | null;};
	}

	export interface LoadableIconIfaceInitOptions {}
	/**
	 * Interface for icons that can be loaded as a stream.
	 */
	interface LoadableIconIface {}
	class LoadableIconIface {
		public constructor(options?: Partial<LoadableIconIfaceInitOptions>);
		/**
		 * The parent interface.
		 */
		public readonly g_iface: GObject.TypeInterface;
		public load: {(icon: LoadableIcon, size: number, cancellable?: Cancellable | null): [ InputStream, string | null ];};
		public load_async: {(icon: LoadableIcon, size: number, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;};
		public load_finish: {(icon: LoadableIcon, res: AsyncResult): [ InputStream, string | null ];};
	}

	export interface MemoryMonitorInterfaceInitOptions {}
	/**
	 * The virtual function table for #GMemoryMonitor.
	 */
	interface MemoryMonitorInterface {}
	class MemoryMonitorInterface {
		public constructor(options?: Partial<MemoryMonitorInterfaceInitOptions>);
		/**
		 * The parent interface.
		 */
		public readonly g_iface: GObject.TypeInterface;
		public low_memory_warning: {(monitor: MemoryMonitor, level: MemoryMonitorWarningLevel): void;};
	}

	export interface MountIfaceInitOptions {}
	/**
	 * Interface for implementing operations for mounts.
	 */
	interface MountIface {}
	class MountIface {
		public constructor(options?: Partial<MountIfaceInitOptions>);
		/**
		 * The parent interface.
		 */
		public readonly g_iface: GObject.TypeInterface;
		public changed: {(mount: Mount): void;};
		public unmounted: {(mount: Mount): void;};
		public get_root: {(mount: Mount): File;};
		public get_name: {(mount: Mount): string;};
		public get_icon: {(mount: Mount): Icon;};
		public get_uuid: {(mount: Mount): string | null;};
		public get_volume: {(mount: Mount): Volume | null;};
		public get_drive: {(mount: Mount): Drive | null;};
		public can_unmount: {(mount: Mount): boolean;};
		public can_eject: {(mount: Mount): boolean;};
		public unmount: {(mount: Mount, flags: MountUnmountFlags, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;};
		public unmount_finish: {(mount: Mount, result: AsyncResult): boolean;};
		public eject: {(mount: Mount, flags: MountUnmountFlags, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;};
		public eject_finish: {(mount: Mount, result: AsyncResult): boolean;};
		public remount: {(mount: Mount, flags: MountMountFlags, mount_operation?: MountOperation | null, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;};
		public remount_finish: {(mount: Mount, result: AsyncResult): boolean;};
		public guess_content_type: {(mount: Mount, force_rescan: boolean, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;};
		public guess_content_type_finish: {(mount: Mount, result: AsyncResult): string[];};
		public guess_content_type_sync: {(mount: Mount, force_rescan: boolean, cancellable?: Cancellable | null): string[];};
		public pre_unmount: {(mount: Mount): void;};
		public unmount_with_operation: {(mount: Mount, flags: MountUnmountFlags, mount_operation?: MountOperation | null, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;};
		public unmount_with_operation_finish: {(mount: Mount, result: AsyncResult): boolean;};
		public eject_with_operation: {(mount: Mount, flags: MountUnmountFlags, mount_operation?: MountOperation | null, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;};
		public eject_with_operation_finish: {(mount: Mount, result: AsyncResult): boolean;};
		public get_default_location: {(mount: Mount): File;};
		public get_sort_key: {(mount: Mount): string | null;};
		public get_symbolic_icon: {(mount: Mount): Icon;};
	}

	export interface NetworkMonitorInterfaceInitOptions {}
	/**
	 * The virtual function table for #GNetworkMonitor.
	 */
	interface NetworkMonitorInterface {}
	class NetworkMonitorInterface {
		public constructor(options?: Partial<NetworkMonitorInterfaceInitOptions>);
		/**
		 * The parent interface.
		 */
		public readonly g_iface: GObject.TypeInterface;
		public network_changed: {(monitor: NetworkMonitor, network_available: boolean): void;};
		public can_reach: {(monitor: NetworkMonitor, connectable: SocketConnectable, cancellable?: Cancellable | null): boolean;};
		public can_reach_async: {(monitor: NetworkMonitor, connectable: SocketConnectable, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;};
		public can_reach_finish: {(monitor: NetworkMonitor, result: AsyncResult): boolean;};
	}

	export interface OutputMessageInitOptions {}
	/**
	 * Structure used for scatter/gather data output when sending multiple
	 * messages or packets in one go. You generally pass in an array of
	 * #GOutputVectors and the operation will use all the buffers as if they
	 * were one buffer.
	 * 
	 * If #address is %NULL then the message is sent to the default receiver
	 * (as previously set by {@link G.socket_connect}).
	 */
	interface OutputMessage {}
	class OutputMessage {
		public constructor(options?: Partial<OutputMessageInitOptions>);
		/**
		 * a #GSocketAddress, or %NULL
		 */
		public address: SocketAddress;
		/**
		 * pointer to an array of output vectors
		 */
		public vectors: OutputVector;
		/**
		 * the number of output vectors pointed to by #vectors.
		 */
		public num_vectors: number;
		/**
		 * initialize to 0. Will be set to the number of bytes
		 *     that have been sent
		 */
		public bytes_sent: number;
		/**
		 * a pointer
		 *   to an array of #GSocketControlMessages, or %NULL.
		 */
		public control_messages: SocketControlMessage[];
		/**
		 * number of elements in #control_messages.
		 */
		public num_control_messages: number;
	}

	export interface OutputVectorInitOptions {}
	/**
	 * Structure used for scatter/gather data output.
	 * You generally pass in an array of #GOutputVectors
	 * and the operation will use all the buffers as if they were
	 * one buffer.
	 */
	interface OutputVector {}
	class OutputVector {
		public constructor(options?: Partial<OutputVectorInitOptions>);
		/**
		 * Pointer to a buffer of data to read.
		 */
		public buffer: any;
		/**
		 * the size of #buffer.
		 */
		public size: number;
	}

	export interface PollableInputStreamInterfaceInitOptions {}
	/**
	 * The interface for pollable input streams.
	 * 
	 * The default implementation of #can_poll always returns %TRUE.
	 * 
	 * The default implementation of #read_nonblocking calls
	 * {@link G.pollable_input_stream_is_readable}, and then calls
	 * g_input_stream_read() if it returns %TRUE. This means you only need
	 * to override it if it is possible that your #is_readable
	 * implementation may return %TRUE when the stream is not actually
	 * readable.
	 */
	interface PollableInputStreamInterface {}
	class PollableInputStreamInterface {
		public constructor(options?: Partial<PollableInputStreamInterfaceInitOptions>);
		/**
		 * The parent interface.
		 */
		public readonly g_iface: GObject.TypeInterface;
		public can_poll: {(stream: PollableInputStream): boolean;};
		public is_readable: {(stream: PollableInputStream): boolean;};
		public create_source: {(stream: PollableInputStream, cancellable?: Cancellable | null): GLib.Source;};
		public read_nonblocking: {(stream: PollableInputStream): [ number, number[] | null ];};
	}

	export interface PollableOutputStreamInterfaceInitOptions {}
	/**
	 * The interface for pollable output streams.
	 * 
	 * The default implementation of #can_poll always returns %TRUE.
	 * 
	 * The default implementation of #write_nonblocking calls
	 * {@link G.pollable_output_stream_is_writable}, and then calls
	 * g_output_stream_write() if it returns %TRUE. This means you only
	 * need to override it if it is possible that your #is_writable
	 * implementation may return %TRUE when the stream is not actually
	 * writable.
	 * 
	 * The default implementation of #writev_nonblocking calls
	 * g_pollable_output_stream_write_nonblocking() for each vector, and converts
	 * its return value and error (if set) to a #GPollableReturn. You should
	 * override this where possible to avoid having to allocate a #GError to return
	 * %G_IO_ERROR_WOULD_BLOCK.
	 */
	interface PollableOutputStreamInterface {}
	class PollableOutputStreamInterface {
		public constructor(options?: Partial<PollableOutputStreamInterfaceInitOptions>);
		/**
		 * The parent interface.
		 */
		public readonly g_iface: GObject.TypeInterface;
		public can_poll: {(stream: PollableOutputStream): boolean;};
		public is_writable: {(stream: PollableOutputStream): boolean;};
		public create_source: {(stream: PollableOutputStream, cancellable?: Cancellable | null): GLib.Source;};
		public write_nonblocking: {(stream: PollableOutputStream, buffer?: number[] | null): number;};
		public writev_nonblocking: {(stream: PollableOutputStream, vectors: OutputVector[]): [ PollableReturn, number | null ];};
	}

	export interface PowerProfileMonitorInterfaceInitOptions {}
	/**
	 * The virtual function table for #GPowerProfileMonitor.
	 */
	interface PowerProfileMonitorInterface {}
	class PowerProfileMonitorInterface {
		public constructor(options?: Partial<PowerProfileMonitorInterfaceInitOptions>);
		/**
		 * The parent interface.
		 */
		public readonly g_iface: GObject.TypeInterface;
	}

	export interface ProxyInterfaceInitOptions {}
	/**
	 * Provides an interface for handling proxy connection and payload.
	 */
	interface ProxyInterface {}
	class ProxyInterface {
		public constructor(options?: Partial<ProxyInterfaceInitOptions>);
		/**
		 * The parent interface.
		 */
		public readonly g_iface: GObject.TypeInterface;
		public connect: {(proxy: Proxy, connection: IOStream, proxy_address: ProxyAddress, cancellable?: Cancellable | null): IOStream;};
		public connect_async: {(proxy: Proxy, connection: IOStream, proxy_address: ProxyAddress, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;};
		public connect_finish: {(proxy: Proxy, result: AsyncResult): IOStream;};
		public supports_hostname: {(proxy: Proxy): boolean;};
	}

	export interface ProxyResolverInterfaceInitOptions {}
	/**
	 * The virtual function table for #GProxyResolver.
	 */
	interface ProxyResolverInterface {}
	class ProxyResolverInterface {
		public constructor(options?: Partial<ProxyResolverInterfaceInitOptions>);
		/**
		 * The parent interface.
		 */
		public readonly g_iface: GObject.TypeInterface;
		public is_supported: {(resolver: ProxyResolver): boolean;};
		public lookup: {(resolver: ProxyResolver, uri: string, cancellable?: Cancellable | null): string[];};
		public lookup_async: {(resolver: ProxyResolver, uri: string, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;};
		public lookup_finish: {(resolver: ProxyResolver, result: AsyncResult): string[];};
	}

	export interface RemoteActionGroupInterfaceInitOptions {}
	/**
	 * The virtual function table for #GRemoteActionGroup.
	 */
	interface RemoteActionGroupInterface {}
	class RemoteActionGroupInterface {
		public constructor(options?: Partial<RemoteActionGroupInterfaceInitOptions>);
		public readonly g_iface: GObject.TypeInterface;
		public activate_action_full: {(remote: RemoteActionGroup, action_name: string, parameter: GLib.Variant | null, platform_data: GLib.Variant): void;};
		public change_action_state_full: {(remote: RemoteActionGroup, action_name: string, value: GLib.Variant, platform_data: GLib.Variant): void;};
	}

	export interface ResourceInitOptions {}
	/**
	 * Applications and libraries often contain binary or textual data that is
	 * really part of the application, rather than user data. For instance
	 * #GtkBuilder .ui files, splashscreen images, GMenu markup XML, CSS files,
	 * icons, etc. These are often shipped as files in `$datadir/appname`, or
	 * manually included as literal strings in the code.
	 * 
	 * The #GResource API and the [glib-compile-resources][glib-compile-resources] program
	 * provide a convenient and efficient alternative to this which has some nice properties. You
	 * maintain the files as normal files, so its easy to edit them, but during the build the files
	 * are combined into a binary bundle that is linked into the executable. This means that loading
	 * the resource files are efficient (as they are already in memory, shared with other instances) and
	 * simple (no need to check for things like I/O errors or locate the files in the filesystem). It
	 * also makes it easier to create relocatable applications.
	 * 
	 * Resource files can also be marked as compressed. Such files will be included in the resource bundle
	 * in a compressed form, but will be automatically uncompressed when the resource is used. This
	 * is very useful e.g. for larger text files that are parsed once (or rarely) and then thrown away.
	 * 
	 * Resource files can also be marked to be preprocessed, by setting the value of the
	 * `preprocess` attribute to a comma-separated list of preprocessing options.
	 * The only options currently supported are:
	 * 
	 * `xml-stripblanks` which will use the xmllint command
	 * to strip ignorable whitespace from the XML file. For this to work,
	 * the `XMLLINT` environment variable must be set to the full path to
	 * the xmllint executable, or xmllint must be in the `PATH`; otherwise
	 * the preprocessing step is skipped.
	 * 
	 * `to-pixdata` (deprecated since gdk-pixbuf 2.32) which will use the
	 * `gdk-pixbuf-pixdata` command to convert images to the #GdkPixdata format,
	 * which allows you to create pixbufs directly using the data inside the
	 * resource file, rather than an (uncompressed) copy of it. For this, the
	 * `gdk-pixbuf-pixdata` program must be in the `PATH`, or the
	 * `GDK_PIXBUF_PIXDATA` environment variable must be set to the full path to the
	 * `gdk-pixbuf-pixdata` executable; otherwise the resource compiler will abort.
	 * `to-pixdata` has been deprecated since gdk-pixbuf 2.32, as #GResource
	 * supports embedding modern image formats just as well. Instead of using it,
	 * embed a PNG or SVG file in your #GResource.
	 * 
	 * `json-stripblanks` which will use the `json-glib-format` command to strip
	 * ignorable whitespace from the JSON file. For this to work, the
	 * `JSON_GLIB_FORMAT` environment variable must be set to the full path to the
	 * `json-glib-format` executable, or it must be in the `PATH`;
	 * otherwise the preprocessing step is skipped. In addition, at least version
	 * 1.6 of `json-glib-format` is required.
	 * 
	 * Resource files will be exported in the GResource namespace using the
	 * combination of the given `prefix` and the filename from the `file` element.
	 * The `alias` attribute can be used to alter the filename to expose them at a
	 * different location in the resource namespace. Typically, this is used to
	 * include files from a different source directory without exposing the source
	 * directory in the resource namespace, as in the example below.
	 * 
	 * Resource bundles are created by the [glib-compile-resources][glib-compile-resources] program
	 * which takes an XML file that describes the bundle, and a set of files that the XML references. These
	 * are combined into a binary resource bundle.
	 * 
	 * An example resource description:
	 * |[
	 * <?xml version="1.0" encoding="UTF-8"?>
	 * <gresources>
	 *   <gresource prefix="/org/gtk/Example">
	 *     <file>data/splashscreen.png</file>
	 *     <file compressed="true">dialog.ui</file>
	 *     <file preprocess="xml-stripblanks">menumarkup.xml</file>
	 *     <file alias="example.css">data/example.css</file>
	 *   </gresource>
	 * </gresources>
	 * ]|
	 * 
	 * This will create a resource bundle with the following files:
	 * |[
	 * /org/gtk/Example/data/splashscreen.png
	 * /org/gtk/Example/dialog.ui
	 * /org/gtk/Example/menumarkup.xml
	 * /org/gtk/Example/example.css
	 * ]|
	 * 
	 * Note that all resources in the process share the same namespace, so use Java-style
	 * path prefixes (like in the above example) to avoid conflicts.
	 * 
	 * You can then use [glib-compile-resources][glib-compile-resources] to compile the XML to a
	 * binary bundle that you can load with {@link G.resource_load}. However, its more common to use the --generate-source and
	 * --generate-header arguments to create a source file and header to link directly into your application.
	 * This will generate `get_resource()`, `register_resource()` and
	 * `unregister_resource()` functions, prefixed by the `--c-name` argument passed
	 * to [glib-compile-resources][glib-compile-resources]. `get_resource()` returns
	 * the generated #GResource object. The register and unregister functions
	 * register the resource so its files can be accessed using
	 * g_resources_lookup_data().
	 * 
	 * Once a #GResource has been created and registered all the data in it can be accessed globally in the process by
	 * using API calls like g_resources_open_stream() to stream the data or g_resources_lookup_data() to get a direct pointer
	 * to the data. You can also use URIs like "resource:///org/gtk/Example/data/splashscreen.png" with #GFile to access
	 * the resource data.
	 * 
	 * Some higher-level APIs, such as #GtkApplication, will automatically load
	 * resources from certain well-known paths in the resource namespace as a
	 * convenience. See the documentation for those APIs for details.
	 * 
	 * There are two forms of the generated source, the default version uses the compiler support for constructor
	 * and destructor functions (where available) to automatically create and register the #GResource on startup
	 * or library load time. If you pass `--manual-register`, two functions to register/unregister the resource are created
	 * instead. This requires an explicit initialization call in your application/library, but it works on all platforms,
	 * even on the minor ones where constructors are not supported. (Constructor support is available for at least Win32, Mac OS and Linux.)
	 * 
	 * Note that resource data can point directly into the data segment of e.g. a library, so if you are unloading libraries
	 * during runtime you need to be very careful with keeping around pointers to data from a resource, as this goes away
	 * when the library is unloaded. However, in practice this is not generally a problem, since most resource accesses
	 * are for your own resources, and resource data is often used once, during parsing, and then released.
	 * 
	 * When debugging a program or testing a change to an installed version, it is often useful to be able to
	 * replace resources in the program or library, without recompiling, for debugging or quick hacking and testing
	 * purposes. Since GLib 2.50, it is possible to use the `G_RESOURCE_OVERLAYS` environment variable to selectively overlay
	 * resources with replacements from the filesystem.  It is a %G_SEARCHPATH_SEPARATOR-separated list of substitutions to perform
	 * during resource lookups. It is ignored when running in a setuid process.
	 * 
	 * A substitution has the form
	 * 
	 * |[
	 *    /org/gtk/libgtk=/home/desrt/gtk-overlay
	 * ]|
	 * 
	 * The part before the `=` is the resource subpath for which the overlay applies.  The part after is a
	 * filesystem path which contains files and subdirectories as you would like to be loaded as resources with the
	 * equivalent names.
	 * 
	 * In the example above, if an application tried to load a resource with the resource path
	 * `/org/gtk/libgtk/ui/gtkdialog.ui` then GResource would check the filesystem path
	 * `/home/desrt/gtk-overlay/ui/gtkdialog.ui`.  If a file was found there, it would be used instead.  This is an
	 * overlay, not an outright replacement, which means that if a file is not found at that path, the built-in
	 * version will be used instead.  Whiteouts are not currently supported.
	 * 
	 * Substitutions must start with a slash, and must not contain a trailing slash before the '='.  The path after
	 * the slash should ideally be absolute, but this is not strictly required.  It is possible to overlay the
	 * location of a single resource with an individual file.
	 */
	interface Resource {}
	class Resource {
		public constructor(options?: Partial<ResourceInitOptions>);
		/**
		 * Creates a GResource from a reference to the binary resource bundle.
		 * This will keep a reference to #data while the resource lives, so
		 * the data should not be modified or freed.
		 * 
		 * If you want to use this resource in the global resource namespace you need
		 * to register it with {@link G.resources_register}.
		 * 
		 * Note: #data must be backed by memory that is at least pointer aligned.
		 * Otherwise this function will internally create a copy of the memory since
		 * GLib 2.56, or in older versions fail and exit the process.
		 * 
		 * If #data is empty or corrupt, %G_RESOURCE_ERROR_INTERNAL will be returned.
		 * @param data A #GBytes
		 * @returns a new #GResource, or %NULL on error
		 */
		public static new_from_data(data: GLib.Bytes): Resource;
		/**
		 * Loads a binary resource bundle and creates a #GResource representation of it, allowing
		 * you to query it for data.
		 * 
		 * If you want to use this resource in the global resource namespace you need
		 * to register it with {@link G.resources_register}.
		 * 
		 * If #filename is empty or the data in it is corrupt,
		 * %G_RESOURCE_ERROR_INTERNAL will be returned. If #filename doesn’t exist, or
		 * there is an error in reading it, an error from g_mapped_file_new() will be
		 * returned.
		 * @param filename the path of a filename to load, in the GLib filename encoding
		 * @returns a new #GResource, or %NULL on error
		 */
		public static load(filename: string): Resource;
		/**
		 * Registers the resource with the process-global set of resources.
		 * Once a resource is registered the files in it can be accessed
		 * with the global resource lookup functions like {@link G.resources_lookup_data}.
		 */
		public _register(): void;
		/**
		 * Unregisters the resource from the process-global set of resources.
		 */
		public _unregister(): void;
		/**
		 * Returns all the names of children at the specified #path in the resource.
		 * The return result is a %NULL terminated list of strings which should
		 * be released with {@link G.strfreev}.
		 * 
		 * If #path is invalid or does not exist in the #GResource,
		 * %G_RESOURCE_ERROR_NOT_FOUND will be returned.
		 * 
		 * #lookup_flags controls the behaviour of the lookup.
		 * @param path A pathname inside the resource
		 * @param lookup_flags A #GResourceLookupFlags
		 * @returns an array of constant strings
		 */
		public enumerate_children(path: string, lookup_flags: ResourceLookupFlags): string[];
		/**
		 * Looks for a file at the specified #path in the resource and
		 * if found returns information about it.
		 * 
		 * #lookup_flags controls the behaviour of the lookup.
		 * @param path A pathname inside the resource
		 * @param lookup_flags A #GResourceLookupFlags
		 * @returns %TRUE if the file was found. %FALSE if there were errors
		 * 
		 * a location to place the length of the contents of the file,
		 *    or %NULL if the length is not needed
		 * 
		 * a location to place the flags about the file,
		 *    or %NULL if the length is not needed
		 */
		public get_info(path: string, lookup_flags: ResourceLookupFlags): [ boolean, number | null, number | null ];
		/**
		 * Looks for a file at the specified #path in the resource and
		 * returns a #GBytes that lets you directly access the data in
		 * memory.
		 * 
		 * The data is always followed by a zero byte, so you
		 * can safely use the data as a C string. However, that byte
		 * is not included in the size of the GBytes.
		 * 
		 * For uncompressed resource files this is a pointer directly into
		 * the resource bundle, which is typically in some readonly data section
		 * in the program binary. For compressed files we allocate memory on
		 * the heap and automatically uncompress the data.
		 * 
		 * #lookup_flags controls the behaviour of the lookup.
		 * @param path A pathname inside the resource
		 * @param lookup_flags A #GResourceLookupFlags
		 * @returns #GBytes or %NULL on error.
		 *     Free the returned object with {@link G.bytes_unref}
		 */
		public lookup_data(path: string, lookup_flags: ResourceLookupFlags): GLib.Bytes;
		/**
		 * Looks for a file at the specified #path in the resource and
		 * returns a #GInputStream that lets you read the data.
		 * 
		 * #lookup_flags controls the behaviour of the lookup.
		 * @param path A pathname inside the resource
		 * @param lookup_flags A #GResourceLookupFlags
		 * @returns #GInputStream or %NULL on error.
		 *     Free the returned object with {@link GObject.unref}
		 */
		public open_stream(path: string, lookup_flags: ResourceLookupFlags): InputStream;
		/**
		 * Atomically increments the reference count of #resource by one. This
		 * function is MT-safe and may be called from any thread.
		 * @returns The passed in #GResource
		 */
		public ref(): Resource;
		/**
		 * Atomically decrements the reference count of #resource by one. If the
		 * reference count drops to 0, all memory allocated by the resource is
		 * released. This function is MT-safe and may be called from any
		 * thread.
		 */
		public unref(): void;
	}

	export interface SeekableIfaceInitOptions {}
	/**
	 * Provides an interface for implementing seekable functionality on I/O Streams.
	 */
	interface SeekableIface {}
	class SeekableIface {
		public constructor(options?: Partial<SeekableIfaceInitOptions>);
		/**
		 * The parent interface.
		 */
		public readonly g_iface: GObject.TypeInterface;
		public tell: {(seekable: Seekable): number;};
		public can_seek: {(seekable: Seekable): boolean;};
		public seek: {(seekable: Seekable, offset: number, type: GLib.SeekType, cancellable?: Cancellable | null): boolean;};
		public can_truncate: {(seekable: Seekable): boolean;};
		public truncate_fn: {(seekable: Seekable, offset: number, cancellable?: Cancellable | null): boolean;};
	}

	export interface SettingsSchemaInitOptions {}
	/**
	 * The #GSettingsSchemaSource and #GSettingsSchema APIs provide a
	 * mechanism for advanced control over the loading of schemas and a
	 * mechanism for introspecting their content.
	 * 
	 * Plugin loading systems that wish to provide plugins a way to access
	 * settings face the problem of how to make the schemas for these
	 * settings visible to GSettings.  Typically, a plugin will want to ship
	 * the schema along with itself and it won't be installed into the
	 * standard system directories for schemas.
	 * 
	 * #GSettingsSchemaSource provides a mechanism for dealing with this by
	 * allowing the creation of a new 'schema source' from which schemas can
	 * be acquired.  This schema source can then become part of the metadata
	 * associated with the plugin and queried whenever the plugin requires
	 * access to some settings.
	 * 
	 * Consider the following example:
	 * 
	 * |[<!-- language="C" -->
	 * typedef struct
	 * {
	 *    ...
	 *    GSettingsSchemaSource *schema_source;
	 *    ...
	 * } Plugin;
	 * 
	 * Plugin *
	 * initialise_plugin (const gchar *dir)
	 * {
	 *   Plugin *plugin;
	 * 
	 *   ...
	 * 
	 *   plugin->schema_source =
	 *     g_settings_schema_source_new_from_directory (dir,
	 *       g_settings_schema_source_get_default (), FALSE, NULL);
	 * 
	 *   ...
	 * 
	 *   return plugin;
	 * }
	 * 
	 * ...
	 * 
	 * GSettings *
	 * plugin_get_settings (Plugin      *plugin,
	 *                      const gchar *schema_id)
	 * {
	 *   GSettingsSchema *schema;
	 * 
	 *   if (schema_id == NULL)
	 *     schema_id = plugin->identifier;
	 * 
	 *   schema = g_settings_schema_source_lookup (plugin->schema_source,
	 *                                             schema_id, FALSE);
	 * 
	 *   if (schema == NULL)
	 *     {
	 *       ... disable the plugin or abort, etc ...
	 *     }
	 * 
	 *   return g_settings_new_full (schema, NULL, NULL);
	 * }
	 * ]|
	 * 
	 * The code above shows how hooks should be added to the code that
	 * initialises (or enables) the plugin to create the schema source and
	 * how an API can be added to the plugin system to provide a convenient
	 * way for the plugin to access its settings, using the schemas that it
	 * ships.
	 * 
	 * From the standpoint of the plugin, it would need to ensure that it
	 * ships a gschemas.compiled file as part of itself, and then simply do
	 * the following:
	 * 
	 * |[<!-- language="C" -->
	 * {
	 *   GSettings *settings;
	 *   gint some_value;
	 * 
	 *   settings = plugin_get_settings (self, NULL);
	 *   some_value = g_settings_get_int (settings, "some-value");
	 *   ...
	 * }
	 * ]|
	 * 
	 * It's also possible that the plugin system expects the schema source
	 * files (ie: .gschema.xml files) instead of a gschemas.compiled file.
	 * In that case, the plugin loading system must compile the schemas for
	 * itself before attempting to create the settings source.
	 */
	interface SettingsSchema {}
	class SettingsSchema {
		public constructor(options?: Partial<SettingsSchemaInitOptions>);
		/**
		 * Get the ID of #schema.
		 * @returns the ID
		 */
		public get_id(): string;
		/**
		 * Gets the key named #name from #schema.
		 * 
		 * It is a programmer error to request a key that does not exist.  See
		 * {@link G.settings_schema_list_keys}.
		 * @param name the name of a key
		 * @returns the #GSettingsSchemaKey for #name
		 */
		public get_key(name: string): SettingsSchemaKey;
		/**
		 * Gets the path associated with #schema, or %NULL.
		 * 
		 * Schemas may be single-instance or relocatable.  Single-instance
		 * schemas correspond to exactly one set of keys in the backend
		 * database: those located at the path returned by this function.
		 * 
		 * Relocatable schemas can be referenced by other schemas and can
		 * therefore describe multiple sets of keys at different locations.  For
		 * relocatable schemas, this function will return %NULL.
		 * @returns the path of the schema, or %NULL
		 */
		public get_path(): string | null;
		/**
		 * Checks if #schema has a key named #name.
		 * @param name the name of a key
		 * @returns %TRUE if such a key exists
		 */
		public has_key(name: string): boolean;
		/**
		 * Gets the list of children in #schema.
		 * 
		 * You should free the return value with {@link G.strfreev} when you are done
		 * with it.
		 * @returns a list of the children on
		 *    #settings, in no defined order
		 */
		public list_children(): string[];
		/**
		 * Introspects the list of keys on #schema.
		 * 
		 * You should probably not be calling this function from "normal" code
		 * (since you should already know what keys are in your schema).  This
		 * function is intended for introspection reasons.
		 * @returns a list of the keys on
		 *   #schema, in no defined order
		 */
		public list_keys(): string[];
		/**
		 * Increase the reference count of #schema, returning a new reference.
		 * @returns a new reference to #schema
		 */
		public ref(): SettingsSchema;
		/**
		 * Decrease the reference count of #schema, possibly freeing it.
		 */
		public unref(): void;
	}

	export interface SettingsSchemaKeyInitOptions {}
	/**
	 * #GSettingsSchemaKey is an opaque data structure and can only be accessed
	 * using the following functions.
	 */
	interface SettingsSchemaKey {}
	class SettingsSchemaKey {
		public constructor(options?: Partial<SettingsSchemaKeyInitOptions>);
		/**
		 * Gets the default value for #key.
		 * 
		 * Note that this is the default value according to the schema.  System
		 * administrator defaults and lockdown are not visible via this API.
		 * @returns the default value for the key
		 */
		public get_default_value(): GLib.Variant;
		/**
		 * Gets the description for #key.
		 * 
		 * If no description has been provided in the schema for #key, returns
		 * %NULL.
		 * 
		 * The description can be one sentence to several paragraphs in length.
		 * Paragraphs are delimited with a double newline.  Descriptions can be
		 * translated and the value returned from this function is is the
		 * current locale.
		 * 
		 * This function is slow.  The summary and description information for
		 * the schemas is not stored in the compiled schema database so this
		 * function has to parse all of the source XML files in the schema
		 * directory.
		 * @returns the description for #key, or %NULL
		 */
		public get_description(): string | null;
		/**
		 * Gets the name of #key.
		 * @returns the name of #key.
		 */
		public get_name(): string;
		/**
		 * Queries the range of a key.
		 * 
		 * This function will return a #GVariant that fully describes the range
		 * of values that are valid for #key.
		 * 
		 * The type of #GVariant returned is `(sv)`. The string describes
		 * the type of range restriction in effect. The type and meaning of
		 * the value contained in the variant depends on the string.
		 * 
		 * If the string is `'type'` then the variant contains an empty array.
		 * The element type of that empty array is the expected type of value
		 * and all values of that type are valid.
		 * 
		 * If the string is `'enum'` then the variant contains an array
		 * enumerating the possible values. Each item in the array is
		 * a possible valid value and no other values are valid.
		 * 
		 * If the string is `'flags'` then the variant contains an array. Each
		 * item in the array is a value that may appear zero or one times in an
		 * array to be used as the value for this key. For example, if the
		 * variant contained the array `['x', 'y']` then the valid values for
		 * the key would be `[]`, `['x']`, `['y']`, `['x', 'y']` and
		 * `['y', 'x']`.
		 * 
		 * Finally, if the string is `'range'` then the variant contains a pair
		 * of like-typed values -- the minimum and maximum permissible values
		 * for this key.
		 * 
		 * This information should not be used by normal programs.  It is
		 * considered to be a hint for introspection purposes.  Normal programs
		 * should already know what is permitted by their own schema.  The
		 * format may change in any way in the future -- but particularly, new
		 * forms may be added to the possibilities described above.
		 * 
		 * You should free the returned value with {@link G.variant_unref} when it is
		 * no longer needed.
		 * @returns a #GVariant describing the range
		 */
		public get_range(): GLib.Variant;
		/**
		 * Gets the summary for #key.
		 * 
		 * If no summary has been provided in the schema for #key, returns
		 * %NULL.
		 * 
		 * The summary is a short description of the purpose of the key; usually
		 * one short sentence.  Summaries can be translated and the value
		 * returned from this function is is the current locale.
		 * 
		 * This function is slow.  The summary and description information for
		 * the schemas is not stored in the compiled schema database so this
		 * function has to parse all of the source XML files in the schema
		 * directory.
		 * @returns the summary for #key, or %NULL
		 */
		public get_summary(): string | null;
		/**
		 * Gets the #GVariantType of #key.
		 * @returns the type of #key
		 */
		public get_value_type(): GLib.VariantType;
		/**
		 * Checks if the given #value is within the
		 * permitted range for #key.
		 * 
		 * It is a programmer error if #value is not of the correct type — you
		 * must check for this first.
		 * @param value the value to check
		 * @returns %TRUE if #value is valid for #key
		 */
		public range_check(value: GLib.Variant): boolean;
		/**
		 * Increase the reference count of #key, returning a new reference.
		 * @returns a new reference to #key
		 */
		public ref(): SettingsSchemaKey;
		/**
		 * Decrease the reference count of #key, possibly freeing it.
		 */
		public unref(): void;
	}

	export interface SettingsSchemaSourceInitOptions {}
	/**
	 * This is an opaque structure type.  You may not access it directly.
	 */
	interface SettingsSchemaSource {}
	class SettingsSchemaSource {
		public constructor(options?: Partial<SettingsSchemaSourceInitOptions>);
		/**
		 * Attempts to create a new schema source corresponding to the contents
		 * of the given directory.
		 * 
		 * This function is not required for normal uses of #GSettings but it
		 * may be useful to authors of plugin management systems.
		 * 
		 * The directory should contain a file called `gschemas.compiled` as
		 * produced by the [glib-compile-schemas][glib-compile-schemas] tool.
		 * 
		 * If #trusted is %TRUE then `gschemas.compiled` is trusted not to be
		 * corrupted. This assumption has a performance advantage, but can result
		 * in crashes or inconsistent behaviour in the case of a corrupted file.
		 * Generally, you should set #trusted to %TRUE for files installed by the
		 * system and to %FALSE for files in the home directory.
		 * 
		 * In either case, an empty file or some types of corruption in the file will
		 * result in %G_FILE_ERROR_INVAL being returned.
		 * 
		 * If #parent is non-%NULL then there are two effects.
		 * 
		 * First, if {@link G.settings_schema_source_lookup} is called with the
		 * #recursive flag set to %TRUE and the schema can not be found in the
		 * source, the lookup will recurse to the parent.
		 * 
		 * Second, any references to other schemas specified within this
		 * source (ie: `child` or `extends`) references may be resolved
		 * from the #parent.
		 * 
		 * For this second reason, except in very unusual situations, the
		 * #parent should probably be given as the default schema source, as
		 * returned by g_settings_schema_source_get_default().
		 * @param directory the filename of a directory
		 * @param parent a #GSettingsSchemaSource, or %NULL
		 * @param trusted %TRUE, if the directory is trusted
		 * @returns 
		 */
		public static new_from_directory(directory: string, parent: SettingsSchemaSource | null, trusted: boolean): SettingsSchemaSource;
		/**
		 * Gets the default system schema source.
		 * 
		 * This function is not required for normal uses of #GSettings but it
		 * may be useful to authors of plugin management systems or to those who
		 * want to introspect the content of schemas.
		 * 
		 * If no schemas are installed, %NULL will be returned.
		 * 
		 * The returned source may actually consist of multiple schema sources
		 * from different directories, depending on which directories were given
		 * in `XDG_DATA_DIRS` and `GSETTINGS_SCHEMA_DIR`. For this reason, all
		 * lookups performed against the default source should probably be done
		 * recursively.
		 * @returns the default schema source
		 */
		public static get_default(): SettingsSchemaSource | null;
		/**
		 * Lists the schemas in a given source.
		 * 
		 * If #recursive is %TRUE then include parent sources.  If %FALSE then
		 * only include the schemas from one source (ie: one directory).  You
		 * probably want %TRUE.
		 * 
		 * Non-relocatable schemas are those for which you can call
		 * {@link G.settings_new}.  Relocatable schemas are those for which you must
		 * use g_settings_new_with_path().
		 * 
		 * Do not call this function from normal programs.  This is designed for
		 * use by database editors, commandline tools, etc.
		 * @param recursive if we should recurse
		 * @returns the
		 *   list of non-relocatable schemas, in no defined order
		 * 
		 * the list
		 *   of relocatable schemas, in no defined order
		 */
		public list_schemas(recursive: boolean): [ string[], string[] ];
		/**
		 * Looks up a schema with the identifier #schema_id in #source.
		 * 
		 * This function is not required for normal uses of #GSettings but it
		 * may be useful to authors of plugin management systems or to those who
		 * want to introspect the content of schemas.
		 * 
		 * If the schema isn't found directly in #source and #recursive is %TRUE
		 * then the parent sources will also be checked.
		 * 
		 * If the schema isn't found, %NULL is returned.
		 * @param schema_id a schema ID
		 * @param recursive %TRUE if the lookup should be recursive
		 * @returns a new #GSettingsSchema
		 */
		public lookup(schema_id: string, recursive: boolean): SettingsSchema | null;
		/**
		 * Increase the reference count of #source, returning a new reference.
		 * @returns a new reference to #source
		 */
		public ref(): SettingsSchemaSource;
		/**
		 * Decrease the reference count of #source, possibly freeing it.
		 */
		public unref(): void;
	}

	export interface SocketConnectableIfaceInitOptions {}
	/**
	 * Provides an interface for returning a #GSocketAddressEnumerator
	 * and #GProxyAddressEnumerator
	 */
	interface SocketConnectableIface {}
	class SocketConnectableIface {
		public constructor(options?: Partial<SocketConnectableIfaceInitOptions>);
		/**
		 * The parent interface.
		 */
		public readonly g_iface: GObject.TypeInterface;
		public enumerate: {(connectable: SocketConnectable): SocketAddressEnumerator;};
		public proxy_enumerate: {(connectable: SocketConnectable): SocketAddressEnumerator;};
		public to_string: {(connectable: SocketConnectable): string;};
	}

	export interface SrvTargetInitOptions {}
	/**
	 * SRV (service) records are used by some network protocols to provide
	 * service-specific aliasing and load-balancing. For example, XMPP
	 * (Jabber) uses SRV records to locate the XMPP server for a domain;
	 * rather than connecting directly to "example.com" or assuming a
	 * specific server hostname like "xmpp.example.com", an XMPP client
	 * would look up the "xmpp-client" SRV record for "example.com", and
	 * then connect to whatever host was pointed to by that record.
	 * 
	 * You can use {@link G.resolver_lookup_service} or
	 * g_resolver_lookup_service_async() to find the #GSrvTargets
	 * for a given service. However, if you are simply planning to connect
	 * to the remote service, you can use #GNetworkService's
	 * #GSocketConnectable interface and not need to worry about
	 * #GSrvTarget at all.
	 */
	interface SrvTarget {}
	class SrvTarget {
		public constructor(options?: Partial<SrvTargetInitOptions>);
		/**
		 * Creates a new #GSrvTarget with the given parameters.
		 * 
		 * You should not need to use this; normally #GSrvTargets are
		 * created by #GResolver.
		 * @param hostname the host that the service is running on
		 * @param port the port that the service is running on
		 * @param priority the target's priority
		 * @param weight the target's weight
		 * @returns a new #GSrvTarget.
		 */
		public static new(hostname: string, port: number, priority: number, weight: number): SrvTarget;
		/**
		 * Sorts #targets in place according to the algorithm in RFC 2782.
		 * @param targets a #GList of #GSrvTarget
		 * @returns the head of the sorted list.
		 */
		public static list_sort(targets: any[]): any[];
		/**
		 * Copies #target
		 * @returns a copy of #target
		 */
		public copy(): SrvTarget;
		/**
		 * Frees #target
		 */
		public free(): void;
		/**
		 * Gets #target's hostname (in ASCII form; if you are going to present
		 * this to the user, you should use {@link G.hostname_is_ascii_encoded} to
		 * check if it contains encoded Unicode segments, and use
		 * g_hostname_to_unicode() to convert it if it does.)
		 * @returns #target's hostname
		 */
		public get_hostname(): string;
		/**
		 * Gets #target's port
		 * @returns #target's port
		 */
		public get_port(): number;
		/**
		 * Gets #target's priority. You should not need to look at this;
		 * #GResolver already sorts the targets according to the algorithm in
		 * RFC 2782.
		 * @returns #target's priority
		 */
		public get_priority(): number;
		/**
		 * Gets #target's weight. You should not need to look at this;
		 * #GResolver already sorts the targets according to the algorithm in
		 * RFC 2782.
		 * @returns #target's weight
		 */
		public get_weight(): number;
	}

	export interface StaticResourceInitOptions {}
	/**
	 * #GStaticResource is an opaque data structure and can only be accessed
	 * using the following functions.
	 */
	interface StaticResource {}
	class StaticResource {
		public constructor(options?: Partial<StaticResourceInitOptions>);
		public readonly data: number;
		public readonly data_len: number;
		public readonly resource: Resource;
		public readonly next: StaticResource;
		public readonly padding: any;
		/**
		 * Finalized a GResource initialized by {@link G.static_resource_init}.
		 * 
		 * This is normally used by code generated by
		 * [glib-compile-resources][glib-compile-resources]
		 * and is not typically used by other code.
		 */
		public fini(): void;
		/**
		 * Gets the GResource that was registered by a call to {@link G.static_resource_init}.
		 * 
		 * This is normally used by code generated by
		 * [glib-compile-resources][glib-compile-resources]
		 * and is not typically used by other code.
		 * @returns a #GResource
		 */
		public get_resource(): Resource;
		/**
		 * Initializes a GResource from static data using a
		 * GStaticResource.
		 * 
		 * This is normally used by code generated by
		 * [glib-compile-resources][glib-compile-resources]
		 * and is not typically used by other code.
		 */
		public init(): void;
	}

	export interface TlsBackendInterfaceInitOptions {}
	/**
	 * Provides an interface for describing TLS-related types.
	 */
	interface TlsBackendInterface {}
	class TlsBackendInterface {
		public constructor(options?: Partial<TlsBackendInterfaceInitOptions>);
		/**
		 * The parent interface.
		 */
		public readonly g_iface: GObject.TypeInterface;
		public supports_tls: {(backend: TlsBackend): boolean;};
		public get_certificate_type: {(): GObject.Type;};
		public get_client_connection_type: {(): GObject.Type;};
		public get_server_connection_type: {(): GObject.Type;};
		public get_file_database_type: {(): GObject.Type;};
		public get_default_database: {(backend: TlsBackend): TlsDatabase;};
		public supports_dtls: {(backend: TlsBackend): boolean;};
		public get_dtls_client_connection_type: {(): GObject.Type;};
		public get_dtls_server_connection_type: {(): GObject.Type;};
	}

	export interface TlsClientConnectionInterfaceInitOptions {}
	/**
	 * vtable for a #GTlsClientConnection implementation.
	 */
	interface TlsClientConnectionInterface {}
	class TlsClientConnectionInterface {
		public constructor(options?: Partial<TlsClientConnectionInterfaceInitOptions>);
		/**
		 * The parent interface.
		 */
		public readonly g_iface: GObject.TypeInterface;
		public copy_session_state: {(conn: TlsClientConnection, source: TlsClientConnection): void;};
	}

	export interface TlsFileDatabaseInterfaceInitOptions {}
	/**
	 * Provides an interface for #GTlsFileDatabase implementations.
	 */
	interface TlsFileDatabaseInterface {}
	class TlsFileDatabaseInterface {
		public constructor(options?: Partial<TlsFileDatabaseInterfaceInitOptions>);
		/**
		 * The parent interface.
		 */
		public readonly g_iface: GObject.TypeInterface;
		public readonly padding: any[];
	}

	export interface TlsServerConnectionInterfaceInitOptions {}
	/**
	 * vtable for a #GTlsServerConnection implementation.
	 */
	interface TlsServerConnectionInterface {}
	class TlsServerConnectionInterface {
		public constructor(options?: Partial<TlsServerConnectionInterfaceInitOptions>);
		/**
		 * The parent interface.
		 */
		public readonly g_iface: GObject.TypeInterface;
	}

	export interface UnixMountEntryInitOptions {}
	/**
	 * Defines a Unix mount entry (e.g. <filename>/media/cdrom</filename>).
	 * This corresponds roughly to a mtab entry.
	 */
	interface UnixMountEntry {}
	class UnixMountEntry {
		public constructor(options?: Partial<UnixMountEntryInitOptions>);
	}

	export interface UnixMountPointInitOptions {}
	/**
	 * Defines a Unix mount point (e.g. <filename>/dev</filename>).
	 * This corresponds roughly to a fstab entry.
	 */
	interface UnixMountPoint {}
	class UnixMountPoint {
		public constructor(options?: Partial<UnixMountPointInitOptions>);
		/**
		 * Gets a #GUnixMountPoint for a given mount path. If #time_read is set, it
		 * will be filled with a unix timestamp for checking if the mount points have
		 * changed since with {@link G.unix_mount_points_changed_since}.
		 * 
		 * If more mount points have the same mount path, the last matching mount point
		 * is returned.
		 * @param mount_path path for a possible unix mount point.
		 * @returns a #GUnixMountPoint, or %NULL if no match
		 * is found.
		 * 
		 * guint64 to contain a timestamp.
		 */
		public static at(mount_path: string): [ UnixMountPoint | null, number | null ];
		/**
		 * Compares two unix mount points.
		 * @param mount2 a #GUnixMount.
		 * @returns 1, 0 or -1 if #mount1 is greater than, equal to,
		 * or less than #mount2, respectively.
		 */
		public compare(mount2: UnixMountPoint): number;
		/**
		 * Makes a copy of #mount_point.
		 * @returns a new #GUnixMountPoint
		 */
		public copy(): UnixMountPoint;
		/**
		 * Frees a unix mount point.
		 */
		public free(): void;
		/**
		 * Gets the device path for a unix mount point.
		 * @returns a string containing the device path.
		 */
		public get_device_path(): string;
		/**
		 * Gets the file system type for the mount point.
		 * @returns a string containing the file system type.
		 */
		public get_fs_type(): string;
		/**
		 * Gets the mount path for a unix mount point.
		 * @returns a string containing the mount path.
		 */
		public get_mount_path(): string;
		/**
		 * Gets the options for the mount point.
		 * @returns a string containing the options.
		 */
		public get_options(): string | null;
		/**
		 * Guesses whether a Unix mount point can be ejected.
		 * @returns %TRUE if #mount_point is deemed to be ejectable.
		 */
		public guess_can_eject(): boolean;
		/**
		 * Guesses the icon of a Unix mount point.
		 * @returns a #GIcon
		 */
		public guess_icon(): Icon;
		/**
		 * Guesses the name of a Unix mount point.
		 * The result is a translated string.
		 * @returns A newly allocated string that must
		 *     be freed with {@link G.free}
		 */
		public guess_name(): string;
		/**
		 * Guesses the symbolic icon of a Unix mount point.
		 * @returns a #GIcon
		 */
		public guess_symbolic_icon(): Icon;
		/**
		 * Checks if a unix mount point is a loopback device.
		 * @returns %TRUE if the mount point is a loopback. %FALSE otherwise.
		 */
		public is_loopback(): boolean;
		/**
		 * Checks if a unix mount point is read only.
		 * @returns %TRUE if a mount point is read only.
		 */
		public is_readonly(): boolean;
		/**
		 * Checks if a unix mount point is mountable by the user.
		 * @returns %TRUE if the mount point is user mountable.
		 */
		public is_user_mountable(): boolean;
	}

	export interface VolumeIfaceInitOptions {}
	/**
	 * Interface for implementing operations for mountable volumes.
	 */
	interface VolumeIface {}
	class VolumeIface {
		public constructor(options?: Partial<VolumeIfaceInitOptions>);
		/**
		 * The parent interface.
		 */
		public readonly g_iface: GObject.TypeInterface;
		public changed: {(volume: Volume): void;};
		public removed: {(volume: Volume): void;};
		public get_name: {(volume: Volume): string;};
		public get_icon: {(volume: Volume): Icon;};
		public get_uuid: {(volume: Volume): string | null;};
		public get_drive: {(volume: Volume): Drive | null;};
		public get_mount: {(volume: Volume): Mount | null;};
		public can_mount: {(volume: Volume): boolean;};
		public can_eject: {(volume: Volume): boolean;};
		public mount_fn: {(volume: Volume, flags: MountMountFlags, mount_operation?: MountOperation | null, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;};
		public mount_finish: {(volume: Volume, result: AsyncResult): boolean;};
		public eject: {(volume: Volume, flags: MountUnmountFlags, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;};
		public eject_finish: {(volume: Volume, result: AsyncResult): boolean;};
		public get_identifier: {(volume: Volume, kind: string): string | null;};
		public enumerate_identifiers: {(volume: Volume): string[];};
		public should_automount: {(volume: Volume): boolean;};
		public get_activation_root: {(volume: Volume): File | null;};
		public eject_with_operation: {(volume: Volume, flags: MountUnmountFlags, mount_operation?: MountOperation | null, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;};
		public eject_with_operation_finish: {(volume: Volume, result: AsyncResult): boolean;};
		public get_sort_key: {(volume: Volume): string | null;};
		public get_symbolic_icon: {(volume: Volume): Icon;};
	}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link Action} instead.
	 */
	interface IAction {
		/**
		 * If #action is currently enabled.
		 * 
		 * If the action is disabled then calls to {@link G.action_activate} and
		 * g_action_change_state() have no effect.
		 */
		readonly enabled: boolean;
		/**
		 * The name of the action.  This is mostly meaningful for identifying
		 * the action once it has been added to a #GActionGroup. It is immutable.
		 */
		readonly name: string;
		/**
		 * The type of the parameter that must be given when activating the
		 * action. This is immutable, and may be %NULL if no parameter is needed when
		 * activating the action.
		 */
		readonly parameter_type: GLib.VariantType;
		/**
		 * The state of the action, or %NULL if the action is stateless.
		 */
		readonly state: GLib.Variant;
		/**
		 * The #GVariantType of the state that the action has, or %NULL if the
		 * action is stateless. This is immutable.
		 */
		readonly state_type: GLib.VariantType;
		/**
		 * Activates the action.
		 * 
		 * #parameter must be the correct type of parameter for the action (ie:
		 * the parameter type given at construction time).  If the parameter
		 * type was %NULL then #parameter must also be %NULL.
		 * 
		 * If the #parameter GVariant is floating, it is consumed.
		 * @param parameter the parameter to the activation
		 */
		activate(parameter?: GLib.Variant | null): void;
		/**
		 * Request for the state of #action to be changed to #value.
		 * 
		 * The action must be stateful and #value must be of the correct type.
		 * See {@link G.action_get_state_type}.
		 * 
		 * This call merely requests a change.  The action may refuse to change
		 * its state or may change its state to something other than #value.
		 * See g_action_get_state_hint().
		 * 
		 * If the #value GVariant is floating, it is consumed.
		 * @param value the new state
		 */
		change_state(value: GLib.Variant): void;
		/**
		 * Checks if #action is currently enabled.
		 * 
		 * An action must be enabled in order to be activated or in order to
		 * have its state changed from outside callers.
		 * @returns whether the action is enabled
		 */
		get_enabled(): boolean;
		/**
		 * Queries the name of #action.
		 * @returns the name of the action
		 */
		get_name(): string;
		/**
		 * Queries the type of the parameter that must be given when activating
		 * #action.
		 * 
		 * When activating the action using {@link G.action_activate}, the #GVariant
		 * given to that function must be of the type returned by this function.
		 * 
		 * In the case that this function returns %NULL, you must not give any
		 * #GVariant, but %NULL instead.
		 * @returns the parameter type
		 */
		get_parameter_type(): GLib.VariantType | null;
		/**
		 * Queries the current state of #action.
		 * 
		 * If the action is not stateful then %NULL will be returned.  If the
		 * action is stateful then the type of the return value is the type
		 * given by {@link G.action_get_state_type}.
		 * 
		 * The return value (if non-%NULL) should be freed with
		 * g_variant_unref() when it is no longer required.
		 * @returns the current state of the action
		 */
		get_state(): GLib.Variant | null;
		/**
		 * Requests a hint about the valid range of values for the state of
		 * #action.
		 * 
		 * If %NULL is returned it either means that the action is not stateful
		 * or that there is no hint about the valid range of values for the
		 * state of the action.
		 * 
		 * If a #GVariant array is returned then each item in the array is a
		 * possible value for the state.  If a #GVariant pair (ie: two-tuple) is
		 * returned then the tuple specifies the inclusive lower and upper bound
		 * of valid values for the state.
		 * 
		 * In any case, the information is merely a hint.  It may be possible to
		 * have a state value outside of the hinted range and setting a value
		 * within the range may fail.
		 * 
		 * The return value (if non-%NULL) should be freed with
		 * {@link G.variant_unref} when it is no longer required.
		 * @returns the state range hint
		 */
		get_state_hint(): GLib.Variant | null;
		/**
		 * Queries the type of the state of #action.
		 * 
		 * If the action is stateful (e.g. created with
		 * {@link G.simple_action_new_stateful}) then this function returns the
		 * #GVariantType of the state.  This is the type of the initial value
		 * given as the state. All calls to g_action_change_state() must give a
		 * #GVariant of this type and g_action_get_state() will return a
		 * #GVariant of the same type.
		 * 
		 * If the action is not stateful (e.g. created with g_simple_action_new())
		 * then this function will return %NULL. In that case, g_action_get_state()
		 * will return %NULL and you must not call g_action_change_state().
		 * @returns the state type, if the action is stateful
		 */
		get_state_type(): GLib.VariantType | null;
		connect(signal: "notify::enabled", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::name", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::parameter-type", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::state", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::state-type", callback: (owner: this, ...args: any) => void): number;

	}

	type ActionInitOptionsMixin  = {};
	export interface ActionInitOptions extends ActionInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link Action} instead.
	 */
	type ActionMixin = IAction;

	/**
	 * #GAction represents a single named action.
	 * 
	 * The main interface to an action is that it can be activated with
	 * {@link G.action_activate}.  This results in the 'activate' signal being
	 * emitted.  An activation has a #GVariant parameter (which may be
	 * %NULL).  The correct type for the parameter is determined by a static
	 * parameter type (which is given at construction time).
	 * 
	 * An action may optionally have a state, in which case the state may be
	 * set with g_action_change_state().  This call takes a #GVariant.  The
	 * correct type for the state is determined by a static state type
	 * (which is given at construction time).
	 * 
	 * The state may have a hint associated with it, specifying its valid
	 * range.
	 * 
	 * #GAction is merely the interface to the concept of an action, as
	 * described above.  Various implementations of actions exist, including
	 * #GSimpleAction.
	 * 
	 * In all cases, the implementing class is responsible for storing the
	 * name of the action, the parameter type, the enabled state, the
	 * optional state type and the state and emitting the appropriate
	 * signals when these change.  The implementor is responsible for filtering
	 * calls to g_action_activate() and g_action_change_state() for type
	 * safety and for the state being enabled.
	 * 
	 * Probably the only useful thing to do with a #GAction is to put it
	 * inside of a #GSimpleActionGroup.
	 */
	interface Action extends ActionMixin {}

	class Action {
		public constructor(options?: Partial<ActionInitOptions>);
		/**
		 * Checks if #action_name is valid.
		 * 
		 * #action_name is valid if it consists only of alphanumeric characters,
		 * plus '-' and '.'.  The empty string is not a valid action name.
		 * 
		 * It is an error to call this function with a non-utf8 #action_name.
		 * #action_name must not be %NULL.
		 * @param action_name a potential action name
		 * @returns %TRUE if #action_name is valid
		 */
		public static name_is_valid(action_name: string): boolean;
		/**
		 * Parses a detailed action name into its separate name and target
		 * components.
		 * 
		 * Detailed action names can have three formats.
		 * 
		 * The first format is used to represent an action name with no target
		 * value and consists of just an action name containing no whitespace
		 * nor the characters ':', '(' or ')'.  For example: "app.action".
		 * 
		 * The second format is used to represent an action with a target value
		 * that is a non-empty string consisting only of alphanumerics, plus '-'
		 * and '.'.  In that case, the action name and target value are
		 * separated by a double colon ("::").  For example:
		 * "app.action::target".
		 * 
		 * The third format is used to represent an action with any type of
		 * target value, including strings.  The target value follows the action
		 * name, surrounded in parens.  For example: "app.action(42)".  The
		 * target value is parsed using {@link G.variant_parse}.  If a tuple-typed
		 * value is desired, it must be specified in the same way, resulting in
		 * two sets of parens, for example: "app.action((1,2,3))".  A string
		 * target can be specified this way as well: "app.action('target')".
		 * For strings, this third format must be used if * target value is
		 * empty or contains characters other than alphanumerics, '-' and '.'.
		 * @param detailed_name a detailed action name
		 * @returns %TRUE if successful, else %FALSE with #error set
		 * 
		 * the action name
		 * 
		 * the target value, or %NULL for no target
		 */
		public static parse_detailed_name(detailed_name: string): [ boolean, string, GLib.Variant ];
		/**
		 * Formats a detailed action name from #action_name and #target_value.
		 * 
		 * It is an error to call this function with an invalid action name.
		 * 
		 * This function is the opposite of {@link G.action_parse_detailed_name}.
		 * It will produce a string that can be parsed back to the #action_name
		 * and #target_value by that function.
		 * 
		 * See that function for the types of strings that will be printed by
		 * this function.
		 * @param action_name a valid action name
		 * @param target_value a #GVariant target value, or %NULL
		 * @returns a detailed format string
		 */
		public static print_detailed_name(action_name: string, target_value?: GLib.Variant | null): string;
	}



	/** This construct is only for enabling class multi-inheritance,
	 * use {@link ActionGroup} instead.
	 */
	interface IActionGroup {
		/**
		 * Emits the #GActionGroup::action-added signal on #action_group.
		 * 
		 * This function should only be called by #GActionGroup implementations.
		 * @param action_name the name of an action in the group
		 */
		action_added(action_name: string): void;
		/**
		 * Emits the #GActionGroup::action-enabled-changed signal on #action_group.
		 * 
		 * This function should only be called by #GActionGroup implementations.
		 * @param action_name the name of an action in the group
		 * @param enabled whether or not the action is now enabled
		 */
		action_enabled_changed(action_name: string, enabled: boolean): void;
		/**
		 * Emits the #GActionGroup::action-removed signal on #action_group.
		 * 
		 * This function should only be called by #GActionGroup implementations.
		 * @param action_name the name of an action in the group
		 */
		action_removed(action_name: string): void;
		/**
		 * Emits the #GActionGroup::action-state-changed signal on #action_group.
		 * 
		 * This function should only be called by #GActionGroup implementations.
		 * @param action_name the name of an action in the group
		 * @param state the new state of the named action
		 */
		action_state_changed(action_name: string, state: GLib.Variant): void;
		/**
		 * Activate the named action within #action_group.
		 * 
		 * If the action is expecting a parameter, then the correct type of
		 * parameter must be given as #parameter.  If the action is expecting no
		 * parameters then #parameter must be %NULL.  See
		 * {@link G.action_group_get_action_parameter_type}.
		 * 
		 * If the #GActionGroup implementation supports asynchronous remote
		 * activation over D-Bus, this call may return before the relevant
		 * D-Bus traffic has been sent, or any replies have been received. In
		 * order to block on such asynchronous activation calls,
		 * g_dbus_connection_flush() should be called prior to the code, which
		 * depends on the result of the action activation. Without flushing
		 * the D-Bus connection, there is no guarantee that the action would
		 * have been activated.
		 * 
		 * The following code which runs in a remote app instance, shows an
		 * example of a "quit" action being activated on the primary app
		 * instance over D-Bus. Here g_dbus_connection_flush() is called
		 * before `exit()`. Without g_dbus_connection_flush(), the "quit" action
		 * may fail to be activated on the primary instance.
		 * 
		 * |[<!-- language="C" -->
		 * // call "quit" action on primary instance
		 * g_action_group_activate_action (G_ACTION_GROUP (app), "quit", NULL);
		 * 
		 * // make sure the action is activated now
		 * g_dbus_connection_flush (...);
		 * 
		 * g_debug ("application has been terminated. exiting.");
		 * 
		 * exit (0);
		 * ]|
		 * @param action_name the name of the action to activate
		 * @param parameter parameters to the activation
		 */
		activate_action(action_name: string, parameter?: GLib.Variant | null): void;
		/**
		 * Request for the state of the named action within #action_group to be
		 * changed to #value.
		 * 
		 * The action must be stateful and #value must be of the correct type.
		 * See {@link G.action_group_get_action_state_type}.
		 * 
		 * This call merely requests a change.  The action may refuse to change
		 * its state or may change its state to something other than #value.
		 * See g_action_group_get_action_state_hint().
		 * 
		 * If the #value GVariant is floating, it is consumed.
		 * @param action_name the name of the action to request the change on
		 * @param value the new state
		 */
		change_action_state(action_name: string, value: GLib.Variant): void;
		/**
		 * Checks if the named action within #action_group is currently enabled.
		 * 
		 * An action must be enabled in order to be activated or in order to
		 * have its state changed from outside callers.
		 * @param action_name the name of the action to query
		 * @returns whether or not the action is currently enabled
		 */
		get_action_enabled(action_name: string): boolean;
		/**
		 * Queries the type of the parameter that must be given when activating
		 * the named action within #action_group.
		 * 
		 * When activating the action using {@link G.action_group_activate_action},
		 * the #GVariant given to that function must be of the type returned
		 * by this function.
		 * 
		 * In the case that this function returns %NULL, you must not give any
		 * #GVariant, but %NULL instead.
		 * 
		 * The parameter type of a particular action will never change but it is
		 * possible for an action to be removed and for a new action to be added
		 * with the same name but a different parameter type.
		 * @param action_name the name of the action to query
		 * @returns the parameter type
		 */
		get_action_parameter_type(action_name: string): GLib.VariantType | null;
		/**
		 * Queries the current state of the named action within #action_group.
		 * 
		 * If the action is not stateful then %NULL will be returned.  If the
		 * action is stateful then the type of the return value is the type
		 * given by {@link G.action_group_get_action_state_type}.
		 * 
		 * The return value (if non-%NULL) should be freed with
		 * g_variant_unref() when it is no longer required.
		 * @param action_name the name of the action to query
		 * @returns the current state of the action
		 */
		get_action_state(action_name: string): GLib.Variant | null;
		/**
		 * Requests a hint about the valid range of values for the state of the
		 * named action within #action_group.
		 * 
		 * If %NULL is returned it either means that the action is not stateful
		 * or that there is no hint about the valid range of values for the
		 * state of the action.
		 * 
		 * If a #GVariant array is returned then each item in the array is a
		 * possible value for the state.  If a #GVariant pair (ie: two-tuple) is
		 * returned then the tuple specifies the inclusive lower and upper bound
		 * of valid values for the state.
		 * 
		 * In any case, the information is merely a hint.  It may be possible to
		 * have a state value outside of the hinted range and setting a value
		 * within the range may fail.
		 * 
		 * The return value (if non-%NULL) should be freed with
		 * {@link G.variant_unref} when it is no longer required.
		 * @param action_name the name of the action to query
		 * @returns the state range hint
		 */
		get_action_state_hint(action_name: string): GLib.Variant | null;
		/**
		 * Queries the type of the state of the named action within
		 * #action_group.
		 * 
		 * If the action is stateful then this function returns the
		 * #GVariantType of the state.  All calls to
		 * {@link G.action_group_change_action_state} must give a #GVariant of this
		 * type and g_action_group_get_action_state() will return a #GVariant
		 * of the same type.
		 * 
		 * If the action is not stateful then this function will return %NULL.
		 * In that case, g_action_group_get_action_state() will return %NULL
		 * and you must not call g_action_group_change_action_state().
		 * 
		 * The state type of a particular action will never change but it is
		 * possible for an action to be removed and for a new action to be added
		 * with the same name but a different state type.
		 * @param action_name the name of the action to query
		 * @returns the state type, if the action is stateful
		 */
		get_action_state_type(action_name: string): GLib.VariantType | null;
		/**
		 * Checks if the named action exists within #action_group.
		 * @param action_name the name of the action to check for
		 * @returns whether the named action exists
		 */
		has_action(action_name: string): boolean;
		/**
		 * Lists the actions contained within #action_group.
		 * 
		 * The caller is responsible for freeing the list with {@link G.strfreev} when
		 * it is no longer required.
		 * @returns a %NULL-terminated array of the names of the
		 * actions in the group
		 */
		list_actions(): string[];
		/**
		 * Queries all aspects of the named action within an #action_group.
		 * 
		 * This function acquires the information available from
		 * {@link G.action_group_has_action}, g_action_group_get_action_enabled(),
		 * g_action_group_get_action_parameter_type(),
		 * g_action_group_get_action_state_type(),
		 * g_action_group_get_action_state_hint() and
		 * g_action_group_get_action_state() with a single function call.
		 * 
		 * This provides two main benefits.
		 * 
		 * The first is the improvement in efficiency that comes with not having
		 * to perform repeated lookups of the action in order to discover
		 * different things about it.  The second is that implementing
		 * #GActionGroup can now be done by only overriding this one virtual
		 * function.
		 * 
		 * The interface provides a default implementation of this function that
		 * calls the individual functions, as required, to fetch the
		 * information.  The interface also provides default implementations of
		 * those functions that call this function.  All implementations,
		 * therefore, must override either this function or all of the others.
		 * 
		 * If the action exists, %TRUE is returned and any of the requested
		 * fields (as indicated by having a non-%NULL reference passed in) are
		 * filled.  If the action doesn't exist, %FALSE is returned and the
		 * fields may or may not have been modified.
		 * @param action_name the name of an action in the group
		 * @returns %TRUE if the action exists, else %FALSE
		 * 
		 * if the action is presently enabled
		 * 
		 * the parameter type, or %NULL if none needed
		 * 
		 * the state type, or %NULL if stateless
		 * 
		 * the state hint, or %NULL if none
		 * 
		 * the current state, or %NULL if stateless
		 */
		query_action(action_name: string): [ boolean, boolean, GLib.VariantType | null, GLib.VariantType | null, GLib.Variant | null, GLib.Variant | null ];
		/**
		 * Signals that a new action was just added to the group.
		 * This signal is emitted after the action has been added
		 * and is now visible.
		 * @param signal 
		 * @param callback Callback function
		 *  - owner: owner of the emitted event 
		 *  - action_name: the name of the action in #action_group 
		 * 
		 * @returns Callback ID
		 */
		connect(signal: "action-added", callback: (owner: this, action_name: string) => void): number;
		/**
		 * Signals that the enabled status of the named action has changed.
		 * @param signal 
		 * @param callback Callback function
		 *  - owner: owner of the emitted event 
		 *  - action_name: the name of the action in #action_group 
		 *  - enabled: whether the action is enabled or not 
		 * 
		 * @returns Callback ID
		 */
		connect(signal: "action-enabled-changed", callback: (owner: this, action_name: string, enabled: boolean) => void): number;
		/**
		 * Signals that an action is just about to be removed from the group.
		 * This signal is emitted before the action is removed, so the action
		 * is still visible and can be queried from the signal handler.
		 * @param signal 
		 * @param callback Callback function
		 *  - owner: owner of the emitted event 
		 *  - action_name: the name of the action in #action_group 
		 * 
		 * @returns Callback ID
		 */
		connect(signal: "action-removed", callback: (owner: this, action_name: string) => void): number;
		/**
		 * Signals that the state of the named action has changed.
		 * @param signal 
		 * @param callback Callback function
		 *  - owner: owner of the emitted event 
		 *  - action_name: the name of the action in #action_group 
		 *  - value: the new value of the state 
		 * 
		 * @returns Callback ID
		 */
		connect(signal: "action-state-changed", callback: (owner: this, action_name: string, value: GLib.Variant) => void): number;

	}

	type ActionGroupInitOptionsMixin  = {};
	export interface ActionGroupInitOptions extends ActionGroupInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link ActionGroup} instead.
	 */
	type ActionGroupMixin = IActionGroup;

	/**
	 * #GActionGroup represents a group of actions. Actions can be used to
	 * expose functionality in a structured way, either from one part of a
	 * program to another, or to the outside world. Action groups are often
	 * used together with a #GMenuModel that provides additional
	 * representation data for displaying the actions to the user, e.g. in
	 * a menu.
	 * 
	 * The main way to interact with the actions in a GActionGroup is to
	 * activate them with {@link G.action_group_activate_action}. Activating an
	 * action may require a #GVariant parameter. The required type of the
	 * parameter can be inquired with g_action_group_get_action_parameter_type().
	 * Actions may be disabled, see g_action_group_get_action_enabled().
	 * Activating a disabled action has no effect.
	 * 
	 * Actions may optionally have a state in the form of a #GVariant. The
	 * current state of an action can be inquired with
	 * g_action_group_get_action_state(). Activating a stateful action may
	 * change its state, but it is also possible to set the state by calling
	 * g_action_group_change_action_state().
	 * 
	 * As typical example, consider a text editing application which has an
	 * option to change the current font to 'bold'. A good way to represent
	 * this would be a stateful action, with a boolean state. Activating the
	 * action would toggle the state.
	 * 
	 * Each action in the group has a unique name (which is a string).  All
	 * method calls, except g_action_group_list_actions() take the name of
	 * an action as an argument.
	 * 
	 * The #GActionGroup API is meant to be the 'public' API to the action
	 * group.  The calls here are exactly the interaction that 'external
	 * forces' (eg: UI, incoming D-Bus messages, etc.) are supposed to have
	 * with actions.  'Internal' APIs (ie: ones meant only to be accessed by
	 * the action group implementation) are found on subclasses.  This is
	 * why you will find - for example - g_action_group_get_action_enabled()
	 * but not an equivalent set() call.
	 * 
	 * Signals are emitted on the action group in response to state changes
	 * on individual actions.
	 * 
	 * Implementations of #GActionGroup should provide implementations for
	 * the virtual functions g_action_group_list_actions() and
	 * g_action_group_query_action().  The other virtual functions should
	 * not be implemented - their "wrappers" are actually implemented with
	 * calls to g_action_group_query_action().
	 */
	interface ActionGroup extends ActionGroupMixin {}

	class ActionGroup {
		public constructor(options?: Partial<ActionGroupInitOptions>);
	}



	/** This construct is only for enabling class multi-inheritance,
	 * use {@link ActionMap} instead.
	 */
	interface IActionMap {
		/**
		 * Adds an action to the #action_map.
		 * 
		 * If the action map already contains an action with the same name
		 * as #action then the old action is dropped from the action map.
		 * 
		 * The action map takes its own reference on #action.
		 * @param action a #GAction
		 */
		add_action(action: Action): void;
		/**
		 * A convenience function for creating multiple #GSimpleAction instances
		 * and adding them to a #GActionMap.
		 * 
		 * Each action is constructed as per one #GActionEntry.
		 * 
		 * |[<!-- language="C" -->
		 * static void
		 * activate_quit (GSimpleAction *simple,
		 *                GVariant      *parameter,
		 *                gpointer       user_data)
		 * {
		 *   exit (0);
		 * }
		 * 
		 * static void
		 * activate_print_string (GSimpleAction *simple,
		 *                        GVariant      *parameter,
		 *                        gpointer       user_data)
		 * {
		 *   g_print ("%s\n", g_variant_get_string (parameter, NULL));
		 * }
		 * 
		 * static GActionGroup *
		 * create_action_group (void)
		 * {
		 *   const GActionEntry entries[] = {
		 *     { "quit",         activate_quit              },
		 *     { "print-string", activate_print_string, "s" }
		 *   };
		 *   GSimpleActionGroup *group;
		 * 
		 *   group = g_simple_action_group_new ();
		 *   g_action_map_add_action_entries (G_ACTION_MAP (group), entries, G_N_ELEMENTS (entries), NULL);
		 * 
		 *   return G_ACTION_GROUP (group);
		 * }
		 * ]|
		 * @param entries a pointer to
		 *           the first item in an array of #GActionEntry structs
		 * @param user_data the user data for signal connections
		 */
		add_action_entries(entries: ActionEntry[], user_data?: any | null): void;
		/**
		 * Looks up the action with the name #action_name in #action_map.
		 * 
		 * If no such action exists, returns %NULL.
		 * @param action_name the name of an action
		 * @returns a #GAction, or %NULL
		 */
		lookup_action(action_name: string): Action | null;
		/**
		 * Removes the named action from the action map.
		 * 
		 * If no action of this name is in the map then nothing happens.
		 * @param action_name the name of the action
		 */
		remove_action(action_name: string): void;
	}

	type ActionMapInitOptionsMixin  = {};
	export interface ActionMapInitOptions extends ActionMapInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link ActionMap} instead.
	 */
	type ActionMapMixin = IActionMap;

	/**
	 * The GActionMap interface is implemented by #GActionGroup
	 * implementations that operate by containing a number of
	 * named #GAction instances, such as #GSimpleActionGroup.
	 * 
	 * One useful application of this interface is to map the
	 * names of actions from various action groups to unique,
	 * prefixed names (e.g. by prepending "app." or "win.").
	 * This is the motivation for the 'Map' part of the interface
	 * name.
	 */
	interface ActionMap extends ActionMapMixin {}

	class ActionMap {
		public constructor(options?: Partial<ActionMapInitOptions>);
	}



	/** This construct is only for enabling class multi-inheritance,
	 * use {@link AppInfo} instead.
	 */
	interface IAppInfo {
		/**
		 * Adds a content type to the application information to indicate the
		 * application is capable of opening files with the given content type.
		 * @param content_type a string.
		 * @returns %TRUE on success, %FALSE on error.
		 */
		add_supports_type(content_type: string): boolean;
		/**
		 * Obtains the information whether the #GAppInfo can be deleted.
		 * See {@link G.app_info_delete}.
		 * @returns %TRUE if #appinfo can be deleted
		 */
		can_delete(): boolean;
		/**
		 * Checks if a supported content type can be removed from an application.
		 * @returns %TRUE if it is possible to remove supported
		 *     content types from a given #appinfo, %FALSE if not.
		 */
		can_remove_supports_type(): boolean;
		/**
		 * Tries to delete a #GAppInfo.
		 * 
		 * On some platforms, there may be a difference between user-defined
		 * #GAppInfos which can be deleted, and system-wide ones which cannot.
		 * See {@link G.app_info_can_delete}.
		 * @returns %TRUE if #appinfo has been deleted
		 */
		delete(): boolean;
		/**
		 * Creates a duplicate of a #GAppInfo.
		 * @returns a duplicate of #appinfo.
		 */
		dup(): AppInfo;
		/**
		 * Checks if two #GAppInfos are equal.
		 * 
		 * Note that the check *may not* compare each individual
		 * field, and only does an identity check. In case detecting changes in the
		 * contents is needed, program code must additionally compare relevant fields.
		 * @param appinfo2 the second #GAppInfo.
		 * @returns %TRUE if #appinfo1 is equal to #appinfo2. %FALSE otherwise.
		 */
		equal(appinfo2: AppInfo): boolean;
		/**
		 * Gets the commandline with which the application will be
		 * started.
		 * @returns a string containing the #appinfo's commandline,
		 *     or %NULL if this information is not available
		 */
		get_commandline(): string | null;
		/**
		 * Gets a human-readable description of an installed application.
		 * @returns a string containing a description of the
		 * application #appinfo, or %NULL if none.
		 */
		get_description(): string | null;
		/**
		 * Gets the display name of the application. The display name is often more
		 * descriptive to the user than the name itself.
		 * @returns the display name of the application for #appinfo, or the name if
		 * no display name is available.
		 */
		get_display_name(): string;
		/**
		 * Gets the executable's name for the installed application.
		 * @returns a string containing the #appinfo's application
		 * binaries name
		 */
		get_executable(): string;
		/**
		 * Gets the icon for the application.
		 * @returns the default #GIcon for #appinfo or %NULL
		 * if there is no default icon.
		 */
		get_icon(): Icon | null;
		/**
		 * Gets the ID of an application. An id is a string that
		 * identifies the application. The exact format of the id is
		 * platform dependent. For instance, on Unix this is the
		 * desktop file id from the xdg menu specification.
		 * 
		 * Note that the returned ID may be %NULL, depending on how
		 * the #appinfo has been constructed.
		 * @returns a string containing the application's ID.
		 */
		get_id(): string | null;
		/**
		 * Gets the installed name of the application.
		 * @returns the name of the application for #appinfo.
		 */
		get_name(): string;
		/**
		 * Retrieves the list of content types that #app_info claims to support.
		 * If this information is not provided by the environment, this function
		 * will return %NULL.
		 * This function does not take in consideration associations added with
		 * {@link G.app_info_add_supports_type}, but only those exported directly by
		 * the application.
		 * @returns 
		 *    a list of content types.
		 */
		get_supported_types(): string[];
		/**
		 * Launches the application. Passes #files to the launched application
		 * as arguments, using the optional #context to get information
		 * about the details of the launcher (like what screen it is on).
		 * On error, #error will be set accordingly.
		 * 
		 * To launch the application without arguments pass a %NULL #files list.
		 * 
		 * Note that even if the launch is successful the application launched
		 * can fail to start if it runs into problems during startup. There is
		 * no way to detect this.
		 * 
		 * Some URIs can be changed when passed through a GFile (for instance
		 * unsupported URIs with strange formats like mailto:), so if you have
		 * a textual URI you want to pass in as argument, consider using
		 * {@link G.app_info_launch_uris} instead.
		 * 
		 * The launched application inherits the environment of the launching
		 * process, but it can be modified with g_app_launch_context_setenv()
		 * and g_app_launch_context_unsetenv().
		 * 
		 * On UNIX, this function sets the `GIO_LAUNCHED_DESKTOP_FILE`
		 * environment variable with the path of the launched desktop file and
		 * `GIO_LAUNCHED_DESKTOP_FILE_PID` to the process id of the launched
		 * process. This can be used to ignore `GIO_LAUNCHED_DESKTOP_FILE`,
		 * should it be inherited by further processes. The `DISPLAY` and
		 * `DESKTOP_STARTUP_ID` environment variables are also set, based
		 * on information provided in #context.
		 * @param files a #GList of #GFile objects
		 * @param context a #GAppLaunchContext or %NULL
		 * @returns %TRUE on successful launch, %FALSE otherwise.
		 */
		launch(files?: File[] | null, context?: AppLaunchContext | null): boolean;
		/**
		 * Launches the application. This passes the #uris to the launched application
		 * as arguments, using the optional #context to get information
		 * about the details of the launcher (like what screen it is on).
		 * On error, #error will be set accordingly.
		 * 
		 * To launch the application without arguments pass a %NULL #uris list.
		 * 
		 * Note that even if the launch is successful the application launched
		 * can fail to start if it runs into problems during startup. There is
		 * no way to detect this.
		 * @param uris a #GList containing URIs to launch.
		 * @param context a #GAppLaunchContext or %NULL
		 * @returns %TRUE on successful launch, %FALSE otherwise.
		 */
		launch_uris(uris?: string[] | null, context?: AppLaunchContext | null): boolean;
		/**
		 * Async version of {@link G.app_info_launch_uris}.
		 * 
		 * The #callback is invoked immediately after the application launch, but it
		 * waits for activation in case of D-Bus–activated applications and also provides
		 * extended error information for sandboxed applications, see notes for
		 * g_app_info_launch_default_for_uri_async().
		 * @param uris a #GList containing URIs to launch.
		 * @param context a #GAppLaunchContext or %NULL
		 * @param cancellable a #GCancellable
		 * @param callback a #GAsyncReadyCallback to call when the request is done
		 */
		launch_uris_async(uris?: string[] | null, context?: AppLaunchContext | null, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;
		/**
		 * Finishes a {@link G.app_info_launch_uris_async} operation.
		 * @param result a #GAsyncResult
		 * @returns %TRUE on successful launch, %FALSE otherwise.
		 */
		launch_uris_finish(result: AsyncResult): boolean;
		/**
		 * Removes a supported type from an application, if possible.
		 * @param content_type a string.
		 * @returns %TRUE on success, %FALSE on error.
		 */
		remove_supports_type(content_type: string): boolean;
		/**
		 * Sets the application as the default handler for the given file extension.
		 * @param extension a string containing the file extension
		 *     (without the dot).
		 * @returns %TRUE on success, %FALSE on error.
		 */
		set_as_default_for_extension(extension: string): boolean;
		/**
		 * Sets the application as the default handler for a given type.
		 * @param content_type the content type.
		 * @returns %TRUE on success, %FALSE on error.
		 */
		set_as_default_for_type(content_type: string): boolean;
		/**
		 * Sets the application as the last used application for a given type.
		 * This will make the application appear as first in the list returned
		 * by {@link G.app_info_get_recommended_for_type}, regardless of the default
		 * application for that content type.
		 * @param content_type the content type.
		 * @returns %TRUE on success, %FALSE on error.
		 */
		set_as_last_used_for_type(content_type: string): boolean;
		/**
		 * Checks if the application info should be shown in menus that
		 * list available applications.
		 * @returns %TRUE if the #appinfo should be shown, %FALSE otherwise.
		 */
		should_show(): boolean;
		/**
		 * Checks if the application accepts files as arguments.
		 * @returns %TRUE if the #appinfo supports files.
		 */
		supports_files(): boolean;
		/**
		 * Checks if the application supports reading files and directories from URIs.
		 * @returns %TRUE if the #appinfo supports URIs.
		 */
		supports_uris(): boolean;
	}

	type AppInfoInitOptionsMixin  = {};
	export interface AppInfoInitOptions extends AppInfoInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link AppInfo} instead.
	 */
	type AppInfoMixin = IAppInfo;

	/**
	 * #GAppInfo and #GAppLaunchContext are used for describing and launching
	 * applications installed on the system.
	 * 
	 * As of GLib 2.20, URIs will always be converted to POSIX paths
	 * (using {@link G.file_get_path}) when using g_app_info_launch() even if
	 * the application requested an URI and not a POSIX path. For example
	 * for a desktop-file based application with Exec key `totem
	 * %U` and a single URI, `sftp://foo/file.avi`, then
	 * `/home/user/.gvfs/sftp on foo/file.avi` will be passed. This will
	 * only work if a set of suitable GIO extensions (such as gvfs 2.26
	 * compiled with FUSE support), is available and operational; if this
	 * is not the case, the URI will be passed unmodified to the application.
	 * Some URIs, such as `mailto:`, of course cannot be mapped to a POSIX
	 * path (in gvfs there's no FUSE mount for it); such URIs will be
	 * passed unmodified to the application.
	 * 
	 * Specifically for gvfs 2.26 and later, the POSIX URI will be mapped
	 * back to the GIO URI in the #GFile constructors (since gvfs
	 * implements the #GVfs extension point). As such, if the application
	 * needs to examine the URI, it needs to use g_file_get_uri() or
	 * similar on #GFile. In other words, an application cannot assume
	 * that the URI passed to e.g. g_file_new_for_commandline_arg() is
	 * equal to the result of g_file_get_uri(). The following snippet
	 * illustrates this:
	 * 
	 * |[
	 * GFile *f;
	 * char *uri;
	 * 
	 * file = g_file_new_for_commandline_arg (uri_from_commandline);
	 * 
	 * uri = g_file_get_uri (file);
	 * strcmp (uri, uri_from_commandline) == 0;
	 * g_free (uri);
	 * 
	 * if (g_file_has_uri_scheme (file, "cdda"))
	 *   {
	 *     // do something special with uri
	 *   }
	 * g_object_unref (file);
	 * ]|
	 * 
	 * This code will work when both `cdda://sr0/Track 1.wav` and
	 * `/home/user/.gvfs/cdda on sr0/Track 1.wav` is passed to the
	 * application. It should be noted that it's generally not safe
	 * for applications to rely on the format of a particular URIs.
	 * Different launcher applications (e.g. file managers) may have
	 * different ideas of what a given URI means.
	 */
	interface AppInfo extends AppInfoMixin {}

	class AppInfo {
		public constructor(options?: Partial<AppInfoInitOptions>);
		/**
		 * Creates a new #GAppInfo from the given information.
		 * 
		 * Note that for #commandline, the quoting rules of the Exec key of the
		 * [freedesktop.org Desktop Entry Specification](http://freedesktop.org/Standards/desktop-entry-spec)
		 * are applied. For example, if the #commandline contains
		 * percent-encoded URIs, the percent-character must be doubled in order to prevent it from
		 * being swallowed by Exec key unquoting. See the specification for exact quoting rules.
		 * @param commandline the commandline to use
		 * @param application_name the application name, or %NULL to use #commandline
		 * @param flags flags that can specify details of the created #GAppInfo
		 * @returns new #GAppInfo for given command.
		 */
		public static create_from_commandline(commandline: string, application_name: string | null, flags: AppInfoCreateFlags): AppInfo;
		/**
		 * Gets a list of all of the applications currently registered
		 * on this system.
		 * 
		 * For desktop files, this includes applications that have
		 * `NoDisplay=true` set or are excluded from display by means
		 * of `OnlyShowIn` or `NotShowIn`. See {@link G.app_info_should_show}.
		 * The returned list does not include applications which have
		 * the `Hidden` key set.
		 * @returns a newly allocated #GList of references to #GAppInfos.
		 */
		public static get_all(): AppInfo[];
		/**
		 * Gets a list of all #GAppInfos for a given content type,
		 * including the recommended and fallback #GAppInfos. See
		 * {@link G.app_info_get_recommended_for_type} and
		 * g_app_info_get_fallback_for_type().
		 * @param content_type the content type to find a #GAppInfo for
		 * @returns #GList of #GAppInfos
		 *     for given #content_type or %NULL on error.
		 */
		public static get_all_for_type(content_type: string): AppInfo[];
		/**
		 * Gets the default #GAppInfo for a given content type.
		 * @param content_type the content type to find a #GAppInfo for
		 * @param must_support_uris if %TRUE, the #GAppInfo is expected to
		 *     support URIs
		 * @returns #GAppInfo for given #content_type or
		 *     %NULL on error.
		 */
		public static get_default_for_type(content_type: string, must_support_uris: boolean): AppInfo | null;
		/**
		 * Gets the default application for handling URIs with
		 * the given URI scheme. A URI scheme is the initial part
		 * of the URI, up to but not including the ':', e.g. "http",
		 * "ftp" or "sip".
		 * @param uri_scheme a string containing a URI scheme.
		 * @returns #GAppInfo for given #uri_scheme or
		 *     %NULL on error.
		 */
		public static get_default_for_uri_scheme(uri_scheme: string): AppInfo | null;
		/**
		 * Gets a list of fallback #GAppInfos for a given content type, i.e.
		 * those applications which claim to support the given content type
		 * by MIME type subclassing and not directly.
		 * @param content_type the content type to find a #GAppInfo for
		 * @returns #GList of #GAppInfos
		 *     for given #content_type or %NULL on error.
		 */
		public static get_fallback_for_type(content_type: string): AppInfo[];
		/**
		 * Gets a list of recommended #GAppInfos for a given content type, i.e.
		 * those applications which claim to support the given content type exactly,
		 * and not by MIME type subclassing.
		 * Note that the first application of the list is the last used one, i.e.
		 * the last one for which {@link G.app_info_set_as_last_used_for_type} has been
		 * called.
		 * @param content_type the content type to find a #GAppInfo for
		 * @returns #GList of #GAppInfos
		 *     for given #content_type or %NULL on error.
		 */
		public static get_recommended_for_type(content_type: string): AppInfo[];
		/**
		 * Utility function that launches the default application
		 * registered to handle the specified uri. Synchronous I/O
		 * is done on the uri to detect the type of the file if
		 * required.
		 * 
		 * The D-Bus–activated applications don't have to be started if your application
		 * terminates too soon after this function. To prevent this, use
		 * {@link G.app_info_launch_default_for_uri_async} instead.
		 * @param uri the uri to show
		 * @param context an optional #GAppLaunchContext
		 * @returns %TRUE on success, %FALSE on error.
		 */
		public static launch_default_for_uri(uri: string, context?: AppLaunchContext | null): boolean;
		/**
		 * Async version of {@link G.app_info_launch_default_for_uri}.
		 * 
		 * This version is useful if you are interested in receiving
		 * error information in the case where the application is
		 * sandboxed and the portal may present an application chooser
		 * dialog to the user.
		 * 
		 * This is also useful if you want to be sure that the D-Bus–activated
		 * applications are really started before termination and if you are interested
		 * in receiving error information from their activation.
		 * @param uri the uri to show
		 * @param context an optional #GAppLaunchContext
		 * @param cancellable a #GCancellable
		 * @param callback a #GAsyncReadyCallback to call when the request is done
		 */
		public static launch_default_for_uri_async(uri: string, context?: AppLaunchContext | null, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;
		/**
		 * Finishes an asynchronous launch-default-for-uri operation.
		 * @param result a #GAsyncResult
		 * @returns %TRUE if the launch was successful, %FALSE if #error is set
		 */
		public static launch_default_for_uri_finish(result: AsyncResult): boolean;
		/**
		 * Removes all changes to the type associations done by
		 * {@link G.app_info_set_as_default_for_type},
		 * g_app_info_set_as_default_for_extension(),
		 * g_app_info_add_supports_type() or
		 * g_app_info_remove_supports_type().
		 * @param content_type a content type
		 */
		public static reset_type_associations(content_type: string): void;
	}



	/** This construct is only for enabling class multi-inheritance,
	 * use {@link AsyncInitable} instead.
	 */
	interface IAsyncInitable {
		/**
		 * Starts asynchronous initialization of the object implementing the
		 * interface. This must be done before any real use of the object after
		 * initial construction. If the object also implements #GInitable you can
		 * optionally call {@link G.initable_init} instead.
		 * 
		 * This method is intended for language bindings. If writing in C,
		 * g_async_initable_new_async() should typically be used instead.
		 * 
		 * When the initialization is finished, #callback will be called. You can
		 * then call g_async_initable_init_finish() to get the result of the
		 * initialization.
		 * 
		 * Implementations may also support cancellation. If #cancellable is not
		 * %NULL, then initialization can be cancelled by triggering the cancellable
		 * object from another thread. If the operation was cancelled, the error
		 * %G_IO_ERROR_CANCELLED will be returned. If #cancellable is not %NULL, and
		 * the object doesn't support cancellable initialization, the error
		 * %G_IO_ERROR_NOT_SUPPORTED will be returned.
		 * 
		 * As with #GInitable, if the object is not initialized, or initialization
		 * returns with an error, then all operations on the object except
		 * g_object_ref() and g_object_unref() are considered to be invalid, and
		 * have undefined behaviour. They will often fail with g_critical() or
		 * g_warning(), but this must not be relied on.
		 * 
		 * Callers should not assume that a class which implements #GAsyncInitable can
		 * be initialized multiple times; for more information, see g_initable_init().
		 * If a class explicitly supports being initialized multiple times,
		 * implementation requires yielding all subsequent calls to init_async() on the
		 * results of the first call.
		 * 
		 * For classes that also support the #GInitable interface, the default
		 * implementation of this method will run the g_initable_init() function
		 * in a thread, so if you want to support asynchronous initialization via
		 * threads, just implement the #GAsyncInitable interface without overriding
		 * any interface methods.
		 * @param io_priority the [I/O priority][io-priority] of the operation
		 * @param cancellable optional #GCancellable object, %NULL to ignore.
		 * @param callback a #GAsyncReadyCallback to call when the request is satisfied
		 */
		init_async(io_priority: number, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;
		/**
		 * Finishes asynchronous initialization and returns the result.
		 * See {@link G.async_initable_init_async}.
		 * @param res a #GAsyncResult.
		 * @returns %TRUE if successful. If an error has occurred, this function
		 * will return %FALSE and set #error appropriately if present.
		 */
		init_finish(res: AsyncResult): boolean;
		/**
		 * Finishes the async construction for the various g_async_initable_new
		 * calls, returning the created object or %NULL on error.
		 * @param res the #GAsyncResult from the callback
		 * @returns a newly created #GObject,
		 *      or %NULL on error. Free with {@link GObject.unref}.
		 */
		new_finish(res: AsyncResult): GObject.Object;
	}

	type AsyncInitableInitOptionsMixin  = {};
	export interface AsyncInitableInitOptions extends AsyncInitableInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link AsyncInitable} instead.
	 */
	type AsyncInitableMixin = IAsyncInitable;

	/**
	 * This is the asynchronous version of #GInitable; it behaves the same
	 * in all ways except that initialization is asynchronous. For more details
	 * see the descriptions on #GInitable.
	 * 
	 * A class may implement both the #GInitable and #GAsyncInitable interfaces.
	 * 
	 * Users of objects implementing this are not intended to use the interface
	 * method directly; instead it will be used automatically in various ways.
	 * For C applications you generally just call {@link G.async_initable_new_async}
	 * directly, or indirectly via a foo_thing_new_async() wrapper. This will call
	 * g_async_initable_init_async() under the cover, calling back with %NULL and
	 * a set %GError on failure.
	 * 
	 * A typical implementation might look something like this:
	 * 
	 * |[<!-- language="C" -->
	 * enum {
	 *    NOT_INITIALIZED,
	 *    INITIALIZING,
	 *    INITIALIZED
	 * };
	 * 
	 * static void
	 * _foo_ready_cb (Foo *self)
	 * {
	 *   GList *l;
	 * 
	 *   self->priv->state = INITIALIZED;
	 * 
	 *   for (l = self->priv->init_results; l != NULL; l = l->next)
	 *     {
	 *       GTask *task = l->data;
	 * 
	 *       if (self->priv->success)
	 *         g_task_return_boolean (task, TRUE);
	 *       else
	 *         g_task_return_new_error (task, ...);
	 *       g_object_unref (task);
	 *     }
	 * 
	 *   g_list_free (self->priv->init_results);
	 *   self->priv->init_results = NULL;
	 * }
	 * 
	 * static void
	 * foo_init_async (GAsyncInitable       *initable,
	 *                 int                   io_priority,
	 *                 GCancellable         *cancellable,
	 *                 GAsyncReadyCallback   callback,
	 *                 gpointer              user_data)
	 * {
	 *   Foo *self = FOO (initable);
	 *   GTask *task;
	 * 
	 *   task = g_task_new (initable, cancellable, callback, user_data);
	 *   g_task_set_name (task, G_STRFUNC);
	 * 
	 *   switch (self->priv->state)
	 *     {
	 *       case NOT_INITIALIZED:
	 *         _foo_get_ready (self);
	 *         self->priv->init_results = g_list_append (self->priv->init_results,
	 *                                                   task);
	 *         self->priv->state = INITIALIZING;
	 *         break;
	 *       case INITIALIZING:
	 *         self->priv->init_results = g_list_append (self->priv->init_results,
	 *                                                   task);
	 *         break;
	 *       case INITIALIZED:
	 *         if (!self->priv->success)
	 *           g_task_return_new_error (task, ...);
	 *         else
	 *           g_task_return_boolean (task, TRUE);
	 *         g_object_unref (task);
	 *         break;
	 *     }
	 * }
	 * 
	 * static gboolean
	 * foo_init_finish (GAsyncInitable       *initable,
	 *                  GAsyncResult         *result,
	 *                  GError              **error)
	 * {
	 *   g_return_val_if_fail (g_task_is_valid (result, initable), FALSE);
	 * 
	 *   return g_task_propagate_boolean (G_TASK (result), error);
	 * }
	 * 
	 * static void
	 * foo_async_initable_iface_init (gpointer g_iface,
	 *                                gpointer data)
	 * {
	 *   GAsyncInitableIface *iface = g_iface;
	 * 
	 *   iface->init_async = foo_init_async;
	 *   iface->init_finish = foo_init_finish;
	 * }
	 * ]|
	 */
	interface AsyncInitable extends AsyncInitableMixin {}

	class AsyncInitable {
		public constructor(options?: Partial<AsyncInitableInitOptions>);
		/**
		 * Helper function for constructing #GAsyncInitable object. This is
		 * similar to {@link GObject.new} but also initializes the object asynchronously.
		 * 
		 * When the initialization is finished, #callback will be called. You can
		 * then call g_async_initable_new_finish() to get the new object and check
		 * for any errors.
		 * @param object_type a #GType supporting #GAsyncInitable.
		 * @param io_priority the [I/O priority][io-priority] of the operation
		 * @param cancellable optional #GCancellable object, %NULL to ignore.
		 * @param callback a #GAsyncReadyCallback to call when the initialization is
		 *     finished
		 * @param first_property_name the name of the first property, or %NULL if no
		 *     properties
		 */
		public static new_async(object_type: GObject.Type, io_priority: number, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null, first_property_name?: string | null): void;
		/**
		 * Helper function for constructing #GAsyncInitable object. This is
		 * similar to {@link GObject.new_valist} but also initializes the object
		 * asynchronously.
		 * 
		 * When the initialization is finished, #callback will be called. You can
		 * then call g_async_initable_new_finish() to get the new object and check
		 * for any errors.
		 * @param object_type a #GType supporting #GAsyncInitable.
		 * @param first_property_name the name of the first property, followed by
		 * the value, and other property value pairs, and ended by %NULL.
		 * @param var_args The var args list generated from #first_property_name.
		 * @param io_priority the [I/O priority][io-priority] of the operation
		 * @param cancellable optional #GCancellable object, %NULL to ignore.
		 * @param callback a #GAsyncReadyCallback to call when the initialization is
		 *     finished
		 */
		public static new_valist_async(object_type: GObject.Type, first_property_name: string, var_args: any[], io_priority: number, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;
		/**
		 * @deprecated
		 * Use {@link GObject.new_with_properties} and
		 * g_async_initable_init_async() instead. See #GParameter for more information.
		 * 
		 * Helper function for constructing #GAsyncInitable object. This is
		 * similar to {@link GObject.newv} but also initializes the object asynchronously.
		 * 
		 * When the initialization is finished, #callback will be called. You can
		 * then call g_async_initable_new_finish() to get the new object and check
		 * for any errors.
		 * @param object_type a #GType supporting #GAsyncInitable.
		 * @param n_parameters the number of parameters in #parameters
		 * @param parameters the parameters to use to construct the object
		 * @param io_priority the [I/O priority][io-priority] of the operation
		 * @param cancellable optional #GCancellable object, %NULL to ignore.
		 * @param callback a #GAsyncReadyCallback to call when the initialization is
		 *     finished
		 */
		public static newv_async(object_type: GObject.Type, n_parameters: number, parameters: GObject.Parameter, io_priority: number, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;
	}



	/** This construct is only for enabling class multi-inheritance,
	 * use {@link AsyncResult} instead.
	 */
	interface IAsyncResult {
		/**
		 * Gets the source object from a #GAsyncResult.
		 * @returns a new reference to the source
		 *    object for the #res, or %NULL if there is none.
		 */
		get_source_object(): GObject.Object | null;
		/**
		 * Gets the user data from a #GAsyncResult.
		 * @returns the user data for #res.
		 */
		get_user_data(): any | null;
		/**
		 * Checks if #res has the given #source_tag (generally a function
		 * pointer indicating the function #res was created by).
		 * @param source_tag an application-defined tag
		 * @returns %TRUE if #res has the indicated #source_tag, %FALSE if
		 *   not.
		 */
		is_tagged(source_tag?: any | null): boolean;
		/**
		 * If #res is a #GSimpleAsyncResult, this is equivalent to
		 * {@link G.simple_async_result_propagate_error}. Otherwise it returns
		 * %FALSE.
		 * 
		 * This can be used for legacy error handling in async *_finish()
		 * wrapper functions that traditionally handled #GSimpleAsyncResult
		 * error returns themselves rather than calling into the virtual method.
		 * This should not be used in new code; #GAsyncResult errors that are
		 * set by virtual methods should also be extracted by virtual methods,
		 * to enable subclasses to chain up correctly.
		 * @returns %TRUE if #error is has been filled in with an error from
		 *   #res, %FALSE if not.
		 */
		legacy_propagate_error(): boolean;
	}

	type AsyncResultInitOptionsMixin  = {};
	export interface AsyncResultInitOptions extends AsyncResultInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link AsyncResult} instead.
	 */
	type AsyncResultMixin = IAsyncResult;

	/**
	 * Provides a base class for implementing asynchronous function results.
	 * 
	 * Asynchronous operations are broken up into two separate operations
	 * which are chained together by a #GAsyncReadyCallback. To begin
	 * an asynchronous operation, provide a #GAsyncReadyCallback to the
	 * asynchronous function. This callback will be triggered when the
	 * operation has completed, and must be run in a later iteration of
	 * the [thread-default main context][g-main-context-push-thread-default]
	 * from where the operation was initiated. It will be passed a
	 * #GAsyncResult instance filled with the details of the operation's
	 * success or failure, the object the asynchronous function was
	 * started for and any error codes returned. The asynchronous callback
	 * function is then expected to call the corresponding {@link ".finish}"
	 * function, passing the object the function was called for, the
	 * #GAsyncResult instance, and (optionally) an #error to grab any
	 * error conditions that may have occurred.
	 * 
	 * The "_finish()" function for an operation takes the generic result
	 * (of type #GAsyncResult) and returns the specific result that the
	 * operation in question yields (e.g. a #GFileEnumerator for a
	 * "enumerate children" operation). If the result or error status of the
	 * operation is not needed, there is no need to call the "_finish()"
	 * function; GIO will take care of cleaning up the result and error
	 * information after the #GAsyncReadyCallback returns. You can pass
	 * %NULL for the #GAsyncReadyCallback if you don't need to take any
	 * action at all after the operation completes. Applications may also
	 * take a reference to the #GAsyncResult and call "_finish()" later;
	 * however, the "_finish()" function may be called at most once.
	 * 
	 * Example of a typical asynchronous operation flow:
	 * |[<!-- language="C" -->
	 * void _theoretical_frobnitz_async (Theoretical         *t,
	 *                                   GCancellable        *c,
	 *                                   GAsyncReadyCallback  cb,
	 *                                   gpointer             u);
	 * 
	 * gboolean _theoretical_frobnitz_finish (Theoretical   *t,
	 *                                        GAsyncResult  *res,
	 *                                        GError       **e);
	 * 
	 * static void
	 * frobnitz_result_func (GObject      *source_object,
	 * 		 GAsyncResult *res,
	 * 		 gpointer      user_data)
	 * {
	 *   gboolean success = FALSE;
	 * 
	 *   success = _theoretical_frobnitz_finish (source_object, res, NULL);
	 * 
	 *   if (success)
	 *     g_printf ("Hurray!\n");
	 *   else
	 *     g_printf ("Uh oh!\n");
	 * 
	 *   ...
	 * 
	 * }
	 * 
	 * int main (int argc, void *argv[])
	 * {
	 *    ...
	 * 
	 *    _theoretical_frobnitz_async (theoretical_data,
	 *                                 NULL,
	 *                                 frobnitz_result_func,
	 *                                 NULL);
	 * 
	 *    ...
	 * }
	 * ]|
	 * 
	 * The callback for an asynchronous operation is called only once, and is
	 * always called, even in the case of a cancelled operation. On cancellation
	 * the result is a %G_IO_ERROR_CANCELLED error.
	 * 
	 * ## I/O Priority # {#io-priority}
	 * 
	 * Many I/O-related asynchronous operations have a priority parameter,
	 * which is used in certain cases to determine the order in which
	 * operations are executed. They are not used to determine system-wide
	 * I/O scheduling. Priorities are integers, with lower numbers indicating
	 * higher priority. It is recommended to choose priorities between
	 * %G_PRIORITY_LOW and %G_PRIORITY_HIGH, with %G_PRIORITY_DEFAULT
	 * as a default.
	 */
	interface AsyncResult extends AsyncResultMixin {}

	class AsyncResult {
		public constructor(options?: Partial<AsyncResultInitOptions>);
	}



	/** This construct is only for enabling class multi-inheritance,
	 * use {@link Converter} instead.
	 */
	interface IConverter {
		/**
		 * This is the main operation used when converting data. It is to be called
		 * multiple times in a loop, and each time it will do some work, i.e.
		 * producing some output (in #outbuf) or consuming some input (from #inbuf) or
		 * both. If its not possible to do any work an error is returned.
		 * 
		 * Note that a single call may not consume all input (or any input at all).
		 * Also a call may produce output even if given no input, due to state stored
		 * in the converter producing output.
		 * 
		 * If any data was either produced or consumed, and then an error happens, then
		 * only the successful conversion is reported and the error is returned on the
		 * next call.
		 * 
		 * A full conversion loop involves calling this method repeatedly, each time
		 * giving it new input and space output space. When there is no more input
		 * data after the data in #inbuf, the flag %G_CONVERTER_INPUT_AT_END must be set.
		 * The loop will be (unless some error happens) returning %G_CONVERTER_CONVERTED
		 * each time until all data is consumed and all output is produced, then
		 * %G_CONVERTER_FINISHED is returned instead. Note, that %G_CONVERTER_FINISHED
		 * may be returned even if %G_CONVERTER_INPUT_AT_END is not set, for instance
		 * in a decompression converter where the end of data is detectable from the
		 * data (and there might even be other data after the end of the compressed data).
		 * 
		 * When some data has successfully been converted #bytes_read and is set to
		 * the number of bytes read from #inbuf, and #bytes_written is set to indicate
		 * how many bytes was written to #outbuf. If there are more data to output
		 * or consume (i.e. unless the %G_CONVERTER_INPUT_AT_END is specified) then
		 * %G_CONVERTER_CONVERTED is returned, and if no more data is to be output
		 * then %G_CONVERTER_FINISHED is returned.
		 * 
		 * On error %G_CONVERTER_ERROR is returned and #error is set accordingly.
		 * Some errors need special handling:
		 * 
		 * %G_IO_ERROR_NO_SPACE is returned if there is not enough space
		 * to write the resulting converted data, the application should
		 * call the function again with a larger #outbuf to continue.
		 * 
		 * %G_IO_ERROR_PARTIAL_INPUT is returned if there is not enough
		 * input to fully determine what the conversion should produce,
		 * and the %G_CONVERTER_INPUT_AT_END flag is not set. This happens for
		 * example with an incomplete multibyte sequence when converting text,
		 * or when a regexp matches up to the end of the input (and may match
		 * further input). It may also happen when #inbuf_size is zero and
		 * there is no more data to produce.
		 * 
		 * When this happens the application should read more input and then
		 * call the function again. If further input shows that there is no
		 * more data call the function again with the same data but with
		 * the %G_CONVERTER_INPUT_AT_END flag set. This may cause the conversion
		 * to finish as e.g. in the regexp match case (or, to fail again with
		 * %G_IO_ERROR_PARTIAL_INPUT in e.g. a charset conversion where the
		 * input is actually partial).
		 * 
		 * After {@link G.converter_convert} has returned %G_CONVERTER_FINISHED the
		 * converter object is in an invalid state where its not allowed
		 * to call g_converter_convert() anymore. At this time you can only
		 * free the object or call g_converter_reset() to reset it to the
		 * initial state.
		 * 
		 * If the flag %G_CONVERTER_FLUSH is set then conversion is modified
		 * to try to write out all internal state to the output. The application
		 * has to call the function multiple times with the flag set, and when
		 * the available input has been consumed and all internal state has
		 * been produced then %G_CONVERTER_FLUSHED (or %G_CONVERTER_FINISHED if
		 * really at the end) is returned instead of %G_CONVERTER_CONVERTED.
		 * This is somewhat similar to what happens at the end of the input stream,
		 * but done in the middle of the data.
		 * 
		 * This has different meanings for different conversions. For instance
		 * in a compression converter it would mean that we flush all the
		 * compression state into output such that if you uncompress the
		 * compressed data you get back all the input data. Doing this may
		 * make the final file larger due to padding though. Another example
		 * is a regexp conversion, where if you at the end of the flushed data
		 * have a match, but there is also a potential longer match. In the
		 * non-flushed case we would ask for more input, but when flushing we
		 * treat this as the end of input and do the match.
		 * 
		 * Flushing is not always possible (like if a charset converter flushes
		 * at a partial multibyte sequence). Converters are supposed to try
		 * to produce as much output as possible and then return an error
		 * (typically %G_IO_ERROR_PARTIAL_INPUT).
		 * @param inbuf the buffer
		 *         containing the data to convert.
		 * @param outbuf a buffer to write
		 *    converted data in.
		 * @param flags a #GConverterFlags controlling the conversion details
		 * @returns a #GConverterResult, %G_CONVERTER_ERROR on error.
		 * 
		 * will be set to the number of bytes read from #inbuf on success
		 * 
		 * will be set to the number of bytes written to #outbuf on success
		 */
		convert(inbuf: number[], outbuf: number[], flags: ConverterFlags): [ ConverterResult, number, number ];
		/**
		 * Resets all internal state in the converter, making it behave
		 * as if it was just created. If the converter has any internal
		 * state that would produce output then that output is lost.
		 */
		reset(): void;
	}

	type ConverterInitOptionsMixin  = {};
	export interface ConverterInitOptions extends ConverterInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link Converter} instead.
	 */
	type ConverterMixin = IConverter;

	/**
	 * #GConverter is implemented by objects that convert
	 * binary data in various ways. The conversion can be
	 * stateful and may fail at any place.
	 * 
	 * Some example conversions are: character set conversion,
	 * compression, decompression and regular expression
	 * replace.
	 */
	interface Converter extends ConverterMixin {}

	class Converter {
		public constructor(options?: Partial<ConverterInitOptions>);
	}



	/** This construct is only for enabling class multi-inheritance,
	 * use {@link DBusInterface} instead.
	 */
	interface IDBusInterface {
		/**
		 * Gets D-Bus introspection information for the D-Bus interface
		 * implemented by #interface_.
		 * @returns A #GDBusInterfaceInfo. Do not free.
		 */
		get_info(): DBusInterfaceInfo;
		/**
		 * Gets the #GDBusObject that #interface_ belongs to, if any.
		 * @returns A #GDBusObject or %NULL. The returned
		 * reference should be freed with {@link GObject.unref}.
		 */
		get_object(): DBusObject | null;
		/**
		 * Sets the #GDBusObject for #interface_ to #object.
		 * 
		 * Note that #interface_ will hold a weak reference to #object.
		 * @param object A #GDBusObject or %NULL.
		 */
		set_object(object?: DBusObject | null): void;
	}

	type DBusInterfaceInitOptionsMixin  = {};
	export interface DBusInterfaceInitOptions extends DBusInterfaceInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link DBusInterface} instead.
	 */
	type DBusInterfaceMixin = IDBusInterface;

	/**
	 * The #GDBusInterface type is the base type for D-Bus interfaces both
	 * on the service side (see #GDBusInterfaceSkeleton) and client side
	 * (see #GDBusProxy).
	 */
	interface DBusInterface extends DBusInterfaceMixin {}

	class DBusInterface {
		public constructor(options?: Partial<DBusInterfaceInitOptions>);
	}



	/** This construct is only for enabling class multi-inheritance,
	 * use {@link DBusObject} instead.
	 */
	interface IDBusObject {
		/**
		 * Gets the D-Bus interface with name #interface_name associated with
		 * #object, if any.
		 * @param interface_name A D-Bus interface name.
		 * @returns %NULL if not found, otherwise a
		 *   #GDBusInterface that must be freed with {@link GObject.unref}.
		 */
		get_interface(interface_name: string): DBusInterface | null;
		/**
		 * Gets the D-Bus interfaces associated with #object.
		 * @returns A list of #GDBusInterface instances.
		 *   The returned list must be freed by {@link G.list_free} after each element has been freed
		 *   with g_object_unref().
		 */
		get_interfaces(): DBusInterface[];
		/**
		 * Gets the object path for #object.
		 * @returns A string owned by #object. Do not free.
		 */
		get_object_path(): string;
		/**
		 * Emitted when #interface is added to #object.
		 * @param signal 
		 * @param callback Callback function
		 *  - owner: owner of the emitted event 
		 *  - _interface: The #GDBusInterface that was added. 
		 * 
		 * @returns Callback ID
		 */
		connect(signal: "interface-added", callback: (owner: this, _interface: DBusInterface) => void): number;
		/**
		 * Emitted when #interface is removed from #object.
		 * @param signal 
		 * @param callback Callback function
		 *  - owner: owner of the emitted event 
		 *  - _interface: The #GDBusInterface that was removed. 
		 * 
		 * @returns Callback ID
		 */
		connect(signal: "interface-removed", callback: (owner: this, _interface: DBusInterface) => void): number;

	}

	type DBusObjectInitOptionsMixin  = {};
	export interface DBusObjectInitOptions extends DBusObjectInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link DBusObject} instead.
	 */
	type DBusObjectMixin = IDBusObject;

	/**
	 * The #GDBusObject type is the base type for D-Bus objects on both
	 * the service side (see #GDBusObjectSkeleton) and the client side
	 * (see #GDBusObjectProxy). It is essentially just a container of
	 * interfaces.
	 */
	interface DBusObject extends DBusObjectMixin {}

	class DBusObject {
		public constructor(options?: Partial<DBusObjectInitOptions>);
	}



	/** This construct is only for enabling class multi-inheritance,
	 * use {@link DBusObjectManager} instead.
	 */
	interface IDBusObjectManager {
		/**
		 * Gets the interface proxy for #interface_name at #object_path, if
		 * any.
		 * @param object_path Object path to look up.
		 * @param interface_name D-Bus interface name to look up.
		 * @returns A #GDBusInterface instance or %NULL. Free
		 *   with {@link GObject.unref}.
		 */
		get_interface(object_path: string, interface_name: string): DBusInterface | null;
		/**
		 * Gets the #GDBusObjectProxy at #object_path, if any.
		 * @param object_path Object path to look up.
		 * @returns A #GDBusObject or %NULL. Free with
		 *   {@link GObject.unref}.
		 */
		get_object(object_path: string): DBusObject | null;
		/**
		 * Gets the object path that #manager is for.
		 * @returns A string owned by #manager. Do not free.
		 */
		get_object_path(): string;
		/**
		 * Gets all #GDBusObject objects known to #manager.
		 * @returns A list of
		 *   #GDBusObject objects. The returned list should be freed with
		 *   {@link G.list_free} after each element has been freed with
		 *   g_object_unref().
		 */
		get_objects(): DBusObject[];
		/**
		 * Emitted when #interface is added to #object.
		 * 
		 * This signal exists purely as a convenience to avoid having to
		 * connect signals to all objects managed by #manager.
		 * @param signal 
		 * @param callback Callback function
		 *  - owner: owner of the emitted event 
		 *  - object: The #GDBusObject on which an interface was added. 
		 *  - _interface: The #GDBusInterface that was added. 
		 * 
		 * @returns Callback ID
		 */
		connect(signal: "interface-added", callback: (owner: this, object: DBusObject, _interface: DBusInterface) => void): number;
		/**
		 * Emitted when #interface has been removed from #object.
		 * 
		 * This signal exists purely as a convenience to avoid having to
		 * connect signals to all objects managed by #manager.
		 * @param signal 
		 * @param callback Callback function
		 *  - owner: owner of the emitted event 
		 *  - object: The #GDBusObject on which an interface was removed. 
		 *  - _interface: The #GDBusInterface that was removed. 
		 * 
		 * @returns Callback ID
		 */
		connect(signal: "interface-removed", callback: (owner: this, object: DBusObject, _interface: DBusInterface) => void): number;
		/**
		 * Emitted when #object is added to #manager.
		 * @param signal 
		 * @param callback Callback function
		 *  - owner: owner of the emitted event 
		 *  - object: The #GDBusObject that was added. 
		 * 
		 * @returns Callback ID
		 */
		connect(signal: "object-added", callback: (owner: this, object: DBusObject) => void): number;
		/**
		 * Emitted when #object is removed from #manager.
		 * @param signal 
		 * @param callback Callback function
		 *  - owner: owner of the emitted event 
		 *  - object: The #GDBusObject that was removed. 
		 * 
		 * @returns Callback ID
		 */
		connect(signal: "object-removed", callback: (owner: this, object: DBusObject) => void): number;

	}

	type DBusObjectManagerInitOptionsMixin  = {};
	export interface DBusObjectManagerInitOptions extends DBusObjectManagerInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link DBusObjectManager} instead.
	 */
	type DBusObjectManagerMixin = IDBusObjectManager;

	/**
	 * The #GDBusObjectManager type is the base type for service- and
	 * client-side implementations of the standardized
	 * [org.freedesktop.DBus.ObjectManager](http://dbus.freedesktop.org/doc/dbus-specification.html#standard-interfaces-objectmanager)
	 * interface.
	 * 
	 * See #GDBusObjectManagerClient for the client-side implementation
	 * and #GDBusObjectManagerServer for the service-side implementation.
	 */
	interface DBusObjectManager extends DBusObjectManagerMixin {}

	class DBusObjectManager {
		public constructor(options?: Partial<DBusObjectManagerInitOptions>);
	}



	/** This construct is only for enabling class multi-inheritance,
	 * use {@link DatagramBased} instead.
	 */
	interface IDatagramBased {
		/**
		 * Checks on the readiness of #datagram_based to perform operations. The
		 * operations specified in #condition are checked for and masked against the
		 * currently-satisfied conditions on #datagram_based. The result is returned.
		 * 
		 * %G_IO_IN will be set in the return value if data is available to read with
		 * {@link G.datagram_based_receive_messages}, or if the connection is closed remotely
		 * (EOS); and if the datagram_based has not been closed locally using some
		 * implementation-specific method (such as g_socket_close() or
		 * g_socket_shutdown() with #shutdown_read set, if it’s a #GSocket).
		 * 
		 * If the connection is shut down or closed (by calling g_socket_close() or
		 * g_socket_shutdown() with #shutdown_read set, if it’s a #GSocket, for
		 * example), all calls to this function will return %G_IO_ERROR_CLOSED.
		 * 
		 * %G_IO_OUT will be set if it is expected that at least one byte can be sent
		 * using g_datagram_based_send_messages() without blocking. It will not be set
		 * if the datagram_based has been closed locally.
		 * 
		 * %G_IO_HUP will be set if the connection has been closed locally.
		 * 
		 * %G_IO_ERR will be set if there was an asynchronous error in transmitting data
		 * previously enqueued using g_datagram_based_send_messages().
		 * 
		 * Note that on Windows, it is possible for an operation to return
		 * %G_IO_ERROR_WOULD_BLOCK even immediately after
		 * g_datagram_based_condition_check() has claimed that the #GDatagramBased is
		 * ready for writing. Rather than calling g_datagram_based_condition_check() and
		 * then writing to the #GDatagramBased if it succeeds, it is generally better to
		 * simply try writing right away, and try again later if the initial attempt
		 * returns %G_IO_ERROR_WOULD_BLOCK.
		 * 
		 * It is meaningless to specify %G_IO_ERR or %G_IO_HUP in #condition; these
		 * conditions will always be set in the output if they are true. Apart from
		 * these flags, the output is guaranteed to be masked by #condition.
		 * 
		 * This call never blocks.
		 * @param condition a #GIOCondition mask to check
		 * @returns the #GIOCondition mask of the current state
		 */
		condition_check(condition: GLib.IOCondition): GLib.IOCondition;
		/**
		 * Waits for up to #timeout microseconds for condition to become true on
		 * #datagram_based. If the condition is met, %TRUE is returned.
		 * 
		 * If #cancellable is cancelled before the condition is met, or if #timeout is
		 * reached before the condition is met, then %FALSE is returned and #error is
		 * set appropriately (%G_IO_ERROR_CANCELLED or %G_IO_ERROR_TIMED_OUT).
		 * @param condition a #GIOCondition mask to wait for
		 * @param timeout the maximum time (in microseconds) to wait, 0 to not block, or -1
		 *   to block indefinitely
		 * @param cancellable a #GCancellable
		 * @returns %TRUE if the condition was met, %FALSE otherwise
		 */
		// condition_wait(condition: GLib.IOCondition, timeout: number, cancellable?: Cancellable | null): boolean;
		/**
		 * Creates a #GSource that can be attached to a #GMainContext to monitor for
		 * the availability of the specified #condition on the #GDatagramBased. The
		 * #GSource keeps a reference to the #datagram_based.
		 * 
		 * The callback on the source is of the #GDatagramBasedSourceFunc type.
		 * 
		 * It is meaningless to specify %G_IO_ERR or %G_IO_HUP in #condition; these
		 * conditions will always be reported in the callback if they are true.
		 * 
		 * If non-%NULL, #cancellable can be used to cancel the source, which will
		 * cause the source to trigger, reporting the current condition (which is
		 * likely 0 unless cancellation happened at the same time as a condition
		 * change). You can check for this in the callback using
		 * {@link G.cancellable_is_cancelled}.
		 * @param condition a #GIOCondition mask to monitor
		 * @param cancellable a #GCancellable
		 * @returns a newly allocated #GSource
		 */
		create_source(condition: GLib.IOCondition, cancellable?: Cancellable | null): GLib.Source;
		/**
		 * Receive one or more data messages from #datagram_based in one go.
		 * 
		 * #messages must point to an array of #GInputMessage structs and
		 * #num_messages must be the length of this array. Each #GInputMessage
		 * contains a pointer to an array of #GInputVector structs describing the
		 * buffers that the data received in each message will be written to.
		 * 
		 * #flags modify how all messages are received. The commonly available
		 * arguments for this are available in the #GSocketMsgFlags enum, but the
		 * values there are the same as the system values, and the flags
		 * are passed in as-is, so you can pass in system-specific flags too. These
		 * flags affect the overall receive operation. Flags affecting individual
		 * messages are returned in #GInputMessage.flags.
		 * 
		 * The other members of #GInputMessage are treated as described in its
		 * documentation.
		 * 
		 * If #timeout is negative the call will block until #num_messages have been
		 * received, the connection is closed remotely (EOS), #cancellable is cancelled,
		 * or an error occurs.
		 * 
		 * If #timeout is 0 the call will return up to #num_messages without blocking,
		 * or %G_IO_ERROR_WOULD_BLOCK if no messages are queued in the operating system
		 * to be received.
		 * 
		 * If #timeout is positive the call will block on the same conditions as if
		 * #timeout were negative. If the timeout is reached
		 * before any messages are received, %G_IO_ERROR_TIMED_OUT is returned,
		 * otherwise it will return the number of messages received before timing out.
		 * (Note: This is effectively the behaviour of `MSG_WAITFORONE` with
		 * recvmmsg().)
		 * 
		 * To be notified when messages are available, wait for the %G_IO_IN condition.
		 * Note though that you may still receive %G_IO_ERROR_WOULD_BLOCK from
		 * g_datagram_based_receive_messages() even if you were previously notified of a
		 * %G_IO_IN condition.
		 * 
		 * If the remote peer closes the connection, any messages queued in the
		 * underlying receive buffer will be returned, and subsequent calls to
		 * g_datagram_based_receive_messages() will return 0 (with no error set).
		 * 
		 * If the connection is shut down or closed (by calling g_socket_close() or
		 * g_socket_shutdown() with #shutdown_read set, if it’s a #GSocket, for
		 * example), all calls to this function will return %G_IO_ERROR_CLOSED.
		 * 
		 * On error -1 is returned and #error is set accordingly. An error will only
		 * be returned if zero messages could be received; otherwise the number of
		 * messages successfully received before the error will be returned. If
		 * #cancellable is cancelled, %G_IO_ERROR_CANCELLED is returned as with any
		 * other error.
		 * @param messages an array of #GInputMessage structs
		 * @param flags an int containing #GSocketMsgFlags flags for the overall operation
		 * @param timeout the maximum time (in microseconds) to wait, 0 to not block, or -1
		 *   to block indefinitely
		 * @param cancellable a %GCancellable
		 * @returns number of messages received, or -1 on error. Note that the number
		 *     of messages received may be smaller than #num_messages if #timeout is
		 *     zero or positive, if the peer closed the connection, or if #num_messages
		 *     was larger than `UIO_MAXIOV` (1024), in which case the caller may re-try
		 *     to receive the remaining messages.
		 */
		// receive_messages(messages: InputMessage[], flags: number, timeout: number, cancellable?: Cancellable | null): number;
		/**
		 * Send one or more data messages from #datagram_based in one go.
		 * 
		 * #messages must point to an array of #GOutputMessage structs and
		 * #num_messages must be the length of this array. Each #GOutputMessage
		 * contains an address to send the data to, and a pointer to an array of
		 * #GOutputVector structs to describe the buffers that the data to be sent
		 * for each message will be gathered from.
		 * 
		 * #flags modify how the message is sent. The commonly available arguments
		 * for this are available in the #GSocketMsgFlags enum, but the
		 * values there are the same as the system values, and the flags
		 * are passed in as-is, so you can pass in system-specific flags too.
		 * 
		 * The other members of #GOutputMessage are treated as described in its
		 * documentation.
		 * 
		 * If #timeout is negative the call will block until #num_messages have been
		 * sent, #cancellable is cancelled, or an error occurs.
		 * 
		 * If #timeout is 0 the call will send up to #num_messages without blocking,
		 * or will return %G_IO_ERROR_WOULD_BLOCK if there is no space to send messages.
		 * 
		 * If #timeout is positive the call will block on the same conditions as if
		 * #timeout were negative. If the timeout is reached before any messages are
		 * sent, %G_IO_ERROR_TIMED_OUT is returned, otherwise it will return the number
		 * of messages sent before timing out.
		 * 
		 * To be notified when messages can be sent, wait for the %G_IO_OUT condition.
		 * Note though that you may still receive %G_IO_ERROR_WOULD_BLOCK from
		 * {@link G.datagram_based_send_messages} even if you were previously notified of a
		 * %G_IO_OUT condition. (On Windows in particular, this is very common due to
		 * the way the underlying APIs work.)
		 * 
		 * If the connection is shut down or closed (by calling g_socket_close() or
		 * g_socket_shutdown() with #shutdown_write set, if it’s a #GSocket, for
		 * example), all calls to this function will return %G_IO_ERROR_CLOSED.
		 * 
		 * On error -1 is returned and #error is set accordingly. An error will only
		 * be returned if zero messages could be sent; otherwise the number of messages
		 * successfully sent before the error will be returned. If #cancellable is
		 * cancelled, %G_IO_ERROR_CANCELLED is returned as with any other error.
		 * @param messages an array of #GOutputMessage structs
		 * @param flags an int containing #GSocketMsgFlags flags
		 * @param timeout the maximum time (in microseconds) to wait, 0 to not block, or -1
		 *   to block indefinitely
		 * @param cancellable a %GCancellable
		 * @returns number of messages sent, or -1 on error. Note that the number of
		 *     messages sent may be smaller than #num_messages if #timeout is zero
		 *     or positive, or if #num_messages was larger than `UIO_MAXIOV` (1024), in
		 *     which case the caller may re-try to send the remaining messages.
		 */
		// send_messages(messages: OutputMessage[], flags: number, timeout: number, cancellable?: Cancellable | null): number;
	}

	type DatagramBasedInitOptionsMixin  = {};
	export interface DatagramBasedInitOptions extends DatagramBasedInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link DatagramBased} instead.
	 */
	type DatagramBasedMixin = IDatagramBased;

	/**
	 * A #GDatagramBased is a networking interface for representing datagram-based
	 * communications. It is a more or less direct mapping of the core parts of the
	 * BSD socket API in a portable GObject interface. It is implemented by
	 * #GSocket, which wraps the UNIX socket API on UNIX and winsock2 on Windows.
	 * 
	 * #GDatagramBased is entirely platform independent, and is intended to be used
	 * alongside higher-level networking APIs such as #GIOStream.
	 * 
	 * It uses vectored scatter/gather I/O by default, allowing for many messages
	 * to be sent or received in a single call. Where possible, implementations of
	 * the interface should take advantage of vectored I/O to minimise processing
	 * or system calls. For example, #GSocket uses recvmmsg() and sendmmsg() where
	 * possible. Callers should take advantage of scatter/gather I/O (the use of
	 * multiple buffers per message) to avoid unnecessary copying of data to
	 * assemble or disassemble a message.
	 * 
	 * Each #GDatagramBased operation has a timeout parameter which may be negative
	 * for blocking behaviour, zero for non-blocking behaviour, or positive for
	 * timeout behaviour. A blocking operation blocks until finished or there is an
	 * error. A non-blocking operation will return immediately with a
	 * %G_IO_ERROR_WOULD_BLOCK error if it cannot make progress. A timeout operation
	 * will block until the operation is complete or the timeout expires; if the
	 * timeout expires it will return what progress it made, or
	 * %G_IO_ERROR_TIMED_OUT if no progress was made. To know when a call would
	 * successfully run you can call g_datagram_based_condition_check() or
	 * g_datagram_based_condition_wait(). You can also use
	 * g_datagram_based_create_source() and attach it to a #GMainContext to get
	 * callbacks when I/O is possible.
	 * 
	 * When running a non-blocking operation applications should always be able to
	 * handle getting a %G_IO_ERROR_WOULD_BLOCK error even when some other function
	 * said that I/O was possible. This can easily happen in case of a race
	 * condition in the application, but it can also happen for other reasons. For
	 * instance, on Windows a socket is always seen as writable until a write
	 * returns %G_IO_ERROR_WOULD_BLOCK.
	 * 
	 * As with #GSocket, #GDatagramBaseds can be either connection oriented (for
	 * example, SCTP) or connectionless (for example, UDP). #GDatagramBaseds must be
	 * datagram-based, not stream-based. The interface does not cover connection
	 * establishment — use methods on the underlying type to establish a connection
	 * before sending and receiving data through the #GDatagramBased API. For
	 * connectionless socket types the target/source address is specified or
	 * received in each I/O operation.
	 * 
	 * Like most other APIs in GLib, #GDatagramBased is not inherently thread safe.
	 * To use a #GDatagramBased concurrently from multiple threads, you must
	 * implement your own locking.
	 */
	interface DatagramBased extends DatagramBasedMixin {}

	class DatagramBased {
		public constructor(options?: Partial<DatagramBasedInitOptions>);
	}



	/** This construct is only for enabling class multi-inheritance,
	 * use {@link DesktopAppInfoLookup} instead.
	 */
	interface IDesktopAppInfoLookup {
		/**
		 * @deprecated
		 * The #GDesktopAppInfoLookup interface is deprecated and
		 *    unused by GIO.
		 * 
		 * Gets the default application for launching applications
		 * using this URI scheme for a particular #GDesktopAppInfoLookup
		 * implementation.
		 * 
		 * The #GDesktopAppInfoLookup interface and this function is used
		 * to implement {@link G.app_info_get_default_for_uri_scheme} backends
		 * in a GIO module. There is no reason for applications to use it
		 * directly. Applications should use g_app_info_get_default_for_uri_scheme().
		 * @param uri_scheme a string containing a URI scheme.
		 * @returns #GAppInfo for given #uri_scheme or
		 *    %NULL on error.
		 */
		get_default_for_uri_scheme(uri_scheme: string): AppInfo | null;
	}

	type DesktopAppInfoLookupInitOptionsMixin  = {};
	export interface DesktopAppInfoLookupInitOptions extends DesktopAppInfoLookupInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link DesktopAppInfoLookup} instead.
	 */
	type DesktopAppInfoLookupMixin = IDesktopAppInfoLookup;

	/**
	 * #GDesktopAppInfoLookup is an opaque data structure and can only be accessed
	 * using the following functions.
	 */
	interface DesktopAppInfoLookup extends DesktopAppInfoLookupMixin {}

	class DesktopAppInfoLookup {
		public constructor(options?: Partial<DesktopAppInfoLookupInitOptions>);
	}



	/** This construct is only for enabling class multi-inheritance,
	 * use {@link Drive} instead.
	 */
	interface IDrive {
		/**
		 * Checks if a drive can be ejected.
		 * @returns %TRUE if the #drive can be ejected, %FALSE otherwise.
		 */
		can_eject(): boolean;
		/**
		 * Checks if a drive can be polled for media changes.
		 * @returns %TRUE if the #drive can be polled for media changes,
		 *     %FALSE otherwise.
		 */
		can_poll_for_media(): boolean;
		/**
		 * Checks if a drive can be started.
		 * @returns %TRUE if the #drive can be started, %FALSE otherwise.
		 */
		can_start(): boolean;
		/**
		 * Checks if a drive can be started degraded.
		 * @returns %TRUE if the #drive can be started degraded, %FALSE otherwise.
		 */
		can_start_degraded(): boolean;
		/**
		 * Checks if a drive can be stopped.
		 * @returns %TRUE if the #drive can be stopped, %FALSE otherwise.
		 */
		can_stop(): boolean;
		/**
		 * @deprecated
		 * Use {@link G.drive_eject_with_operation} instead.
		 * 
		 * Asynchronously ejects a drive.
		 * 
		 * When the operation is finished, #callback will be called.
		 * You can then call {@link G.drive_eject_finish} to obtain the
		 * result of the operation.
		 * @param flags flags affecting the unmount if required for eject
		 * @param cancellable optional #GCancellable object, %NULL to ignore.
		 * @param callback a #GAsyncReadyCallback, or %NULL.
		 */
		eject(flags: MountUnmountFlags, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;
		/**
		 * @deprecated
		 * Use {@link G.drive_eject_with_operation_finish} instead.
		 * 
		 * Finishes ejecting a drive.
		 * @param result a #GAsyncResult.
		 * @returns %TRUE if the drive has been ejected successfully,
		 *     %FALSE otherwise.
		 */
		eject_finish(result: AsyncResult): boolean;
		/**
		 * Ejects a drive. This is an asynchronous operation, and is
		 * finished by calling {@link G.drive_eject_with_operation_finish} with the #drive
		 * and #GAsyncResult data returned in the #callback.
		 * @param flags flags affecting the unmount if required for eject
		 * @param mount_operation a #GMountOperation or %NULL to avoid
		 *     user interaction.
		 * @param cancellable optional #GCancellable object, %NULL to ignore.
		 * @param callback a #GAsyncReadyCallback, or %NULL.
		 */
		eject_with_operation(flags: MountUnmountFlags, mount_operation?: MountOperation | null, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;
		/**
		 * Finishes ejecting a drive. If any errors occurred during the operation,
		 * #error will be set to contain the errors and %FALSE will be returned.
		 * @param result a #GAsyncResult.
		 * @returns %TRUE if the drive was successfully ejected. %FALSE otherwise.
		 */
		eject_with_operation_finish(result: AsyncResult): boolean;
		/**
		 * Gets the kinds of identifiers that #drive has.
		 * Use {@link G.drive_get_identifier} to obtain the identifiers
		 * themselves.
		 * @returns a %NULL-terminated
		 *     array of strings containing kinds of identifiers. Use {@link G.strfreev}
		 *     to free.
		 */
		enumerate_identifiers(): string[];
		/**
		 * Gets the icon for #drive.
		 * @returns #GIcon for the #drive.
		 *    Free the returned object with {@link GObject.unref}.
		 */
		get_icon(): Icon;
		/**
		 * Gets the identifier of the given kind for #drive. The only
		 * identifier currently available is
		 * #G_DRIVE_IDENTIFIER_KIND_UNIX_DEVICE.
		 * @param kind the kind of identifier to return
		 * @returns a newly allocated string containing the
		 *     requested identifier, or %NULL if the #GDrive
		 *     doesn't have this kind of identifier.
		 */
		get_identifier(kind: string): string | null;
		/**
		 * Gets the name of #drive.
		 * @returns a string containing #drive's name. The returned
		 *     string should be freed when no longer needed.
		 */
		get_name(): string;
		/**
		 * Gets the sort key for #drive, if any.
		 * @returns Sorting key for #drive or %NULL if no such key is available.
		 */
		get_sort_key(): string | null;
		/**
		 * Gets a hint about how a drive can be started/stopped.
		 * @returns A value from the #GDriveStartStopType enumeration.
		 */
		get_start_stop_type(): DriveStartStopType;
		/**
		 * Gets the icon for #drive.
		 * @returns symbolic #GIcon for the #drive.
		 *    Free the returned object with {@link GObject.unref}.
		 */
		get_symbolic_icon(): Icon;
		/**
		 * Get a list of mountable volumes for #drive.
		 * 
		 * The returned list should be freed with {@link G.list_free}, after
		 * its elements have been unreffed with g_object_unref().
		 * @returns #GList containing any #GVolume objects on the given #drive.
		 */
		get_volumes(): Volume[];
		/**
		 * Checks if the #drive has media. Note that the OS may not be polling
		 * the drive for media changes; see {@link G.drive_is_media_check_automatic}
		 * for more details.
		 * @returns %TRUE if #drive has media, %FALSE otherwise.
		 */
		has_media(): boolean;
		/**
		 * Check if #drive has any mountable volumes.
		 * @returns %TRUE if the #drive contains volumes, %FALSE otherwise.
		 */
		has_volumes(): boolean;
		/**
		 * Checks if #drive is capable of automatically detecting media changes.
		 * @returns %TRUE if the #drive is capable of automatically detecting
		 *     media changes, %FALSE otherwise.
		 */
		is_media_check_automatic(): boolean;
		/**
		 * Checks if the #drive supports removable media.
		 * @returns %TRUE if #drive supports removable media, %FALSE otherwise.
		 */
		is_media_removable(): boolean;
		/**
		 * Checks if the #GDrive and/or its media is considered removable by the user.
		 * See {@link G.drive_is_media_removable}.
		 * @returns %TRUE if #drive and/or its media is considered removable, %FALSE otherwise.
		 */
		is_removable(): boolean;
		/**
		 * Asynchronously polls #drive to see if media has been inserted or removed.
		 * 
		 * When the operation is finished, #callback will be called.
		 * You can then call {@link G.drive_poll_for_media_finish} to obtain the
		 * result of the operation.
		 * @param cancellable optional #GCancellable object, %NULL to ignore.
		 * @param callback a #GAsyncReadyCallback, or %NULL.
		 */
		poll_for_media(cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;
		/**
		 * Finishes an operation started with {@link G.drive_poll_for_media} on a drive.
		 * @param result a #GAsyncResult.
		 * @returns %TRUE if the drive has been poll_for_mediaed successfully,
		 *     %FALSE otherwise.
		 */
		poll_for_media_finish(result: AsyncResult): boolean;
		/**
		 * Asynchronously starts a drive.
		 * 
		 * When the operation is finished, #callback will be called.
		 * You can then call {@link G.drive_start_finish} to obtain the
		 * result of the operation.
		 * @param flags flags affecting the start operation.
		 * @param mount_operation a #GMountOperation or %NULL to avoid
		 *     user interaction.
		 * @param cancellable optional #GCancellable object, %NULL to ignore.
		 * @param callback a #GAsyncReadyCallback, or %NULL.
		 */
		start(flags: DriveStartFlags, mount_operation?: MountOperation | null, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;
		/**
		 * Finishes starting a drive.
		 * @param result a #GAsyncResult.
		 * @returns %TRUE if the drive has been started successfully,
		 *     %FALSE otherwise.
		 */
		start_finish(result: AsyncResult): boolean;
		/**
		 * Asynchronously stops a drive.
		 * 
		 * When the operation is finished, #callback will be called.
		 * You can then call {@link G.drive_stop_finish} to obtain the
		 * result of the operation.
		 * @param flags flags affecting the unmount if required for stopping.
		 * @param mount_operation a #GMountOperation or %NULL to avoid
		 *     user interaction.
		 * @param cancellable optional #GCancellable object, %NULL to ignore.
		 * @param callback a #GAsyncReadyCallback, or %NULL.
		 */
		stop(flags: MountUnmountFlags, mount_operation?: MountOperation | null, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;
		/**
		 * Finishes stopping a drive.
		 * @param result a #GAsyncResult.
		 * @returns %TRUE if the drive has been stopped successfully,
		 *     %FALSE otherwise.
		 */
		stop_finish(result: AsyncResult): boolean;
		/**
		 * Emitted when the drive's state has changed.
		 * @param signal 
		 * @param callback Callback function
		 *  - owner: owner of the emitted event 
		 * 
		 * @returns Callback ID
		 */
		connect(signal: "changed", callback: (owner: this) => void): number;
		/**
		 * This signal is emitted when the #GDrive have been
		 * disconnected. If the recipient is holding references to the
		 * object they should release them so the object can be
		 * finalized.
		 * @param signal 
		 * @param callback Callback function
		 *  - owner: owner of the emitted event 
		 * 
		 * @returns Callback ID
		 */
		connect(signal: "disconnected", callback: (owner: this) => void): number;
		/**
		 * Emitted when the physical eject button (if any) of a drive has
		 * been pressed.
		 * @param signal 
		 * @param callback Callback function
		 *  - owner: owner of the emitted event 
		 * 
		 * @returns Callback ID
		 */
		connect(signal: "eject-button", callback: (owner: this) => void): number;
		/**
		 * Emitted when the physical stop button (if any) of a drive has
		 * been pressed.
		 * @param signal 
		 * @param callback Callback function
		 *  - owner: owner of the emitted event 
		 * 
		 * @returns Callback ID
		 */
		connect(signal: "stop-button", callback: (owner: this) => void): number;

	}

	type DriveInitOptionsMixin  = {};
	export interface DriveInitOptions extends DriveInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link Drive} instead.
	 */
	type DriveMixin = IDrive;

	/**
	 * #GDrive - this represent a piece of hardware connected to the machine.
	 * It's generally only created for removable hardware or hardware with
	 * removable media.
	 * 
	 * #GDrive is a container class for #GVolume objects that stem from
	 * the same piece of media. As such, #GDrive abstracts a drive with
	 * (or without) removable media and provides operations for querying
	 * whether media is available, determining whether media change is
	 * automatically detected and ejecting the media.
	 * 
	 * If the #GDrive reports that media isn't automatically detected, one
	 * can poll for media; typically one should not do this periodically
	 * as a poll for media operation is potentially expensive and may
	 * spin up the drive creating noise.
	 * 
	 * #GDrive supports starting and stopping drives with authentication
	 * support for the former. This can be used to support a diverse set
	 * of use cases including connecting/disconnecting iSCSI devices,
	 * powering down external disk enclosures and starting/stopping
	 * multi-disk devices such as RAID devices. Note that the actual
	 * semantics and side-effects of starting/stopping a #GDrive may vary
	 * according to implementation. To choose the correct verbs in e.g. a
	 * file manager, use {@link G.drive_get_start_stop_type}.
	 * 
	 * For porting from GnomeVFS note that there is no equivalent of
	 * #GDrive in that API.
	 */
	interface Drive extends DriveMixin {}

	class Drive {
		public constructor(options?: Partial<DriveInitOptions>);
	}



	/** This construct is only for enabling class multi-inheritance,
	 * use {@link DtlsClientConnection} instead.
	 */
	interface IDtlsClientConnection {
		/**
		 * A list of the distinguished names of the Certificate Authorities
		 * that the server will accept client certificates signed by. If the
		 * server requests a client certificate during the handshake, then
		 * this property will be set after the handshake completes.
		 * 
		 * Each item in the list is a #GByteArray which contains the complete
		 * subject DN of the certificate authority.
		 */
		readonly accepted_cas: any[];
		/**
		 * A #GSocketConnectable describing the identity of the server that
		 * is expected on the other end of the connection.
		 * 
		 * If the %G_TLS_CERTIFICATE_BAD_IDENTITY flag is set in
		 * #GDtlsClientConnection:validation-flags, this object will be used
		 * to determine the expected identify of the remote end of the
		 * connection; if #GDtlsClientConnection:server-identity is not set,
		 * or does not match the identity presented by the server, then the
		 * %G_TLS_CERTIFICATE_BAD_IDENTITY validation will fail.
		 * 
		 * In addition to its use in verifying the server certificate,
		 * this is also used to give a hint to the server about what
		 * certificate we expect, which is useful for servers that serve
		 * virtual hosts.
		 */
		server_identity: SocketConnectable;
		/**
		 * What steps to perform when validating a certificate received from
		 * a server. Server certificates that fail to validate in any of the
		 * ways indicated here will be rejected unless the application
		 * overrides the default via #GDtlsConnection::accept-certificate.
		 */
		validation_flags: TlsCertificateFlags;
		/**
		 * Gets the list of distinguished names of the Certificate Authorities
		 * that the server will accept certificates from. This will be set
		 * during the TLS handshake if the server requests a certificate.
		 * Otherwise, it will be %NULL.
		 * 
		 * Each item in the list is a #GByteArray which contains the complete
		 * subject DN of the certificate authority.
		 * @returns the list of
		 * CA DNs. You should unref each element with {@link G.byte_array_unref} and then
		 * the free the list with g_list_free().
		 */
		get_accepted_cas(): GLib.List;
		/**
		 * Gets #conn's expected server identity
		 * @returns a #GSocketConnectable describing the
		 * expected server identity, or %NULL if the expected identity is not
		 * known.
		 */
		get_server_identity(): SocketConnectable;
		/**
		 * Gets #conn's validation flags
		 * @returns the validation flags
		 */
		get_validation_flags(): TlsCertificateFlags;
		/**
		 * Sets #conn's expected server identity, which is used both to tell
		 * servers on virtual hosts which certificate to present, and also
		 * to let #conn know what name to look for in the certificate when
		 * performing %G_TLS_CERTIFICATE_BAD_IDENTITY validation, if enabled.
		 * @param identity a #GSocketConnectable describing the expected server identity
		 */
		set_server_identity(identity: SocketConnectable): void;
		/**
		 * Sets #conn's validation flags, to override the default set of
		 * checks performed when validating a server certificate. By default,
		 * %G_TLS_CERTIFICATE_VALIDATE_ALL is used.
		 * @param flags the #GTlsCertificateFlags to use
		 */
		set_validation_flags(flags: TlsCertificateFlags): void;
		connect(signal: "notify::accepted-cas", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::server-identity", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::validation-flags", callback: (owner: this, ...args: any) => void): number;

	}

	type DtlsClientConnectionInitOptionsMixin = Pick<IDtlsClientConnection,
		"server_identity" |
		"validation_flags">;

	export interface DtlsClientConnectionInitOptions extends DtlsClientConnectionInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link DtlsClientConnection} instead.
	 */
	type DtlsClientConnectionMixin = IDtlsClientConnection;

	/**
	 * #GDtlsClientConnection is the client-side subclass of
	 * #GDtlsConnection, representing a client-side DTLS connection.
	 */
	interface DtlsClientConnection extends DtlsClientConnectionMixin {}

	class DtlsClientConnection {
		public constructor(options?: Partial<DtlsClientConnectionInitOptions>);
		/**
		 * Creates a new #GDtlsClientConnection wrapping #base_socket which is
		 * assumed to communicate with the server identified by #server_identity.
		 * @param base_socket the #GDatagramBased to wrap
		 * @param server_identity the expected identity of the server
		 * @returns the new
		 *   #GDtlsClientConnection, or %NULL on error
		 */
		public static new(base_socket: DatagramBased, server_identity?: SocketConnectable | null): DtlsClientConnection;
	}



	/** This construct is only for enabling class multi-inheritance,
	 * use {@link DtlsConnection} instead.
	 */
	interface IDtlsConnection {
		/**
		 * The list of application-layer protocols that the connection
		 * advertises that it is willing to speak. See
		 * {@link G.dtls_connection_set_advertised_protocols}.
		 */
		advertised_protocols: string[];
		/**
		 * The #GDatagramBased that the connection wraps. Note that this may be any
		 * implementation of #GDatagramBased, not just a #GSocket.
		 */
		base_socket: DatagramBased;
		/**
		 * The connection's certificate; see
		 * {@link G.dtls_connection_set_certificate}.
		 */
		certificate: TlsCertificate;
		/**
		 * The name of the DTLS ciphersuite in use. See {@link G.dtls_connection_get_ciphersuite_name}.
		 */
		readonly ciphersuite_name: string;
		/**
		 * The certificate database to use when verifying this TLS connection.
		 * If no certificate database is set, then the default database will be
		 * used. See {@link G.tls_backend_get_default_database}.
		 */
		database: TlsDatabase;
		/**
		 * A #GTlsInteraction object to be used when the connection or certificate
		 * database need to interact with the user. This will be used to prompt the
		 * user for passwords where necessary.
		 */
		interaction: TlsInteraction;
		/**
		 * The application-layer protocol negotiated during the TLS
		 * handshake. See {@link G.dtls_connection_get_negotiated_protocol}.
		 */
		readonly negotiated_protocol: string;
		/**
		 * The connection's peer's certificate, after the TLS handshake has
		 * completed or failed. Note in particular that this is not yet set
		 * during the emission of #GDtlsConnection::accept-certificate.
		 * 
		 * (You can watch for a #GObject::notify signal on this property to
		 * detect when a handshake has occurred.)
		 */
		readonly peer_certificate: TlsCertificate;
		/**
		 * The errors noticed while verifying
		 * #GDtlsConnection:peer-certificate. Normally this should be 0, but
		 * it may not be if #GDtlsClientConnection:validation-flags is not
		 * %G_TLS_CERTIFICATE_VALIDATE_ALL, or if
		 * #GDtlsConnection::accept-certificate overrode the default
		 * behavior.
		 */
		readonly peer_certificate_errors: TlsCertificateFlags;
		/**
		 * The DTLS protocol version in use. See {@link G.dtls_connection_get_protocol_version}.
		 */
		readonly protocol_version: TlsProtocolVersion;
		/**
		 * @deprecated
		 * The rehandshake mode is ignored.
		 * 
		 * The rehandshaking mode. See
		 * {@link G.dtls_connection_set_rehandshake_mode}.
		 */
		rehandshake_mode: TlsRehandshakeMode;
		/**
		 * Whether or not proper TLS close notification is required.
		 * See {@link G.dtls_connection_set_require_close_notify}.
		 */
		require_close_notify: boolean;
		/**
		 * Close the DTLS connection. This is equivalent to calling
		 * {@link G.dtls_connection_shutdown} to shut down both sides of the connection.
		 * 
		 * Closing a #GDtlsConnection waits for all buffered but untransmitted data to
		 * be sent before it completes. It then sends a `close_notify` DTLS alert to the
		 * peer and may wait for a `close_notify` to be received from the peer. It does
		 * not close the underlying #GDtlsConnection:base-socket; that must be closed
		 * separately.
		 * 
		 * Once #conn is closed, all other operations will return %G_IO_ERROR_CLOSED.
		 * Closing a #GDtlsConnection multiple times will not return an error.
		 * 
		 * #GDtlsConnections will be automatically closed when the last reference is
		 * dropped, but you might want to call this function to make sure resources are
		 * released as early as possible.
		 * 
		 * If #cancellable is cancelled, the #GDtlsConnection may be left
		 * partially-closed and any pending untransmitted data may be lost. Call
		 * g_dtls_connection_close() again to complete closing the #GDtlsConnection.
		 * @param cancellable a #GCancellable, or %NULL
		 * @returns %TRUE on success, %FALSE otherwise
		 */
		close(cancellable?: Cancellable | null): boolean;
		/**
		 * Asynchronously close the DTLS connection. See {@link G.dtls_connection_close} for
		 * more information.
		 * @param io_priority the [I/O priority][io-priority] of the request
		 * @param cancellable a #GCancellable, or %NULL
		 * @param callback callback to call when the close operation is complete
		 */
		close_async(io_priority: number, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;
		/**
		 * Finish an asynchronous TLS close operation. See {@link G.dtls_connection_close}
		 * for more information.
		 * @param result a #GAsyncResult
		 * @returns %TRUE on success, %FALSE on failure, in which
		 * case #error will be set
		 */
		close_finish(result: AsyncResult): boolean;
		/**
		 * Used by #GDtlsConnection implementations to emit the
		 * #GDtlsConnection::accept-certificate signal.
		 * @param peer_cert the peer's #GTlsCertificate
		 * @param errors the problems with #peer_cert
		 * @returns %TRUE if one of the signal handlers has returned
		 *     %TRUE to accept #peer_cert
		 */
		emit_accept_certificate(peer_cert: TlsCertificate, errors: TlsCertificateFlags): boolean;
		/**
		 * Gets #conn's certificate, as set by
		 * {@link G.dtls_connection_set_certificate}.
		 * @returns #conn's certificate, or %NULL
		 */
		get_certificate(): TlsCertificate | null;
		/**
		 * Query the TLS backend for TLS channel binding data of #type for #conn.
		 * 
		 * This call retrieves TLS channel binding data as specified in RFC
		 * [5056](https://tools.ietf.org/html/rfc5056), RFC
		 * [5929](https://tools.ietf.org/html/rfc5929), and related RFCs.  The
		 * binding data is returned in #data.  The #data is resized by the callee
		 * using #GByteArray buffer management and will be freed when the #data
		 * is destroyed by {@link G.byte_array_unref}. If #data is %NULL, it will only
		 * check whether TLS backend is able to fetch the data (e.g. whether #type
		 * is supported by the TLS backend). It does not guarantee that the data
		 * will be available though.  That could happen if TLS connection does not
		 * support #type or the binding data is not available yet due to additional
		 * negotiation or input required.
		 * @param type #GTlsChannelBindingType type of data to fetch
		 * @returns %TRUE on success, %FALSE otherwise
		 * 
		 * #GByteArray is
		 *        filled with the binding data, or %NULL
		 */
		get_channel_binding_data(type: TlsChannelBindingType): [ boolean, number[] | null ];
		/**
		 * Returns the name of the current DTLS ciphersuite, or %NULL if the
		 * connection has not handshaked or has been closed. Beware that the TLS
		 * backend may use any of multiple different naming conventions, because
		 * OpenSSL and GnuTLS have their own ciphersuite naming conventions that
		 * are different from each other and different from the standard, IANA-
		 * registered ciphersuite names. The ciphersuite name is intended to be
		 * displayed to the user for informative purposes only, and parsing it
		 * is not recommended.
		 * @returns The name of the current DTLS ciphersuite, or %NULL
		 */
		get_ciphersuite_name(): string | null;
		/**
		 * Gets the certificate database that #conn uses to verify
		 * peer certificates. See {@link G.dtls_connection_set_database}.
		 * @returns the certificate database that #conn uses or %NULL
		 */
		get_database(): TlsDatabase | null;
		/**
		 * Get the object that will be used to interact with the user. It will be used
		 * for things like prompting the user for passwords. If %NULL is returned, then
		 * no user interaction will occur for this connection.
		 * @returns The interaction object.
		 */
		get_interaction(): TlsInteraction | null;
		/**
		 * Gets the name of the application-layer protocol negotiated during
		 * the handshake.
		 * 
		 * If the peer did not use the ALPN extension, or did not advertise a
		 * protocol that matched one of #conn's protocols, or the TLS backend
		 * does not support ALPN, then this will be %NULL. See
		 * {@link G.dtls_connection_set_advertised_protocols}.
		 * @returns the negotiated protocol, or %NULL
		 */
		get_negotiated_protocol(): string | null;
		/**
		 * Gets #conn's peer's certificate after the handshake has completed
		 * or failed. (It is not set during the emission of
		 * #GDtlsConnection::accept-certificate.)
		 * @returns #conn's peer's certificate, or %NULL
		 */
		get_peer_certificate(): TlsCertificate | null;
		/**
		 * Gets the errors associated with validating #conn's peer's
		 * certificate, after the handshake has completed or failed. (It is
		 * not set during the emission of #GDtlsConnection::accept-certificate.)
		 * @returns #conn's peer's certificate errors
		 */
		get_peer_certificate_errors(): TlsCertificateFlags;
		/**
		 * Returns the current DTLS protocol version, which may be
		 * %G_TLS_PROTOCOL_VERSION_UNKNOWN if the connection has not handshaked, or
		 * has been closed, or if the TLS backend has implemented a protocol version
		 * that is not a recognized #GTlsProtocolVersion.
		 * @returns The current DTLS protocol version
		 */
		get_protocol_version(): TlsProtocolVersion;
		/**
		 * @deprecated
		 * Changing the rehandshake mode is no longer
		 *   required for compatibility. Also, rehandshaking has been removed
		 *   from the TLS protocol in TLS 1.3.
		 * 
		 * Gets #conn rehandshaking mode. See
		 * {@link G.dtls_connection_set_rehandshake_mode} for details.
		 * @returns %G_TLS_REHANDSHAKE_SAFELY
		 */
		get_rehandshake_mode(): TlsRehandshakeMode;
		/**
		 * Tests whether or not #conn expects a proper TLS close notification
		 * when the connection is closed. See
		 * {@link G.dtls_connection_set_require_close_notify} for details.
		 * @returns %TRUE if #conn requires a proper TLS close notification.
		 */
		get_require_close_notify(): boolean;
		/**
		 * Attempts a TLS handshake on #conn.
		 * 
		 * On the client side, it is never necessary to call this method;
		 * although the connection needs to perform a handshake after
		 * connecting, #GDtlsConnection will handle this for you automatically
		 * when you try to send or receive data on the connection. You can call
		 * {@link G.dtls_connection_handshake} manually if you want to know whether
		 * the initial handshake succeeded or failed (as opposed to just
		 * immediately trying to use #conn to read or write, in which case,
		 * if it fails, it may not be possible to tell if it failed before
		 * or after completing the handshake), but beware that servers may reject
		 * client authentication after the handshake has completed, so a
		 * successful handshake does not indicate the connection will be usable.
		 * 
		 * Likewise, on the server side, although a handshake is necessary at
		 * the beginning of the communication, you do not need to call this
		 * function explicitly unless you want clearer error reporting.
		 * 
		 * Previously, calling g_dtls_connection_handshake() after the initial
		 * handshake would trigger a rehandshake; however, this usage was
		 * deprecated in GLib 2.60 because rehandshaking was removed from the
		 * TLS protocol in TLS 1.3. Since GLib 2.64, calling this function after
		 * the initial handshake will no longer do anything.
		 * 
		 * #GDtlsConnection::accept_certificate may be emitted during the
		 * handshake.
		 * @param cancellable a #GCancellable, or %NULL
		 * @returns success or failure
		 */
		handshake(cancellable?: Cancellable | null): boolean;
		/**
		 * Asynchronously performs a TLS handshake on #conn. See
		 * {@link G.dtls_connection_handshake} for more information.
		 * @param io_priority the [I/O priority][io-priority] of the request
		 * @param cancellable a #GCancellable, or %NULL
		 * @param callback callback to call when the handshake is complete
		 */
		handshake_async(io_priority: number, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;
		/**
		 * Finish an asynchronous TLS handshake operation. See
		 * {@link G.dtls_connection_handshake} for more information.
		 * @param result a #GAsyncResult.
		 * @returns %TRUE on success, %FALSE on failure, in which
		 * case #error will be set.
		 */
		handshake_finish(result: AsyncResult): boolean;
		/**
		 * Sets the list of application-layer protocols to advertise that the
		 * caller is willing to speak on this connection. The
		 * Application-Layer Protocol Negotiation (ALPN) extension will be
		 * used to negotiate a compatible protocol with the peer; use
		 * {@link G.dtls_connection_get_negotiated_protocol} to find the negotiated
		 * protocol after the handshake.  Specifying %NULL for the the value
		 * of #protocols will disable ALPN negotiation.
		 * 
		 * See [IANA TLS ALPN Protocol IDs](https://www.iana.org/assignments/tls-extensiontype-values/tls-extensiontype-values.xhtml#alpn-protocol-ids)
		 * for a list of registered protocol IDs.
		 * @param protocols a %NULL-terminated
		 *   array of ALPN protocol names (eg, "http/1.1", "h2"), or %NULL
		 */
		set_advertised_protocols(protocols?: string[] | null): void;
		/**
		 * This sets the certificate that #conn will present to its peer
		 * during the TLS handshake. For a #GDtlsServerConnection, it is
		 * mandatory to set this, and that will normally be done at construct
		 * time.
		 * 
		 * For a #GDtlsClientConnection, this is optional. If a handshake fails
		 * with %G_TLS_ERROR_CERTIFICATE_REQUIRED, that means that the server
		 * requires a certificate, and if you try connecting again, you should
		 * call this method first. You can call
		 * {@link G.dtls_client_connection_get_accepted_cas} on the failed connection
		 * to get a list of Certificate Authorities that the server will
		 * accept certificates from.
		 * 
		 * (It is also possible that a server will allow the connection with
		 * or without a certificate; in that case, if you don't provide a
		 * certificate, you can tell that the server requested one by the fact
		 * that g_dtls_client_connection_get_accepted_cas() will return
		 * non-%NULL.)
		 * @param certificate the certificate to use for #conn
		 */
		set_certificate(certificate: TlsCertificate): void;
		/**
		 * Sets the certificate database that is used to verify peer certificates.
		 * This is set to the default database by default. See
		 * {@link G.tls_backend_get_default_database}. If set to %NULL, then
		 * peer certificate validation will always set the
		 * %G_TLS_CERTIFICATE_UNKNOWN_CA error (meaning
		 * #GDtlsConnection::accept-certificate will always be emitted on
		 * client-side connections, unless that bit is not set in
		 * #GDtlsClientConnection:validation-flags).
		 * @param database a #GTlsDatabase
		 */
		set_database(database?: TlsDatabase | null): void;
		/**
		 * Set the object that will be used to interact with the user. It will be used
		 * for things like prompting the user for passwords.
		 * 
		 * The #interaction argument will normally be a derived subclass of
		 * #GTlsInteraction. %NULL can also be provided if no user interaction
		 * should occur for this connection.
		 * @param interaction an interaction object, or %NULL
		 */
		set_interaction(interaction?: TlsInteraction | null): void;
		/**
		 * @deprecated
		 * Changing the rehandshake mode is no longer
		 *   required for compatibility. Also, rehandshaking has been removed
		 *   from the TLS protocol in TLS 1.3.
		 * 
		 * Since GLib 2.64, changing the rehandshake mode is no longer supported
		 * and will have no effect. With TLS 1.3, rehandshaking has been removed from
		 * the TLS protocol, replaced by separate post-handshake authentication and
		 * rekey operations.
		 * @param mode the rehandshaking mode
		 */
		set_rehandshake_mode(mode: TlsRehandshakeMode): void;
		/**
		 * Sets whether or not #conn expects a proper TLS close notification
		 * before the connection is closed. If this is %TRUE (the default),
		 * then #conn will expect to receive a TLS close notification from its
		 * peer before the connection is closed, and will return a
		 * %G_TLS_ERROR_EOF error if the connection is closed without proper
		 * notification (since this may indicate a network error, or
		 * man-in-the-middle attack).
		 * 
		 * In some protocols, the application will know whether or not the
		 * connection was closed cleanly based on application-level data
		 * (because the application-level data includes a length field, or is
		 * somehow self-delimiting); in this case, the close notify is
		 * redundant and may be omitted. You
		 * can use {@link G.dtls_connection_set_require_close_notify} to tell #conn
		 * to allow an "unannounced" connection close, in which case the close
		 * will show up as a 0-length read, as in a non-TLS
		 * #GDatagramBased, and it is up to the application to check that
		 * the data has been fully received.
		 * 
		 * Note that this only affects the behavior when the peer closes the
		 * connection; when the application calls g_dtls_connection_close_async() on
		 * #conn itself, this will send a close notification regardless of the
		 * setting of this property. If you explicitly want to do an unclean
		 * close, you can close #conn's #GDtlsConnection:base-socket rather
		 * than closing #conn itself.
		 * @param require_close_notify whether or not to require close notification
		 */
		set_require_close_notify(require_close_notify: boolean): void;
		/**
		 * Shut down part or all of a DTLS connection.
		 * 
		 * If #shutdown_read is %TRUE then the receiving side of the connection is shut
		 * down, and further reading is disallowed. Subsequent calls to
		 * {@link G.datagram_based_receive_messages} will return %G_IO_ERROR_CLOSED.
		 * 
		 * If #shutdown_write is %TRUE then the sending side of the connection is shut
		 * down, and further writing is disallowed. Subsequent calls to
		 * g_datagram_based_send_messages() will return %G_IO_ERROR_CLOSED.
		 * 
		 * It is allowed for both #shutdown_read and #shutdown_write to be TRUE — this
		 * is equivalent to calling g_dtls_connection_close().
		 * 
		 * If #cancellable is cancelled, the #GDtlsConnection may be left
		 * partially-closed and any pending untransmitted data may be lost. Call
		 * g_dtls_connection_shutdown() again to complete closing the #GDtlsConnection.
		 * @param shutdown_read %TRUE to stop reception of incoming datagrams
		 * @param shutdown_write %TRUE to stop sending outgoing datagrams
		 * @param cancellable a #GCancellable, or %NULL
		 * @returns %TRUE on success, %FALSE otherwise
		 */
		shutdown(shutdown_read: boolean, shutdown_write: boolean, cancellable?: Cancellable | null): boolean;
		/**
		 * Asynchronously shut down part or all of the DTLS connection. See
		 * {@link G.dtls_connection_shutdown} for more information.
		 * @param shutdown_read %TRUE to stop reception of incoming datagrams
		 * @param shutdown_write %TRUE to stop sending outgoing datagrams
		 * @param io_priority the [I/O priority][io-priority] of the request
		 * @param cancellable a #GCancellable, or %NULL
		 * @param callback callback to call when the shutdown operation is complete
		 */
		shutdown_async(shutdown_read: boolean, shutdown_write: boolean, io_priority: number, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;
		/**
		 * Finish an asynchronous TLS shutdown operation. See
		 * {@link G.dtls_connection_shutdown} for more information.
		 * @param result a #GAsyncResult
		 * @returns %TRUE on success, %FALSE on failure, in which
		 * case #error will be set
		 */
		shutdown_finish(result: AsyncResult): boolean;
		/**
		 * Emitted during the TLS handshake after the peer certificate has
		 * been received. You can examine #peer_cert's certification path by
		 * calling {@link G.tls_certificate_get_issuer} on it.
		 * 
		 * For a client-side connection, #peer_cert is the server's
		 * certificate, and the signal will only be emitted if the
		 * certificate was not acceptable according to #conn's
		 * #GDtlsClientConnection:validation_flags. If you would like the
		 * certificate to be accepted despite #errors, return %TRUE from the
		 * signal handler. Otherwise, if no handler accepts the certificate,
		 * the handshake will fail with %G_TLS_ERROR_BAD_CERTIFICATE.
		 * 
		 * For a server-side connection, #peer_cert is the certificate
		 * presented by the client, if this was requested via the server's
		 * #GDtlsServerConnection:authentication_mode. On the server side,
		 * the signal is always emitted when the client presents a
		 * certificate, and the certificate will only be accepted if a
		 * handler returns %TRUE.
		 * 
		 * Note that if this signal is emitted as part of asynchronous I/O
		 * in the main thread, then you should not attempt to interact with
		 * the user before returning from the signal handler. If you want to
		 * let the user decide whether or not to accept the certificate, you
		 * would have to return %FALSE from the signal handler on the first
		 * attempt, and then after the connection attempt returns a
		 * %G_TLS_ERROR_BAD_CERTIFICATE, you can interact with the user, and
		 * if the user decides to accept the certificate, remember that fact,
		 * create a new connection, and return %TRUE from the signal handler
		 * the next time.
		 * 
		 * If you are doing I/O in another thread, you do not
		 * need to worry about this, and can simply block in the signal
		 * handler until the UI thread returns an answer.
		 * @param signal 
		 * @param callback Callback function
		 *  - owner: owner of the emitted event 
		 *  - peer_cert: the peer's #GTlsCertificate 
		 *  - errors: the problems with #peer_cert. 
		 *  - returns %TRUE to accept #peer_cert (which will also
		 * immediately end the signal emission). %FALSE to allow the signal
		 * emission to continue, which will cause the handshake to fail if
		 * no one else overrides it. 
		 * 
		 * @returns Callback ID
		 */
		connect(signal: "accept-certificate", callback: (owner: this, peer_cert: TlsCertificate, errors: TlsCertificateFlags) => boolean): number;

		connect(signal: "notify::advertised-protocols", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::base-socket", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::certificate", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::ciphersuite-name", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::database", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::interaction", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::negotiated-protocol", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::peer-certificate", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::peer-certificate-errors", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::protocol-version", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::rehandshake-mode", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::require-close-notify", callback: (owner: this, ...args: any) => void): number;

	}

	type DtlsConnectionInitOptionsMixin = Pick<IDtlsConnection,
		"advertised_protocols" |
		"base_socket" |
		"certificate" |
		"database" |
		"interaction" |
		"rehandshake_mode" |
		"require_close_notify">;

	export interface DtlsConnectionInitOptions extends DtlsConnectionInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link DtlsConnection} instead.
	 */
	type DtlsConnectionMixin = IDtlsConnection;

	/**
	 * #GDtlsConnection is the base DTLS connection class type, which wraps
	 * a #GDatagramBased and provides DTLS encryption on top of it. Its
	 * subclasses, #GDtlsClientConnection and #GDtlsServerConnection,
	 * implement client-side and server-side DTLS, respectively.
	 * 
	 * For TLS support, see #GTlsConnection.
	 * 
	 * As DTLS is datagram based, #GDtlsConnection implements #GDatagramBased,
	 * presenting a datagram-socket-like API for the encrypted connection. This
	 * operates over a base datagram connection, which is also a #GDatagramBased
	 * (#GDtlsConnection:base-socket).
	 * 
	 * To close a DTLS connection, use {@link G.dtls_connection_close}.
	 * 
	 * Neither #GDtlsServerConnection or #GDtlsClientConnection set the peer address
	 * on their base #GDatagramBased if it is a #GSocket — it is up to the caller to
	 * do that if they wish. If they do not, and g_socket_close() is called on the
	 * base socket, the #GDtlsConnection will not raise a %G_IO_ERROR_NOT_CONNECTED
	 * error on further I/O.
	 */
	interface DtlsConnection extends DtlsConnectionMixin {}

	class DtlsConnection {
		public constructor(options?: Partial<DtlsConnectionInitOptions>);
	}



	/** This construct is only for enabling class multi-inheritance,
	 * use {@link DtlsServerConnection} instead.
	 */
	interface IDtlsServerConnection {
		/**
		 * The #GTlsAuthenticationMode for the server. This can be changed
		 * before calling {@link G.dtls_connection_handshake} if you want to
		 * rehandshake with a different mode from the initial handshake.
		 */
		authentication_mode: TlsAuthenticationMode;

		connect(signal: "notify::authentication-mode", callback: (owner: this, ...args: any) => void): number;

	}

	type DtlsServerConnectionInitOptionsMixin = Pick<IDtlsServerConnection,
		"authentication_mode">;

	export interface DtlsServerConnectionInitOptions extends DtlsServerConnectionInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link DtlsServerConnection} instead.
	 */
	type DtlsServerConnectionMixin = IDtlsServerConnection;

	/**
	 * #GDtlsServerConnection is the server-side subclass of #GDtlsConnection,
	 * representing a server-side DTLS connection.
	 */
	interface DtlsServerConnection extends DtlsServerConnectionMixin {}

	class DtlsServerConnection {
		public constructor(options?: Partial<DtlsServerConnectionInitOptions>);
		/**
		 * Creates a new #GDtlsServerConnection wrapping #base_socket.
		 * @param base_socket the #GDatagramBased to wrap
		 * @param certificate the default server certificate, or %NULL
		 * @returns the new
		 *   #GDtlsServerConnection, or %NULL on error
		 */
		public static new(base_socket: DatagramBased, certificate?: TlsCertificate | null): DtlsServerConnection;
	}



	/** This construct is only for enabling class multi-inheritance,
	 * use {@link File} instead.
	 */
	interface IFile {
		/**
		 * Gets an output stream for appending data to the file.
		 * If the file doesn't already exist it is created.
		 * 
		 * By default files created are generally readable by everyone,
		 * but if you pass #G_FILE_CREATE_PRIVATE in #flags the file
		 * will be made readable only to the current user, to the level that
		 * is supported on the target filesystem.
		 * 
		 * If #cancellable is not %NULL, then the operation can be cancelled
		 * by triggering the cancellable object from another thread. If the
		 * operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
		 * returned.
		 * 
		 * Some file systems don't allow all file names, and may return an
		 * %G_IO_ERROR_INVALID_FILENAME error. If the file is a directory the
		 * %G_IO_ERROR_IS_DIRECTORY error will be returned. Other errors are
		 * possible too, and depend on what kind of filesystem the file is on.
		 * @param flags a set of #GFileCreateFlags
		 * @param cancellable optional #GCancellable object,
		 *     %NULL to ignore
		 * @returns a #GFileOutputStream, or %NULL on error.
		 *     Free the returned object with {@link GObject.unref}.
		 */
		append_to(flags: FileCreateFlags, cancellable?: Cancellable | null): FileOutputStream;
		/**
		 * Asynchronously opens #file for appending.
		 * 
		 * For more details, see {@link G.file_append_to} which is
		 * the synchronous version of this call.
		 * 
		 * When the operation is finished, #callback will be called.
		 * You can then call g_file_append_to_finish() to get the result
		 * of the operation.
		 * @param flags a set of #GFileCreateFlags
		 * @param io_priority the [I/O priority][io-priority] of the request
		 * @param cancellable optional #GCancellable object,
		 *     %NULL to ignore
		 * @param callback a #GAsyncReadyCallback to call
		 *     when the request is satisfied
		 */
		append_to_async(flags: FileCreateFlags, io_priority: number, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;
		/**
		 * Finishes an asynchronous file append operation started with
		 * {@link G.file_append_to_async}.
		 * @param res #GAsyncResult
		 * @returns a valid #GFileOutputStream
		 *     or %NULL on error.
		 *     Free the returned object with {@link GObject.unref}.
		 */
		append_to_finish(res: AsyncResult): FileOutputStream;
		/**
		 * Prepares the file attribute query string for copying to #file.
		 * 
		 * This function prepares an attribute query string to be
		 * passed to {@link G.file_query_info} to get a list of attributes
		 * normally copied with the file (see g_file_copy_attributes()
		 * for the detailed description). This function is used by the
		 * implementation of g_file_copy_attributes() and is useful
		 * when one needs to query and set the attributes in two
		 * stages (e.g., for recursive move of a directory).
		 * @param flags a set of #GFileCopyFlags
		 * @param cancellable optional #GCancellable object,
		 *     %NULL to ignore
		 * @returns an attribute query string for {@link G.file_query_info},
		 *     or %NULL if an error occurs.
		 */
		build_attribute_list_for_copy(flags: FileCopyFlags, cancellable?: Cancellable | null): string;
		/**
		 * Copies the file #source to the location specified by #destination.
		 * Can not handle recursive copies of directories.
		 * 
		 * If the flag #G_FILE_COPY_OVERWRITE is specified an already
		 * existing #destination file is overwritten.
		 * 
		 * If the flag #G_FILE_COPY_NOFOLLOW_SYMLINKS is specified then symlinks
		 * will be copied as symlinks, otherwise the target of the
		 * #source symlink will be copied.
		 * 
		 * If the flag #G_FILE_COPY_ALL_METADATA is specified then all the metadata
		 * that is possible to copy is copied, not just the default subset (which,
		 * for instance, does not include the owner, see #GFileInfo).
		 * 
		 * If #cancellable is not %NULL, then the operation can be cancelled by
		 * triggering the cancellable object from another thread. If the operation
		 * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
		 * 
		 * If #progress_callback is not %NULL, then the operation can be monitored
		 * by setting this to a #GFileProgressCallback function.
		 * #progress_callback_data will be passed to this function. It is guaranteed
		 * that this callback will be called after all data has been transferred with
		 * the total number of bytes copied during the operation.
		 * 
		 * If the #source file does not exist, then the %G_IO_ERROR_NOT_FOUND error
		 * is returned, independent on the status of the #destination.
		 * 
		 * If #G_FILE_COPY_OVERWRITE is not specified and the target exists, then
		 * the error %G_IO_ERROR_EXISTS is returned.
		 * 
		 * If trying to overwrite a file over a directory, the %G_IO_ERROR_IS_DIRECTORY
		 * error is returned. If trying to overwrite a directory with a directory the
		 * %G_IO_ERROR_WOULD_MERGE error is returned.
		 * 
		 * If the source is a directory and the target does not exist, or
		 * #G_FILE_COPY_OVERWRITE is specified and the target is a file, then the
		 * %G_IO_ERROR_WOULD_RECURSE error is returned.
		 * 
		 * If you are interested in copying the #GFile object itself (not the on-disk
		 * file), see {@link G.file_dup}.
		 * @param destination destination #GFile
		 * @param flags set of #GFileCopyFlags
		 * @param cancellable optional #GCancellable object,
		 *     %NULL to ignore
		 * @param progress_callback function to callback with
		 *     progress information, or %NULL if progress information is not needed
		 * @returns %TRUE on success, %FALSE otherwise.
		 */
		copy(destination: File, flags: FileCopyFlags, cancellable?: Cancellable | null, progress_callback?: FileProgressCallback | null): boolean;
		/**
		 * Copies the file #source to the location specified by #destination
		 * asynchronously. For details of the behaviour, see {@link G.file_copy}.
		 * 
		 * If #progress_callback is not %NULL, then that function that will be called
		 * just like in g_file_copy(). The callback will run in the default main context
		 * of the thread calling g_file_copy_async() — the same context as #callback is
		 * run in.
		 * 
		 * When the operation is finished, #callback will be called. You can then call
		 * g_file_copy_finish() to get the result of the operation.
		 * @param destination destination #GFile
		 * @param flags set of #GFileCopyFlags
		 * @param io_priority the [I/O priority][io-priority] of the request
		 * @param cancellable optional #GCancellable object,
		 *     %NULL to ignore
		 */
		copy_async(destination: File, flags: FileCopyFlags, io_priority: number, cancellable?: Cancellable | null): void;
		/**
		 * Copies the file attributes from #source to #destination.
		 * 
		 * Normally only a subset of the file attributes are copied,
		 * those that are copies in a normal file copy operation
		 * (which for instance does not include e.g. owner). However
		 * if #G_FILE_COPY_ALL_METADATA is specified in #flags, then
		 * all the metadata that is possible to copy is copied. This
		 * is useful when implementing move by copy + delete source.
		 * @param destination a #GFile to copy attributes to
		 * @param flags a set of #GFileCopyFlags
		 * @param cancellable optional #GCancellable object,
		 *     %NULL to ignore
		 * @returns %TRUE if the attributes were copied successfully,
		 *     %FALSE otherwise.
		 */
		copy_attributes(destination: File, flags: FileCopyFlags, cancellable?: Cancellable | null): boolean;
		/**
		 * Finishes copying the file started with {@link G.file_copy_async}.
		 * @param res a #GAsyncResult
		 * @returns a %TRUE on success, %FALSE on error.
		 */
		copy_finish(res: AsyncResult): boolean;
		/**
		 * Creates a new file and returns an output stream for writing to it.
		 * The file must not already exist.
		 * 
		 * By default files created are generally readable by everyone,
		 * but if you pass #G_FILE_CREATE_PRIVATE in #flags the file
		 * will be made readable only to the current user, to the level
		 * that is supported on the target filesystem.
		 * 
		 * If #cancellable is not %NULL, then the operation can be cancelled
		 * by triggering the cancellable object from another thread. If the
		 * operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
		 * returned.
		 * 
		 * If a file or directory with this name already exists the
		 * %G_IO_ERROR_EXISTS error will be returned. Some file systems don't
		 * allow all file names, and may return an %G_IO_ERROR_INVALID_FILENAME
		 * error, and if the name is to long %G_IO_ERROR_FILENAME_TOO_LONG will
		 * be returned. Other errors are possible too, and depend on what kind
		 * of filesystem the file is on.
		 * @param flags a set of #GFileCreateFlags
		 * @param cancellable optional #GCancellable object,
		 *     %NULL to ignore
		 * @returns a #GFileOutputStream for the newly created
		 *     file, or %NULL on error.
		 *     Free the returned object with {@link GObject.unref}.
		 */
		create(flags: FileCreateFlags, cancellable?: Cancellable | null): FileOutputStream;
		/**
		 * Asynchronously creates a new file and returns an output stream
		 * for writing to it. The file must not already exist.
		 * 
		 * For more details, see {@link G.file_create} which is
		 * the synchronous version of this call.
		 * 
		 * When the operation is finished, #callback will be called.
		 * You can then call g_file_create_finish() to get the result
		 * of the operation.
		 * @param flags a set of #GFileCreateFlags
		 * @param io_priority the [I/O priority][io-priority] of the request
		 * @param cancellable optional #GCancellable object,
		 *     %NULL to ignore
		 * @param callback a #GAsyncReadyCallback to call
		 *     when the request is satisfied
		 */
		create_async(flags: FileCreateFlags, io_priority: number, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;
		/**
		 * Finishes an asynchronous file create operation started with
		 * {@link G.file_create_async}.
		 * @param res a #GAsyncResult
		 * @returns a #GFileOutputStream or %NULL on error.
		 *     Free the returned object with {@link GObject.unref}.
		 */
		create_finish(res: AsyncResult): FileOutputStream;
		/**
		 * Creates a new file and returns a stream for reading and
		 * writing to it. The file must not already exist.
		 * 
		 * By default files created are generally readable by everyone,
		 * but if you pass #G_FILE_CREATE_PRIVATE in #flags the file
		 * will be made readable only to the current user, to the level
		 * that is supported on the target filesystem.
		 * 
		 * If #cancellable is not %NULL, then the operation can be cancelled
		 * by triggering the cancellable object from another thread. If the
		 * operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
		 * returned.
		 * 
		 * If a file or directory with this name already exists, the
		 * %G_IO_ERROR_EXISTS error will be returned. Some file systems don't
		 * allow all file names, and may return an %G_IO_ERROR_INVALID_FILENAME
		 * error, and if the name is too long, %G_IO_ERROR_FILENAME_TOO_LONG
		 * will be returned. Other errors are possible too, and depend on what
		 * kind of filesystem the file is on.
		 * 
		 * Note that in many non-local file cases read and write streams are
		 * not supported, so make sure you really need to do read and write
		 * streaming, rather than just opening for reading or writing.
		 * @param flags a set of #GFileCreateFlags
		 * @param cancellable optional #GCancellable object,
		 *     %NULL to ignore
		 * @returns a #GFileIOStream for the newly created
		 *     file, or %NULL on error.
		 *     Free the returned object with {@link GObject.unref}.
		 */
		create_readwrite(flags: FileCreateFlags, cancellable?: Cancellable | null): FileIOStream;
		/**
		 * Asynchronously creates a new file and returns a stream
		 * for reading and writing to it. The file must not already exist.
		 * 
		 * For more details, see {@link G.file_create_readwrite} which is
		 * the synchronous version of this call.
		 * 
		 * When the operation is finished, #callback will be called.
		 * You can then call g_file_create_readwrite_finish() to get
		 * the result of the operation.
		 * @param flags a set of #GFileCreateFlags
		 * @param io_priority the [I/O priority][io-priority] of the request
		 * @param cancellable optional #GCancellable object,
		 *     %NULL to ignore
		 * @param callback a #GAsyncReadyCallback to call
		 *     when the request is satisfied
		 */
		create_readwrite_async(flags: FileCreateFlags, io_priority: number, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;
		/**
		 * Finishes an asynchronous file create operation started with
		 * {@link G.file_create_readwrite_async}.
		 * @param res a #GAsyncResult
		 * @returns a #GFileIOStream or %NULL on error.
		 *     Free the returned object with {@link GObject.unref}.
		 */
		create_readwrite_finish(res: AsyncResult): FileIOStream;
		/**
		 * Deletes a file. If the #file is a directory, it will only be
		 * deleted if it is empty. This has the same semantics as {@link G.unlink}.
		 * 
		 * If #file doesn’t exist, %G_IO_ERROR_NOT_FOUND will be returned. This allows
		 * for deletion to be implemented avoiding
		 * [time-of-check to time-of-use races](https://en.wikipedia.org/wiki/Time-of-check_to_time-of-use):
		 * |[
		 * g_autoptr(GError) local_error = NULL;
		 * if (!g_file_delete (my_file, my_cancellable, &local_error) &&
		 *     !g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND))
		 *   {
		 *     // deletion failed for some reason other than the file not existing:
		 *     // so report the error
		 *     g_warning ("Failed to delete %s: %s",
		 *                g_file_peek_path (my_file), local_error->message);
		 *   }
		 * ]|
		 * 
		 * If #cancellable is not %NULL, then the operation can be cancelled by
		 * triggering the cancellable object from another thread. If the operation
		 * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
		 * @param cancellable optional #GCancellable object,
		 *     %NULL to ignore
		 * @returns %TRUE if the file was deleted. %FALSE otherwise.
		 */
		delete(cancellable?: Cancellable | null): boolean;
		/**
		 * Asynchronously delete a file. If the #file is a directory, it will
		 * only be deleted if it is empty.  This has the same semantics as
		 * {@link G.unlink}.
		 * @param io_priority the [I/O priority][io-priority] of the request
		 * @param cancellable optional #GCancellable object,
		 *     %NULL to ignore
		 * @param callback a #GAsyncReadyCallback to call
		 *     when the request is satisfied
		 */
		delete_async(io_priority: number | null, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;
		/**
		 * Finishes deleting a file started with {@link G.file_delete_async}.
		 * @param result a #GAsyncResult
		 * @returns %TRUE if the file was deleted. %FALSE otherwise.
		 */
		delete_finish(result: AsyncResult): boolean;
		/**
		 * Duplicates a #GFile handle. This operation does not duplicate
		 * the actual file or directory represented by the #GFile; see
		 * {@link G.file_copy} if attempting to copy a file.
		 * 
		 * g_file_dup() is useful when a second handle is needed to the same underlying
		 * file, for use in a separate thread (#GFile is not thread-safe). For use
		 * within the same thread, use g_object_ref() to increment the existing object’s
		 * reference count.
		 * 
		 * This call does no blocking I/O.
		 * @returns a new #GFile that is a duplicate
		 *     of the given #GFile.
		 */
		dup(): File;
		/**
		 * @deprecated
		 * Use {@link G.file_eject_mountable_with_operation} instead.
		 * 
		 * Starts an asynchronous eject on a mountable.
		 * When this operation has completed, #callback will be called with
		 * #user_user data, and the operation can be finalized with
		 * {@link G.file_eject_mountable_finish}.
		 * 
		 * If #cancellable is not %NULL, then the operation can be cancelled by
		 * triggering the cancellable object from another thread. If the operation
		 * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
		 * @param flags flags affecting the operation
		 * @param cancellable optional #GCancellable object,
		 *     %NULL to ignore
		 * @param callback a #GAsyncReadyCallback to call
		 *     when the request is satisfied, or %NULL
		 */
		eject_mountable(flags: MountUnmountFlags, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;
		/**
		 * @deprecated
		 * Use {@link G.file_eject_mountable_with_operation_finish}
		 *     instead.
		 * 
		 * Finishes an asynchronous eject operation started by
		 * {@link G.file_eject_mountable}.
		 * @param result a #GAsyncResult
		 * @returns %TRUE if the #file was ejected successfully.
		 *     %FALSE otherwise.
		 */
		eject_mountable_finish(result: AsyncResult): boolean;
		/**
		 * Starts an asynchronous eject on a mountable.
		 * When this operation has completed, #callback will be called with
		 * #user_user data, and the operation can be finalized with
		 * {@link G.file_eject_mountable_with_operation_finish}.
		 * 
		 * If #cancellable is not %NULL, then the operation can be cancelled by
		 * triggering the cancellable object from another thread. If the operation
		 * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
		 * @param flags flags affecting the operation
		 * @param mount_operation a #GMountOperation,
		 *     or %NULL to avoid user interaction
		 * @param cancellable optional #GCancellable object,
		 *     %NULL to ignore
		 * @param callback a #GAsyncReadyCallback to call
		 *     when the request is satisfied, or %NULL
		 */
		eject_mountable_with_operation(flags: MountUnmountFlags, mount_operation?: MountOperation | null, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;
		/**
		 * Finishes an asynchronous eject operation started by
		 * {@link G.file_eject_mountable_with_operation}.
		 * @param result a #GAsyncResult
		 * @returns %TRUE if the #file was ejected successfully.
		 *     %FALSE otherwise.
		 */
		eject_mountable_with_operation_finish(result: AsyncResult): boolean;
		/**
		 * Gets the requested information about the files in a directory.
		 * The result is a #GFileEnumerator object that will give out
		 * #GFileInfo objects for all the files in the directory.
		 * 
		 * The #attributes value is a string that specifies the file
		 * attributes that should be gathered. It is not an error if
		 * it's not possible to read a particular requested attribute
		 * from a file - it just won't be set. #attributes should
		 * be a comma-separated list of attributes or attribute wildcards.
		 * The wildcard "*" means all attributes, and a wildcard like
		 * "standard::*" means all attributes in the standard namespace.
		 * An example attribute query be "standard::*,owner::user".
		 * The standard attributes are available as defines, like
		 * #G_FILE_ATTRIBUTE_STANDARD_NAME.
		 * 
		 * If #cancellable is not %NULL, then the operation can be cancelled
		 * by triggering the cancellable object from another thread. If the
		 * operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
		 * returned.
		 * 
		 * If the file does not exist, the %G_IO_ERROR_NOT_FOUND error will
		 * be returned. If the file is not a directory, the %G_IO_ERROR_NOT_DIRECTORY
		 * error will be returned. Other errors are possible too.
		 * @param attributes an attribute query string
		 * @param flags a set of #GFileQueryInfoFlags
		 * @param cancellable optional #GCancellable object,
		 *     %NULL to ignore
		 * @returns A #GFileEnumerator if successful,
		 *     %NULL on error. Free the returned object with {@link GObject.unref}.
		 */
		enumerate_children(attributes: string, flags: FileQueryInfoFlags, cancellable?: Cancellable | null): FileEnumerator;
		/**
		 * Asynchronously gets the requested information about the files
		 * in a directory. The result is a #GFileEnumerator object that will
		 * give out #GFileInfo objects for all the files in the directory.
		 * 
		 * For more details, see {@link G.file_enumerate_children} which is
		 * the synchronous version of this call.
		 * 
		 * When the operation is finished, #callback will be called. You can
		 * then call g_file_enumerate_children_finish() to get the result of
		 * the operation.
		 * @param attributes an attribute query string
		 * @param flags a set of #GFileQueryInfoFlags
		 * @param io_priority the [I/O priority][io-priority] of the request
		 * @param cancellable optional #GCancellable object,
		 *     %NULL to ignore
		 * @param callback a #GAsyncReadyCallback to call when the
		 *     request is satisfied
		 */
		enumerate_children_async(attributes: string, flags: FileQueryInfoFlags, io_priority: number, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;
		/**
		 * Finishes an async enumerate children operation.
		 * See {@link G.file_enumerate_children_async}.
		 * @param res a #GAsyncResult
		 * @returns a #GFileEnumerator or %NULL
		 *     if an error occurred.
		 *     Free the returned object with {@link GObject.unref}.
		 */
		enumerate_children_finish(res: AsyncResult): FileEnumerator;
		/**
		 * Checks if the two given #GFiles refer to the same file.
		 * 
		 * Note that two #GFiles that differ can still refer to the same
		 * file on the filesystem due to various forms of filename
		 * aliasing.
		 * 
		 * This call does no blocking I/O.
		 * @param file2 the second #GFile
		 * @returns %TRUE if #file1 and #file2 are equal.
		 */
		equal(file2: File): boolean;
		/**
		 * Gets a #GMount for the #GFile.
		 * 
		 * #GMount is returned only for user interesting locations, see
		 * #GVolumeMonitor. If the #GFileIface for #file does not have a #mount,
		 * #error will be set to %G_IO_ERROR_NOT_FOUND and %NULL #will be returned.
		 * 
		 * If #cancellable is not %NULL, then the operation can be cancelled by
		 * triggering the cancellable object from another thread. If the operation
		 * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
		 * @param cancellable optional #GCancellable object,
		 *     %NULL to ignore
		 * @returns a #GMount where the #file is located
		 *     or %NULL on error.
		 *     Free the returned object with {@link GObject.unref}.
		 */
		find_enclosing_mount(cancellable?: Cancellable | null): Mount;
		/**
		 * Asynchronously gets the mount for the file.
		 * 
		 * For more details, see {@link G.file_find_enclosing_mount} which is
		 * the synchronous version of this call.
		 * 
		 * When the operation is finished, #callback will be called.
		 * You can then call g_file_find_enclosing_mount_finish() to
		 * get the result of the operation.
		 * @param io_priority the [I/O priority][io-priority] of the request
		 * @param cancellable optional #GCancellable object,
		 *     %NULL to ignore
		 * @param callback a #GAsyncReadyCallback to call
		 *     when the request is satisfied
		 */
		find_enclosing_mount_async(io_priority: number, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;
		/**
		 * Finishes an asynchronous find mount request.
		 * See {@link G.file_find_enclosing_mount_async}.
		 * @param res a #GAsyncResult
		 * @returns #GMount for given #file or %NULL on error.
		 *     Free the returned object with {@link GObject.unref}.
		 */
		find_enclosing_mount_finish(res: AsyncResult): Mount;
		/**
		 * Gets the base name (the last component of the path) for a given #GFile.
		 * 
		 * If called for the top level of a system (such as the filesystem root
		 * or a uri like sftp://host/) it will return a single directory separator
		 * (and on Windows, possibly a drive letter).
		 * 
		 * The base name is a byte string (not UTF-8). It has no defined encoding
		 * or rules other than it may not contain zero bytes.  If you want to use
		 * filenames in a user interface you should use the display name that you
		 * can get by requesting the %G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME
		 * attribute with {@link G.file_query_info}.
		 * 
		 * This call does no blocking I/O.
		 * @returns string containing the #GFile's
		 *     base name, or %NULL if given #GFile is invalid. The returned string
		 *     should be freed with {@link G.free} when no longer needed.
		 */
		get_basename(): string | null;
		/**
		 * Gets a child of #file with basename equal to #name.
		 * 
		 * Note that the file with that specific name might not exist, but
		 * you can still have a #GFile that points to it. You can use this
		 * for instance to create that file.
		 * 
		 * This call does no blocking I/O.
		 * @param name string containing the child's basename
		 * @returns a #GFile to a child specified by #name.
		 *     Free the returned object with {@link GObject.unref}.
		 */
		get_child(name: string): File;
		/**
		 * Gets the child of #file for a given #display_name (i.e. a UTF-8
		 * version of the name). If this function fails, it returns %NULL
		 * and #error will be set. This is very useful when constructing a
		 * #GFile for a new file and the user entered the filename in the
		 * user interface, for instance when you select a directory and
		 * type a filename in the file selector.
		 * 
		 * This call does no blocking I/O.
		 * @param display_name string to a possible child
		 * @returns a #GFile to the specified child, or
		 *     %NULL if the display name couldn't be converted.
		 *     Free the returned object with {@link GObject.unref}.
		 */
		get_child_for_display_name(display_name: string): File;
		/**
		 * Gets the parent directory for the #file.
		 * If the #file represents the root directory of the
		 * file system, then %NULL will be returned.
		 * 
		 * This call does no blocking I/O.
		 * @returns a #GFile structure to the
		 *     parent of the given #GFile or %NULL if there is no parent. Free
		 *     the returned object with {@link GObject.unref}.
		 */
		get_parent(): File | null;
		/**
		 * Gets the parse name of the #file.
		 * A parse name is a UTF-8 string that describes the
		 * file such that one can get the #GFile back using
		 * {@link G.file_parse_name}.
		 * 
		 * This is generally used to show the #GFile as a nice
		 * full-pathname kind of string in a user interface,
		 * like in a location entry.
		 * 
		 * For local files with names that can safely be converted
		 * to UTF-8 the pathname is used, otherwise the IRI is used
		 * (a form of URI that allows UTF-8 characters unescaped).
		 * 
		 * This call does no blocking I/O.
		 * @returns a string containing the #GFile's parse name.
		 *     The returned string should be freed with {@link G.free}
		 *     when no longer needed.
		 */
		get_parse_name(): string;
		/**
		 * Gets the local pathname for #GFile, if one exists. If non-%NULL, this is
		 * guaranteed to be an absolute, canonical path. It might contain symlinks.
		 * 
		 * This call does no blocking I/O.
		 * @returns string containing the #GFile's path,
		 *     or %NULL if no such path exists. The returned string should be freed
		 *     with {@link G.free} when no longer needed.
		 */
		get_path(): string | null;
		/**
		 * Gets the path for #descendant relative to #parent.
		 * 
		 * This call does no blocking I/O.
		 * @param descendant input #GFile
		 * @returns string with the relative path from
		 *     #descendant to #parent, or %NULL if #descendant doesn't have #parent as
		 *     prefix. The returned string should be freed with {@link G.free} when
		 *     no longer needed.
		 */
		get_relative_path(descendant: File): string | null;
		/**
		 * Gets the URI for the #file.
		 * 
		 * This call does no blocking I/O.
		 * @returns a string containing the #GFile's URI. If the #GFile was constructed
		 *     with an invalid URI, an invalid URI is returned.
		 *     The returned string should be freed with {@link G.free}
		 *     when no longer needed.
		 */
		get_uri(): string;
		/**
		 * Gets the URI scheme for a #GFile.
		 * RFC 3986 decodes the scheme as:
		 * |[
		 * URI = scheme ":" hier-part [ "?" query ] [ "#" fragment ]
		 * ]|
		 * Common schemes include "file", "http", "ftp", etc.
		 * 
		 * The scheme can be different from the one used to construct the #GFile,
		 * in that it might be replaced with one that is logically equivalent to the #GFile.
		 * 
		 * This call does no blocking I/O.
		 * @returns a string containing the URI scheme for the given
		 *     #GFile or %NULL if the #GFile was constructed with an invalid URI. The
		 *     returned string should be freed with {@link G.free} when no longer needed.
		 */
		get_uri_scheme(): string | null;
		/**
		 * Checks if #file has a parent, and optionally, if it is #parent.
		 * 
		 * If #parent is %NULL then this function returns %TRUE if #file has any
		 * parent at all.  If #parent is non-%NULL then %TRUE is only returned
		 * if #file is an immediate child of #parent.
		 * @param parent the parent to check for, or %NULL
		 * @returns %TRUE if #file is an immediate child of #parent (or any parent in
		 *          the case that #parent is %NULL).
		 */
		has_parent(parent?: File | null): boolean;
		/**
		 * Checks whether #file has the prefix specified by #prefix.
		 * 
		 * In other words, if the names of initial elements of #file's
		 * pathname match #prefix. Only full pathname elements are matched,
		 * so a path like /foo is not considered a prefix of /foobar, only
		 * of /foo/bar.
		 * 
		 * A #GFile is not a prefix of itself. If you want to check for
		 * equality, use {@link G.file_equal}.
		 * 
		 * This call does no I/O, as it works purely on names. As such it can
		 * sometimes return %FALSE even if #file is inside a #prefix (from a
		 * filesystem point of view), because the prefix of #file is an alias
		 * of #prefix.
		 * @param prefix input #GFile
		 * @returns %TRUE if the #file's parent, grandparent, etc is #prefix,
		 *     %FALSE otherwise.
		 */
		has_prefix(prefix: File): boolean;
		/**
		 * Checks to see if a #GFile has a given URI scheme.
		 * 
		 * This call does no blocking I/O.
		 * @param uri_scheme a string containing a URI scheme
		 * @returns %TRUE if #GFile's backend supports the
		 *     given URI scheme, %FALSE if URI scheme is %NULL,
		 *     not supported, or #GFile is invalid.
		 */
		has_uri_scheme(uri_scheme: string): boolean;
		/**
		 * Creates a hash value for a #GFile.
		 * 
		 * This call does no blocking I/O.
		 * @returns 0 if #file is not a valid #GFile, otherwise an
		 *     integer that can be used as hash value for the #GFile.
		 *     This function is intended for easily hashing a #GFile to
		 *     add to a #GHashTable or similar data structure.
		 */
		hash(): number;
		/**
		 * Checks to see if a file is native to the platform.
		 * 
		 * A native file is one expressed in the platform-native filename format,
		 * e.g. "C:\Windows" or "/usr/bin/". This does not mean the file is local,
		 * as it might be on a locally mounted remote filesystem.
		 * 
		 * On some systems non-native files may be available using the native
		 * filesystem via a userspace filesystem (FUSE), in these cases this call
		 * will return %FALSE, but {@link G.file_get_path} will still return a native path.
		 * 
		 * This call does no blocking I/O.
		 * @returns %TRUE if #file is native
		 */
		is_native(): boolean;
		/**
		 * Loads the contents of #file and returns it as #GBytes.
		 * 
		 * If #file is a resource:// based URI, the resulting bytes will reference the
		 * embedded resource instead of a copy. Otherwise, this is equivalent to calling
		 * {@link G.file_load_contents} and g_bytes_new_take().
		 * 
		 * For resources, #etag_out will be set to %NULL.
		 * 
		 * The data contained in the resulting #GBytes is always zero-terminated, but
		 * this is not included in the #GBytes length. The resulting #GBytes should be
		 * freed with g_bytes_unref() when no longer in use.
		 * @param cancellable a #GCancellable or %NULL
		 * @returns a #GBytes or %NULL and #error is set
		 * 
		 * a location to place the current
		 *     entity tag for the file, or %NULL if the entity tag is not needed
		 */
		load_bytes(cancellable?: Cancellable | null): [ GLib.Bytes, string | null ];
		/**
		 * Asynchronously loads the contents of #file as #GBytes.
		 * 
		 * If #file is a resource:// based URI, the resulting bytes will reference the
		 * embedded resource instead of a copy. Otherwise, this is equivalent to calling
		 * {@link G.file_load_contents_async} and g_bytes_new_take().
		 * 
		 * #callback should call g_file_load_bytes_finish() to get the result of this
		 * asynchronous operation.
		 * 
		 * See g_file_load_bytes() for more information.
		 * @param cancellable a #GCancellable or %NULL
		 * @param callback a #GAsyncReadyCallback to call when the
		 *     request is satisfied
		 */
		load_bytes_async(cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;
		/**
		 * Completes an asynchronous request to {@link G.file_load_bytes_async}.
		 * 
		 * For resources, #etag_out will be set to %NULL.
		 * 
		 * The data contained in the resulting #GBytes is always zero-terminated, but
		 * this is not included in the #GBytes length. The resulting #GBytes should be
		 * freed with g_bytes_unref() when no longer in use.
		 * 
		 * See g_file_load_bytes() for more information.
		 * @param result a #GAsyncResult provided to the callback
		 * @returns a #GBytes or %NULL and #error is set
		 * 
		 * a location to place the current
		 *     entity tag for the file, or %NULL if the entity tag is not needed
		 */
		load_bytes_finish(result: AsyncResult): [ GLib.Bytes, string | null ];
		/**
		 * Loads the content of the file into memory. The data is always
		 * zero-terminated, but this is not included in the resultant #length.
		 * The returned #contents should be freed with {@link G.free} when no longer
		 * needed.
		 * 
		 * If #cancellable is not %NULL, then the operation can be cancelled by
		 * triggering the cancellable object from another thread. If the operation
		 * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
		 * @param cancellable optional #GCancellable object, %NULL to ignore
		 * @returns %TRUE if the #file's contents were successfully loaded.
		 *     %FALSE if there were errors.
		 * 
		 * a location to place the contents of the file
		 * 
		 * a location to place the current entity tag for the file,
		 *    or %NULL if the entity tag is not needed
		 */
		load_contents(cancellable?: Cancellable | null): [success: boolean, contents: Uint8Array];
		/**
		 * Starts an asynchronous load of the #file's contents.
		 * 
		 * For more details, see {@link G.file_load_contents} which is
		 * the synchronous version of this call.
		 * 
		 * When the load operation has completed, #callback will be called
		 * with #user data. To finish the operation, call
		 * g_file_load_contents_finish() with the #GAsyncResult returned by
		 * the #callback.
		 * 
		 * If #cancellable is not %NULL, then the operation can be cancelled by
		 * triggering the cancellable object from another thread. If the operation
		 * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
		 * @param cancellable optional #GCancellable object, %NULL to ignore
		 * @param callback a #GAsyncReadyCallback to call when the request is satisfied
		 */
		load_contents_async(cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;
		/**
		 * Finishes an asynchronous load of the #file's contents.
		 * The contents are placed in #contents, and #length is set to the
		 * size of the #contents string. The #contents should be freed with
		 * {@link G.free} when no longer needed. If #etag_out is present, it will be
		 * set to the new entity tag for the #file.
		 * @param res a #GAsyncResult
		 * @returns %TRUE if the load was successful. If %FALSE and #error is
		 *     present, it will be set appropriately.
		 * 
		 * a location to place the contents of the file
		 * 
		 * a location to place the current entity tag for the file,
		 *     or %NULL if the entity tag is not needed
		 */
		load_contents_finish(res: AsyncResult): [ boolean, number[], string | null ];
		/**
		 * Reads the partial contents of a file. A #GFileReadMoreCallback should
		 * be used to stop reading from the file when appropriate, else this
		 * function will behave exactly as {@link G.file_load_contents_async}. This
		 * operation can be finished by g_file_load_partial_contents_finish().
		 * 
		 * Users of this function should be aware that #user_data is passed to
		 * both the #read_more_callback and the #callback.
		 * 
		 * If #cancellable is not %NULL, then the operation can be cancelled by
		 * triggering the cancellable object from another thread. If the operation
		 * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
		 * @param cancellable optional #GCancellable object, %NULL to ignore
		 * @param read_more_callback a
		 *     #GFileReadMoreCallback to receive partial data
		 *     and to specify whether further data should be read
		 * @param callback a #GAsyncReadyCallback to call
		 *     when the request is satisfied
		 */
		load_partial_contents_async(cancellable: Cancellable | null, read_more_callback: FileReadMoreCallback, callback?: AsyncReadyCallback | null): void;
		/**
		 * Finishes an asynchronous partial load operation that was started
		 * with {@link G.file_load_partial_contents_async}. The data is always
		 * zero-terminated, but this is not included in the resultant #length.
		 * The returned #contents should be freed with g_free() when no longer
		 * needed.
		 * @param res a #GAsyncResult
		 * @returns %TRUE if the load was successful. If %FALSE and #error is
		 *     present, it will be set appropriately.
		 * 
		 * a location to place the contents of the file
		 * 
		 * a location to place the current entity tag for the file,
		 *     or %NULL if the entity tag is not needed
		 */
		load_partial_contents_finish(res: AsyncResult): [ boolean, number[], string | null ];
		/**
		 * Creates a directory. Note that this will only create a child directory
		 * of the immediate parent directory of the path or URI given by the #GFile.
		 * To recursively create directories, see {@link G.file_make_directory_with_parents}.
		 * This function will fail if the parent directory does not exist, setting
		 * #error to %G_IO_ERROR_NOT_FOUND. If the file system doesn't support
		 * creating directories, this function will fail, setting #error to
		 * %G_IO_ERROR_NOT_SUPPORTED.
		 * 
		 * For a local #GFile the newly created directory will have the default
		 * (current) ownership and permissions of the current process.
		 * 
		 * If #cancellable is not %NULL, then the operation can be cancelled by
		 * triggering the cancellable object from another thread. If the operation
		 * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
		 * @param cancellable optional #GCancellable object,
		 *     %NULL to ignore
		 * @returns %TRUE on successful creation, %FALSE otherwise.
		 */
		make_directory(cancellable?: Cancellable | null): boolean;
		/**
		 * Asynchronously creates a directory.
		 * @param io_priority the [I/O priority][io-priority] of the request
		 * @param cancellable optional #GCancellable object,
		 *     %NULL to ignore
		 * @param callback a #GAsyncReadyCallback to call
		 *     when the request is satisfied
		 */
		make_directory_async(io_priority: number, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;
		/**
		 * Finishes an asynchronous directory creation, started with
		 * {@link G.file_make_directory_async}.
		 * @param result a #GAsyncResult
		 * @returns %TRUE on successful directory creation, %FALSE otherwise.
		 */
		make_directory_finish(result: AsyncResult): boolean;
		/**
		 * Creates a directory and any parent directories that may not
		 * exist similar to 'mkdir -p'. If the file system does not support
		 * creating directories, this function will fail, setting #error to
		 * %G_IO_ERROR_NOT_SUPPORTED. If the directory itself already exists,
		 * this function will fail setting #error to %G_IO_ERROR_EXISTS, unlike
		 * the similar {@link G.mkdir_with_parents}.
		 * 
		 * For a local #GFile the newly created directories will have the default
		 * (current) ownership and permissions of the current process.
		 * 
		 * If #cancellable is not %NULL, then the operation can be cancelled by
		 * triggering the cancellable object from another thread. If the operation
		 * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
		 * @param cancellable optional #GCancellable object,
		 *     %NULL to ignore
		 * @returns %TRUE if all directories have been successfully created, %FALSE
		 * otherwise.
		 */
		make_directory_with_parents(cancellable?: Cancellable | null): boolean;
		/**
		 * Creates a symbolic link named #file which contains the string
		 * #symlink_value.
		 * 
		 * If #cancellable is not %NULL, then the operation can be cancelled by
		 * triggering the cancellable object from another thread. If the operation
		 * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
		 * @param symlink_value a string with the path for the target
		 *     of the new symlink
		 * @param cancellable optional #GCancellable object,
		 *     %NULL to ignore
		 * @returns %TRUE on the creation of a new symlink, %FALSE otherwise.
		 */
		make_symbolic_link(symlink_value: string, cancellable?: Cancellable | null): boolean;
		/**
		 * Recursively measures the disk usage of #file.
		 * 
		 * This is essentially an analog of the 'du' command, but it also
		 * reports the number of directories and non-directory files encountered
		 * (including things like symbolic links).
		 * 
		 * By default, errors are only reported against the toplevel file
		 * itself.  Errors found while recursing are silently ignored, unless
		 * %G_FILE_MEASURE_REPORT_ANY_ERROR is given in #flags.
		 * 
		 * The returned size, #disk_usage, is in bytes and should be formatted
		 * with {@link G.format_size} in order to get something reasonable for showing
		 * in a user interface.
		 * 
		 * #progress_callback and #progress_data can be given to request
		 * periodic progress updates while scanning.  See the documentation for
		 * #GFileMeasureProgressCallback for information about when and how the
		 * callback will be invoked.
		 * @param flags #GFileMeasureFlags
		 * @param cancellable optional #GCancellable
		 * @param progress_callback a #GFileMeasureProgressCallback
		 * @returns %TRUE if successful, with the out parameters set.
		 *          %FALSE otherwise, with #error set.
		 * 
		 * the number of bytes of disk space used
		 * 
		 * the number of directories encountered
		 * 
		 * the number of non-directories encountered
		 */
		measure_disk_usage(flags: FileMeasureFlags, cancellable?: Cancellable | null, progress_callback?: FileMeasureProgressCallback | null): [ boolean, number | null, number | null, number | null ];
		/**
		 * Recursively measures the disk usage of #file.
		 * 
		 * This is the asynchronous version of {@link G.file_measure_disk_usage}.  See
		 * there for more information.
		 * @param flags #GFileMeasureFlags
		 * @param io_priority the [I/O priority][io-priority] of the request
		 * @param cancellable optional #GCancellable
		 * @param progress_callback a #GFileMeasureProgressCallback
		 * @param callback a #GAsyncReadyCallback to call when complete
		 */
		measure_disk_usage_async(flags: FileMeasureFlags, io_priority: number, cancellable?: Cancellable | null, progress_callback?: FileMeasureProgressCallback | null, callback?: AsyncReadyCallback | null): void;
		/**
		 * Collects the results from an earlier call to
		 * {@link G.file_measure_disk_usage_async}.  See g_file_measure_disk_usage() for
		 * more information.
		 * @param result the #GAsyncResult passed to your #GAsyncReadyCallback
		 * @returns %TRUE if successful, with the out parameters set.
		 *          %FALSE otherwise, with #error set.
		 * 
		 * the number of bytes of disk space used
		 * 
		 * the number of directories encountered
		 * 
		 * the number of non-directories encountered
		 */
		measure_disk_usage_finish(result: AsyncResult): [ boolean, number | null, number | null, number | null ];
		/**
		 * Obtains a file or directory monitor for the given file,
		 * depending on the type of the file.
		 * 
		 * If #cancellable is not %NULL, then the operation can be cancelled by
		 * triggering the cancellable object from another thread. If the operation
		 * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
		 * @param flags a set of #GFileMonitorFlags
		 * @param cancellable optional #GCancellable object,
		 *     %NULL to ignore
		 * @returns a #GFileMonitor for the given #file,
		 *     or %NULL on error.
		 *     Free the returned object with {@link GObject.unref}.
		 */
		monitor(flags: FileMonitorFlags, cancellable?: Cancellable | null): FileMonitor;
		/**
		 * Obtains a directory monitor for the given file.
		 * This may fail if directory monitoring is not supported.
		 * 
		 * If #cancellable is not %NULL, then the operation can be cancelled by
		 * triggering the cancellable object from another thread. If the operation
		 * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
		 * 
		 * It does not make sense for #flags to contain
		 * %G_FILE_MONITOR_WATCH_HARD_LINKS, since hard links can not be made to
		 * directories.  It is not possible to monitor all the files in a
		 * directory for changes made via hard links; if you want to do this then
		 * you must register individual watches with {@link G.file_monitor}.
		 * @param flags a set of #GFileMonitorFlags
		 * @param cancellable optional #GCancellable object,
		 *     %NULL to ignore
		 * @returns a #GFileMonitor for the given #file,
		 *     or %NULL on error.
		 *     Free the returned object with {@link GObject.unref}.
		 */
		monitor_directory(flags: FileMonitorFlags, cancellable?: Cancellable | null): FileMonitor;
		/**
		 * Obtains a file monitor for the given file. If no file notification
		 * mechanism exists, then regular polling of the file is used.
		 * 
		 * If #cancellable is not %NULL, then the operation can be cancelled by
		 * triggering the cancellable object from another thread. If the operation
		 * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
		 * 
		 * If #flags contains %G_FILE_MONITOR_WATCH_HARD_LINKS then the monitor
		 * will also attempt to report changes made to the file via another
		 * filename (ie, a hard link). Without this flag, you can only rely on
		 * changes made through the filename contained in #file to be
		 * reported. Using this flag may result in an increase in resource
		 * usage, and may not have any effect depending on the #GFileMonitor
		 * backend and/or filesystem type.
		 * @param flags a set of #GFileMonitorFlags
		 * @param cancellable optional #GCancellable object,
		 *     %NULL to ignore
		 * @returns a #GFileMonitor for the given #file,
		 *     or %NULL on error.
		 *     Free the returned object with {@link GObject.unref}.
		 */
		monitor_file(flags: FileMonitorFlags, cancellable?: Cancellable | null): FileMonitor;
		/**
		 * Starts a #mount_operation, mounting the volume that contains
		 * the file #location.
		 * 
		 * When this operation has completed, #callback will be called with
		 * #user_user data, and the operation can be finalized with
		 * {@link G.file_mount_enclosing_volume_finish}.
		 * 
		 * If #cancellable is not %NULL, then the operation can be cancelled by
		 * triggering the cancellable object from another thread. If the operation
		 * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
		 * @param flags flags affecting the operation
		 * @param mount_operation a #GMountOperation
		 *     or %NULL to avoid user interaction
		 * @param cancellable optional #GCancellable object,
		 *     %NULL to ignore
		 * @param callback a #GAsyncReadyCallback to call
		 *     when the request is satisfied, or %NULL
		 */
		mount_enclosing_volume(flags: MountMountFlags, mount_operation?: MountOperation | null, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;
		/**
		 * Finishes a mount operation started by {@link G.file_mount_enclosing_volume}.
		 * @param result a #GAsyncResult
		 * @returns %TRUE if successful. If an error has occurred,
		 *     this function will return %FALSE and set #error
		 *     appropriately if present.
		 */
		mount_enclosing_volume_finish(result: AsyncResult): boolean;
		/**
		 * Mounts a file of type G_FILE_TYPE_MOUNTABLE.
		 * Using #mount_operation, you can request callbacks when, for instance,
		 * passwords are needed during authentication.
		 * 
		 * If #cancellable is not %NULL, then the operation can be cancelled by
		 * triggering the cancellable object from another thread. If the operation
		 * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
		 * 
		 * When the operation is finished, #callback will be called.
		 * You can then call {@link G.file_mount_mountable_finish} to get
		 * the result of the operation.
		 * @param flags flags affecting the operation
		 * @param mount_operation a #GMountOperation,
		 *     or %NULL to avoid user interaction
		 * @param cancellable optional #GCancellable object,
		 *     %NULL to ignore
		 * @param callback a #GAsyncReadyCallback to call
		 *     when the request is satisfied, or %NULL
		 */
		mount_mountable(flags: MountMountFlags, mount_operation?: MountOperation | null, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;
		/**
		 * Finishes a mount operation. See {@link G.file_mount_mountable} for details.
		 * 
		 * Finish an asynchronous mount operation that was started
		 * with g_file_mount_mountable().
		 * @param result a #GAsyncResult
		 * @returns a #GFile or %NULL on error.
		 *     Free the returned object with {@link GObject.unref}.
		 */
		mount_mountable_finish(result: AsyncResult): File;
		/**
		 * Tries to move the file or directory #source to the location specified
		 * by #destination. If native move operations are supported then this is
		 * used, otherwise a copy + delete fallback is used. The native
		 * implementation may support moving directories (for instance on moves
		 * inside the same filesystem), but the fallback code does not.
		 * 
		 * If the flag #G_FILE_COPY_OVERWRITE is specified an already
		 * existing #destination file is overwritten.
		 * 
		 * If #cancellable is not %NULL, then the operation can be cancelled by
		 * triggering the cancellable object from another thread. If the operation
		 * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
		 * 
		 * If #progress_callback is not %NULL, then the operation can be monitored
		 * by setting this to a #GFileProgressCallback function.
		 * #progress_callback_data will be passed to this function. It is
		 * guaranteed that this callback will be called after all data has been
		 * transferred with the total number of bytes copied during the operation.
		 * 
		 * If the #source file does not exist, then the %G_IO_ERROR_NOT_FOUND
		 * error is returned, independent on the status of the #destination.
		 * 
		 * If #G_FILE_COPY_OVERWRITE is not specified and the target exists,
		 * then the error %G_IO_ERROR_EXISTS is returned.
		 * 
		 * If trying to overwrite a file over a directory, the %G_IO_ERROR_IS_DIRECTORY
		 * error is returned. If trying to overwrite a directory with a directory the
		 * %G_IO_ERROR_WOULD_MERGE error is returned.
		 * 
		 * If the source is a directory and the target does not exist, or
		 * #G_FILE_COPY_OVERWRITE is specified and the target is a file, then
		 * the %G_IO_ERROR_WOULD_RECURSE error may be returned (if the native
		 * move operation isn't available).
		 * @param destination #GFile pointing to the destination location
		 * @param flags set of #GFileCopyFlags
		 * @param cancellable optional #GCancellable object,
		 *     %NULL to ignore
		 * @param progress_callback #GFileProgressCallback
		 *     function for updates
		 * @returns %TRUE on successful move, %FALSE otherwise.
		 */
		move(destination: File, flags: FileCopyFlags, cancellable?: Cancellable | null, progress_callback?: FileProgressCallback | null): boolean;
		/**
		 * Opens an existing file for reading and writing. The result is
		 * a #GFileIOStream that can be used to read and write the contents
		 * of the file.
		 * 
		 * If #cancellable is not %NULL, then the operation can be cancelled
		 * by triggering the cancellable object from another thread. If the
		 * operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
		 * returned.
		 * 
		 * If the file does not exist, the %G_IO_ERROR_NOT_FOUND error will
		 * be returned. If the file is a directory, the %G_IO_ERROR_IS_DIRECTORY
		 * error will be returned. Other errors are possible too, and depend on
		 * what kind of filesystem the file is on. Note that in many non-local
		 * file cases read and write streams are not supported, so make sure you
		 * really need to do read and write streaming, rather than just opening
		 * for reading or writing.
		 * @param cancellable a #GCancellable
		 * @returns #GFileIOStream or %NULL on error.
		 *     Free the returned object with {@link GObject.unref}.
		 */
		open_readwrite(cancellable?: Cancellable | null): FileIOStream;
		/**
		 * Asynchronously opens #file for reading and writing.
		 * 
		 * For more details, see {@link G.file_open_readwrite} which is
		 * the synchronous version of this call.
		 * 
		 * When the operation is finished, #callback will be called.
		 * You can then call g_file_open_readwrite_finish() to get
		 * the result of the operation.
		 * @param io_priority the [I/O priority][io-priority] of the request
		 * @param cancellable optional #GCancellable object,
		 *     %NULL to ignore
		 * @param callback a #GAsyncReadyCallback to call
		 *     when the request is satisfied
		 */
		open_readwrite_async(io_priority: number, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;
		/**
		 * Finishes an asynchronous file read operation started with
		 * {@link G.file_open_readwrite_async}.
		 * @param res a #GAsyncResult
		 * @returns a #GFileIOStream or %NULL on error.
		 *     Free the returned object with {@link GObject.unref}.
		 */
		open_readwrite_finish(res: AsyncResult): FileIOStream;
		/**
		 * Exactly like {@link G.file_get_path}, but caches the result via
		 * g_object_set_qdata_full().  This is useful for example in C
		 * applications which mix `g_file_*` APIs with native ones.  It
		 * also avoids an extra duplicated string when possible, so will be
		 * generally more efficient.
		 * 
		 * This call does no blocking I/O.
		 * @returns string containing the #GFile's path,
		 *     or %NULL if no such path exists. The returned string is owned by #file.
		 */
		peek_path(): string | null;
		/**
		 * Polls a file of type #G_FILE_TYPE_MOUNTABLE.
		 * 
		 * If #cancellable is not %NULL, then the operation can be cancelled by
		 * triggering the cancellable object from another thread. If the operation
		 * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
		 * 
		 * When the operation is finished, #callback will be called.
		 * You can then call {@link G.file_mount_mountable_finish} to get
		 * the result of the operation.
		 * @param cancellable optional #GCancellable object, %NULL to ignore
		 * @param callback a #GAsyncReadyCallback to call
		 *     when the request is satisfied, or %NULL
		 */
		poll_mountable(cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;
		/**
		 * Finishes a poll operation. See {@link G.file_poll_mountable} for details.
		 * 
		 * Finish an asynchronous poll operation that was polled
		 * with g_file_poll_mountable().
		 * @param result a #GAsyncResult
		 * @returns %TRUE if the operation finished successfully. %FALSE
		 * otherwise.
		 */
		poll_mountable_finish(result: AsyncResult): boolean;
		/**
		 * Returns the #GAppInfo that is registered as the default
		 * application to handle the file specified by #file.
		 * 
		 * If #cancellable is not %NULL, then the operation can be cancelled by
		 * triggering the cancellable object from another thread. If the operation
		 * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
		 * @param cancellable optional #GCancellable object, %NULL to ignore
		 * @returns a #GAppInfo if the handle was found,
		 *     %NULL if there were errors.
		 *     When you are done with it, release it with {@link GObject.unref}
		 */
		query_default_handler(cancellable?: Cancellable | null): AppInfo;
		/**
		 * Async version of {@link G.file_query_default_handler}.
		 * @param io_priority the [I/O priority][io-priority] of the request
		 * @param cancellable optional #GCancellable object, %NULL to ignore
		 * @param callback a #GAsyncReadyCallback to call when the request is done
		 */
		query_default_handler_async(io_priority: number, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;
		/**
		 * Finishes a {@link G.file_query_default_handler_async} operation.
		 * @param result a #GAsyncResult
		 * @returns a #GAppInfo if the handle was found,
		 *     %NULL if there were errors.
		 *     When you are done with it, release it with {@link GObject.unref}
		 */
		query_default_handler_finish(result: AsyncResult): AppInfo;
		/**
		 * Utility function to check if a particular file exists. This is
		 * implemented using {@link G.file_query_info} and as such does blocking I/O.
		 * 
		 * Note that in many cases it is [racy to first check for file existence](https://en.wikipedia.org/wiki/Time_of_check_to_time_of_use)
		 * and then execute something based on the outcome of that, because the
		 * file might have been created or removed in between the operations. The
		 * general approach to handling that is to not check, but just do the
		 * operation and handle the errors as they come.
		 * 
		 * As an example of race-free checking, take the case of reading a file,
		 * and if it doesn't exist, creating it. There are two racy versions: read
		 * it, and on error create it; and: check if it exists, if not create it.
		 * These can both result in two processes creating the file (with perhaps
		 * a partially written file as the result). The correct approach is to
		 * always try to create the file with g_file_create() which will either
		 * atomically create the file or fail with a %G_IO_ERROR_EXISTS error.
		 * 
		 * However, in many cases an existence check is useful in a user interface,
		 * for instance to make a menu item sensitive/insensitive, so that you don't
		 * have to fool users that something is possible and then just show an error
		 * dialog. If you do this, you should make sure to also handle the errors
		 * that can happen due to races when you execute the operation.
		 * @param cancellable optional #GCancellable object,
		 *     %NULL to ignore
		 * @returns %TRUE if the file exists (and can be detected without error),
		 *     %FALSE otherwise (or if cancelled).
		 */
		query_exists(cancellable?: Cancellable | null): boolean;
		/**
		 * Utility function to inspect the #GFileType of a file. This is
		 * implemented using {@link G.file_query_info} and as such does blocking I/O.
		 * 
		 * The primary use case of this method is to check if a file is
		 * a regular file, directory, or symlink.
		 * @param flags a set of #GFileQueryInfoFlags passed to {@link G.file_query_info}
		 * @param cancellable optional #GCancellable object,
		 *     %NULL to ignore
		 * @returns The #GFileType of the file and #G_FILE_TYPE_UNKNOWN
		 *     if the file does not exist
		 */
		query_file_type(flags: FileQueryInfoFlags, cancellable?: Cancellable | null): FileType;
		/**
		 * Similar to {@link G.file_query_info}, but obtains information
		 * about the filesystem the #file is on, rather than the file itself.
		 * For instance the amount of space available and the type of
		 * the filesystem.
		 * 
		 * The #attributes value is a string that specifies the attributes
		 * that should be gathered. It is not an error if it's not possible
		 * to read a particular requested attribute from a file - it just
		 * won't be set. #attributes should be a comma-separated list of
		 * attributes or attribute wildcards. The wildcard "*" means all
		 * attributes, and a wildcard like "filesystem::*" means all attributes
		 * in the filesystem namespace. The standard namespace for filesystem
		 * attributes is "filesystem". Common attributes of interest are
		 * #G_FILE_ATTRIBUTE_FILESYSTEM_SIZE (the total size of the filesystem
		 * in bytes), #G_FILE_ATTRIBUTE_FILESYSTEM_FREE (number of bytes available),
		 * and #G_FILE_ATTRIBUTE_FILESYSTEM_TYPE (type of the filesystem).
		 * 
		 * If #cancellable is not %NULL, then the operation can be cancelled
		 * by triggering the cancellable object from another thread. If the
		 * operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
		 * returned.
		 * 
		 * If the file does not exist, the %G_IO_ERROR_NOT_FOUND error will
		 * be returned. Other errors are possible too, and depend on what
		 * kind of filesystem the file is on.
		 * @param attributes an attribute query string
		 * @param cancellable optional #GCancellable object,
		 *     %NULL to ignore
		 * @returns a #GFileInfo or %NULL if there was an error.
		 *     Free the returned object with {@link GObject.unref}.
		 */
		query_filesystem_info(attributes: string, cancellable?: Cancellable | null): FileInfo;
		/**
		 * Asynchronously gets the requested information about the filesystem
		 * that the specified #file is on. The result is a #GFileInfo object
		 * that contains key-value attributes (such as type or size for the
		 * file).
		 * 
		 * For more details, see {@link G.file_query_filesystem_info} which is the
		 * synchronous version of this call.
		 * 
		 * When the operation is finished, #callback will be called. You can
		 * then call g_file_query_info_finish() to get the result of the
		 * operation.
		 * @param attributes an attribute query string
		 * @param io_priority the [I/O priority][io-priority] of the request
		 * @param cancellable optional #GCancellable object,
		 *     %NULL to ignore
		 * @param callback a #GAsyncReadyCallback to call
		 *     when the request is satisfied
		 */
		query_filesystem_info_async(attributes: string, io_priority: number, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;
		/**
		 * Finishes an asynchronous filesystem info query.
		 * See {@link G.file_query_filesystem_info_async}.
		 * @param res a #GAsyncResult
		 * @returns #GFileInfo for given #file
		 *     or %NULL on error.
		 *     Free the returned object with {@link GObject.unref}.
		 */
		query_filesystem_info_finish(res: AsyncResult): FileInfo;
		/**
		 * Gets the requested information about specified #file.
		 * The result is a #GFileInfo object that contains key-value
		 * attributes (such as the type or size of the file).
		 * 
		 * The #attributes value is a string that specifies the file
		 * attributes that should be gathered. It is not an error if
		 * it's not possible to read a particular requested attribute
		 * from a file - it just won't be set. #attributes should be a
		 * comma-separated list of attributes or attribute wildcards.
		 * The wildcard "*" means all attributes, and a wildcard like
		 * "standard::*" means all attributes in the standard namespace.
		 * An example attribute query be "standard::*,owner::user".
		 * The standard attributes are available as defines, like
		 * #G_FILE_ATTRIBUTE_STANDARD_NAME.
		 * 
		 * If #cancellable is not %NULL, then the operation can be cancelled
		 * by triggering the cancellable object from another thread. If the
		 * operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
		 * returned.
		 * 
		 * For symlinks, normally the information about the target of the
		 * symlink is returned, rather than information about the symlink
		 * itself. However if you pass #G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS
		 * in #flags the information about the symlink itself will be returned.
		 * Also, for symlinks that point to non-existing files the information
		 * about the symlink itself will be returned.
		 * 
		 * If the file does not exist, the %G_IO_ERROR_NOT_FOUND error will be
		 * returned. Other errors are possible too, and depend on what kind of
		 * filesystem the file is on.
		 * @param attributes an attribute query string
		 * @param flags a set of #GFileQueryInfoFlags
		 * @param cancellable optional #GCancellable object,
		 *     %NULL to ignore
		 * @returns a #GFileInfo for the given #file, or %NULL
		 *     on error. Free the returned object with {@link GObject.unref}.
		 */
		query_info(attributes: string, flags: FileQueryInfoFlags, cancellable?: Cancellable | null): FileInfo;
		/**
		 * Asynchronously gets the requested information about specified #file.
		 * The result is a #GFileInfo object that contains key-value attributes
		 * (such as type or size for the file).
		 * 
		 * For more details, see {@link G.file_query_info} which is the synchronous
		 * version of this call.
		 * 
		 * When the operation is finished, #callback will be called. You can
		 * then call g_file_query_info_finish() to get the result of the operation.
		 * @param attributes an attribute query string
		 * @param flags a set of #GFileQueryInfoFlags
		 * @param io_priority the [I/O priority][io-priority] of the request
		 * @param cancellable optional #GCancellable object,
		 *     %NULL to ignore
		 * @param callback a #GAsyncReadyCallback to call when the
		 *     request is satisfied
		 */
		query_info_async(attributes: string, flags: FileQueryInfoFlags, io_priority: number | null, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;
		/**
		 * Finishes an asynchronous file info query.
		 * See {@link G.file_query_info_async}.
		 * @param res a #GAsyncResult
		 * @returns #GFileInfo for given #file
		 *     or %NULL on error. Free the returned object with
		 *     {@link GObject.unref}.
		 */
		query_info_finish(res: AsyncResult): FileInfo;
		/**
		 * Obtain the list of settable attributes for the file.
		 * 
		 * Returns the type and full attribute name of all the attributes
		 * that can be set on this file. This doesn't mean setting it will
		 * always succeed though, you might get an access failure, or some
		 * specific file may not support a specific attribute.
		 * 
		 * If #cancellable is not %NULL, then the operation can be cancelled by
		 * triggering the cancellable object from another thread. If the operation
		 * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
		 * @param cancellable optional #GCancellable object,
		 *     %NULL to ignore
		 * @returns a #GFileAttributeInfoList describing the settable attributes.
		 *     When you are done with it, release it with
		 *     {@link G.file_attribute_info_list_unref}
		 */
		query_settable_attributes(cancellable?: Cancellable | null): FileAttributeInfoList;
		/**
		 * Obtain the list of attribute namespaces where new attributes
		 * can be created by a user. An example of this is extended
		 * attributes (in the "xattr" namespace).
		 * 
		 * If #cancellable is not %NULL, then the operation can be cancelled by
		 * triggering the cancellable object from another thread. If the operation
		 * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
		 * @param cancellable optional #GCancellable object,
		 *     %NULL to ignore
		 * @returns a #GFileAttributeInfoList describing the writable namespaces.
		 *     When you are done with it, release it with
		 *     {@link G.file_attribute_info_list_unref}
		 */
		query_writable_namespaces(cancellable?: Cancellable | null): FileAttributeInfoList;
		/**
		 * Opens a file for reading. The result is a #GFileInputStream that
		 * can be used to read the contents of the file.
		 * 
		 * If #cancellable is not %NULL, then the operation can be cancelled by
		 * triggering the cancellable object from another thread. If the operation
		 * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
		 * 
		 * If the file does not exist, the %G_IO_ERROR_NOT_FOUND error will be
		 * returned. If the file is a directory, the %G_IO_ERROR_IS_DIRECTORY
		 * error will be returned. Other errors are possible too, and depend
		 * on what kind of filesystem the file is on.
		 * @param cancellable a #GCancellable
		 * @returns #GFileInputStream or %NULL on error.
		 *     Free the returned object with {@link GObject.unref}.
		 */
		read(cancellable?: Cancellable | null): FileInputStream;
		/**
		 * Asynchronously opens #file for reading.
		 * 
		 * For more details, see {@link G.file_read} which is
		 * the synchronous version of this call.
		 * 
		 * When the operation is finished, #callback will be called.
		 * You can then call g_file_read_finish() to get the result
		 * of the operation.
		 * @param io_priority the [I/O priority][io-priority] of the request
		 * @param cancellable optional #GCancellable object,
		 *     %NULL to ignore
		 * @param callback a #GAsyncReadyCallback to call
		 *     when the request is satisfied
		 */
		read_async(io_priority: number, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;
		/**
		 * Finishes an asynchronous file read operation started with
		 * {@link G.file_read_async}.
		 * @param res a #GAsyncResult
		 * @returns a #GFileInputStream or %NULL on error.
		 *     Free the returned object with {@link GObject.unref}.
		 */
		read_finish(res: AsyncResult): FileInputStream;
		/**
		 * Returns an output stream for overwriting the file, possibly
		 * creating a backup copy of the file first. If the file doesn't exist,
		 * it will be created.
		 * 
		 * This will try to replace the file in the safest way possible so
		 * that any errors during the writing will not affect an already
		 * existing copy of the file. For instance, for local files it
		 * may write to a temporary file and then atomically rename over
		 * the destination when the stream is closed.
		 * 
		 * By default files created are generally readable by everyone,
		 * but if you pass #G_FILE_CREATE_PRIVATE in #flags the file
		 * will be made readable only to the current user, to the level that
		 * is supported on the target filesystem.
		 * 
		 * If #cancellable is not %NULL, then the operation can be cancelled
		 * by triggering the cancellable object from another thread. If the
		 * operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
		 * returned.
		 * 
		 * If you pass in a non-%NULL #etag value and #file already exists, then
		 * this value is compared to the current entity tag of the file, and if
		 * they differ an %G_IO_ERROR_WRONG_ETAG error is returned. This
		 * generally means that the file has been changed since you last read
		 * it. You can get the new etag from {@link G.file_output_stream_get_etag}
		 * after you've finished writing and closed the #GFileOutputStream. When
		 * you load a new file you can use g_file_input_stream_query_info() to
		 * get the etag of the file.
		 * 
		 * If #make_backup is %TRUE, this function will attempt to make a
		 * backup of the current file before overwriting it. If this fails
		 * a %G_IO_ERROR_CANT_CREATE_BACKUP error will be returned. If you
		 * want to replace anyway, try again with #make_backup set to %FALSE.
		 * 
		 * If the file is a directory the %G_IO_ERROR_IS_DIRECTORY error will
		 * be returned, and if the file is some other form of non-regular file
		 * then a %G_IO_ERROR_NOT_REGULAR_FILE error will be returned. Some
		 * file systems don't allow all file names, and may return an
		 * %G_IO_ERROR_INVALID_FILENAME error, and if the name is to long
		 * %G_IO_ERROR_FILENAME_TOO_LONG will be returned. Other errors are
		 * possible too, and depend on what kind of filesystem the file is on.
		 * @param etag an optional [entity tag][gfile-etag]
		 *     for the current #GFile, or #NULL to ignore
		 * @param make_backup %TRUE if a backup should be created
		 * @param flags a set of #GFileCreateFlags
		 * @param cancellable optional #GCancellable object,
		 *     %NULL to ignore
		 * @returns a #GFileOutputStream or %NULL on error.
		 *     Free the returned object with {@link GObject.unref}.
		 */
		replace(etag: string | null, make_backup: boolean, flags: FileCreateFlags, cancellable?: Cancellable | null): FileOutputStream;
		/**
		 * Asynchronously overwrites the file, replacing the contents,
		 * possibly creating a backup copy of the file first.
		 * 
		 * For more details, see {@link G.file_replace} which is
		 * the synchronous version of this call.
		 * 
		 * When the operation is finished, #callback will be called.
		 * You can then call g_file_replace_finish() to get the result
		 * of the operation.
		 * @param etag an [entity tag][gfile-etag] for the current #GFile,
		 *     or %NULL to ignore
		 * @param make_backup %TRUE if a backup should be created
		 * @param flags a set of #GFileCreateFlags
		 * @param io_priority the [I/O priority][io-priority] of the request
		 * @param cancellable optional #GCancellable object,
		 *     %NULL to ignore
		 * @param callback a #GAsyncReadyCallback to call
		 *     when the request is satisfied
		 */
		replace_async(etag: string | null, make_backup: boolean, flags: FileCreateFlags, io_priority: number, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;
		/**
		 * Replaces the contents of #file with #contents of #length bytes.
		 * 
		 * If #etag is specified (not %NULL), any existing file must have that etag,
		 * or the error %G_IO_ERROR_WRONG_ETAG will be returned.
		 * 
		 * If #make_backup is %TRUE, this function will attempt to make a backup
		 * of #file. Internally, it uses {@link G.file_replace}, so will try to replace the
		 * file contents in the safest way possible. For example, atomic renames are
		 * used when replacing local files’ contents.
		 * 
		 * If #cancellable is not %NULL, then the operation can be cancelled by
		 * triggering the cancellable object from another thread. If the operation
		 * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
		 * 
		 * The returned #new_etag can be used to verify that the file hasn't
		 * changed the next time it is saved over.
		 * @param contents a string containing the new contents for #file
		 * @param etag the old [entity-tag][gfile-etag] for the document,
		 *     or %NULL
		 * @param make_backup %TRUE if a backup should be created
		 * @param flags a set of #GFileCreateFlags
		 * @param cancellable optional #GCancellable object, %NULL to ignore
		 * @returns %TRUE if successful. If an error has occurred, this function
		 *     will return %FALSE and set #error appropriately if present.
		 * 
		 * a location to a new [entity tag][gfile-etag]
		 *      for the document. This should be freed with {@link G.free} when no longer
		 *      needed, or %NULL
		 */
		replace_contents(contents: string, etag: string | null, make_backup: boolean, flags: FileCreateFlags, cancellable?: Cancellable | null): [ boolean, string | null ];
		/**
		 * Starts an asynchronous replacement of #file with the given
		 * #contents of #length bytes. #etag will replace the document's
		 * current entity tag.
		 * 
		 * When this operation has completed, #callback will be called with
		 * #user_user data, and the operation can be finalized with
		 * {@link G.file_replace_contents_finish}.
		 * 
		 * If #cancellable is not %NULL, then the operation can be cancelled by
		 * triggering the cancellable object from another thread. If the operation
		 * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
		 * 
		 * If #make_backup is %TRUE, this function will attempt to
		 * make a backup of #file.
		 * 
		 * Note that no copy of #contents will be made, so it must stay valid
		 * until #callback is called. See g_file_replace_contents_bytes_async()
		 * for a #GBytes version that will automatically hold a reference to the
		 * contents (without copying) for the duration of the call.
		 * @param contents string of contents to replace the file with
		 * @param etag a new [entity tag][gfile-etag] for the #file, or %NULL
		 * @param make_backup %TRUE if a backup should be created
		 * @param flags a set of #GFileCreateFlags
		 * @param cancellable optional #GCancellable object, %NULL to ignore
		 * @param callback a #GAsyncReadyCallback to call when the request is satisfied
		 */
		replace_contents_async(contents: number[], etag: string | null, make_backup: boolean, flags: FileCreateFlags, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;
		/**
		 * Same as {@link G.file_replace_contents_async} but takes a #GBytes input instead.
		 * This function will keep a ref on #contents until the operation is done.
		 * Unlike g_file_replace_contents_async() this allows forgetting about the
		 * content without waiting for the callback.
		 * 
		 * When this operation has completed, #callback will be called with
		 * #user_user data, and the operation can be finalized with
		 * g_file_replace_contents_finish().
		 * @param contents a #GBytes
		 * @param etag a new [entity tag][gfile-etag] for the #file, or %NULL
		 * @param make_backup %TRUE if a backup should be created
		 * @param flags a set of #GFileCreateFlags
		 * @param cancellable optional #GCancellable object, %NULL to ignore
		 * @param callback a #GAsyncReadyCallback to call when the request is satisfied
		 */
		replace_contents_bytes_async(contents: GLib.Bytes, etag: string | null, make_backup: boolean, flags: FileCreateFlags, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;
		/**
		 * Finishes an asynchronous replace of the given #file. See
		 * {@link G.file_replace_contents_async}. Sets #new_etag to the new entity
		 * tag for the document, if present.
		 * @param res a #GAsyncResult
		 * @returns %TRUE on success, %FALSE on failure.
		 * 
		 * a location of a new [entity tag][gfile-etag]
		 *     for the document. This should be freed with {@link G.free} when it is no
		 *     longer needed, or %NULL
		 */
		replace_contents_finish(res: AsyncResult): [ boolean, string | null ];
		/**
		 * Finishes an asynchronous file replace operation started with
		 * {@link G.file_replace_async}.
		 * @param res a #GAsyncResult
		 * @returns a #GFileOutputStream, or %NULL on error.
		 *     Free the returned object with {@link GObject.unref}.
		 */
		replace_finish(res: AsyncResult): FileOutputStream;
		/**
		 * Returns an output stream for overwriting the file in readwrite mode,
		 * possibly creating a backup copy of the file first. If the file doesn't
		 * exist, it will be created.
		 * 
		 * For details about the behaviour, see {@link G.file_replace} which does the
		 * same thing but returns an output stream only.
		 * 
		 * Note that in many non-local file cases read and write streams are not
		 * supported, so make sure you really need to do read and write streaming,
		 * rather than just opening for reading or writing.
		 * @param etag an optional [entity tag][gfile-etag]
		 *     for the current #GFile, or #NULL to ignore
		 * @param make_backup %TRUE if a backup should be created
		 * @param flags a set of #GFileCreateFlags
		 * @param cancellable optional #GCancellable object,
		 *     %NULL to ignore
		 * @returns a #GFileIOStream or %NULL on error.
		 *     Free the returned object with {@link GObject.unref}.
		 */
		replace_readwrite(etag: string | null, make_backup: boolean, flags: FileCreateFlags, cancellable?: Cancellable | null): FileIOStream;
		/**
		 * Asynchronously overwrites the file in read-write mode,
		 * replacing the contents, possibly creating a backup copy
		 * of the file first.
		 * 
		 * For more details, see {@link G.file_replace_readwrite} which is
		 * the synchronous version of this call.
		 * 
		 * When the operation is finished, #callback will be called.
		 * You can then call g_file_replace_readwrite_finish() to get
		 * the result of the operation.
		 * @param etag an [entity tag][gfile-etag] for the current #GFile,
		 *     or %NULL to ignore
		 * @param make_backup %TRUE if a backup should be created
		 * @param flags a set of #GFileCreateFlags
		 * @param io_priority the [I/O priority][io-priority] of the request
		 * @param cancellable optional #GCancellable object,
		 *     %NULL to ignore
		 * @param callback a #GAsyncReadyCallback to call
		 *     when the request is satisfied
		 */
		replace_readwrite_async(etag: string | null, make_backup: boolean, flags: FileCreateFlags | null, io_priority: number | null, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;
		/**
		 * Finishes an asynchronous file replace operation started with
		 * {@link G.file_replace_readwrite_async}.
		 * @param res a #GAsyncResult
		 * @returns a #GFileIOStream, or %NULL on error.
		 *     Free the returned object with {@link GObject.unref}.
		 */
		replace_readwrite_finish(res: AsyncResult): FileIOStream;
		/**
		 * Resolves a relative path for #file to an absolute path.
		 * 
		 * This call does no blocking I/O.
		 * @param relative_path a given relative path string
		 * @returns #GFile to the resolved path.
		 *     %NULL if #relative_path is %NULL or if #file is invalid.
		 *     Free the returned object with {@link GObject.unref}.
		 */
		resolve_relative_path(relative_path: string): File;
		/**
		 * Sets an attribute in the file with attribute name #attribute to #value_p.
		 * 
		 * Some attributes can be unset by setting #type to
		 * %G_FILE_ATTRIBUTE_TYPE_INVALID and #value_p to %NULL.
		 * 
		 * If #cancellable is not %NULL, then the operation can be cancelled by
		 * triggering the cancellable object from another thread. If the operation
		 * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
		 * @param attribute a string containing the attribute's name
		 * @param type The type of the attribute
		 * @param value_p a pointer to the value (or the pointer
		 *     itself if the type is a pointer type)
		 * @param flags a set of #GFileQueryInfoFlags
		 * @param cancellable optional #GCancellable object,
		 *     %NULL to ignore
		 * @returns %TRUE if the attribute was set, %FALSE otherwise.
		 */
		set_attribute(attribute: string, type: FileAttributeType, value_p: any | null, flags: FileQueryInfoFlags, cancellable?: Cancellable | null): boolean;
		/**
		 * Sets #attribute of type %G_FILE_ATTRIBUTE_TYPE_BYTE_STRING to #value.
		 * If #attribute is of a different type, this operation will fail,
		 * returning %FALSE.
		 * 
		 * If #cancellable is not %NULL, then the operation can be cancelled by
		 * triggering the cancellable object from another thread. If the operation
		 * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
		 * @param attribute a string containing the attribute's name
		 * @param value a string containing the attribute's new value
		 * @param flags a #GFileQueryInfoFlags
		 * @param cancellable optional #GCancellable object,
		 *     %NULL to ignore
		 * @returns %TRUE if the #attribute was successfully set to #value
		 *     in the #file, %FALSE otherwise.
		 */
		set_attribute_byte_string(attribute: string, value: string, flags: FileQueryInfoFlags, cancellable?: Cancellable | null): boolean;
		/**
		 * Sets #attribute of type %G_FILE_ATTRIBUTE_TYPE_INT32 to #value.
		 * If #attribute is of a different type, this operation will fail.
		 * 
		 * If #cancellable is not %NULL, then the operation can be cancelled by
		 * triggering the cancellable object from another thread. If the operation
		 * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
		 * @param attribute a string containing the attribute's name
		 * @param value a #gint32 containing the attribute's new value
		 * @param flags a #GFileQueryInfoFlags
		 * @param cancellable optional #GCancellable object,
		 *     %NULL to ignore
		 * @returns %TRUE if the #attribute was successfully set to #value
		 *     in the #file, %FALSE otherwise.
		 */
		set_attribute_int32(attribute: string, value: number, flags: FileQueryInfoFlags, cancellable?: Cancellable | null): boolean;
		/**
		 * Sets #attribute of type %G_FILE_ATTRIBUTE_TYPE_INT64 to #value.
		 * If #attribute is of a different type, this operation will fail.
		 * 
		 * If #cancellable is not %NULL, then the operation can be cancelled by
		 * triggering the cancellable object from another thread. If the operation
		 * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
		 * @param attribute a string containing the attribute's name
		 * @param value a #guint64 containing the attribute's new value
		 * @param flags a #GFileQueryInfoFlags
		 * @param cancellable optional #GCancellable object,
		 *     %NULL to ignore
		 * @returns %TRUE if the #attribute was successfully set, %FALSE otherwise.
		 */
		set_attribute_int64(attribute: string, value: number, flags: FileQueryInfoFlags, cancellable?: Cancellable | null): boolean;
		/**
		 * Sets #attribute of type %G_FILE_ATTRIBUTE_TYPE_STRING to #value.
		 * If #attribute is of a different type, this operation will fail.
		 * 
		 * If #cancellable is not %NULL, then the operation can be cancelled by
		 * triggering the cancellable object from another thread. If the operation
		 * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
		 * @param attribute a string containing the attribute's name
		 * @param value a string containing the attribute's value
		 * @param flags #GFileQueryInfoFlags
		 * @param cancellable optional #GCancellable object,
		 *     %NULL to ignore
		 * @returns %TRUE if the #attribute was successfully set, %FALSE otherwise.
		 */
		set_attribute_string(attribute: string, value: string, flags: FileQueryInfoFlags, cancellable?: Cancellable | null): boolean;
		/**
		 * Sets #attribute of type %G_FILE_ATTRIBUTE_TYPE_UINT32 to #value.
		 * If #attribute is of a different type, this operation will fail.
		 * 
		 * If #cancellable is not %NULL, then the operation can be cancelled by
		 * triggering the cancellable object from another thread. If the operation
		 * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
		 * @param attribute a string containing the attribute's name
		 * @param value a #guint32 containing the attribute's new value
		 * @param flags a #GFileQueryInfoFlags
		 * @param cancellable optional #GCancellable object,
		 *     %NULL to ignore
		 * @returns %TRUE if the #attribute was successfully set to #value
		 *     in the #file, %FALSE otherwise.
		 */
		set_attribute_uint32(attribute: string, value: number, flags: FileQueryInfoFlags, cancellable?: Cancellable | null): boolean;
		/**
		 * Sets #attribute of type %G_FILE_ATTRIBUTE_TYPE_UINT64 to #value.
		 * If #attribute is of a different type, this operation will fail.
		 * 
		 * If #cancellable is not %NULL, then the operation can be cancelled by
		 * triggering the cancellable object from another thread. If the operation
		 * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
		 * @param attribute a string containing the attribute's name
		 * @param value a #guint64 containing the attribute's new value
		 * @param flags a #GFileQueryInfoFlags
		 * @param cancellable optional #GCancellable object,
		 *     %NULL to ignore
		 * @returns %TRUE if the #attribute was successfully set to #value
		 *     in the #file, %FALSE otherwise.
		 */
		set_attribute_uint64(attribute: string, value: number, flags: FileQueryInfoFlags, cancellable?: Cancellable | null): boolean;
		/**
		 * Asynchronously sets the attributes of #file with #info.
		 * 
		 * For more details, see {@link G.file_set_attributes_from_info},
		 * which is the synchronous version of this call.
		 * 
		 * When the operation is finished, #callback will be called.
		 * You can then call g_file_set_attributes_finish() to get
		 * the result of the operation.
		 * @param info a #GFileInfo
		 * @param flags a #GFileQueryInfoFlags
		 * @param io_priority the [I/O priority][io-priority] of the request
		 * @param cancellable optional #GCancellable object,
		 *     %NULL to ignore
		 * @param callback a #GAsyncReadyCallback
		 */
		set_attributes_async(info: FileInfo, flags: FileQueryInfoFlags, io_priority: number, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;
		/**
		 * Finishes setting an attribute started in {@link G.file_set_attributes_async}.
		 * @param result a #GAsyncResult
		 * @returns %TRUE if the attributes were set correctly, %FALSE otherwise.
		 * 
		 * a #GFileInfo
		 */
		set_attributes_finish(result: AsyncResult): [ boolean, FileInfo ];
		/**
		 * Tries to set all attributes in the #GFileInfo on the target
		 * values, not stopping on the first error.
		 * 
		 * If there is any error during this operation then #error will
		 * be set to the first error. Error on particular fields are flagged
		 * by setting the "status" field in the attribute value to
		 * %G_FILE_ATTRIBUTE_STATUS_ERROR_SETTING, which means you can
		 * also detect further errors.
		 * 
		 * If #cancellable is not %NULL, then the operation can be cancelled by
		 * triggering the cancellable object from another thread. If the operation
		 * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
		 * @param info a #GFileInfo
		 * @param flags #GFileQueryInfoFlags
		 * @param cancellable optional #GCancellable object,
		 *     %NULL to ignore
		 * @returns %FALSE if there was any error, %TRUE otherwise.
		 */
		set_attributes_from_info(info: FileInfo, flags: FileQueryInfoFlags, cancellable?: Cancellable | null): boolean;
		/**
		 * Renames #file to the specified display name.
		 * 
		 * The display name is converted from UTF-8 to the correct encoding
		 * for the target filesystem if possible and the #file is renamed to this.
		 * 
		 * If you want to implement a rename operation in the user interface the
		 * edit name (#G_FILE_ATTRIBUTE_STANDARD_EDIT_NAME) should be used as the
		 * initial value in the rename widget, and then the result after editing
		 * should be passed to {@link G.file_set_display_name}.
		 * 
		 * On success the resulting converted filename is returned.
		 * 
		 * If #cancellable is not %NULL, then the operation can be cancelled by
		 * triggering the cancellable object from another thread. If the operation
		 * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
		 * @param display_name a string
		 * @param cancellable optional #GCancellable object,
		 *     %NULL to ignore
		 * @returns a #GFile specifying what #file was renamed to,
		 *     or %NULL if there was an error.
		 *     Free the returned object with {@link GObject.unref}.
		 */
		set_display_name(display_name: string, cancellable?: Cancellable | null): File;
		/**
		 * Asynchronously sets the display name for a given #GFile.
		 * 
		 * For more details, see {@link G.file_set_display_name} which is
		 * the synchronous version of this call.
		 * 
		 * When the operation is finished, #callback will be called.
		 * You can then call g_file_set_display_name_finish() to get
		 * the result of the operation.
		 * @param display_name a string
		 * @param io_priority the [I/O priority][io-priority] of the request
		 * @param cancellable optional #GCancellable object,
		 *     %NULL to ignore
		 * @param callback a #GAsyncReadyCallback to call
		 *     when the request is satisfied
		 */
		set_display_name_async(display_name: string, io_priority: number, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;
		/**
		 * Finishes setting a display name started with
		 * {@link G.file_set_display_name_async}.
		 * @param res a #GAsyncResult
		 * @returns a #GFile or %NULL on error.
		 *     Free the returned object with {@link GObject.unref}.
		 */
		set_display_name_finish(res: AsyncResult): File;
		/**
		 * Starts a file of type #G_FILE_TYPE_MOUNTABLE.
		 * Using #start_operation, you can request callbacks when, for instance,
		 * passwords are needed during authentication.
		 * 
		 * If #cancellable is not %NULL, then the operation can be cancelled by
		 * triggering the cancellable object from another thread. If the operation
		 * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
		 * 
		 * When the operation is finished, #callback will be called.
		 * You can then call {@link G.file_mount_mountable_finish} to get
		 * the result of the operation.
		 * @param flags flags affecting the operation
		 * @param start_operation a #GMountOperation, or %NULL to avoid user interaction
		 * @param cancellable optional #GCancellable object, %NULL to ignore
		 * @param callback a #GAsyncReadyCallback to call when the request is satisfied, or %NULL
		 */
		start_mountable(flags: DriveStartFlags, start_operation?: MountOperation | null, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;
		/**
		 * Finishes a start operation. See {@link G.file_start_mountable} for details.
		 * 
		 * Finish an asynchronous start operation that was started
		 * with g_file_start_mountable().
		 * @param result a #GAsyncResult
		 * @returns %TRUE if the operation finished successfully. %FALSE
		 * otherwise.
		 */
		start_mountable_finish(result: AsyncResult): boolean;
		/**
		 * Stops a file of type #G_FILE_TYPE_MOUNTABLE.
		 * 
		 * If #cancellable is not %NULL, then the operation can be cancelled by
		 * triggering the cancellable object from another thread. If the operation
		 * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
		 * 
		 * When the operation is finished, #callback will be called.
		 * You can then call {@link G.file_stop_mountable_finish} to get
		 * the result of the operation.
		 * @param flags flags affecting the operation
		 * @param mount_operation a #GMountOperation,
		 *     or %NULL to avoid user interaction.
		 * @param cancellable optional #GCancellable object,
		 *     %NULL to ignore
		 * @param callback a #GAsyncReadyCallback to call
		 *     when the request is satisfied, or %NULL
		 */
		stop_mountable(flags: MountUnmountFlags, mount_operation?: MountOperation | null, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;
		/**
		 * Finishes a stop operation, see {@link G.file_stop_mountable} for details.
		 * 
		 * Finish an asynchronous stop operation that was started
		 * with g_file_stop_mountable().
		 * @param result a #GAsyncResult
		 * @returns %TRUE if the operation finished successfully.
		 *     %FALSE otherwise.
		 */
		stop_mountable_finish(result: AsyncResult): boolean;
		/**
		 * Checks if #file supports
		 * [thread-default contexts][g-main-context-push-thread-default-context].
		 * If this returns %FALSE, you cannot perform asynchronous operations on
		 * #file in a thread that has a thread-default context.
		 * @returns Whether or not #file supports thread-default contexts.
		 */
		supports_thread_contexts(): boolean;
		/**
		 * Sends #file to the "Trashcan", if possible. This is similar to
		 * deleting it, but the user can recover it before emptying the trashcan.
		 * Not all file systems support trashing, so this call can return the
		 * %G_IO_ERROR_NOT_SUPPORTED error. Since GLib 2.66, the `x-gvfs-notrash` unix
		 * mount option can be used to disable {@link G.file_trash} support for certain
		 * mounts, the %G_IO_ERROR_NOT_SUPPORTED error will be returned in that case.
		 * 
		 * If #cancellable is not %NULL, then the operation can be cancelled by
		 * triggering the cancellable object from another thread. If the operation
		 * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
		 * @param cancellable optional #GCancellable object,
		 *     %NULL to ignore
		 * @returns %TRUE on successful trash, %FALSE otherwise.
		 */
		trash(cancellable?: Cancellable | null): boolean;
		/**
		 * Asynchronously sends #file to the Trash location, if possible.
		 * @param io_priority the [I/O priority][io-priority] of the request
		 * @param cancellable optional #GCancellable object,
		 *     %NULL to ignore
		 * @param callback a #GAsyncReadyCallback to call
		 *     when the request is satisfied
		 */
		trash_async(io_priority: number, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;
		/**
		 * Finishes an asynchronous file trashing operation, started with
		 * {@link G.file_trash_async}.
		 * @param result a #GAsyncResult
		 * @returns %TRUE on successful trash, %FALSE otherwise.
		 */
		trash_finish(result: AsyncResult): boolean;
		/**
		 * @deprecated
		 * Use {@link G.file_unmount_mountable_with_operation} instead.
		 * 
		 * Unmounts a file of type G_FILE_TYPE_MOUNTABLE.
		 * 
		 * If #cancellable is not %NULL, then the operation can be cancelled by
		 * triggering the cancellable object from another thread. If the operation
		 * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
		 * 
		 * When the operation is finished, #callback will be called.
		 * You can then call {@link G.file_unmount_mountable_finish} to get
		 * the result of the operation.
		 * @param flags flags affecting the operation
		 * @param cancellable optional #GCancellable object,
		 *     %NULL to ignore
		 * @param callback a #GAsyncReadyCallback to call
		 *     when the request is satisfied, or %NULL
		 */
		unmount_mountable(flags: MountUnmountFlags, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;
		/**
		 * @deprecated
		 * Use {@link G.file_unmount_mountable_with_operation_finish}
		 *     instead.
		 * 
		 * Finishes an unmount operation, see {@link G.file_unmount_mountable} for details.
		 * 
		 * Finish an asynchronous unmount operation that was started
		 * with g_file_unmount_mountable().
		 * @param result a #GAsyncResult
		 * @returns %TRUE if the operation finished successfully.
		 *     %FALSE otherwise.
		 */
		unmount_mountable_finish(result: AsyncResult): boolean;
		/**
		 * Unmounts a file of type #G_FILE_TYPE_MOUNTABLE.
		 * 
		 * If #cancellable is not %NULL, then the operation can be cancelled by
		 * triggering the cancellable object from another thread. If the operation
		 * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
		 * 
		 * When the operation is finished, #callback will be called.
		 * You can then call {@link G.file_unmount_mountable_finish} to get
		 * the result of the operation.
		 * @param flags flags affecting the operation
		 * @param mount_operation a #GMountOperation,
		 *     or %NULL to avoid user interaction
		 * @param cancellable optional #GCancellable object,
		 *     %NULL to ignore
		 * @param callback a #GAsyncReadyCallback to call
		 *     when the request is satisfied, or %NULL
		 */
		unmount_mountable_with_operation(flags: MountUnmountFlags, mount_operation?: MountOperation | null, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;
		/**
		 * Finishes an unmount operation,
		 * see {@link G.file_unmount_mountable_with_operation} for details.
		 * 
		 * Finish an asynchronous unmount operation that was started
		 * with g_file_unmount_mountable_with_operation().
		 * @param result a #GAsyncResult
		 * @returns %TRUE if the operation finished successfully.
		 *     %FALSE otherwise.
		 */
		unmount_mountable_with_operation_finish(result: AsyncResult): boolean;
	}

	type FileInitOptionsMixin  = {};
	export interface FileInitOptions extends FileInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link File} instead.
	 */
	type FileMixin = IFile;

	/**
	 * #GFile is a high level abstraction for manipulating files on a
	 * virtual file system. #GFiles are lightweight, immutable objects
	 * that do no I/O upon creation. It is necessary to understand that
	 * #GFile objects do not represent files, merely an identifier for a
	 * file. All file content I/O is implemented as streaming operations
	 * (see #GInputStream and #GOutputStream).
	 * 
	 * To construct a #GFile, you can use:
	 * - {@link G.file_new_for_path} if you have a path.
	 * - g_file_new_for_uri() if you have a URI.
	 * - g_file_new_for_commandline_arg() for a command line argument.
	 * - g_file_new_tmp() to create a temporary file from a template.
	 * - g_file_parse_name() from a UTF-8 string gotten from g_file_get_parse_name().
	 * - g_file_new_build_filename() to create a file from path elements.
	 * 
	 * One way to think of a #GFile is as an abstraction of a pathname. For
	 * normal files the system pathname is what is stored internally, but as
	 * #GFiles are extensible it could also be something else that corresponds
	 * to a pathname in a userspace implementation of a filesystem.
	 * 
	 * #GFiles make up hierarchies of directories and files that correspond to
	 * the files on a filesystem. You can move through the file system with
	 * #GFile using g_file_get_parent() to get an identifier for the parent
	 * directory, g_file_get_child() to get a child within a directory,
	 * g_file_resolve_relative_path() to resolve a relative path between two
	 * #GFiles. There can be multiple hierarchies, so you may not end up at
	 * the same root if you repeatedly call g_file_get_parent() on two different
	 * files.
	 * 
	 * All #GFiles have a basename (get with g_file_get_basename()). These names
	 * are byte strings that are used to identify the file on the filesystem
	 * (relative to its parent directory) and there is no guarantees that they
	 * have any particular charset encoding or even make any sense at all. If
	 * you want to use filenames in a user interface you should use the display
	 * name that you can get by requesting the
	 * %G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME attribute with g_file_query_info().
	 * This is guaranteed to be in UTF-8 and can be used in a user interface.
	 * But always store the real basename or the #GFile to use to actually
	 * access the file, because there is no way to go from a display name to
	 * the actual name.
	 * 
	 * Using #GFile as an identifier has the same weaknesses as using a path
	 * in that there may be multiple aliases for the same file. For instance,
	 * hard or soft links may cause two different #GFiles to refer to the same
	 * file. Other possible causes for aliases are: case insensitive filesystems,
	 * short and long names on FAT/NTFS, or bind mounts in Linux. If you want to
	 * check if two #GFiles point to the same file you can query for the
	 * %G_FILE_ATTRIBUTE_ID_FILE attribute. Note that #GFile does some trivial
	 * canonicalization of pathnames passed in, so that trivial differences in
	 * the path string used at creation (duplicated slashes, slash at end of
	 * path, "." or ".." path segments, etc) does not create different #GFiles.
	 * 
	 * Many #GFile operations have both synchronous and asynchronous versions
	 * to suit your application. Asynchronous versions of synchronous functions
	 * simply have _async() appended to their function names. The asynchronous
	 * I/O functions call a #GAsyncReadyCallback which is then used to finalize
	 * the operation, producing a GAsyncResult which is then passed to the
	 * function's matching _finish() operation.
	 * 
	 * It is highly recommended to use asynchronous calls when running within a
	 * shared main loop, such as in the main thread of an application. This avoids
	 * I/O operations blocking other sources on the main loop from being dispatched.
	 * Synchronous I/O operations should be performed from worker threads. See the
	 * [introduction to asynchronous programming section][async-programming] for
	 * more.
	 * 
	 * Some #GFile operations almost always take a noticeable amount of time, and
	 * so do not have synchronous analogs. Notable cases include:
	 * - g_file_mount_mountable() to mount a mountable file.
	 * - g_file_unmount_mountable_with_operation() to unmount a mountable file.
	 * - g_file_eject_mountable_with_operation() to eject a mountable file.
	 * 
	 * ## Entity Tags # {#gfile-etag}
	 * 
	 * One notable feature of #GFiles are entity tags, or "etags" for
	 * short. Entity tags are somewhat like a more abstract version of the
	 * traditional mtime, and can be used to quickly determine if the file
	 * has been modified from the version on the file system. See the
	 * HTTP 1.1
	 * [specification](http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html)
	 * for HTTP Etag headers, which are a very similar concept.
	 */
	interface File extends FileMixin {}

	class File {
		public constructor(options?: Partial<FileInitOptions>);
		/**
		 * Constructs a #GFile from a series of elements using the correct
		 * separator for filenames.
		 * 
		 * Using this function is equivalent to calling {@link G.build_filename},
		 * followed by g_file_new_for_path() on the result.
		 * @param first_element the first element in the path
		 * @returns a new #GFile
		 */
		public static new_build_filename(first_element: string): File;
		/**
		 * Creates a #GFile with the given argument from the command line.
		 * The value of #arg can be either a URI, an absolute path or a
		 * relative path resolved relative to the current working directory.
		 * This operation never fails, but the returned object might not
		 * support any I/O operation if #arg points to a malformed path.
		 * 
		 * Note that on Windows, this function expects its argument to be in
		 * UTF-8 -- not the system code page.  This means that you
		 * should not use this function with string from argv as it is passed
		 * to main().  g_win32_get_command_line() will return a UTF-8 version of
		 * the commandline.  #GApplication also uses UTF-8 but
		 * g_application_command_line_create_file_for_arg() may be more useful
		 * for you there.  It is also always possible to use this function with
		 * #GOptionContext arguments of type %G_OPTION_ARG_FILENAME.
		 * @param arg a command line string
		 * @returns a new #GFile.
		 *    Free the returned object with {@link GObject.unref}.
		 */
		public static new_for_commandline_arg(arg: string): File;
		/**
		 * Creates a #GFile with the given argument from the command line.
		 * 
		 * This function is similar to {@link G.file_new_for_commandline_arg} except
		 * that it allows for passing the current working directory as an
		 * argument instead of using the current working directory of the
		 * process.
		 * 
		 * This is useful if the commandline argument was given in a context
		 * other than the invocation of the current process.
		 * 
		 * See also g_application_command_line_create_file_for_arg().
		 * @param arg a command line string
		 * @param cwd the current working directory of the commandline
		 * @returns a new #GFile
		 */
		public static new_for_commandline_arg_and_cwd(arg: string, cwd: string): File;
		/**
		 * Constructs a #GFile for a given path. This operation never
		 * fails, but the returned object might not support any I/O
		 * operation if #path is malformed.
		 * @param path a string containing a relative or absolute path.
		 *     The string must be encoded in the glib filename encoding.
		 * @returns a new #GFile for the given #path.
		 *   Free the returned object with {@link GObject.unref}.
		 */
		public static new_for_path(path: string): File;
		/**
		 * Constructs a #GFile for a given URI. This operation never
		 * fails, but the returned object might not support any I/O
		 * operation if #uri is malformed or if the uri type is
		 * not supported.
		 * @param uri a UTF-8 string containing a URI
		 * @returns a new #GFile for the given #uri.
		 *     Free the returned object with {@link GObject.unref}.
		 */
		public static new_for_uri(uri: string): File;
		/**
		 * Opens a file in the preferred directory for temporary files (as
		 * returned by {@link G.get_tmp_dir}) and returns a #GFile and
		 * #GFileIOStream pointing to it.
		 * 
		 * #tmpl should be a string in the GLib file name encoding
		 * containing a sequence of six 'X' characters, and containing no
		 * directory components. If it is %NULL, a default template is used.
		 * 
		 * Unlike the other #GFile constructors, this will return %NULL if
		 * a temporary file could not be created.
		 * @param tmpl Template for the file
		 *   name, as in {@link G.file_open_tmp}, or %NULL for a default template
		 * @returns a new #GFile.
		 *     Free the returned object with {@link GObject.unref}.
		 * 
		 * on return, a #GFileIOStream for the created file
		 */
		public static new_tmp(tmpl?: string | null): [ File, FileIOStream ];
		/**
		 * Constructs a #GFile with the given #parse_name (i.e. something
		 * given by {@link G.file_get_parse_name}). This operation never fails,
		 * but the returned object might not support any I/O operation if
		 * the #parse_name cannot be parsed.
		 * @param parse_name a file name or path to be parsed
		 * @returns a new #GFile.
		 */
		public static parse_name(parse_name: string): File;
	}



	/** This construct is only for enabling class multi-inheritance,
	 * use {@link FileDescriptorBased} instead.
	 */
	interface IFileDescriptorBased {
		/**
		 * Gets the underlying file descriptor.
		 * @returns The file descriptor
		 */
		get_fd(): number;
	}

	type FileDescriptorBasedInitOptionsMixin  = {};
	export interface FileDescriptorBasedInitOptions extends FileDescriptorBasedInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link FileDescriptorBased} instead.
	 */
	type FileDescriptorBasedMixin = IFileDescriptorBased;

	/**
	 * #GFileDescriptorBased is implemented by streams (implementations of
	 * #GInputStream or #GOutputStream) that are based on file descriptors.
	 * 
	 * Note that `<gio/gfiledescriptorbased.h>` belongs to the UNIX-specific
	 * GIO interfaces, thus you have to use the `gio-unix-2.0.pc` pkg-config
	 * file when using it.
	 */
	interface FileDescriptorBased extends FileDescriptorBasedMixin {}

	class FileDescriptorBased {
		public constructor(options?: Partial<FileDescriptorBasedInitOptions>);
	}



	/** This construct is only for enabling class multi-inheritance,
	 * use {@link Icon} instead.
	 */
	interface IIcon {
		/**
		 * Checks if two icons are equal.
		 * @param icon2 pointer to the second #GIcon.
		 * @returns %TRUE if #icon1 is equal to #icon2. %FALSE otherwise.
		 */
		equal(icon2?: Icon | null): boolean;
		/**
		 * Serializes a #GIcon into a #GVariant. An equivalent #GIcon can be retrieved
		 * back by calling {@link G.icon_deserialize} on the returned value.
		 * As serialization will avoid using raw icon data when possible, it only
		 * makes sense to transfer the #GVariant between processes on the same machine,
		 * (as opposed to over the network), and within the same file system namespace.
		 * @returns a #GVariant, or %NULL when serialization fails. The #GVariant will not be floating.
		 */
		serialize(): GLib.Variant | null;
		/**
		 * Generates a textual representation of #icon that can be used for
		 * serialization such as when passing #icon to a different process or
		 * saving it to persistent storage. Use {@link G.icon_new_for_string} to
		 * get #icon back from the returned string.
		 * 
		 * The encoding of the returned string is proprietary to #GIcon except
		 * in the following two cases
		 * 
		 * - If #icon is a #GFileIcon, the returned string is a native path
		 *   (such as `/path/to/my icon.png`) without escaping
		 *   if the #GFile for #icon is a native file.  If the file is not
		 *   native, the returned string is the result of g_file_get_uri()
		 *   (such as `sftp://path/to/my%20icon.png`).
		 * 
		 * - If #icon is a #GThemedIcon with exactly one name and no fallbacks,
		 *   the encoding is simply the name (such as `network-server`).
		 * @returns An allocated NUL-terminated UTF8 string or
		 * %NULL if #icon can't be serialized. Use {@link G.free} to free.
		 */
		to_string(): string | null;
	}

	type IconInitOptionsMixin  = {};
	export interface IconInitOptions extends IconInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link Icon} instead.
	 */
	type IconMixin = IIcon;

	/**
	 * #GIcon is a very minimal interface for icons. It provides functions
	 * for checking the equality of two icons, hashing of icons and
	 * serializing an icon to and from strings.
	 * 
	 * #GIcon does not provide the actual pixmap for the icon as this is out
	 * of GIO's scope, however implementations of #GIcon may contain the name
	 * of an icon (see #GThemedIcon), or the path to an icon (see #GLoadableIcon).
	 * 
	 * To obtain a hash of a #GIcon, see {@link G.icon_hash}.
	 * 
	 * To check if two #GIcons are equal, see g_icon_equal().
	 * 
	 * For serializing a #GIcon, use g_icon_serialize() and
	 * g_icon_deserialize().
	 * 
	 * If you want to consume #GIcon (for example, in a toolkit) you must
	 * be prepared to handle at least the three following cases:
	 * #GLoadableIcon, #GThemedIcon and #GEmblemedIcon.  It may also make
	 * sense to have fast-paths for other cases (like handling #GdkPixbuf
	 * directly, for example) but all compliant #GIcon implementations
	 * outside of GIO must implement #GLoadableIcon.
	 * 
	 * If your application or library provides one or more #GIcon
	 * implementations you need to ensure that your new implementation also
	 * implements #GLoadableIcon.  Additionally, you must provide an
	 * implementation of g_icon_serialize() that gives a result that is
	 * understood by g_icon_deserialize(), yielding one of the built-in icon
	 * types.
	 */
	interface Icon extends IconMixin {}

	class Icon {
		public constructor(options?: Partial<IconInitOptions>);
		/**
		 * Deserializes a #GIcon previously serialized using {@link G.icon_serialize}.
		 * @param value a #GVariant created with {@link G.icon_serialize}
		 * @returns a #GIcon, or %NULL when deserialization fails.
		 */
		public static deserialize(value: GLib.Variant): Icon | null;
		/**
		 * Gets a hash for an icon.
		 * @param icon #gconstpointer to an icon object.
		 * @returns a #guint containing a hash for the #icon, suitable for
		 * use in a #GHashTable or similar data structure.
		 */
		public static hash(icon: any): number;
		/**
		 * Generate a #GIcon instance from #str. This function can fail if
		 * #str is not valid - see {@link G.icon_to_string} for discussion.
		 * 
		 * If your application or library provides one or more #GIcon
		 * implementations you need to ensure that each #GType is registered
		 * with the type system prior to calling g_icon_new_for_string().
		 * @param str A string obtained via {@link G.icon_to_string}.
		 * @returns An object implementing the #GIcon
		 *          interface or %NULL if #error is set.
		 */
		public static new_for_string(str: string): Icon;
	}



	/** This construct is only for enabling class multi-inheritance,
	 * use {@link Initable} instead.
	 */
	interface IInitable {
		/**
		 * Initializes the object implementing the interface.
		 * 
		 * This method is intended for language bindings. If writing in C,
		 * {@link G.initable_new} should typically be used instead.
		 * 
		 * The object must be initialized before any real use after initial
		 * construction, either with this function or g_async_initable_init_async().
		 * 
		 * Implementations may also support cancellation. If #cancellable is not %NULL,
		 * then initialization can be cancelled by triggering the cancellable object
		 * from another thread. If the operation was cancelled, the error
		 * %G_IO_ERROR_CANCELLED will be returned. If #cancellable is not %NULL and
		 * the object doesn't support cancellable initialization the error
		 * %G_IO_ERROR_NOT_SUPPORTED will be returned.
		 * 
		 * If the object is not initialized, or initialization returns with an
		 * error, then all operations on the object except g_object_ref() and
		 * g_object_unref() are considered to be invalid, and have undefined
		 * behaviour. See the [introduction][ginitable] for more details.
		 * 
		 * Callers should not assume that a class which implements #GInitable can be
		 * initialized multiple times, unless the class explicitly documents itself as
		 * supporting this. Generally, a class’ implementation of init() can assume
		 * (and assert) that it will only be called once. Previously, this documentation
		 * recommended all #GInitable implementations should be idempotent; that
		 * recommendation was relaxed in GLib 2.54.
		 * 
		 * If a class explicitly supports being initialized multiple times, it is
		 * recommended that the method is idempotent: multiple calls with the same
		 * arguments should return the same results. Only the first call initializes
		 * the object; further calls return the result of the first call.
		 * 
		 * One reason why a class might need to support idempotent initialization is if
		 * it is designed to be used via the singleton pattern, with a
		 * #GObjectClass.constructor that sometimes returns an existing instance.
		 * In this pattern, a caller would expect to be able to call g_initable_init()
		 * on the result of g_object_new(), regardless of whether it is in fact a new
		 * instance.
		 * @param cancellable optional #GCancellable object, %NULL to ignore.
		 * @returns %TRUE if successful. If an error has occurred, this function will
		 *     return %FALSE and set #error appropriately if present.
		 */
		init(cancellable?: Cancellable | null): boolean;
	}

	type InitableInitOptionsMixin  = {};
	export interface InitableInitOptions extends InitableInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link Initable} instead.
	 */
	type InitableMixin = IInitable;

	/**
	 * #GInitable is implemented by objects that can fail during
	 * initialization. If an object implements this interface then
	 * it must be initialized as the first thing after construction,
	 * either via {@link G.initable_init} or g_async_initable_init_async()
	 * (the latter is only available if it also implements #GAsyncInitable).
	 * 
	 * If the object is not initialized, or initialization returns with an
	 * error, then all operations on the object except g_object_ref() and
	 * g_object_unref() are considered to be invalid, and have undefined
	 * behaviour. They will often fail with g_critical() or g_warning(), but
	 * this must not be relied on.
	 * 
	 * Users of objects implementing this are not intended to use
	 * the interface method directly, instead it will be used automatically
	 * in various ways. For C applications you generally just call
	 * g_initable_new() directly, or indirectly via a foo_thing_new() wrapper.
	 * This will call g_initable_init() under the cover, returning %NULL and
	 * setting a #GError on failure (at which point the instance is
	 * unreferenced).
	 * 
	 * For bindings in languages where the native constructor supports
	 * exceptions the binding could check for objects implementing %GInitable
	 * during normal construction and automatically initialize them, throwing
	 * an exception on failure.
	 */
	interface Initable extends InitableMixin {}

	class Initable {
		public constructor(options?: Partial<InitableInitOptions>);
		/**
		 * Helper function for constructing #GInitable object. This is
		 * similar to {@link GObject.new} but also initializes the object
		 * and returns %NULL, setting an error on failure.
		 * @param object_type a #GType supporting #GInitable.
		 * @param cancellable optional #GCancellable object, %NULL to ignore.
		 * @param error a #GError location to store the error occurring, or %NULL to
		 *    ignore.
		 * @param first_property_name the name of the first property, or %NULL if no
		 *     properties
		 * @returns a newly allocated
		 *      #GObject, or %NULL on error
		 */
		public static new(object_type: GObject.Type, cancellable: Cancellable | null, error: GLib.Error, first_property_name?: string | null): GObject.Object;
		/**
		 * Helper function for constructing #GInitable object. This is
		 * similar to {@link GObject.new_valist} but also initializes the object
		 * and returns %NULL, setting an error on failure.
		 * @param object_type a #GType supporting #GInitable.
		 * @param first_property_name the name of the first property, followed by
		 * the value, and other property value pairs, and ended by %NULL.
		 * @param var_args The var args list generated from #first_property_name.
		 * @param cancellable optional #GCancellable object, %NULL to ignore.
		 * @returns a newly allocated
		 *      #GObject, or %NULL on error
		 */
		public static new_valist(object_type: GObject.Type, first_property_name: string, var_args: any[], cancellable?: Cancellable | null): GObject.Object;
		/**
		 * @deprecated
		 * Use {@link GObject.new_with_properties} and
		 * g_initable_init() instead. See #GParameter for more information.
		 * 
		 * Helper function for constructing #GInitable object. This is
		 * similar to {@link GObject.newv} but also initializes the object
		 * and returns %NULL, setting an error on failure.
		 * @param object_type a #GType supporting #GInitable.
		 * @param parameters the parameters to use to construct the object
		 * @param cancellable optional #GCancellable object, %NULL to ignore.
		 * @returns a newly allocated
		 *      #GObject, or %NULL on error
		 */
		public static newv(object_type: GObject.Type, parameters: GObject.Parameter[], cancellable?: Cancellable | null): GObject.Object;
	}



	/** This construct is only for enabling class multi-inheritance,
	 * use {@link ListModel} instead.
	 */
	interface IListModel {
		/**
		 * Get the item at #position. If #position is greater than the number of
		 * items in #list, %NULL is returned.
		 * 
		 * %NULL is never returned for an index that is smaller than the length
		 * of the list.  See {@link G.list_model_get_n_items}.
		 * @param position the position of the item to fetch
		 * @returns the object at #position.
		 */
		get_item(position: number): GObject.Object | null;
		/**
		 * Gets the type of the items in #list. All items returned from
		 * {@link G.list_model_get_type} are of that type or a subtype, or are an
		 * implementation of that interface.
		 * 
		 * The item type of a #GListModel can not change during the life of the
		 * model.
		 * @returns the #GType of the items contained in #list.
		 */
		get_item_type(): GObject.Type;
		/**
		 * Gets the number of items in #list.
		 * 
		 * Depending on the model implementation, calling this function may be
		 * less efficient than iterating the list with increasing values for
		 * #position until {@link G.list_model_get_item} returns %NULL.
		 * @returns the number of items in #list.
		 */
		get_n_items(): number;
		/**
		 * Emits the #GListModel::items-changed signal on #list.
		 * 
		 * This function should only be called by classes implementing
		 * #GListModel. It has to be called after the internal representation
		 * of #list has been updated, because handlers connected to this signal
		 * might query the new state of the list.
		 * 
		 * Implementations must only make changes to the model (as visible to
		 * its consumer) in places that will not cause problems for that
		 * consumer.  For models that are driven directly by a write API (such
		 * as #GListStore), changes can be reported in response to uses of that
		 * API.  For models that represent remote data, changes should only be
		 * made from a fresh mainloop dispatch.  It is particularly not
		 * permitted to make changes in response to a call to the #GListModel
		 * consumer API.
		 * 
		 * Stated another way: in general, it is assumed that code making a
		 * series of accesses to the model via the API, without returning to the
		 * mainloop, and without calling other code, will continue to view the
		 * same contents of the model.
		 * @param position the position at which #list changed
		 * @param removed the number of items removed
		 * @param added the number of items added
		 */
		items_changed(position: number, removed: number, added: number): void;
		/**
		 * This signal is emitted whenever items were added to or removed
		 * from #list. At #position, #removed items were removed and #added
		 * items were added in their place.
		 * 
		 * Note: If #removed != #added, the positions of all later items
		 * in the model change.
		 * @param signal 
		 * @param callback Callback function
		 *  - owner: owner of the emitted event 
		 *  - position: the position at which #list changed 
		 *  - removed: the number of items removed 
		 *  - added: the number of items added 
		 * 
		 * @returns Callback ID
		 */
		connect(signal: "items-changed", callback: (owner: this, position: number, removed: number, added: number) => void): number;

	}

	type ListModelInitOptionsMixin  = {};
	export interface ListModelInitOptions extends ListModelInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link ListModel} instead.
	 */
	type ListModelMixin = IListModel;

	/**
	 * #GListModel is an interface that represents a mutable list of
	 * #GObjects. Its main intention is as a model for various widgets in
	 * user interfaces, such as list views, but it can also be used as a
	 * convenient method of returning lists of data, with support for
	 * updates.
	 * 
	 * Each object in the list may also report changes in itself via some
	 * mechanism (normally the #GObject::notify signal).  Taken together
	 * with the #GListModel::items-changed signal, this provides for a list
	 * that can change its membership, and in which the members can change
	 * their individual properties.
	 * 
	 * A good example would be the list of visible wireless network access
	 * points, where each access point can report dynamic properties such as
	 * signal strength.
	 * 
	 * It is important to note that the #GListModel itself does not report
	 * changes to the individual items.  It only reports changes to the list
	 * membership.  If you want to observe changes to the objects themselves
	 * then you need to connect signals to the objects that you are
	 * interested in.
	 * 
	 * All items in a #GListModel are of (or derived from) the same type.
	 * {@link G.list_model_get_item_type} returns that type.  The type may be an
	 * interface, in which case all objects in the list must implement it.
	 * 
	 * The semantics are close to that of an array:
	 * g_list_model_get_n_items() returns the number of items in the list and
	 * g_list_model_get_item() returns an item at a (0-based) position. In
	 * order to allow implementations to calculate the list length lazily,
	 * you can also iterate over items: starting from 0, repeatedly call
	 * g_list_model_get_item() until it returns %NULL.
	 * 
	 * An implementation may create objects lazily, but must take care to
	 * return the same object for a given position until all references to
	 * it are gone.
	 * 
	 * On the other side, a consumer is expected only to hold references on
	 * objects that are currently "user visible", in order to facilitate the
	 * maximum level of laziness in the implementation of the list and to
	 * reduce the required number of signal connections at a given time.
	 * 
	 * This interface is intended only to be used from a single thread.  The
	 * thread in which it is appropriate to use it depends on the particular
	 * implementation, but typically it will be from the thread that owns
	 * the [thread-default main context][g-main-context-push-thread-default]
	 * in effect at the time that the model was created.
	 */
	interface ListModel extends ListModelMixin {}

	class ListModel {
		public constructor(options?: Partial<ListModelInitOptions>);
	}



	/** This construct is only for enabling class multi-inheritance,
	 * use {@link LoadableIcon} instead.
	 */
	interface ILoadableIcon {
		/**
		 * Loads a loadable icon. For the asynchronous version of this function,
		 * see {@link G.loadable_icon_load_async}.
		 * @param size an integer.
		 * @param cancellable optional #GCancellable object, %NULL to
		 * ignore.
		 * @returns a #GInputStream to read the icon from.
		 * 
		 * a location to store the type of the loaded
		 * icon, %NULL to ignore.
		 */
		load(size: number, cancellable?: Cancellable | null): [ InputStream, string | null ];
		/**
		 * Loads an icon asynchronously. To finish this function, see
		 * {@link G.loadable_icon_load_finish}. For the synchronous, blocking
		 * version of this function, see g_loadable_icon_load().
		 * @param size an integer.
		 * @param cancellable optional #GCancellable object, %NULL to ignore.
		 * @param callback a #GAsyncReadyCallback to call when the
		 *            request is satisfied
		 */
		load_async(size: number, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;
		/**
		 * Finishes an asynchronous icon load started in {@link G.loadable_icon_load_async}.
		 * @param res a #GAsyncResult.
		 * @returns a #GInputStream to read the icon from.
		 * 
		 * a location to store the type of the loaded
		 *        icon, %NULL to ignore.
		 */
		load_finish(res: AsyncResult): [ InputStream, string | null ];
	}

	type LoadableIconInitOptionsMixin  = {};
	export interface LoadableIconInitOptions extends LoadableIconInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link LoadableIcon} instead.
	 */
	type LoadableIconMixin = ILoadableIcon;

	/**
	 * Extends the #GIcon interface and adds the ability to
	 * load icons from streams.
	 */
	interface LoadableIcon extends LoadableIconMixin {}

	class LoadableIcon {
		public constructor(options?: Partial<LoadableIconInitOptions>);
	}



	/** This construct is only for enabling class multi-inheritance,
	 * use {@link MemoryMonitor} instead.
	 */
	interface IMemoryMonitor {

		/**
		 * Emitted when the system is running low on free memory. The signal
		 * handler should then take the appropriate action depending on the
		 * warning level. See the #GMemoryMonitorWarningLevel documentation for
		 * details.
		 * @param signal 
		 * @param callback Callback function
		 *  - owner: owner of the emitted event 
		 *  - level: the #GMemoryMonitorWarningLevel warning level 
		 * 
		 * @returns Callback ID
		 */
		connect(signal: "low-memory-warning", callback: (owner: this, level: MemoryMonitorWarningLevel) => void): number;

	}

	type MemoryMonitorInitOptionsMixin  = {};
	export interface MemoryMonitorInitOptions extends MemoryMonitorInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link MemoryMonitor} instead.
	 */
	type MemoryMonitorMixin = IMemoryMonitor;

	/**
	 * #GMemoryMonitor will monitor system memory and suggest to the application
	 * when to free memory so as to leave more room for other applications.
	 * It is implemented on Linux using the [Low Memory Monitor](https://gitlab.freedesktop.org/hadess/low-memory-monitor/)
	 * ([API documentation](https://hadess.pages.freedesktop.org/low-memory-monitor/)).
	 * 
	 * There is also an implementation for use inside Flatpak sandboxes.
	 * 
	 * Possible actions to take when the signal is received are:
	 * 
	 *  - Free caches
	 *  - Save files that haven't been looked at in a while to disk, ready to be reopened when needed
	 *  - Run a garbage collection cycle
	 *  - Try and compress fragmented allocations
	 *  - Exit on idle if the process has no reason to stay around
	 *  - Call [`malloc_trim(3)`](man:malloc_trim) to return cached heap pages to
	 *    the kernel (if supported by your libc)
	 * 
	 * Note that some actions may not always improve system performance, and so
	 * should be profiled for your application. {@link `malloc.trim}`, for example, may
	 * make future heap allocations slower (due to releasing cached heap pages back
	 * to the kernel).
	 * 
	 * See #GMemoryMonitorWarningLevel for details on the various warning levels.
	 * 
	 * |[<!-- language="C" -->
	 * static void
	 * warning_cb (GMemoryMonitor *m, GMemoryMonitorWarningLevel level)
	 * {
	 *   g_debug ("Warning level: %d", level);
	 *   if (warning_level > G_MEMORY_MONITOR_WARNING_LEVEL_LOW)
	 *     drop_caches ();
	 * }
	 * 
	 * static GMemoryMonitor *
	 * monitor_low_memory (void)
	 * {
	 *   GMemoryMonitor *m;
	 *   m = g_memory_monitor_dup_default ();
	 *   g_signal_connect (G_OBJECT (m), "low-memory-warning",
	 *                     G_CALLBACK (warning_cb), NULL);
	 *   return m;
	 * }
	 * ]|
	 * 
	 * Don't forget to disconnect the #GMemoryMonitor::low-memory-warning
	 * signal, and unref the #GMemoryMonitor itself when exiting.
	 */
	interface MemoryMonitor extends MemoryMonitorMixin {}

	class MemoryMonitor {
		public constructor(options?: Partial<MemoryMonitorInitOptions>);
		/**
		 * Gets a reference to the default #GMemoryMonitor for the system.
		 * @returns a new reference to the default #GMemoryMonitor
		 */
		public static dup_default(): MemoryMonitor;
	}



	/** This construct is only for enabling class multi-inheritance,
	 * use {@link Mount} instead.
	 */
	interface IMount {
		/**
		 * Checks if #mount can be ejected.
		 * @returns %TRUE if the #mount can be ejected.
		 */
		can_eject(): boolean;
		/**
		 * Checks if #mount can be unmounted.
		 * @returns %TRUE if the #mount can be unmounted.
		 */
		can_unmount(): boolean;
		/**
		 * @deprecated
		 * Use {@link G.mount_eject_with_operation} instead.
		 * 
		 * Ejects a mount. This is an asynchronous operation, and is
		 * finished by calling {@link G.mount_eject_finish} with the #mount
		 * and #GAsyncResult data returned in the #callback.
		 * @param flags flags affecting the unmount if required for eject
		 * @param cancellable optional #GCancellable object, %NULL to ignore.
		 * @param callback a #GAsyncReadyCallback, or %NULL.
		 */
		eject(flags: MountUnmountFlags, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;
		/**
		 * @deprecated
		 * Use {@link G.mount_eject_with_operation_finish} instead.
		 * 
		 * Finishes ejecting a mount. If any errors occurred during the operation,
		 * #error will be set to contain the errors and %FALSE will be returned.
		 * @param result a #GAsyncResult.
		 * @returns %TRUE if the mount was successfully ejected. %FALSE otherwise.
		 */
		eject_finish(result: AsyncResult): boolean;
		/**
		 * Ejects a mount. This is an asynchronous operation, and is
		 * finished by calling {@link G.mount_eject_with_operation_finish} with the #mount
		 * and #GAsyncResult data returned in the #callback.
		 * @param flags flags affecting the unmount if required for eject
		 * @param mount_operation a #GMountOperation or %NULL to avoid
		 *     user interaction.
		 * @param cancellable optional #GCancellable object, %NULL to ignore.
		 * @param callback a #GAsyncReadyCallback, or %NULL.
		 */
		eject_with_operation(flags: MountUnmountFlags, mount_operation?: MountOperation | null, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;
		/**
		 * Finishes ejecting a mount. If any errors occurred during the operation,
		 * #error will be set to contain the errors and %FALSE will be returned.
		 * @param result a #GAsyncResult.
		 * @returns %TRUE if the mount was successfully ejected. %FALSE otherwise.
		 */
		eject_with_operation_finish(result: AsyncResult): boolean;
		/**
		 * Gets the default location of #mount. The default location of the given
		 * #mount is a path that reflects the main entry point for the user (e.g.
		 * the home directory, or the root of the volume).
		 * @returns a #GFile.
		 *      The returned object should be unreffed with
		 *      {@link GObject.unref} when no longer needed.
		 */
		get_default_location(): File;
		/**
		 * Gets the drive for the #mount.
		 * 
		 * This is a convenience method for getting the #GVolume and then
		 * using that object to get the #GDrive.
		 * @returns a #GDrive or %NULL if #mount is not
		 *      associated with a volume or a drive.
		 *      The returned object should be unreffed with
		 *      {@link GObject.unref} when no longer needed.
		 */
		get_drive(): Drive | null;
		/**
		 * Gets the icon for #mount.
		 * @returns a #GIcon.
		 *      The returned object should be unreffed with
		 *      {@link GObject.unref} when no longer needed.
		 */
		get_icon(): Icon;
		/**
		 * Gets the name of #mount.
		 * @returns the name for the given #mount.
		 *     The returned string should be freed with {@link G.free}
		 *     when no longer needed.
		 */
		get_name(): string;
		/**
		 * Gets the root directory on #mount.
		 * @returns a #GFile.
		 *      The returned object should be unreffed with
		 *      {@link GObject.unref} when no longer needed.
		 */
		get_root(): File;
		/**
		 * Gets the sort key for #mount, if any.
		 * @returns Sorting key for #mount or %NULL if no such key is available.
		 */
		get_sort_key(): string | null;
		/**
		 * Gets the symbolic icon for #mount.
		 * @returns a #GIcon.
		 *      The returned object should be unreffed with
		 *      {@link GObject.unref} when no longer needed.
		 */
		get_symbolic_icon(): Icon;
		/**
		 * Gets the UUID for the #mount. The reference is typically based on
		 * the file system UUID for the mount in question and should be
		 * considered an opaque string. Returns %NULL if there is no UUID
		 * available.
		 * @returns the UUID for #mount or %NULL if no UUID
		 *     can be computed.
		 *     The returned string should be freed with {@link G.free}
		 *     when no longer needed.
		 */
		get_uuid(): string | null;
		/**
		 * Gets the volume for the #mount.
		 * @returns a #GVolume or %NULL if #mount is not
		 *      associated with a volume.
		 *      The returned object should be unreffed with
		 *      {@link GObject.unref} when no longer needed.
		 */
		get_volume(): Volume | null;
		/**
		 * Tries to guess the type of content stored on #mount. Returns one or
		 * more textual identifiers of well-known content types (typically
		 * prefixed with "x-content/"), e.g. x-content/image-dcf for camera
		 * memory cards. See the
		 * [shared-mime-info](http://www.freedesktop.org/wiki/Specifications/shared-mime-info-spec)
		 * specification for more on x-content types.
		 * 
		 * This is an asynchronous operation (see
		 * {@link G.mount_guess_content_type_sync} for the synchronous version), and
		 * is finished by calling g_mount_guess_content_type_finish() with the
		 * #mount and #GAsyncResult data returned in the #callback.
		 * @param force_rescan Whether to force a rescan of the content.
		 *     Otherwise a cached result will be used if available
		 * @param cancellable optional #GCancellable object, %NULL to ignore
		 * @param callback a #GAsyncReadyCallback
		 */
		guess_content_type(force_rescan: boolean, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;
		/**
		 * Finishes guessing content types of #mount. If any errors occurred
		 * during the operation, #error will be set to contain the errors and
		 * %FALSE will be returned. In particular, you may get an
		 * %G_IO_ERROR_NOT_SUPPORTED if the mount does not support content
		 * guessing.
		 * @param result a #GAsyncResult
		 * @returns a %NULL-terminated array of content types or %NULL on error.
		 *     Caller should free this array with {@link G.strfreev} when done with it.
		 */
		guess_content_type_finish(result: AsyncResult): string[];
		/**
		 * Tries to guess the type of content stored on #mount. Returns one or
		 * more textual identifiers of well-known content types (typically
		 * prefixed with "x-content/"), e.g. x-content/image-dcf for camera
		 * memory cards. See the
		 * [shared-mime-info](http://www.freedesktop.org/wiki/Specifications/shared-mime-info-spec)
		 * specification for more on x-content types.
		 * 
		 * This is a synchronous operation and as such may block doing IO;
		 * see {@link G.mount_guess_content_type} for the asynchronous version.
		 * @param force_rescan Whether to force a rescan of the content.
		 *     Otherwise a cached result will be used if available
		 * @param cancellable optional #GCancellable object, %NULL to ignore
		 * @returns a %NULL-terminated array of content types or %NULL on error.
		 *     Caller should free this array with {@link G.strfreev} when done with it.
		 */
		guess_content_type_sync(force_rescan: boolean, cancellable?: Cancellable | null): string[];
		/**
		 * Determines if #mount is shadowed. Applications or libraries should
		 * avoid displaying #mount in the user interface if it is shadowed.
		 * 
		 * A mount is said to be shadowed if there exists one or more user
		 * visible objects (currently #GMount objects) with a root that is
		 * inside the root of #mount.
		 * 
		 * One application of shadow mounts is when exposing a single file
		 * system that is used to address several logical volumes. In this
		 * situation, a #GVolumeMonitor implementation would create two
		 * #GVolume objects (for example, one for the camera functionality of
		 * the device and one for a SD card reader on the device) with
		 * activation URIs `gphoto2://[usb:001,002]/store1/`
		 * and `gphoto2://[usb:001,002]/store2/`. When the
		 * underlying mount (with root
		 * `gphoto2://[usb:001,002]/`) is mounted, said
		 * #GVolumeMonitor implementation would create two #GMount objects
		 * (each with their root matching the corresponding volume activation
		 * root) that would shadow the original mount.
		 * 
		 * The proxy monitor in GVfs 2.26 and later, automatically creates and
		 * manage shadow mounts (and shadows the underlying mount) if the
		 * activation root on a #GVolume is set.
		 * @returns %TRUE if #mount is shadowed.
		 */
		is_shadowed(): boolean;
		/**
		 * Remounts a mount. This is an asynchronous operation, and is
		 * finished by calling {@link G.mount_remount_finish} with the #mount
		 * and #GAsyncResults data returned in the #callback.
		 * 
		 * Remounting is useful when some setting affecting the operation
		 * of the volume has been changed, as these may need a remount to
		 * take affect. While this is semantically equivalent with unmounting
		 * and then remounting not all backends might need to actually be
		 * unmounted.
		 * @param flags flags affecting the operation
		 * @param mount_operation a #GMountOperation or %NULL to avoid
		 *     user interaction.
		 * @param cancellable optional #GCancellable object, %NULL to ignore.
		 * @param callback a #GAsyncReadyCallback, or %NULL.
		 */
		remount(flags: MountMountFlags, mount_operation?: MountOperation | null, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;
		/**
		 * Finishes remounting a mount. If any errors occurred during the operation,
		 * #error will be set to contain the errors and %FALSE will be returned.
		 * @param result a #GAsyncResult.
		 * @returns %TRUE if the mount was successfully remounted. %FALSE otherwise.
		 */
		remount_finish(result: AsyncResult): boolean;
		/**
		 * Increments the shadow count on #mount. Usually used by
		 * #GVolumeMonitor implementations when creating a shadow mount for
		 * #mount, see {@link G.mount_is_shadowed} for more information. The caller
		 * will need to emit the #GMount::changed signal on #mount manually.
		 */
		shadow(): void;
		/**
		 * @deprecated
		 * Use {@link G.mount_unmount_with_operation} instead.
		 * 
		 * Unmounts a mount. This is an asynchronous operation, and is
		 * finished by calling {@link G.mount_unmount_finish} with the #mount
		 * and #GAsyncResult data returned in the #callback.
		 * @param flags flags affecting the operation
		 * @param cancellable optional #GCancellable object, %NULL to ignore.
		 * @param callback a #GAsyncReadyCallback, or %NULL.
		 */
		unmount(flags: MountUnmountFlags, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;
		/**
		 * @deprecated
		 * Use {@link G.mount_unmount_with_operation_finish} instead.
		 * 
		 * Finishes unmounting a mount. If any errors occurred during the operation,
		 * #error will be set to contain the errors and %FALSE will be returned.
		 * @param result a #GAsyncResult.
		 * @returns %TRUE if the mount was successfully unmounted. %FALSE otherwise.
		 */
		unmount_finish(result: AsyncResult): boolean;
		/**
		 * Unmounts a mount. This is an asynchronous operation, and is
		 * finished by calling {@link G.mount_unmount_with_operation_finish} with the #mount
		 * and #GAsyncResult data returned in the #callback.
		 * @param flags flags affecting the operation
		 * @param mount_operation a #GMountOperation or %NULL to avoid
		 *     user interaction.
		 * @param cancellable optional #GCancellable object, %NULL to ignore.
		 * @param callback a #GAsyncReadyCallback, or %NULL.
		 */
		unmount_with_operation(flags: MountUnmountFlags, mount_operation?: MountOperation | null, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;
		/**
		 * Finishes unmounting a mount. If any errors occurred during the operation,
		 * #error will be set to contain the errors and %FALSE will be returned.
		 * @param result a #GAsyncResult.
		 * @returns %TRUE if the mount was successfully unmounted. %FALSE otherwise.
		 */
		unmount_with_operation_finish(result: AsyncResult): boolean;
		/**
		 * Decrements the shadow count on #mount. Usually used by
		 * #GVolumeMonitor implementations when destroying a shadow mount for
		 * #mount, see {@link G.mount_is_shadowed} for more information. The caller
		 * will need to emit the #GMount::changed signal on #mount manually.
		 */
		unshadow(): void;
		/**
		 * Emitted when the mount has been changed.
		 * @param signal 
		 * @param callback Callback function
		 *  - owner: owner of the emitted event 
		 * 
		 * @returns Callback ID
		 */
		connect(signal: "changed", callback: (owner: this) => void): number;
		/**
		 * This signal may be emitted when the #GMount is about to be
		 * unmounted.
		 * 
		 * This signal depends on the backend and is only emitted if
		 * GIO was used to unmount.
		 * @param signal 
		 * @param callback Callback function
		 *  - owner: owner of the emitted event 
		 * 
		 * @returns Callback ID
		 */
		connect(signal: "pre-unmount", callback: (owner: this) => void): number;
		/**
		 * This signal is emitted when the #GMount have been
		 * unmounted. If the recipient is holding references to the
		 * object they should release them so the object can be
		 * finalized.
		 * @param signal 
		 * @param callback Callback function
		 *  - owner: owner of the emitted event 
		 * 
		 * @returns Callback ID
		 */
		connect(signal: "unmounted", callback: (owner: this) => void): number;

	}

	type MountInitOptionsMixin  = {};
	export interface MountInitOptions extends MountInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link Mount} instead.
	 */
	type MountMixin = IMount;

	/**
	 * The #GMount interface represents user-visible mounts. Note, when
	 * porting from GnomeVFS, #GMount is the moral equivalent of #GnomeVFSVolume.
	 * 
	 * #GMount is a "mounted" filesystem that you can access. Mounted is in
	 * quotes because it's not the same as a unix mount, it might be a gvfs
	 * mount, but you can still access the files on it if you use GIO. Might or
	 * might not be related to a volume object.
	 * 
	 * Unmounting a #GMount instance is an asynchronous operation. For
	 * more information about asynchronous operations, see #GAsyncResult
	 * and #GTask. To unmount a #GMount instance, first call
	 * {@link G.mount_unmount_with_operation} with (at least) the #GMount instance and a
	 * #GAsyncReadyCallback.  The callback will be fired when the
	 * operation has resolved (either with success or failure), and a
	 * #GAsyncResult structure will be passed to the callback.  That
	 * callback should then call g_mount_unmount_with_operation_finish() with the #GMount
	 * and the #GAsyncResult data to see if the operation was completed
	 * successfully.  If an #error is present when g_mount_unmount_with_operation_finish()
	 * is called, then it will be filled with any error information.
	 */
	interface Mount extends MountMixin {}

	class Mount {
		public constructor(options?: Partial<MountInitOptions>);
	}



	/** This construct is only for enabling class multi-inheritance,
	 * use {@link NetworkMonitor} instead.
	 */
	interface INetworkMonitor {
		/**
		 * More detailed information about the host's network connectivity.
		 * See {@link G.network_monitor_get_connectivity} and
		 * #GNetworkConnectivity for more details.
		 */
		readonly connectivity: NetworkConnectivity;
		/**
		 * Whether the network is considered available. That is, whether the
		 * system has a default route for at least one of IPv4 or IPv6.
		 * 
		 * Real-world networks are of course much more complicated than
		 * this; the machine may be connected to a wifi hotspot that
		 * requires payment before allowing traffic through, or may be
		 * connected to a functioning router that has lost its own upstream
		 * connectivity. Some hosts might only be accessible when a VPN is
		 * active. Other hosts might only be accessible when the VPN is
		 * not active. Thus, it is best to use {@link G.network_monitor_can_reach}
		 * or g_network_monitor_can_reach_async() to test for reachability
		 * on a host-by-host basis. (On the other hand, when the property is
		 * %FALSE, the application can reasonably expect that no remote
		 * hosts at all are reachable, and should indicate this to the user
		 * in its UI.)
		 * 
		 * See also #GNetworkMonitor::network-changed.
		 */
		readonly network_available: boolean;
		/**
		 * Whether the network is considered metered. That is, whether the
		 * system has traffic flowing through the default connection that is
		 * subject to limitations set by service providers. For example, traffic
		 * might be billed by the amount of data transmitted, or there might be a
		 * quota on the amount of traffic per month. This is typical with tethered
		 * connections (3G and 4G) and in such situations, bandwidth intensive
		 * applications may wish to avoid network activity where possible if it will
		 * cost the user money or use up their limited quota.
		 * 
		 * If more information is required about specific devices then the
		 * system network management API should be used instead (for example,
		 * NetworkManager or ConnMan).
		 * 
		 * If this information is not available then no networks will be
		 * marked as metered.
		 * 
		 * See also #GNetworkMonitor:network-available.
		 */
		readonly network_metered: boolean;
		/**
		 * Attempts to determine whether or not the host pointed to by
		 * #connectable can be reached, without actually trying to connect to
		 * it.
		 * 
		 * This may return %TRUE even when #GNetworkMonitor:network-available
		 * is %FALSE, if, for example, #monitor can determine that
		 * #connectable refers to a host on a local network.
		 * 
		 * If #monitor believes that an attempt to connect to #connectable
		 * will succeed, it will return %TRUE. Otherwise, it will return
		 * %FALSE and set #error to an appropriate error (such as
		 * %G_IO_ERROR_HOST_UNREACHABLE).
		 * 
		 * Note that although this does not attempt to connect to
		 * #connectable, it may still block for a brief period of time (eg,
		 * trying to do multicast DNS on the local network), so if you do not
		 * want to block, you should use {@link G.network_monitor_can_reach_async}.
		 * @param connectable a #GSocketConnectable
		 * @param cancellable a #GCancellable, or %NULL
		 * @returns %TRUE if #connectable is reachable, %FALSE if not.
		 */
		can_reach(connectable: SocketConnectable, cancellable?: Cancellable | null): boolean;
		/**
		 * Asynchronously attempts to determine whether or not the host
		 * pointed to by #connectable can be reached, without actually
		 * trying to connect to it.
		 * 
		 * For more details, see {@link G.network_monitor_can_reach}.
		 * 
		 * When the operation is finished, #callback will be called.
		 * You can then call g_network_monitor_can_reach_finish()
		 * to get the result of the operation.
		 * @param connectable a #GSocketConnectable
		 * @param cancellable a #GCancellable, or %NULL
		 * @param callback a #GAsyncReadyCallback to call when the
		 *     request is satisfied
		 */
		can_reach_async(connectable: SocketConnectable, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;
		/**
		 * Finishes an async network connectivity test.
		 * See {@link G.network_monitor_can_reach_async}.
		 * @param result a #GAsyncResult
		 * @returns %TRUE if network is reachable, %FALSE if not.
		 */
		can_reach_finish(result: AsyncResult): boolean;
		/**
		 * Gets a more detailed networking state than
		 * {@link G.network_monitor_get_network_available}.
		 * 
		 * If #GNetworkMonitor:network-available is %FALSE, then the
		 * connectivity state will be %G_NETWORK_CONNECTIVITY_LOCAL.
		 * 
		 * If #GNetworkMonitor:network-available is %TRUE, then the
		 * connectivity state will be %G_NETWORK_CONNECTIVITY_FULL (if there
		 * is full Internet connectivity), %G_NETWORK_CONNECTIVITY_LIMITED (if
		 * the host has a default route, but appears to be unable to actually
		 * reach the full Internet), or %G_NETWORK_CONNECTIVITY_PORTAL (if the
		 * host is trapped behind a "captive portal" that requires some sort
		 * of login or acknowledgement before allowing full Internet access).
		 * 
		 * Note that in the case of %G_NETWORK_CONNECTIVITY_LIMITED and
		 * %G_NETWORK_CONNECTIVITY_PORTAL, it is possible that some sites are
		 * reachable but others are not. In this case, applications can
		 * attempt to connect to remote servers, but should gracefully fall
		 * back to their "offline" behavior if the connection attempt fails.
		 * @returns the network connectivity state
		 */
		get_connectivity(): NetworkConnectivity;
		/**
		 * Checks if the network is available. "Available" here means that the
		 * system has a default route available for at least one of IPv4 or
		 * IPv6. It does not necessarily imply that the public Internet is
		 * reachable. See #GNetworkMonitor:network-available for more details.
		 * @returns whether the network is available
		 */
		get_network_available(): boolean;
		/**
		 * Checks if the network is metered.
		 * See #GNetworkMonitor:network-metered for more details.
		 * @returns whether the connection is metered
		 */
		get_network_metered(): boolean;
		/**
		 * Emitted when the network configuration changes.
		 * @param signal 
		 * @param callback Callback function
		 *  - owner: owner of the emitted event 
		 *  - network_available: the current value of #GNetworkMonitor:network-available 
		 * 
		 * @returns Callback ID
		 */
		connect(signal: "network-changed", callback: (owner: this, network_available: boolean) => void): number;

		connect(signal: "notify::connectivity", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::network-available", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::network-metered", callback: (owner: this, ...args: any) => void): number;

	}

	type NetworkMonitorInitOptionsMixin  = {};
	export interface NetworkMonitorInitOptions extends NetworkMonitorInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link NetworkMonitor} instead.
	 */
	type NetworkMonitorMixin = INetworkMonitor;

	/**
	 * #GNetworkMonitor provides an easy-to-use cross-platform API
	 * for monitoring network connectivity. On Linux, the available
	 * implementations are based on the kernel's netlink interface and
	 * on NetworkManager.
	 * 
	 * There is also an implementation for use inside Flatpak sandboxes.
	 */
	interface NetworkMonitor extends NetworkMonitorMixin {}

	class NetworkMonitor {
		public constructor(options?: Partial<NetworkMonitorInitOptions>);
		/**
		 * Gets the default #GNetworkMonitor for the system.
		 * @returns a #GNetworkMonitor, which will be
		 *     a dummy object if no network monitor is available
		 */
		public static get_default(): NetworkMonitor;
	}



	/** This construct is only for enabling class multi-inheritance,
	 * use {@link PollableInputStream} instead.
	 */
	interface IPollableInputStream {
		/**
		 * Checks if #stream is actually pollable. Some classes may implement
		 * #GPollableInputStream but have only certain instances of that class
		 * be pollable. If this method returns %FALSE, then the behavior of
		 * other #GPollableInputStream methods is undefined.
		 * 
		 * For any given stream, the value returned by this method is constant;
		 * a stream cannot switch from pollable to non-pollable or vice versa.
		 * @returns %TRUE if #stream is pollable, %FALSE if not.
		 */
		can_poll(): boolean;
		/**
		 * Creates a #GSource that triggers when #stream can be read, or
		 * #cancellable is triggered or an error occurs. The callback on the
		 * source is of the #GPollableSourceFunc type.
		 * 
		 * As with {@link G.pollable_input_stream_is_readable}, it is possible that
		 * the stream may not actually be readable even after the source
		 * triggers, so you should use g_pollable_input_stream_read_nonblocking()
		 * rather than g_input_stream_read() from the callback.
		 * @param cancellable a #GCancellable, or %NULL
		 * @returns a new #GSource
		 */
		create_source(cancellable?: Cancellable | null): GLib.Source;
		/**
		 * Checks if #stream can be read.
		 * 
		 * Note that some stream types may not be able to implement this 100%
		 * reliably, and it is possible that a call to {@link G.input_stream_read}
		 * after this returns %TRUE would still block. To guarantee
		 * non-blocking behavior, you should always use
		 * g_pollable_input_stream_read_nonblocking(), which will return a
		 * %G_IO_ERROR_WOULD_BLOCK error rather than blocking.
		 * @returns %TRUE if #stream is readable, %FALSE if not. If an error
		 *   has occurred on #stream, this will result in
		 *   {@link G.pollable_input_stream_is_readable} returning %TRUE, and the
		 *   next attempt to read will return the error.
		 */
		is_readable(): boolean;
		/**
		 * Attempts to read up to #count bytes from #stream into #buffer, as
		 * with {@link G.input_stream_read}. If #stream is not currently readable,
		 * this will immediately return %G_IO_ERROR_WOULD_BLOCK, and you can
		 * use g_pollable_input_stream_create_source() to create a #GSource
		 * that will be triggered when #stream is readable.
		 * 
		 * Note that since this method never blocks, you cannot actually
		 * use #cancellable to cancel it. However, it will return an error
		 * if #cancellable has already been cancelled when you call, which
		 * may happen if you call this method after a source triggers due
		 * to having been cancelled.
		 * @param cancellable a #GCancellable, or %NULL
		 * @returns the number of bytes read, or -1 on error (including
		 *   %G_IO_ERROR_WOULD_BLOCK).
		 * 
		 * a
		 *     buffer to read data into (which should be at least #count bytes long).
		 */
		read_nonblocking(cancellable?: Cancellable | null): [ number, number[] ];
	}

	type PollableInputStreamInitOptionsMixin  = {};
	export interface PollableInputStreamInitOptions extends PollableInputStreamInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link PollableInputStream} instead.
	 */
	type PollableInputStreamMixin = IPollableInputStream;

	/**
	 * #GPollableInputStream is implemented by #GInputStreams that
	 * can be polled for readiness to read. This can be used when
	 * interfacing with a non-GIO API that expects
	 * UNIX-file-descriptor-style asynchronous I/O rather than GIO-style.
	 */
	interface PollableInputStream extends PollableInputStreamMixin {}

	class PollableInputStream {
		public constructor(options?: Partial<PollableInputStreamInitOptions>);
	}



	/** This construct is only for enabling class multi-inheritance,
	 * use {@link PollableOutputStream} instead.
	 */
	interface IPollableOutputStream {
		/**
		 * Checks if #stream is actually pollable. Some classes may implement
		 * #GPollableOutputStream but have only certain instances of that
		 * class be pollable. If this method returns %FALSE, then the behavior
		 * of other #GPollableOutputStream methods is undefined.
		 * 
		 * For any given stream, the value returned by this method is constant;
		 * a stream cannot switch from pollable to non-pollable or vice versa.
		 * @returns %TRUE if #stream is pollable, %FALSE if not.
		 */
		can_poll(): boolean;
		/**
		 * Creates a #GSource that triggers when #stream can be written, or
		 * #cancellable is triggered or an error occurs. The callback on the
		 * source is of the #GPollableSourceFunc type.
		 * 
		 * As with {@link G.pollable_output_stream_is_writable}, it is possible that
		 * the stream may not actually be writable even after the source
		 * triggers, so you should use g_pollable_output_stream_write_nonblocking()
		 * rather than g_output_stream_write() from the callback.
		 * @param cancellable a #GCancellable, or %NULL
		 * @returns a new #GSource
		 */
		create_source(cancellable?: Cancellable | null): GLib.Source;
		/**
		 * Checks if #stream can be written.
		 * 
		 * Note that some stream types may not be able to implement this 100%
		 * reliably, and it is possible that a call to {@link G.output_stream_write}
		 * after this returns %TRUE would still block. To guarantee
		 * non-blocking behavior, you should always use
		 * g_pollable_output_stream_write_nonblocking(), which will return a
		 * %G_IO_ERROR_WOULD_BLOCK error rather than blocking.
		 * @returns %TRUE if #stream is writable, %FALSE if not. If an error
		 *   has occurred on #stream, this will result in
		 *   {@link G.pollable_output_stream_is_writable} returning %TRUE, and the
		 *   next attempt to write will return the error.
		 */
		is_writable(): boolean;
		/**
		 * Attempts to write up to #count bytes from #buffer to #stream, as
		 * with {@link G.output_stream_write}. If #stream is not currently writable,
		 * this will immediately return %G_IO_ERROR_WOULD_BLOCK, and you can
		 * use g_pollable_output_stream_create_source() to create a #GSource
		 * that will be triggered when #stream is writable.
		 * 
		 * Note that since this method never blocks, you cannot actually
		 * use #cancellable to cancel it. However, it will return an error
		 * if #cancellable has already been cancelled when you call, which
		 * may happen if you call this method after a source triggers due
		 * to having been cancelled.
		 * 
		 * Also note that if %G_IO_ERROR_WOULD_BLOCK is returned some underlying
		 * transports like D/TLS require that you re-send the same #buffer and
		 * #count in the next write call.
		 * @param buffer a buffer to write
		 *     data from
		 * @param cancellable a #GCancellable, or %NULL
		 * @returns the number of bytes written, or -1 on error (including
		 *   %G_IO_ERROR_WOULD_BLOCK).
		 */
		write_nonblocking(buffer: number[], cancellable?: Cancellable | null): number;
		/**
		 * Attempts to write the bytes contained in the #n_vectors #vectors to #stream,
		 * as with {@link G.output_stream_writev}. If #stream is not currently writable,
		 * this will immediately return %#G_POLLABLE_RETURN_WOULD_BLOCK, and you can
		 * use g_pollable_output_stream_create_source() to create a #GSource
		 * that will be triggered when #stream is writable. #error will *not* be
		 * set in that case.
		 * 
		 * Note that since this method never blocks, you cannot actually
		 * use #cancellable to cancel it. However, it will return an error
		 * if #cancellable has already been cancelled when you call, which
		 * may happen if you call this method after a source triggers due
		 * to having been cancelled.
		 * 
		 * Also note that if %G_POLLABLE_RETURN_WOULD_BLOCK is returned some underlying
		 * transports like D/TLS require that you re-send the same #vectors and
		 * #n_vectors in the next write call.
		 * @param vectors the buffer containing the #GOutputVectors to write.
		 * @param cancellable a #GCancellable, or %NULL
		 * @returns %#G_POLLABLE_RETURN_OK on success, %G_POLLABLE_RETURN_WOULD_BLOCK
		 * if the stream is not currently writable (and #error is *not* set), or
		 * %G_POLLABLE_RETURN_FAILED if there was an error in which case #error will
		 * be set.
		 * 
		 * location to store the number of bytes that were
		 *     written to the stream
		 */
		writev_nonblocking(vectors: OutputVector[], cancellable?: Cancellable | null): [ PollableReturn, number | null ];
	}

	type PollableOutputStreamInitOptionsMixin  = {};
	export interface PollableOutputStreamInitOptions extends PollableOutputStreamInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link PollableOutputStream} instead.
	 */
	type PollableOutputStreamMixin = IPollableOutputStream;

	/**
	 * #GPollableOutputStream is implemented by #GOutputStreams that
	 * can be polled for readiness to write. This can be used when
	 * interfacing with a non-GIO API that expects
	 * UNIX-file-descriptor-style asynchronous I/O rather than GIO-style.
	 */
	interface PollableOutputStream extends PollableOutputStreamMixin {}

	class PollableOutputStream {
		public constructor(options?: Partial<PollableOutputStreamInitOptions>);
	}



	/** This construct is only for enabling class multi-inheritance,
	 * use {@link PowerProfileMonitor} instead.
	 */
	interface IPowerProfileMonitor {
		/**
		 * Whether “Power Saver” mode is enabled on the system.
		 */
		readonly power_saver_enabled: boolean;
		/**
		 * Gets whether the system is in “Power Saver” mode.
		 * 
		 * You are expected to listen to the
		 * #GPowerProfileMonitor::notify::power-saver-enabled signal to know when the profile has
		 * changed.
		 * @returns Whether the system is in “Power Saver” mode.
		 */
		get_power_saver_enabled(): boolean;
		connect(signal: "notify::power-saver-enabled", callback: (owner: this, ...args: any) => void): number;

	}

	type PowerProfileMonitorInitOptionsMixin  = {};
	export interface PowerProfileMonitorInitOptions extends PowerProfileMonitorInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link PowerProfileMonitor} instead.
	 */
	type PowerProfileMonitorMixin = IPowerProfileMonitor;

	/**
	 * #GPowerProfileMonitor makes it possible for applications as well as OS components
	 * to monitor system power profiles and act upon them. It currently only exports
	 * whether the system is in “Power Saver” mode (known as “Low Power” mode on
	 * some systems).
	 * 
	 * When in “Low Power” mode, it is recommended that applications:
	 * - disabling automatic downloads
	 * - reduce the rate of refresh from online sources such as calendar or
	 *   email synchronisation
	 * - if the application has expensive visual effects, reduce them
	 * 
	 * It is also likely that OS components providing services to applications will
	 * lower their own background activity, for the sake of the system.
	 * 
	 * There are a variety of tools that exist for power consumption analysis, but those
	 * usually depend on the OS and hardware used. On Linux, one could use `upower` to
	 * monitor the battery discharge rate, `powertop` to check on the background activity
	 * or activity at all), `sysprof` to inspect CPU usage, and `intel_gpu_time` to
	 * profile GPU usage.
	 * 
	 * Don't forget to disconnect the #GPowerProfileMonitor::notify::power-saver-enabled
	 * signal, and unref the #GPowerProfileMonitor itself when exiting.
	 */
	interface PowerProfileMonitor extends PowerProfileMonitorMixin {}

	class PowerProfileMonitor {
		public constructor(options?: Partial<PowerProfileMonitorInitOptions>);
		/**
		 * Gets a reference to the default #GPowerProfileMonitor for the system.
		 * @returns a new reference to the default #GPowerProfileMonitor
		 */
		public static dup_default(): PowerProfileMonitor;
	}



	/** This construct is only for enabling class multi-inheritance,
	 * use {@link Proxy} instead.
	 */
	interface IProxy {
		/**
		 * Given #connection to communicate with a proxy (eg, a
		 * #GSocketConnection that is connected to the proxy server), this
		 * does the necessary handshake to connect to #proxy_address, and if
		 * required, wraps the #GIOStream to handle proxy payload.
		 * @param connection a #GIOStream
		 * @param proxy_address a #GProxyAddress
		 * @param cancellable a #GCancellable
		 * @returns a #GIOStream that will replace #connection. This might
		 *               be the same as #connection, in which case a reference
		 *               will be added.
		 */
		connect(connection: IOStream, proxy_address: ProxyAddress, cancellable?: Cancellable | null): IOStream;
		/**
		 * Asynchronous version of {@link G.proxy_connect}.
		 * @param connection a #GIOStream
		 * @param proxy_address a #GProxyAddress
		 * @param cancellable a #GCancellable
		 * @param callback a #GAsyncReadyCallback
		 */
		connect_async(connection: IOStream, proxy_address: ProxyAddress, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;
		/**
		 * See {@link G.proxy_connect}.
		 * @param result a #GAsyncResult
		 * @returns a #GIOStream.
		 */
		connect_finish(result: AsyncResult): IOStream;
		/**
		 * Some proxy protocols expect to be passed a hostname, which they
		 * will resolve to an IP address themselves. Others, like SOCKS4, do
		 * not allow this. This function will return %FALSE if #proxy is
		 * implementing such a protocol. When %FALSE is returned, the caller
		 * should resolve the destination hostname first, and then pass a
		 * #GProxyAddress containing the stringified IP address to
		 * {@link G.proxy_connect} or g_proxy_connect_async().
		 * @returns %TRUE if hostname resolution is supported.
		 */
		supports_hostname(): boolean;
	}

	type ProxyInitOptionsMixin  = {};
	export interface ProxyInitOptions extends ProxyInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link Proxy} instead.
	 */
	type ProxyMixin = IProxy;

	/**
	 * A #GProxy handles connecting to a remote host via a given type of
	 * proxy server. It is implemented by the 'gio-proxy' extension point.
	 * The extensions are named after their proxy protocol name. As an
	 * example, a SOCKS5 proxy implementation can be retrieved with the
	 * name 'socks5' using the function
	 * {@link G.io_extension_point_get_extension_by_name}.
	 */
	interface Proxy extends ProxyMixin {}

	class Proxy {
		public constructor(options?: Partial<ProxyInitOptions>);
		/**
		 * Find the `gio-proxy` extension point for a proxy implementation that supports
		 * the specified protocol.
		 * @param protocol the proxy protocol name (e.g. http, socks, etc)
		 * @returns return a #GProxy or NULL if protocol
		 *               is not supported.
		 */
		public static get_default_for_protocol(protocol: string): Proxy | null;
	}



	/** This construct is only for enabling class multi-inheritance,
	 * use {@link ProxyResolver} instead.
	 */
	interface IProxyResolver {
		/**
		 * Checks if #resolver can be used on this system. (This is used
		 * internally; {@link G.proxy_resolver_get_default} will only return a proxy
		 * resolver that returns %TRUE for this method.)
		 * @returns %TRUE if #resolver is supported.
		 */
		is_supported(): boolean;
		/**
		 * Looks into the system proxy configuration to determine what proxy,
		 * if any, to use to connect to #uri. The returned proxy URIs are of
		 * the form `<protocol>://[user[:password]#]host:port` or
		 * `direct://`, where <protocol> could be http, rtsp, socks
		 * or other proxying protocol.
		 * 
		 * If you don't know what network protocol is being used on the
		 * socket, you should use `none` as the URI protocol.
		 * In this case, the resolver might still return a generic proxy type
		 * (such as SOCKS), but would not return protocol-specific proxy types
		 * (such as http).
		 * 
		 * `direct://` is used when no proxy is needed.
		 * Direct connection should not be attempted unless it is part of the
		 * returned array of proxies.
		 * @param uri a URI representing the destination to connect to
		 * @param cancellable a #GCancellable, or %NULL
		 * @returns A
		 *               NULL-terminated array of proxy URIs. Must be freed
		 *               with {@link G.strfreev}.
		 */
		lookup(uri: string, cancellable?: Cancellable | null): string[];
		/**
		 * Asynchronous lookup of proxy. See {@link G.proxy_resolver_lookup} for more
		 * details.
		 * @param uri a URI representing the destination to connect to
		 * @param cancellable a #GCancellable, or %NULL
		 * @param callback callback to call after resolution completes
		 */
		lookup_async(uri: string, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;
		/**
		 * Call this function to obtain the array of proxy URIs when
		 * {@link G.proxy_resolver_lookup_async} is complete. See
		 * g_proxy_resolver_lookup() for more details.
		 * @param result the result passed to your #GAsyncReadyCallback
		 * @returns A
		 *               NULL-terminated array of proxy URIs. Must be freed
		 *               with {@link G.strfreev}.
		 */
		lookup_finish(result: AsyncResult): string[];
	}

	type ProxyResolverInitOptionsMixin  = {};
	export interface ProxyResolverInitOptions extends ProxyResolverInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link ProxyResolver} instead.
	 */
	type ProxyResolverMixin = IProxyResolver;

	/**
	 * #GProxyResolver provides synchronous and asynchronous network proxy
	 * resolution. #GProxyResolver is used within #GSocketClient through
	 * the method {@link G.socket_connectable_proxy_enumerate}.
	 * 
	 * Implementations of #GProxyResolver based on libproxy and GNOME settings can
	 * be found in glib-networking. GIO comes with an implementation for use inside
	 * Flatpak portals.
	 */
	interface ProxyResolver extends ProxyResolverMixin {}

	class ProxyResolver {
		public constructor(options?: Partial<ProxyResolverInitOptions>);
		/**
		 * Gets the default #GProxyResolver for the system.
		 * @returns the default #GProxyResolver, which
		 *     will be a dummy object if no proxy resolver is available
		 */
		public static get_default(): ProxyResolver;
	}



	/** This construct is only for enabling class multi-inheritance,
	 * use {@link RemoteActionGroup} instead.
	 */
	interface IRemoteActionGroup {
		/**
		 * Activates the remote action.
		 * 
		 * This is the same as {@link G.action_group_activate_action} except that it
		 * allows for provision of "platform data" to be sent along with the
		 * activation request.  This typically contains details such as the user
		 * interaction timestamp or startup notification information.
		 * 
		 * #platform_data must be non-%NULL and must have the type
		 * %G_VARIANT_TYPE_VARDICT.  If it is floating, it will be consumed.
		 * @param action_name the name of the action to activate
		 * @param parameter the optional parameter to the activation
		 * @param platform_data the platform data to send
		 */
		activate_action_full(action_name: string, parameter: GLib.Variant | null, platform_data: GLib.Variant): void;
		/**
		 * Changes the state of a remote action.
		 * 
		 * This is the same as {@link G.action_group_change_action_state} except that
		 * it allows for provision of "platform data" to be sent along with the
		 * state change request.  This typically contains details such as the
		 * user interaction timestamp or startup notification information.
		 * 
		 * #platform_data must be non-%NULL and must have the type
		 * %G_VARIANT_TYPE_VARDICT.  If it is floating, it will be consumed.
		 * @param action_name the name of the action to change the state of
		 * @param value the new requested value for the state
		 * @param platform_data the platform data to send
		 */
		change_action_state_full(action_name: string, value: GLib.Variant, platform_data: GLib.Variant): void;
	}

	type RemoteActionGroupInitOptionsMixin  = {};
	export interface RemoteActionGroupInitOptions extends RemoteActionGroupInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link RemoteActionGroup} instead.
	 */
	type RemoteActionGroupMixin = IRemoteActionGroup;

	/**
	 * The GRemoteActionGroup interface is implemented by #GActionGroup
	 * instances that either transmit action invocations to other processes
	 * or receive action invocations in the local process from other
	 * processes.
	 * 
	 * The interface has `_full` variants of the two
	 * methods on #GActionGroup used to activate actions:
	 * {@link G.action_group_activate_action} and
	 * g_action_group_change_action_state(). These variants allow a
	 * "platform data" #GVariant to be specified: a dictionary providing
	 * context for the action invocation (for example: timestamps, startup
	 * notification IDs, etc).
	 * 
	 * #GDBusActionGroup implements #GRemoteActionGroup.  This provides a
	 * mechanism to send platform data for action invocations over D-Bus.
	 * 
	 * Additionally, g_dbus_connection_export_action_group() will check if
	 * the exported #GActionGroup implements #GRemoteActionGroup and use the
	 * `_full` variants of the calls if available.  This
	 * provides a mechanism by which to receive platform data for action
	 * invocations that arrive by way of D-Bus.
	 */
	interface RemoteActionGroup extends RemoteActionGroupMixin {}

	class RemoteActionGroup {
		public constructor(options?: Partial<RemoteActionGroupInitOptions>);
	}



	/** This construct is only for enabling class multi-inheritance,
	 * use {@link Seekable} instead.
	 */
	interface ISeekable {
		/**
		 * Tests if the stream supports the #GSeekableIface.
		 * @returns %TRUE if #seekable can be seeked. %FALSE otherwise.
		 */
		can_seek(): boolean;
		/**
		 * Tests if the length of the stream can be adjusted with
		 * {@link G.seekable_truncate}.
		 * @returns %TRUE if the stream can be truncated, %FALSE otherwise.
		 */
		can_truncate(): boolean;
		/**
		 * Seeks in the stream by the given #offset, modified by #type.
		 * 
		 * Attempting to seek past the end of the stream will have different
		 * results depending on if the stream is fixed-sized or resizable.  If
		 * the stream is resizable then seeking past the end and then writing
		 * will result in zeros filling the empty space.  Seeking past the end
		 * of a resizable stream and reading will result in EOF.  Seeking past
		 * the end of a fixed-sized stream will fail.
		 * 
		 * Any operation that would result in a negative offset will fail.
		 * 
		 * If #cancellable is not %NULL, then the operation can be cancelled by
		 * triggering the cancellable object from another thread. If the operation
		 * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
		 * @param offset a #goffset.
		 * @param type a #GSeekType.
		 * @param cancellable optional #GCancellable object, %NULL to ignore.
		 * @returns %TRUE if successful. If an error
		 *     has occurred, this function will return %FALSE and set #error
		 *     appropriately if present.
		 */
		seek(offset: number, type: GLib.SeekType, cancellable?: Cancellable | null): boolean;
		/**
		 * Tells the current position within the stream.
		 * @returns the (positive or zero) offset from the beginning of the
		 * buffer, zero if the target is not seekable.
		 */
		tell(): number;
		/**
		 * Sets the length of the stream to #offset. If the stream was previously
		 * larger than #offset, the extra data is discarded. If the stream was
		 * previously shorter than #offset, it is extended with NUL ('\0') bytes.
		 * 
		 * If #cancellable is not %NULL, then the operation can be cancelled by
		 * triggering the cancellable object from another thread. If the operation
		 * was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
		 * operation was partially finished when the operation was cancelled the
		 * partial result will be returned, without an error.
		 * @param offset new length for #seekable, in bytes.
		 * @param cancellable optional #GCancellable object, %NULL to ignore.
		 * @returns %TRUE if successful. If an error
		 *     has occurred, this function will return %FALSE and set #error
		 *     appropriately if present.
		 */
		truncate(offset: number, cancellable?: Cancellable | null): boolean;
	}

	type SeekableInitOptionsMixin  = {};
	export interface SeekableInitOptions extends SeekableInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link Seekable} instead.
	 */
	type SeekableMixin = ISeekable;

	/**
	 * #GSeekable is implemented by streams (implementations of
	 * #GInputStream or #GOutputStream) that support seeking.
	 * 
	 * Seekable streams largely fall into two categories: resizable and
	 * fixed-size.
	 * 
	 * #GSeekable on fixed-sized streams is approximately the same as POSIX
	 * lseek() on a block device (for example: attempting to seek past the
	 * end of the device is an error).  Fixed streams typically cannot be
	 * truncated.
	 * 
	 * #GSeekable on resizable streams is approximately the same as POSIX
	 * lseek() on a normal file.  Seeking past the end and writing data will
	 * usually cause the stream to resize by introducing zero bytes.
	 */
	interface Seekable extends SeekableMixin {}

	class Seekable {
		public constructor(options?: Partial<SeekableInitOptions>);
	}



	/** This construct is only for enabling class multi-inheritance,
	 * use {@link SocketConnectable} instead.
	 */
	interface ISocketConnectable {
		/**
		 * Creates a #GSocketAddressEnumerator for #connectable.
		 * @returns a new #GSocketAddressEnumerator.
		 */
		enumerate(): SocketAddressEnumerator;
		/**
		 * Creates a #GSocketAddressEnumerator for #connectable that will
		 * return a #GProxyAddress for each of its addresses that you must connect
		 * to via a proxy.
		 * 
		 * If #connectable does not implement
		 * {@link G.socket_connectable_proxy_enumerate}, this will fall back to
		 * calling g_socket_connectable_enumerate().
		 * @returns a new #GSocketAddressEnumerator.
		 */
		proxy_enumerate(): SocketAddressEnumerator;
		/**
		 * Format a #GSocketConnectable as a string. This is a human-readable format for
		 * use in debugging output, and is not a stable serialization format. It is not
		 * suitable for use in user interfaces as it exposes too much information for a
		 * user.
		 * 
		 * If the #GSocketConnectable implementation does not support string formatting,
		 * the implementation’s type name will be returned as a fallback.
		 * @returns the formatted string
		 */
		to_string(): string;
	}

	type SocketConnectableInitOptionsMixin  = {};
	export interface SocketConnectableInitOptions extends SocketConnectableInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link SocketConnectable} instead.
	 */
	type SocketConnectableMixin = ISocketConnectable;

	/**
	 * Objects that describe one or more potential socket endpoints
	 * implement #GSocketConnectable. Callers can then use
	 * {@link G.socket_connectable_enumerate} to get a #GSocketAddressEnumerator
	 * to try out each socket address in turn until one succeeds, as shown
	 * in the sample code below.
	 * 
	 * |[<!-- language="C" -->
	 * MyConnectionType *
	 * connect_to_host (const char    *hostname,
	 *                  guint16        port,
	 *                  GCancellable  *cancellable,
	 *                  GError       **error)
	 * {
	 *   MyConnection *conn = NULL;
	 *   GSocketConnectable *addr;
	 *   GSocketAddressEnumerator *enumerator;
	 *   GSocketAddress *sockaddr;
	 *   GError *conn_error = NULL;
	 * 
	 *   addr = g_network_address_new (hostname, port);
	 *   enumerator = g_socket_connectable_enumerate (addr);
	 *   g_object_unref (addr);
	 * 
	 *   // Try each sockaddr until we succeed. Record the first connection error,
	 *   // but not any further ones (since they'll probably be basically the same
	 *   // as the first).
	 *   while (!conn && (sockaddr = g_socket_address_enumerator_next (enumerator, cancellable, error))
	 *     {
	 *       conn = connect_to_sockaddr (sockaddr, conn_error ? NULL : &conn_error);
	 *       g_object_unref (sockaddr);
	 *     }
	 *   g_object_unref (enumerator);
	 * 
	 *   if (conn)
	 *     {
	 *       if (conn_error)
	 *         {
	 *           // We couldn't connect to the first address, but we succeeded
	 *           // in connecting to a later address.
	 *           g_error_free (conn_error);
	 *         }
	 *       return conn;
	 *     }
	 *   else if (error)
	 *     {
	 *       /// Either initial lookup failed, or else the caller cancelled us.
	 *       if (conn_error)
	 *         g_error_free (conn_error);
	 *       return NULL;
	 *     }
	 *   else
	 *     {
	 *       g_error_propagate (error, conn_error);
	 *       return NULL;
	 *     }
	 * }
	 * ]|
	 */
	interface SocketConnectable extends SocketConnectableMixin {}

	class SocketConnectable {
		public constructor(options?: Partial<SocketConnectableInitOptions>);
	}



	/** This construct is only for enabling class multi-inheritance,
	 * use {@link TlsBackend} instead.
	 */
	interface ITlsBackend {
		/**
		 * Gets the #GType of #backend's #GTlsCertificate implementation.
		 * @returns the #GType of #backend's #GTlsCertificate
		 *   implementation.
		 */
		get_certificate_type(): GObject.Type;
		/**
		 * Gets the #GType of #backend's #GTlsClientConnection implementation.
		 * @returns the #GType of #backend's #GTlsClientConnection
		 *   implementation.
		 */
		get_client_connection_type(): GObject.Type;
		/**
		 * Gets the default #GTlsDatabase used to verify TLS connections.
		 * @returns the default database, which should be
		 *               unreffed when done.
		 */
		get_default_database(): TlsDatabase;
		/**
		 * Gets the #GType of #backend’s #GDtlsClientConnection implementation.
		 * @returns the #GType of #backend’s #GDtlsClientConnection
		 *   implementation, or %G_TYPE_INVALID if this backend doesn’t support DTLS.
		 */
		get_dtls_client_connection_type(): GObject.Type;
		/**
		 * Gets the #GType of #backend’s #GDtlsServerConnection implementation.
		 * @returns the #GType of #backend’s #GDtlsServerConnection
		 *   implementation, or %G_TYPE_INVALID if this backend doesn’t support DTLS.
		 */
		get_dtls_server_connection_type(): GObject.Type;
		/**
		 * Gets the #GType of #backend's #GTlsFileDatabase implementation.
		 * @returns the #GType of backend's #GTlsFileDatabase implementation.
		 */
		get_file_database_type(): GObject.Type;
		/**
		 * Gets the #GType of #backend's #GTlsServerConnection implementation.
		 * @returns the #GType of #backend's #GTlsServerConnection
		 *   implementation.
		 */
		get_server_connection_type(): GObject.Type;
		/**
		 * Set the default #GTlsDatabase used to verify TLS connections
		 * 
		 * Any subsequent call to {@link G.tls_backend_get_default_database} will return
		 * the database set in this call.  Existing databases and connections are not
		 * modified.
		 * 
		 * Setting a %NULL default database will reset to using the system default
		 * database as if g_tls_backend_set_default_database() had never been called.
		 * @param database the #GTlsDatabase
		 */
		set_default_database(database?: TlsDatabase | null): void;
		/**
		 * Checks if DTLS is supported. DTLS support may not be available even if TLS
		 * support is available, and vice-versa.
		 * @returns whether DTLS is supported
		 */
		supports_dtls(): boolean;
		/**
		 * Checks if TLS is supported; if this returns %FALSE for the default
		 * #GTlsBackend, it means no "real" TLS backend is available.
		 * @returns whether or not TLS is supported
		 */
		supports_tls(): boolean;
	}

	type TlsBackendInitOptionsMixin  = {};
	export interface TlsBackendInitOptions extends TlsBackendInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link TlsBackend} instead.
	 */
	type TlsBackendMixin = ITlsBackend;

	/**
	 * TLS (Transport Layer Security, aka SSL) and DTLS backend.
	 */
	interface TlsBackend extends TlsBackendMixin {}

	class TlsBackend {
		public constructor(options?: Partial<TlsBackendInitOptions>);
		/**
		 * Gets the default #GTlsBackend for the system.
		 * @returns a #GTlsBackend, which will be a
		 *     dummy object if no TLS backend is available
		 */
		public static get_default(): TlsBackend;
	}



	/** This construct is only for enabling class multi-inheritance,
	 * use {@link TlsClientConnection} instead.
	 */
	interface ITlsClientConnection {
		/**
		 * A list of the distinguished names of the Certificate Authorities
		 * that the server will accept client certificates signed by. If the
		 * server requests a client certificate during the handshake, then
		 * this property will be set after the handshake completes.
		 * 
		 * Each item in the list is a #GByteArray which contains the complete
		 * subject DN of the certificate authority.
		 */
		readonly accepted_cas: any[];
		/**
		 * A #GSocketConnectable describing the identity of the server that
		 * is expected on the other end of the connection.
		 * 
		 * If the %G_TLS_CERTIFICATE_BAD_IDENTITY flag is set in
		 * #GTlsClientConnection:validation-flags, this object will be used
		 * to determine the expected identify of the remote end of the
		 * connection; if #GTlsClientConnection:server-identity is not set,
		 * or does not match the identity presented by the server, then the
		 * %G_TLS_CERTIFICATE_BAD_IDENTITY validation will fail.
		 * 
		 * In addition to its use in verifying the server certificate,
		 * this is also used to give a hint to the server about what
		 * certificate we expect, which is useful for servers that serve
		 * virtual hosts.
		 */
		server_identity: SocketConnectable;
		/**
		 * @deprecated
		 * SSL 3.0 is insecure.
		 * 
		 * SSL 3.0 is no longer supported. See
		 * {@link G.tls_client_connection_set_use_ssl3} for details.
		 */
		use_ssl3: boolean;
		/**
		 * What steps to perform when validating a certificate received from
		 * a server. Server certificates that fail to validate in any of the
		 * ways indicated here will be rejected unless the application
		 * overrides the default via #GTlsConnection::accept-certificate.
		 */
		validation_flags: TlsCertificateFlags;
		/**
		 * Possibly copies session state from one connection to another, for use
		 * in TLS session resumption. This is not normally needed, but may be
		 * used when the same session needs to be used between different
		 * endpoints, as is required by some protocols, such as FTP over TLS.
		 * #source should have already completed a handshake and, since TLS 1.3,
		 * it should have been used to read data at least once. #conn should not
		 * have completed a handshake.
		 * 
		 * It is not possible to know whether a call to this function will
		 * actually do anything. Because session resumption is normally used
		 * only for performance benefit, the TLS backend might not implement
		 * this function. Even if implemented, it may not actually succeed in
		 * allowing #conn to resume #source's TLS session, because the server
		 * may not have sent a session resumption token to #source, or it may
		 * refuse to accept the token from #conn. There is no way to know
		 * whether a call to this function is actually successful.
		 * 
		 * Using this function is not required to benefit from session
		 * resumption. If the TLS backend supports session resumption, the
		 * session will be resumed automatically if it is possible to do so
		 * without weakening the privacy guarantees normally provided by TLS,
		 * without need to call this function. For example, with TLS 1.3,
		 * a session ticket will be automatically copied from any
		 * #GTlsClientConnection that has previously received session tickets
		 * from the server, provided a ticket is available that has not
		 * previously been used for session resumption, since session ticket
		 * reuse would be a privacy weakness. Using this function causes the
		 * ticket to be copied without regard for privacy considerations.
		 * @param source a #GTlsClientConnection
		 */
		copy_session_state(source: TlsClientConnection): void;
		/**
		 * Gets the list of distinguished names of the Certificate Authorities
		 * that the server will accept certificates from. This will be set
		 * during the TLS handshake if the server requests a certificate.
		 * Otherwise, it will be %NULL.
		 * 
		 * Each item in the list is a #GByteArray which contains the complete
		 * subject DN of the certificate authority.
		 * @returns the list of
		 * CA DNs. You should unref each element with {@link G.byte_array_unref} and then
		 * the free the list with g_list_free().
		 */
		get_accepted_cas(): GLib.List;
		/**
		 * Gets #conn's expected server identity
		 * @returns a #GSocketConnectable describing the
		 * expected server identity, or %NULL if the expected identity is not
		 * known.
		 */
		get_server_identity(): SocketConnectable | null;
		/**
		 * @deprecated
		 * SSL 3.0 is insecure.
		 * 
		 * SSL 3.0 is no longer supported. See
		 * {@link G.tls_client_connection_set_use_ssl3} for details.
		 * @returns %FALSE
		 */
		get_use_ssl3(): boolean;
		/**
		 * Gets #conn's validation flags
		 * @returns the validation flags
		 */
		get_validation_flags(): TlsCertificateFlags;
		/**
		 * Sets #conn's expected server identity, which is used both to tell
		 * servers on virtual hosts which certificate to present, and also
		 * to let #conn know what name to look for in the certificate when
		 * performing %G_TLS_CERTIFICATE_BAD_IDENTITY validation, if enabled.
		 * @param identity a #GSocketConnectable describing the expected server identity
		 */
		set_server_identity(identity: SocketConnectable): void;
		/**
		 * @deprecated
		 * SSL 3.0 is insecure.
		 * 
		 * Since GLib 2.42.1, SSL 3.0 is no longer supported.
		 * 
		 * From GLib 2.42.1 through GLib 2.62, this function could be used to
		 * force use of TLS 1.0, the lowest-supported TLS protocol version at
		 * the time. In the past, this was needed to connect to broken TLS
		 * servers that exhibited protocol version intolerance. Such servers
		 * are no longer common, and using TLS 1.0 is no longer considered
		 * acceptable.
		 * 
		 * Since GLib 2.64, this function does nothing.
		 * @param use_ssl3 a #gboolean, ignored
		 */
		set_use_ssl3(use_ssl3: boolean): void;
		/**
		 * Sets #conn's validation flags, to override the default set of
		 * checks performed when validating a server certificate. By default,
		 * %G_TLS_CERTIFICATE_VALIDATE_ALL is used.
		 * @param flags the #GTlsCertificateFlags to use
		 */
		set_validation_flags(flags: TlsCertificateFlags): void;
		connect(signal: "notify::accepted-cas", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::server-identity", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::use-ssl3", callback: (owner: this, ...args: any) => void): number;
		connect(signal: "notify::validation-flags", callback: (owner: this, ...args: any) => void): number;

	}

	type TlsClientConnectionInitOptionsMixin = Pick<ITlsClientConnection,
		"server_identity" |
		"use_ssl3" |
		"validation_flags">;

	export interface TlsClientConnectionInitOptions extends TlsClientConnectionInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link TlsClientConnection} instead.
	 */
	type TlsClientConnectionMixin = ITlsClientConnection;

	/**
	 * #GTlsClientConnection is the client-side subclass of
	 * #GTlsConnection, representing a client-side TLS connection.
	 */
	interface TlsClientConnection extends TlsClientConnectionMixin {}

	class TlsClientConnection {
		public constructor(options?: Partial<TlsClientConnectionInitOptions>);
		/**
		 * Creates a new #GTlsClientConnection wrapping #base_io_stream (which
		 * must have pollable input and output streams) which is assumed to
		 * communicate with the server identified by #server_identity.
		 * 
		 * See the documentation for #GTlsConnection:base-io-stream for restrictions
		 * on when application code can run operations on the #base_io_stream after
		 * this function has returned.
		 * @param base_io_stream the #GIOStream to wrap
		 * @param server_identity the expected identity of the server
		 * @returns the new
		 * #GTlsClientConnection, or %NULL on error
		 */
		public static new(base_io_stream: IOStream, server_identity?: SocketConnectable | null): TlsClientConnection;
	}



	/** This construct is only for enabling class multi-inheritance,
	 * use {@link TlsFileDatabase} instead.
	 */
	interface ITlsFileDatabase {
		/**
		 * The path to a file containing PEM encoded certificate authority
		 * root anchors. The certificates in this file will be treated as
		 * root authorities for the purpose of verifying other certificates
		 * via the {@link G.tls_database_verify_chain} operation.
		 */
		anchors: string;

		connect(signal: "notify::anchors", callback: (owner: this, ...args: any) => void): number;

	}

	type TlsFileDatabaseInitOptionsMixin = Pick<ITlsFileDatabase,
		"anchors">;

	export interface TlsFileDatabaseInitOptions extends TlsFileDatabaseInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link TlsFileDatabase} instead.
	 */
	type TlsFileDatabaseMixin = ITlsFileDatabase;

	/**
	 * #GTlsFileDatabase is implemented by #GTlsDatabase objects which load
	 * their certificate information from a file. It is an interface which
	 * TLS library specific subtypes implement.
	 */
	interface TlsFileDatabase extends TlsFileDatabaseMixin {}

	class TlsFileDatabase {
		public constructor(options?: Partial<TlsFileDatabaseInitOptions>);
		/**
		 * Creates a new #GTlsFileDatabase which uses anchor certificate authorities
		 * in #anchors to verify certificate chains.
		 * 
		 * The certificates in #anchors must be PEM encoded.
		 * @param anchors filename of anchor certificate authorities.
		 * @returns the new
		 * #GTlsFileDatabase, or %NULL on error
		 */
		public static new(anchors: string): TlsFileDatabase;
	}



	/** This construct is only for enabling class multi-inheritance,
	 * use {@link TlsServerConnection} instead.
	 */
	interface ITlsServerConnection {
		/**
		 * The #GTlsAuthenticationMode for the server. This can be changed
		 * before calling {@link G.tls_connection_handshake} if you want to
		 * rehandshake with a different mode from the initial handshake.
		 */
		authentication_mode: TlsAuthenticationMode;

		connect(signal: "notify::authentication-mode", callback: (owner: this, ...args: any) => void): number;

	}

	type TlsServerConnectionInitOptionsMixin = Pick<ITlsServerConnection,
		"authentication_mode">;

	export interface TlsServerConnectionInitOptions extends TlsServerConnectionInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link TlsServerConnection} instead.
	 */
	type TlsServerConnectionMixin = ITlsServerConnection;

	/**
	 * #GTlsServerConnection is the server-side subclass of #GTlsConnection,
	 * representing a server-side TLS connection.
	 */
	interface TlsServerConnection extends TlsServerConnectionMixin {}

	class TlsServerConnection {
		public constructor(options?: Partial<TlsServerConnectionInitOptions>);
		/**
		 * Creates a new #GTlsServerConnection wrapping #base_io_stream (which
		 * must have pollable input and output streams).
		 * 
		 * See the documentation for #GTlsConnection:base-io-stream for restrictions
		 * on when application code can run operations on the #base_io_stream after
		 * this function has returned.
		 * @param base_io_stream the #GIOStream to wrap
		 * @param certificate the default server certificate, or %NULL
		 * @returns the new
		 * #GTlsServerConnection, or %NULL on error
		 */
		public static new(base_io_stream: IOStream, certificate?: TlsCertificate | null): TlsServerConnection;
	}



	/** This construct is only for enabling class multi-inheritance,
	 * use {@link Volume} instead.
	 */
	interface IVolume {
		/**
		 * Checks if a volume can be ejected.
		 * @returns %TRUE if the #volume can be ejected. %FALSE otherwise
		 */
		can_eject(): boolean;
		/**
		 * Checks if a volume can be mounted.
		 * @returns %TRUE if the #volume can be mounted. %FALSE otherwise
		 */
		can_mount(): boolean;
		/**
		 * @deprecated
		 * Use {@link G.volume_eject_with_operation} instead.
		 * 
		 * Ejects a volume. This is an asynchronous operation, and is
		 * finished by calling {@link G.volume_eject_finish} with the #volume
		 * and #GAsyncResult returned in the #callback.
		 * @param flags flags affecting the unmount if required for eject
		 * @param cancellable optional #GCancellable object, %NULL to ignore
		 * @param callback a #GAsyncReadyCallback, or %NULL
		 */
		eject(flags: MountUnmountFlags, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;
		/**
		 * @deprecated
		 * Use {@link G.volume_eject_with_operation_finish} instead.
		 * 
		 * Finishes ejecting a volume. If any errors occurred during the operation,
		 * #error will be set to contain the errors and %FALSE will be returned.
		 * @param result a #GAsyncResult
		 * @returns %TRUE, %FALSE if operation failed
		 */
		eject_finish(result: AsyncResult): boolean;
		/**
		 * Ejects a volume. This is an asynchronous operation, and is
		 * finished by calling {@link G.volume_eject_with_operation_finish} with the #volume
		 * and #GAsyncResult data returned in the #callback.
		 * @param flags flags affecting the unmount if required for eject
		 * @param mount_operation a #GMountOperation or %NULL to
		 *     avoid user interaction
		 * @param cancellable optional #GCancellable object, %NULL to ignore
		 * @param callback a #GAsyncReadyCallback, or %NULL
		 */
		eject_with_operation(flags: MountUnmountFlags, mount_operation?: MountOperation | null, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;
		/**
		 * Finishes ejecting a volume. If any errors occurred during the operation,
		 * #error will be set to contain the errors and %FALSE will be returned.
		 * @param result a #GAsyncResult
		 * @returns %TRUE if the volume was successfully ejected. %FALSE otherwise
		 */
		eject_with_operation_finish(result: AsyncResult): boolean;
		/**
		 * Gets the kinds of [identifiers][volume-identifier] that #volume has.
		 * Use {@link G.volume_get_identifier} to obtain the identifiers themselves.
		 * @returns a %NULL-terminated array
		 *   of strings containing kinds of identifiers. Use {@link G.strfreev} to free.
		 */
		enumerate_identifiers(): string[];
		/**
		 * Gets the activation root for a #GVolume if it is known ahead of
		 * mount time. Returns %NULL otherwise. If not %NULL and if #volume
		 * is mounted, then the result of {@link G.mount_get_root} on the
		 * #GMount object obtained from g_volume_get_mount() will always
		 * either be equal or a prefix of what this function returns. In
		 * other words, in code
		 * 
		 * |[<!-- language="C" -->
		 *   GMount *mount;
		 *   GFile *mount_root
		 *   GFile *volume_activation_root;
		 * 
		 *   mount = g_volume_get_mount (volume); // mounted, so never NULL
		 *   mount_root = g_mount_get_root (mount);
		 *   volume_activation_root = g_volume_get_activation_root (volume); // assume not NULL
		 * ]|
		 * then the expression
		 * |[<!-- language="C" -->
		 *   (g_file_has_prefix (volume_activation_root, mount_root) ||
		 *    g_file_equal (volume_activation_root, mount_root))
		 * ]|
		 * will always be %TRUE.
		 * 
		 * Activation roots are typically used in #GVolumeMonitor
		 * implementations to find the underlying mount to shadow, see
		 * g_mount_is_shadowed() for more details.
		 * @returns the activation root of #volume
		 *     or %NULL. Use {@link GObject.unref} to free.
		 */
		get_activation_root(): File | null;
		/**
		 * Gets the drive for the #volume.
		 * @returns a #GDrive or %NULL if #volume is not
		 *     associated with a drive. The returned object should be unreffed
		 *     with {@link GObject.unref} when no longer needed.
		 */
		get_drive(): Drive | null;
		/**
		 * Gets the icon for #volume.
		 * @returns a #GIcon.
		 *     The returned object should be unreffed with {@link GObject.unref}
		 *     when no longer needed.
		 */
		get_icon(): Icon;
		/**
		 * Gets the identifier of the given kind for #volume.
		 * See the [introduction][volume-identifier] for more
		 * information about volume identifiers.
		 * @param kind the kind of identifier to return
		 * @returns a newly allocated string containing the
		 *     requested identifier, or %NULL if the #GVolume
		 *     doesn't have this kind of identifier
		 */
		get_identifier(kind: string): string | null;
		/**
		 * Gets the mount for the #volume.
		 * @returns a #GMount or %NULL if #volume isn't mounted.
		 *     The returned object should be unreffed with {@link GObject.unref}
		 *     when no longer needed.
		 */
		get_mount(): Mount | null;
		/**
		 * Gets the name of #volume.
		 * @returns the name for the given #volume. The returned string should
		 *     be freed with {@link G.free} when no longer needed.
		 */
		get_name(): string;
		/**
		 * Gets the sort key for #volume, if any.
		 * @returns Sorting key for #volume or %NULL if no such key is available
		 */
		get_sort_key(): string | null;
		/**
		 * Gets the symbolic icon for #volume.
		 * @returns a #GIcon.
		 *     The returned object should be unreffed with {@link GObject.unref}
		 *     when no longer needed.
		 */
		get_symbolic_icon(): Icon;
		/**
		 * Gets the UUID for the #volume. The reference is typically based on
		 * the file system UUID for the volume in question and should be
		 * considered an opaque string. Returns %NULL if there is no UUID
		 * available.
		 * @returns the UUID for #volume or %NULL if no UUID
		 *     can be computed.
		 *     The returned string should be freed with {@link G.free}
		 *     when no longer needed.
		 */
		get_uuid(): string | null;
		/**
		 * Mounts a volume. This is an asynchronous operation, and is
		 * finished by calling {@link G.volume_mount_finish} with the #volume
		 * and #GAsyncResult returned in the #callback.
		 * @param flags flags affecting the operation
		 * @param mount_operation a #GMountOperation or %NULL to avoid user interaction
		 * @param cancellable optional #GCancellable object, %NULL to ignore
		 * @param callback a #GAsyncReadyCallback, or %NULL
		 */
		mount(flags: MountMountFlags, mount_operation?: MountOperation | null, cancellable?: Cancellable | null, callback?: AsyncReadyCallback | null): void;
		/**
		 * Finishes mounting a volume. If any errors occurred during the operation,
		 * #error will be set to contain the errors and %FALSE will be returned.
		 * 
		 * If the mount operation succeeded, {@link G.volume_get_mount} on #volume
		 * is guaranteed to return the mount right after calling this
		 * function; there's no need to listen for the 'mount-added' signal on
		 * #GVolumeMonitor.
		 * @param result a #GAsyncResult
		 * @returns %TRUE, %FALSE if operation failed
		 */
		mount_finish(result: AsyncResult): boolean;
		/**
		 * Returns whether the volume should be automatically mounted.
		 * @returns %TRUE if the volume should be automatically mounted
		 */
		should_automount(): boolean;
		/**
		 * Emitted when the volume has been changed.
		 * @param signal 
		 * @param callback Callback function
		 *  - owner: owner of the emitted event 
		 * 
		 * @returns Callback ID
		 */
		connect(signal: "changed", callback: (owner: this) => void): number;
		/**
		 * This signal is emitted when the #GVolume have been removed. If
		 * the recipient is holding references to the object they should
		 * release them so the object can be finalized.
		 * @param signal 
		 * @param callback Callback function
		 *  - owner: owner of the emitted event 
		 * 
		 * @returns Callback ID
		 */
		connect(signal: "removed", callback: (owner: this) => void): number;

	}

	type VolumeInitOptionsMixin  = {};
	export interface VolumeInitOptions extends VolumeInitOptionsMixin {}

	/** This construct is only for enabling class multi-inheritance,
	 * use {@link Volume} instead.
	 */
	type VolumeMixin = IVolume;

	/**
	 * The #GVolume interface represents user-visible objects that can be
	 * mounted. Note, when porting from GnomeVFS, #GVolume is the moral
	 * equivalent of #GnomeVFSDrive.
	 * 
	 * Mounting a #GVolume instance is an asynchronous operation. For more
	 * information about asynchronous operations, see #GAsyncResult and
	 * #GTask. To mount a #GVolume, first call {@link G.volume_mount} with (at
	 * least) the #GVolume instance, optionally a #GMountOperation object
	 * and a #GAsyncReadyCallback.
	 * 
	 * Typically, one will only want to pass %NULL for the
	 * #GMountOperation if automounting all volumes when a desktop session
	 * starts since it's not desirable to put up a lot of dialogs asking
	 * for credentials.
	 * 
	 * The callback will be fired when the operation has resolved (either
	 * with success or failure), and a #GAsyncResult instance will be
	 * passed to the callback.  That callback should then call
	 * g_volume_mount_finish() with the #GVolume instance and the
	 * #GAsyncResult data to see if the operation was completed
	 * successfully.  If an #error is present when g_volume_mount_finish()
	 * is called, then it will be filled with any error information.
	 * 
	 * ## Volume Identifiers # {#volume-identifier}
	 * 
	 * It is sometimes necessary to directly access the underlying
	 * operating system object behind a volume (e.g. for passing a volume
	 * to an application via the commandline). For this purpose, GIO
	 * allows to obtain an 'identifier' for the volume. There can be
	 * different kinds of identifiers, such as Hal UDIs, filesystem labels,
	 * traditional Unix devices (e.g. `/dev/sda2`), UUIDs. GIO uses predefined
	 * strings as names for the different kinds of identifiers:
	 * #G_VOLUME_IDENTIFIER_KIND_UUID, #G_VOLUME_IDENTIFIER_KIND_LABEL, etc.
	 * Use g_volume_get_identifier() to obtain an identifier for a volume.
	 * 
	 * 
	 * Note that #G_VOLUME_IDENTIFIER_KIND_HAL_UDI will only be available
	 * when the gvfs hal volume monitor is in use. Other volume monitors
	 * will generally be able to provide the #G_VOLUME_IDENTIFIER_KIND_UNIX_DEVICE
	 * identifier, which can be used to obtain a hal device by means of
	 * libhal_manager_find_device_string_match().
	 */
	interface Volume extends VolumeMixin {}

	class Volume {
		public constructor(options?: Partial<VolumeInitOptions>);
	}



	/**
	 * An enumeration for well-known message buses.
	 */
	enum BusType {
		/**
		 * An alias for the message bus that activated the process, if any.
		 */
		STARTER = -1,
		/**
		 * Not a message bus.
		 */
		NONE = 0,
		/**
		 * The system-wide message bus.
		 */
		SYSTEM = 1,
		/**
		 * The login session message bus.
		 */
		SESSION = 2
	}

	/**
	 * Results returned from {@link G.converter_convert}.
	 */
	enum ConverterResult {
		/**
		 * There was an error during conversion.
		 */
		ERROR = 0,
		/**
		 * Some data was consumed or produced
		 */
		CONVERTED = 1,
		/**
		 * The conversion is finished
		 */
		FINISHED = 2,
		/**
		 * Flushing is finished
		 */
		FLUSHED = 3
	}

	/**
	 * Enumeration describing different kinds of native credential types.
	 */
	enum CredentialsType {
		/**
		 * Indicates an invalid native credential type.
		 */
		INVALID = 0,
		/**
		 * The native credentials type is a `struct ucred`.
		 */
		LINUX_UCRED = 1,
		/**
		 * The native credentials type is a `struct cmsgcred`.
		 */
		FREEBSD_CMSGCRED = 2,
		/**
		 * The native credentials type is a `struct sockpeercred`. Added in 2.30.
		 */
		OPENBSD_SOCKPEERCRED = 3,
		/**
		 * The native credentials type is a `ucred_t`. Added in 2.40.
		 */
		SOLARIS_UCRED = 4,
		/**
		 * The native credentials type is a `struct unpcbid`. Added in 2.42.
		 */
		NETBSD_UNPCBID = 5,
		/**
		 * The native credentials type is a `struct xucred`. Added in 2.66.
		 */
		APPLE_XUCRED = 6
	}

	/**
	 * Error codes for the %G_DBUS_ERROR error domain.
	 */
	enum DBusError {
		/**
		 * A generic error; "something went wrong" - see the error message for
		 * more.
		 */
		FAILED = 0,
		/**
		 * There was not enough memory to complete an operation.
		 */
		NO_MEMORY = 1,
		/**
		 * The bus doesn't know how to launch a service to supply the bus name
		 * you wanted.
		 */
		SERVICE_UNKNOWN = 2,
		/**
		 * The bus name you referenced doesn't exist (i.e. no application owns
		 * it).
		 */
		NAME_HAS_NO_OWNER = 3,
		/**
		 * No reply to a message expecting one, usually means a timeout occurred.
		 */
		NO_REPLY = 4,
		/**
		 * Something went wrong reading or writing to a socket, for example.
		 */
		IO_ERROR = 5,
		/**
		 * A D-Bus bus address was malformed.
		 */
		BAD_ADDRESS = 6,
		/**
		 * Requested operation isn't supported (like ENOSYS on UNIX).
		 */
		NOT_SUPPORTED = 7,
		/**
		 * Some limited resource is exhausted.
		 */
		LIMITS_EXCEEDED = 8,
		/**
		 * Security restrictions don't allow doing what you're trying to do.
		 */
		ACCESS_DENIED = 9,
		/**
		 * Authentication didn't work.
		 */
		AUTH_FAILED = 10,
		/**
		 * Unable to connect to server (probably caused by ECONNREFUSED on a
		 * socket).
		 */
		NO_SERVER = 11,
		/**
		 * Certain timeout errors, possibly ETIMEDOUT on a socket.  Note that
		 * %G_DBUS_ERROR_NO_REPLY is used for message reply timeouts. Warning:
		 * this is confusingly-named given that %G_DBUS_ERROR_TIMED_OUT also
		 * exists. We can't fix it for compatibility reasons so just be
		 * careful.
		 */
		TIMEOUT = 12,
		/**
		 * No network access (probably ENETUNREACH on a socket).
		 */
		NO_NETWORK = 13,
		/**
		 * Can't bind a socket since its address is in use (i.e. EADDRINUSE).
		 */
		ADDRESS_IN_USE = 14,
		/**
		 * The connection is disconnected and you're trying to use it.
		 */
		DISCONNECTED = 15,
		/**
		 * Invalid arguments passed to a method call.
		 */
		INVALID_ARGS = 16,
		/**
		 * Missing file.
		 */
		FILE_NOT_FOUND = 17,
		/**
		 * Existing file and the operation you're using does not silently overwrite.
		 */
		FILE_EXISTS = 18,
		/**
		 * Method name you invoked isn't known by the object you invoked it on.
		 */
		UNKNOWN_METHOD = 19,
		/**
		 * Certain timeout errors, e.g. while starting a service. Warning: this is
		 * confusingly-named given that %G_DBUS_ERROR_TIMEOUT also exists. We
		 * can't fix it for compatibility reasons so just be careful.
		 */
		TIMED_OUT = 20,
		/**
		 * Tried to remove or modify a match rule that didn't exist.
		 */
		MATCH_RULE_NOT_FOUND = 21,
		/**
		 * The match rule isn't syntactically valid.
		 */
		MATCH_RULE_INVALID = 22,
		/**
		 * While starting a new process, the exec() call failed.
		 */
		SPAWN_EXEC_FAILED = 23,
		/**
		 * While starting a new process, the fork() call failed.
		 */
		SPAWN_FORK_FAILED = 24,
		/**
		 * While starting a new process, the child exited with a status code.
		 */
		SPAWN_CHILD_EXITED = 25,
		/**
		 * While starting a new process, the child exited on a signal.
		 */
		SPAWN_CHILD_SIGNALED = 26,
		/**
		 * While starting a new process, something went wrong.
		 */
		SPAWN_FAILED = 27,
		/**
		 * We failed to setup the environment correctly.
		 */
		SPAWN_SETUP_FAILED = 28,
		/**
		 * We failed to setup the config parser correctly.
		 */
		SPAWN_CONFIG_INVALID = 29,
		/**
		 * Bus name was not valid.
		 */
		SPAWN_SERVICE_INVALID = 30,
		/**
		 * Service file not found in system-services directory.
		 */
		SPAWN_SERVICE_NOT_FOUND = 31,
		/**
		 * Permissions are incorrect on the setuid helper.
		 */
		SPAWN_PERMISSIONS_INVALID = 32,
		/**
		 * Service file invalid (Name, User or Exec missing).
		 */
		SPAWN_FILE_INVALID = 33,
		/**
		 * Tried to get a UNIX process ID and it wasn't available.
		 */
		SPAWN_NO_MEMORY = 34,
		/**
		 * Tried to get a UNIX process ID and it wasn't available.
		 */
		UNIX_PROCESS_ID_UNKNOWN = 35,
		/**
		 * A type signature is not valid.
		 */
		INVALID_SIGNATURE = 36,
		/**
		 * A file contains invalid syntax or is otherwise broken.
		 */
		INVALID_FILE_CONTENT = 37,
		/**
		 * Asked for SELinux security context and it wasn't available.
		 */
		SELINUX_SECURITY_CONTEXT_UNKNOWN = 38,
		/**
		 * Asked for ADT audit data and it wasn't available.
		 */
		ADT_AUDIT_DATA_UNKNOWN = 39,
		/**
		 * There's already an object with the requested object path.
		 */
		OBJECT_PATH_IN_USE = 40,
		/**
		 * Object you invoked a method on isn't known. Since 2.42
		 */
		UNKNOWN_OBJECT = 41,
		/**
		 * Interface you invoked a method on isn't known by the object. Since 2.42
		 */
		UNKNOWN_INTERFACE = 42,
		/**
		 * Property you tried to access isn't known by the object. Since 2.42
		 */
		UNKNOWN_PROPERTY = 43,
		/**
		 * Property you tried to set is read-only. Since 2.42
		 */
		PROPERTY_READ_ONLY = 44
	}

	/**
	 * Enumeration used to describe the byte order of a D-Bus message.
	 */
	enum DBusMessageByteOrder {
		/**
		 * The byte order is big endian.
		 */
		BIG_ENDIAN = 66,
		/**
		 * The byte order is little endian.
		 */
		LITTLE_ENDIAN = 108
	}

	/**
	 * Header fields used in #GDBusMessage.
	 */
	enum DBusMessageHeaderField {
		/**
		 * Not a valid header field.
		 */
		INVALID = 0,
		/**
		 * The object path.
		 */
		PATH = 1,
		/**
		 * The interface name.
		 */
		INTERFACE = 2,
		/**
		 * The method or signal name.
		 */
		MEMBER = 3,
		/**
		 * The name of the error that occurred.
		 */
		ERROR_NAME = 4,
		/**
		 * The serial number the message is a reply to.
		 */
		REPLY_SERIAL = 5,
		/**
		 * The name the message is intended for.
		 */
		DESTINATION = 6,
		/**
		 * Unique name of the sender of the message (filled in by the bus).
		 */
		SENDER = 7,
		/**
		 * The signature of the message body.
		 */
		SIGNATURE = 8,
		/**
		 * The number of UNIX file descriptors that accompany the message.
		 */
		NUM_UNIX_FDS = 9
	}

	/**
	 * Message types used in #GDBusMessage.
	 */
	enum DBusMessageType {
		/**
		 * Message is of invalid type.
		 */
		INVALID = 0,
		/**
		 * Method call.
		 */
		METHOD_CALL = 1,
		/**
		 * Method reply.
		 */
		METHOD_RETURN = 2,
		/**
		 * Error reply.
		 */
		ERROR = 3,
		/**
		 * Signal emission.
		 */
		SIGNAL = 4
	}

	/**
	 * #GDataStreamByteOrder is used to ensure proper endianness of streaming data sources
	 * across various machine architectures.
	 */
	enum DataStreamByteOrder {
		/**
		 * Selects Big Endian byte order.
		 */
		BIG_ENDIAN = 0,
		/**
		 * Selects Little Endian byte order.
		 */
		LITTLE_ENDIAN = 1,
		/**
		 * Selects endianness based on host machine's architecture.
		 */
		HOST_ENDIAN = 2
	}

	/**
	 * #GDataStreamNewlineType is used when checking for or setting the line endings for a given file.
	 */
	enum DataStreamNewlineType {
		/**
		 * Selects "LF" line endings, common on most modern UNIX platforms.
		 */
		LF = 0,
		/**
		 * Selects "CR" line endings.
		 */
		CR = 1,
		/**
		 * Selects "CR, LF" line ending, common on Microsoft Windows.
		 */
		CR_LF = 2,
		/**
		 * Automatically try to handle any line ending type.
		 */
		ANY = 3
	}

	/**
	 * Enumeration describing how a drive can be started/stopped.
	 */
	enum DriveStartStopType {
		/**
		 * Unknown or drive doesn't support
		 *    start/stop.
		 */
		UNKNOWN = 0,
		/**
		 * The stop method will physically
		 *    shut down the drive and e.g. power down the port the drive is
		 *    attached to.
		 */
		SHUTDOWN = 1,
		/**
		 * The start/stop methods are used
		 *    for connecting/disconnect to the drive over the network.
		 */
		NETWORK = 2,
		/**
		 * The start/stop methods will
		 *    assemble/disassemble a virtual drive from several physical
		 *    drives.
		 */
		MULTIDISK = 3,
		/**
		 * The start/stop methods will
		 *    unlock/lock the disk (for example using the ATA <quote>SECURITY
		 *    UNLOCK DEVICE</quote> command)
		 */
		PASSWORD = 4
	}

	/**
	 * GEmblemOrigin is used to add information about the origin of the emblem
	 * to #GEmblem.
	 */
	enum EmblemOrigin {
		/**
		 * Emblem of unknown origin
		 */
		UNKNOWN = 0,
		/**
		 * Emblem adds device-specific information
		 */
		DEVICE = 1,
		/**
		 * Emblem depicts live metadata, such as "readonly"
		 */
		LIVEMETADATA = 2,
		/**
		 * Emblem comes from a user-defined tag, e.g. set by nautilus (in the future)
		 */
		TAG = 3
	}

	/**
	 * Used by {@link G.file_set_attributes_from_info} when setting file attributes.
	 */
	enum FileAttributeStatus {
		/**
		 * Attribute value is unset (empty).
		 */
		UNSET = 0,
		/**
		 * Attribute value is set.
		 */
		SET = 1,
		/**
		 * Indicates an error in setting the value.
		 */
		ERROR_SETTING = 2
	}

	/**
	 * The data types for file attributes.
	 */
	enum FileAttributeType {
		/**
		 * indicates an invalid or uninitialized type.
		 */
		INVALID = 0,
		/**
		 * a null terminated UTF8 string.
		 */
		STRING = 1,
		/**
		 * a zero terminated string of non-zero bytes.
		 */
		BYTE_STRING = 2,
		/**
		 * a boolean value.
		 */
		BOOLEAN = 3,
		/**
		 * an unsigned 4-byte/32-bit integer.
		 */
		UINT32 = 4,
		/**
		 * a signed 4-byte/32-bit integer.
		 */
		INT32 = 5,
		/**
		 * an unsigned 8-byte/64-bit integer.
		 */
		UINT64 = 6,
		/**
		 * a signed 8-byte/64-bit integer.
		 */
		INT64 = 7,
		/**
		 * a #GObject.
		 */
		OBJECT = 8,
		/**
		 * a %NULL terminated char **. Since 2.22
		 */
		STRINGV = 9
	}

	/**
	 * Specifies what type of event a monitor event is.
	 */
	enum FileMonitorEvent {
		/**
		 * a file changed.
		 */
		CHANGED = 0,
		/**
		 * a hint that this was probably the last change in a set of changes.
		 */
		CHANGES_DONE_HINT = 1,
		/**
		 * a file was deleted.
		 */
		DELETED = 2,
		/**
		 * a file was created.
		 */
		CREATED = 3,
		/**
		 * a file attribute was changed.
		 */
		ATTRIBUTE_CHANGED = 4,
		/**
		 * the file location will soon be unmounted.
		 */
		PRE_UNMOUNT = 5,
		/**
		 * the file location was unmounted.
		 */
		UNMOUNTED = 6,
		/**
		 * the file was moved -- only sent if the
		 *   (deprecated) %G_FILE_MONITOR_SEND_MOVED flag is set
		 */
		MOVED = 7,
		/**
		 * the file was renamed within the
		 *   current directory -- only sent if the %G_FILE_MONITOR_WATCH_MOVES
		 *   flag is set.  Since: 2.46.
		 */
		RENAMED = 8,
		/**
		 * the file was moved into the
		 *   monitored directory from another location -- only sent if the
		 *   %G_FILE_MONITOR_WATCH_MOVES flag is set.  Since: 2.46.
		 */
		MOVED_IN = 9,
		/**
		 * the file was moved out of the
		 *   monitored directory to another location -- only sent if the
		 *   %G_FILE_MONITOR_WATCH_MOVES flag is set.  Since: 2.46
		 */
		MOVED_OUT = 10
	}

	/**
	 * Indicates the file's on-disk type.
	 * 
	 * On Windows systems a file will never have %G_FILE_TYPE_SYMBOLIC_LINK type;
	 * use #GFileInfo and %G_FILE_ATTRIBUTE_STANDARD_IS_SYMLINK to determine
	 * whether a file is a symlink or not. This is due to the fact that NTFS does
	 * not have a single filesystem object type for symbolic links - it has
	 * files that symlink to files, and directories that symlink to directories.
	 * #GFileType enumeration cannot precisely represent this important distinction,
	 * which is why all Windows symlinks will continue to be reported as
	 * %G_FILE_TYPE_REGULAR or %G_FILE_TYPE_DIRECTORY.
	 */
	enum FileType {
		/**
		 * File's type is unknown.
		 */
		UNKNOWN = 0,
		/**
		 * File handle represents a regular file.
		 */
		REGULAR = 1,
		/**
		 * File handle represents a directory.
		 */
		DIRECTORY = 2,
		/**
		 * File handle represents a symbolic link
		 *    (Unix systems).
		 */
		SYMBOLIC_LINK = 3,
		/**
		 * File is a "special" file, such as a socket, fifo,
		 *    block device, or character device.
		 */
		SPECIAL = 4,
		/**
		 * File is a shortcut (Windows systems).
		 */
		SHORTCUT = 5,
		/**
		 * File is a mountable location.
		 */
		MOUNTABLE = 6
	}

	/**
	 * Indicates a hint from the file system whether files should be
	 * previewed in a file manager. Returned as the value of the key
	 * #G_FILE_ATTRIBUTE_FILESYSTEM_USE_PREVIEW.
	 */
	enum FilesystemPreviewType {
		/**
		 * Only preview files if user has explicitly requested it.
		 */
		IF_ALWAYS = 0,
		/**
		 * Preview files if user has requested preview of "local" files.
		 */
		IF_LOCAL = 1,
		/**
		 * Never preview files.
		 */
		NEVER = 2
	}

	/**
	 * Error codes returned by GIO functions.
	 * 
	 * Note that this domain may be extended in future GLib releases. In
	 * general, new error codes either only apply to new APIs, or else
	 * replace %G_IO_ERROR_FAILED in cases that were not explicitly
	 * distinguished before. You should therefore avoid writing code like
	 * |[<!-- language="C" -->
	 * if (g_error_matches (error, G_IO_ERROR, G_IO_ERROR_FAILED))
	 *   {
	 *     // Assume that this is EPRINTERONFIRE
	 *     ...
	 *   }
	 * ]|
	 * but should instead treat all unrecognized error codes the same as
	 * #G_IO_ERROR_FAILED.
	 * 
	 * See also #GPollableReturn for a cheaper way of returning
	 * %G_IO_ERROR_WOULD_BLOCK to callers without allocating a #GError.
	 */
	enum IOErrorEnum {
		/**
		 * Generic error condition for when an operation fails
		 *     and no more specific #GIOErrorEnum value is defined.
		 */
		FAILED = 0,
		/**
		 * File not found.
		 */
		NOT_FOUND = 1,
		/**
		 * File already exists.
		 */
		EXISTS = 2,
		/**
		 * File is a directory.
		 */
		IS_DIRECTORY = 3,
		/**
		 * File is not a directory.
		 */
		NOT_DIRECTORY = 4,
		/**
		 * File is a directory that isn't empty.
		 */
		NOT_EMPTY = 5,
		/**
		 * File is not a regular file.
		 */
		NOT_REGULAR_FILE = 6,
		/**
		 * File is not a symbolic link.
		 */
		NOT_SYMBOLIC_LINK = 7,
		/**
		 * File cannot be mounted.
		 */
		NOT_MOUNTABLE_FILE = 8,
		/**
		 * Filename is too many characters.
		 */
		FILENAME_TOO_LONG = 9,
		/**
		 * Filename is invalid or contains invalid characters.
		 */
		INVALID_FILENAME = 10,
		/**
		 * File contains too many symbolic links.
		 */
		TOO_MANY_LINKS = 11,
		/**
		 * No space left on drive.
		 */
		NO_SPACE = 12,
		/**
		 * Invalid argument.
		 */
		INVALID_ARGUMENT = 13,
		/**
		 * Permission denied.
		 */
		PERMISSION_DENIED = 14,
		/**
		 * Operation (or one of its parameters) not supported
		 */
		NOT_SUPPORTED = 15,
		/**
		 * File isn't mounted.
		 */
		NOT_MOUNTED = 16,
		/**
		 * File is already mounted.
		 */
		ALREADY_MOUNTED = 17,
		/**
		 * File was closed.
		 */
		CLOSED = 18,
		/**
		 * Operation was cancelled. See #GCancellable.
		 */
		CANCELLED = 19,
		/**
		 * Operations are still pending.
		 */
		PENDING = 20,
		/**
		 * File is read only.
		 */
		READ_ONLY = 21,
		/**
		 * Backup couldn't be created.
		 */
		CANT_CREATE_BACKUP = 22,
		/**
		 * File's Entity Tag was incorrect.
		 */
		WRONG_ETAG = 23,
		/**
		 * Operation timed out.
		 */
		TIMED_OUT = 24,
		/**
		 * Operation would be recursive.
		 */
		WOULD_RECURSE = 25,
		/**
		 * File is busy.
		 */
		BUSY = 26,
		/**
		 * Operation would block.
		 */
		WOULD_BLOCK = 27,
		/**
		 * Host couldn't be found (remote operations).
		 */
		HOST_NOT_FOUND = 28,
		/**
		 * Operation would merge files.
		 */
		WOULD_MERGE = 29,
		/**
		 * Operation failed and a helper program has
		 *     already interacted with the user. Do not display any error dialog.
		 */
		FAILED_HANDLED = 30,
		/**
		 * The current process has too many files
		 *     open and can't open any more. Duplicate descriptors do count toward
		 *     this limit. Since 2.20
		 */
		TOO_MANY_OPEN_FILES = 31,
		/**
		 * The object has not been initialized. Since 2.22
		 */
		NOT_INITIALIZED = 32,
		/**
		 * The requested address is already in use. Since 2.22
		 */
		ADDRESS_IN_USE = 33,
		/**
		 * Need more input to finish operation. Since 2.24
		 */
		PARTIAL_INPUT = 34,
		/**
		 * The input data was invalid. Since 2.24
		 */
		INVALID_DATA = 35,
		/**
		 * A remote object generated an error that
		 *     doesn't correspond to a locally registered #GError error
		 *     domain. Use {@link G.dbus_error_get_remote_error} to extract the D-Bus
		 *     error name and g_dbus_error_strip_remote_error() to fix up the
		 *     message so it matches what was received on the wire. Since 2.26.
		 */
		DBUS_ERROR = 36,
		/**
		 * Host unreachable. Since 2.26
		 */
		HOST_UNREACHABLE = 37,
		/**
		 * Network unreachable. Since 2.26
		 */
		NETWORK_UNREACHABLE = 38,
		/**
		 * Connection refused. Since 2.26
		 */
		CONNECTION_REFUSED = 39,
		/**
		 * Connection to proxy server failed. Since 2.26
		 */
		PROXY_FAILED = 40,
		/**
		 * Proxy authentication failed. Since 2.26
		 */
		PROXY_AUTH_FAILED = 41,
		/**
		 * Proxy server needs authentication. Since 2.26
		 */
		PROXY_NEED_AUTH = 42,
		/**
		 * Proxy connection is not allowed by ruleset.
		 *     Since 2.26
		 */
		PROXY_NOT_ALLOWED = 43,
		/**
		 * Broken pipe. Since 2.36
		 */
		BROKEN_PIPE = 44,
		/**
		 * Connection closed by peer. Note that this
		 *     is the same code as %G_IO_ERROR_BROKEN_PIPE; before 2.44 some
		 *     "connection closed" errors returned %G_IO_ERROR_BROKEN_PIPE, but others
		 *     returned %G_IO_ERROR_FAILED. Now they should all return the same
		 *     value, which has this more logical name. Since 2.44.
		 */
		CONNECTION_CLOSED = 44,
		/**
		 * Transport endpoint is not connected. Since 2.44
		 */
		NOT_CONNECTED = 45,
		/**
		 * Message too large. Since 2.48.
		 */
		MESSAGE_TOO_LARGE = 46
	}

	/**
	 * Flags for use with {@link G.io_module_scope_new}.
	 */
	enum IOModuleScopeFlags {
		/**
		 * No module scan flags
		 */
		NONE = 0,
		/**
		 * When using this scope to load or
		 *     scan modules, automatically block a modules which has the same base
		 *     basename as previously loaded module.
		 */
		BLOCK_DUPLICATES = 1
	}

	/**
	 * Memory availability warning levels.
	 * 
	 * Note that because new values might be added, it is recommended that applications check
	 * #GMemoryMonitorWarningLevel as ranges, for example:
	 * |[<!-- language="C" -->
	 * if (warning_level > G_MEMORY_MONITOR_WARNING_LEVEL_LOW)
	 *   drop_caches ();
	 * ]|
	 */
	enum MemoryMonitorWarningLevel {
		/**
		 * Memory on the device is low, processes
		 *   should free up unneeded resources (for example, in-memory caches) so they can
		 *   be used elsewhere.
		 */
		LOW = 50,
		/**
		 * Same as #G_MEMORY_MONITOR_WARNING_LEVEL_LOW
		 *   but the device has even less free memory, so processes should try harder to free
		 *   up unneeded resources. If your process does not need to stay running, it is a
		 *   good time for it to quit.
		 */
		MEDIUM = 100,
		/**
		 * The system will soon start terminating
		 *   processes to reclaim memory, including background processes.
		 */
		CRITICAL = 255
	}

	/**
	 * #GMountOperationResult is returned as a result when a request for
	 * information is send by the mounting operation.
	 */
	enum MountOperationResult {
		/**
		 * The request was fulfilled and the
		 *     user specified data is now available
		 */
		HANDLED = 0,
		/**
		 * The user requested the mount operation
		 *     to be aborted
		 */
		ABORTED = 1,
		/**
		 * The request was unhandled (i.e. not
		 *     implemented)
		 */
		UNHANDLED = 2
	}

	/**
	 * The host's network connectivity state, as reported by #GNetworkMonitor.
	 */
	enum NetworkConnectivity {
		/**
		 * The host is not configured with a
		 *   route to the Internet; it may or may not be connected to a local
		 *   network.
		 */
		LOCAL = 1,
		/**
		 * The host is connected to a network, but
		 *   does not appear to be able to reach the full Internet, perhaps
		 *   due to upstream network problems.
		 */
		LIMITED = 2,
		/**
		 * The host is behind a captive portal and
		 *   cannot reach the full Internet.
		 */
		PORTAL = 3,
		/**
		 * The host is connected to a network, and
		 *   appears to be able to reach the full Internet.
		 */
		FULL = 4
	}

	/**
	 * Priority levels for #GNotifications.
	 */
	enum NotificationPriority {
		/**
		 * the default priority, to be used for the
		 *   majority of notifications (for example email messages, software updates,
		 *   completed download/sync operations)
		 */
		NORMAL = 0,
		/**
		 * for notifications that do not require
		 *   immediate attention - typically used for contextual background
		 *   information, such as contact birthdays or local weather
		 */
		LOW = 1,
		/**
		 * for events that require more attention,
		 *   usually because responses are time-sensitive (for example chat and SMS
		 *   messages or alarms)
		 */
		HIGH = 2,
		/**
		 * for urgent notifications, or notifications
		 *   that require a response in a short space of time (for example phone calls
		 *   or emergency warnings)
		 */
		URGENT = 3
	}

	/**
	 * #GPasswordSave is used to indicate the lifespan of a saved password.
	 * 
	 * #Gvfs stores passwords in the Gnome keyring when this flag allows it
	 * to, and later retrieves it again from there.
	 */
	enum PasswordSave {
		/**
		 * never save a password.
		 */
		NEVER = 0,
		/**
		 * save a password for the session.
		 */
		FOR_SESSION = 1,
		/**
		 * save a password permanently.
		 */
		PERMANENTLY = 2
	}

	/**
	 * Return value for various IO operations that signal errors via the
	 * return value and not necessarily via a #GError.
	 * 
	 * This enum exists to be able to return errors to callers without having to
	 * allocate a #GError. Allocating #GErrors can be quite expensive for
	 * regularly happening errors like %G_IO_ERROR_WOULD_BLOCK.
	 * 
	 * In case of %G_POLLABLE_RETURN_FAILED a #GError should be set for the
	 * operation to give details about the error that happened.
	 */
	enum PollableReturn {
		/**
		 * Generic error condition for when an operation fails.
		 */
		FAILED = 0,
		/**
		 * The operation was successfully finished.
		 */
		OK = 1,
		/**
		 * The operation would block.
		 */
		WOULD_BLOCK = -27
	}

	/**
	 * An error code used with %G_RESOLVER_ERROR in a #GError returned
	 * from a #GResolver routine.
	 */
	enum ResolverError {
		/**
		 * the requested name/address/service was not
		 *     found
		 */
		NOT_FOUND = 0,
		/**
		 * the requested information could not
		 *     be looked up due to a network error or similar problem
		 */
		TEMPORARY_FAILURE = 1,
		/**
		 * unknown error
		 */
		INTERNAL = 2
	}

	/**
	 * The type of record that {@link G.resolver_lookup_records} or
	 * g_resolver_lookup_records_async() should retrieve. The records are returned
	 * as lists of #GVariant tuples. Each record type has different values in
	 * the variant tuples returned.
	 * 
	 * %G_RESOLVER_RECORD_SRV records are returned as variants with the signature
	 * `(qqqs)`, containing a `guint16` with the priority, a `guint16` with the
	 * weight, a `guint16` with the port, and a string of the hostname.
	 * 
	 * %G_RESOLVER_RECORD_MX records are returned as variants with the signature
	 * `(qs)`, representing a `guint16` with the preference, and a string containing
	 * the mail exchanger hostname.
	 * 
	 * %G_RESOLVER_RECORD_TXT records are returned as variants with the signature
	 * `(as)`, representing an array of the strings in the text record. Note: Most TXT
	 * records only contain a single string, but
	 * [RFC 1035](https://tools.ietf.org/html/rfc1035#section-3.3.14) does allow a
	 * record to contain multiple strings. The RFC which defines the interpretation
	 * of a specific TXT record will likely require concatenation of multiple
	 * strings if they are present, as with
	 * [RFC 7208](https://tools.ietf.org/html/rfc7208#section-3.3).
	 * 
	 * %G_RESOLVER_RECORD_SOA records are returned as variants with the signature
	 * `(ssuuuuu)`, representing a string containing the primary name server, a
	 * string containing the administrator, the serial as a `guint32`, the refresh
	 * interval as a `guint32`, the retry interval as a `guint32`, the expire timeout
	 * as a `guint32`, and the TTL as a `guint32`.
	 * 
	 * %G_RESOLVER_RECORD_NS records are returned as variants with the signature
	 * `(s)`, representing a string of the hostname of the name server.
	 */
	enum ResolverRecordType {
		/**
		 * look up DNS SRV records for a domain
		 */
		SRV = 1,
		/**
		 * look up DNS MX records for a domain
		 */
		MX = 2,
		/**
		 * look up DNS TXT records for a name
		 */
		TXT = 3,
		/**
		 * look up DNS SOA records for a zone
		 */
		SOA = 4,
		/**
		 * look up DNS NS records for a domain
		 */
		NS = 5
	}

	/**
	 * An error code used with %G_RESOURCE_ERROR in a #GError returned
	 * from a #GResource routine.
	 */
	enum ResourceError {
		/**
		 * no file was found at the requested path
		 */
		NOT_FOUND = 0,
		/**
		 * unknown error
		 */
		INTERNAL = 1
	}

	/**
	 * Describes an event occurring on a #GSocketClient. See the
	 * #GSocketClient::event signal for more details.
	 * 
	 * Additional values may be added to this type in the future.
	 */
	enum SocketClientEvent {
		/**
		 * The client is doing a DNS lookup.
		 */
		RESOLVING = 0,
		/**
		 * The client has completed a DNS lookup.
		 */
		RESOLVED = 1,
		/**
		 * The client is connecting to a remote
		 *   host (either a proxy or the destination server).
		 */
		CONNECTING = 2,
		/**
		 * The client has connected to a remote
		 *   host.
		 */
		CONNECTED = 3,
		/**
		 * The client is negotiating
		 *   with a proxy to connect to the destination server.
		 */
		PROXY_NEGOTIATING = 4,
		/**
		 * The client has negotiated
		 *   with the proxy server.
		 */
		PROXY_NEGOTIATED = 5,
		/**
		 * The client is performing a
		 *   TLS handshake.
		 */
		TLS_HANDSHAKING = 6,
		/**
		 * The client has performed a
		 *   TLS handshake.
		 */
		TLS_HANDSHAKED = 7,
		/**
		 * The client is done with a particular
		 *   #GSocketConnectable.
		 */
		COMPLETE = 8
	}

	/**
	 * The protocol family of a #GSocketAddress. (These values are
	 * identical to the system defines %AF_INET, %AF_INET6 and %AF_UNIX,
	 * if available.)
	 */
	enum SocketFamily {
		/**
		 * no address family
		 */
		INVALID = 0,
		/**
		 * the UNIX domain family
		 */
		UNIX = 1,
		/**
		 * the IPv4 family
		 */
		IPV4 = 2,
		/**
		 * the IPv6 family
		 */
		IPV6 = 10
	}

	/**
	 * Describes an event occurring on a #GSocketListener. See the
	 * #GSocketListener::event signal for more details.
	 * 
	 * Additional values may be added to this type in the future.
	 */
	enum SocketListenerEvent {
		/**
		 * The listener is about to bind a socket.
		 */
		BINDING = 0,
		/**
		 * The listener has bound a socket.
		 */
		BOUND = 1,
		/**
		 * The listener is about to start
		 *    listening on this socket.
		 */
		LISTENING = 2,
		/**
		 * The listener is now listening on
		 *   this socket.
		 */
		LISTENED = 3
	}

	/**
	 * A protocol identifier is specified when creating a #GSocket, which is a
	 * family/type specific identifier, where 0 means the default protocol for
	 * the particular family/type.
	 * 
	 * This enum contains a set of commonly available and used protocols. You
	 * can also pass any other identifiers handled by the platform in order to
	 * use protocols not listed here.
	 */
	enum SocketProtocol {
		/**
		 * The protocol type is unknown
		 */
		UNKNOWN = -1,
		/**
		 * The default protocol for the family/type
		 */
		DEFAULT = 0,
		/**
		 * TCP over IP
		 */
		TCP = 6,
		/**
		 * UDP over IP
		 */
		UDP = 17,
		/**
		 * SCTP over IP
		 */
		SCTP = 132
	}

	/**
	 * Flags used when creating a #GSocket. Some protocols may not implement
	 * all the socket types.
	 */
	enum SocketType {
		/**
		 * Type unknown or wrong
		 */
		INVALID = 0,
		/**
		 * Reliable connection-based byte streams (e.g. TCP).
		 */
		STREAM = 1,
		/**
		 * Connectionless, unreliable datagram passing.
		 *     (e.g. UDP)
		 */
		DATAGRAM = 2,
		/**
		 * Reliable connection-based passing of datagrams
		 *     of fixed maximum length (e.g. SCTP).
		 */
		SEQPACKET = 3
	}

	/**
	 * The client authentication mode for a #GTlsServerConnection.
	 */
	enum TlsAuthenticationMode {
		/**
		 * client authentication not required
		 */
		NONE = 0,
		/**
		 * client authentication is requested
		 */
		REQUESTED = 1,
		/**
		 * client authentication is required
		 */
		REQUIRED = 2
	}

	/**
	 * Flags for {@link G.tls_interaction_request_certificate},
	 * g_tls_interaction_request_certificate_async(), and
	 * g_tls_interaction_invoke_request_certificate().
	 */
	enum TlsCertificateRequestFlags {
		/**
		 * No flags
		 */
		NONE = 0
	}

	/**
	 * An error code used with %G_TLS_CHANNEL_BINDING_ERROR in a #GError to
	 * indicate a TLS channel binding retrieval error.
	 */
	enum TlsChannelBindingError {
		/**
		 * Either entire binding
		 *    retrieval facility or specific binding type is not implemented in the
		 *    TLS backend.
		 */
		NOT_IMPLEMENTED = 0,
		/**
		 * The handshake is not yet
		 *    complete on the connection which is a strong requirement for any existing
		 *    binding type.
		 */
		INVALID_STATE = 1,
		/**
		 * Handshake is complete but
		 *    binding data is not available. That normally indicates the TLS
		 *    implementation failed to provide the binding data. For example, some
		 *    implementations do not provide a peer certificate for resumed connections.
		 */
		NOT_AVAILABLE = 2,
		/**
		 * Binding type is not supported
		 *    on the current connection. This error could be triggered when requesting
		 *    `tls-server-end-point` binding data for a certificate which has no hash
		 *    function or uses multiple hash functions.
		 */
		NOT_SUPPORTED = 3,
		/**
		 * Any other backend error
		 *    preventing binding data retrieval.
		 */
		GENERAL_ERROR = 4
	}

	/**
	 * The type of TLS channel binding data to retrieve from #GTlsConnection
	 * or #GDtlsConnection, as documented by RFC 5929. The
	 * [`tls-unique-for-telnet`](https://tools.ietf.org/html/rfc5929#section-5)
	 * binding type is not currently implemented.
	 */
	enum TlsChannelBindingType {
		/**
		 * [`tls-unique`](https://tools.ietf.org/html/rfc5929#section-3) binding
		 *    type
		 */
		UNIQUE = 0,
		/**
		 * [`tls-server-end-point`](https://tools.ietf.org/html/rfc5929#section-4)
		 *    binding type
		 */
		SERVER_END_POINT = 1
	}

	/**
	 * Flags for {@link G.tls_database_lookup_certificate_for_handle},
	 * g_tls_database_lookup_certificate_issuer(),
	 * and g_tls_database_lookup_certificates_issued_by().
	 */
	enum TlsDatabaseLookupFlags {
		/**
		 * No lookup flags
		 */
		NONE = 0,
		/**
		 * Restrict lookup to certificates that have
		 *     a private key.
		 */
		KEYPAIR = 1
	}

	/**
	 * An error code used with %G_TLS_ERROR in a #GError returned from a
	 * TLS-related routine.
	 */
	enum TlsError {
		/**
		 * No TLS provider is available
		 */
		UNAVAILABLE = 0,
		/**
		 * Miscellaneous TLS error
		 */
		MISC = 1,
		/**
		 * The certificate presented could not
		 *   be parsed or failed validation.
		 */
		BAD_CERTIFICATE = 2,
		/**
		 * The TLS handshake failed because the
		 *   peer does not seem to be a TLS server.
		 */
		NOT_TLS = 3,
		/**
		 * The TLS handshake failed because the
		 *   peer's certificate was not acceptable.
		 */
		HANDSHAKE = 4,
		/**
		 * The TLS handshake failed because
		 *   the server requested a client-side certificate, but none was
		 *   provided. See {@link G.tls_connection_set_certificate}.
		 */
		CERTIFICATE_REQUIRED = 5,
		/**
		 * The TLS connection was closed without proper
		 *   notice, which may indicate an attack. See
		 *   {@link G.tls_connection_set_require_close_notify}.
		 */
		EOF = 6,
		/**
		 * The TLS handshake failed
		 *   because the client sent the fallback SCSV, indicating a protocol
		 *   downgrade attack. Since: 2.60
		 */
		INAPPROPRIATE_FALLBACK = 7
	}

	/**
	 * #GTlsInteractionResult is returned by various functions in #GTlsInteraction
	 * when finishing an interaction request.
	 */
	enum TlsInteractionResult {
		/**
		 * The interaction was unhandled (i.e. not
		 *     implemented).
		 */
		UNHANDLED = 0,
		/**
		 * The interaction completed, and resulting data
		 *     is available.
		 */
		HANDLED = 1,
		/**
		 * The interaction has failed, or was cancelled.
		 *     and the operation should be aborted.
		 */
		FAILED = 2
	}

	/**
	 * The TLS or DTLS protocol version used by a #GTlsConnection or
	 * #GDtlsConnection. The integer values of these versions are sequential
	 * to ensure newer known protocol versions compare greater than older
	 * known versions. Any known DTLS protocol version will compare greater
	 * than any SSL or TLS protocol version. The protocol version may be
	 * %G_TLS_PROTOCOL_VERSION_UNKNOWN if the TLS backend supports a newer
	 * protocol version that GLib does not yet know about. This means that
	 * it's possible for an unknown DTLS protocol version to compare less
	 * than the TLS protocol versions.
	 */
	enum TlsProtocolVersion {
		/**
		 * No protocol version or unknown protocol version
		 */
		UNKNOWN = 0,
		/**
		 * SSL 3.0, which is insecure and should not be used
		 */
		SSL_3_0 = 1,
		/**
		 * TLS 1.0, which is insecure and should not be used
		 */
		TLS_1_0 = 2,
		/**
		 * TLS 1.1, which is insecure and should not be used
		 */
		TLS_1_1 = 3,
		/**
		 * TLS 1.2, defined by [RFC 5246](https://datatracker.ietf.org/doc/html/rfc5246)
		 */
		TLS_1_2 = 4,
		/**
		 * TLS 1.3, defined by [RFC 8446](https://datatracker.ietf.org/doc/html/rfc8446)
		 */
		TLS_1_3 = 5,
		/**
		 * DTLS 1.0, which is insecure and should not be used
		 */
		DTLS_1_0 = 201,
		/**
		 * DTLS 1.2, defined by [RFC 6347](https://datatracker.ietf.org/doc/html/rfc6347)
		 */
		DTLS_1_2 = 202
	}

	/**
	 * When to allow rehandshaking. See
	 * {@link G.tls_connection_set_rehandshake_mode}.
	 */
	enum TlsRehandshakeMode {
		/**
		 * Never allow rehandshaking
		 */
		NEVER = 0,
		/**
		 * Allow safe rehandshaking only
		 */
		SAFELY = 1,
		/**
		 * Allow unsafe rehandshaking
		 */
		UNSAFELY = 2
	}

	/**
	 * The type of name used by a #GUnixSocketAddress.
	 * %G_UNIX_SOCKET_ADDRESS_PATH indicates a traditional unix domain
	 * socket bound to a filesystem path. %G_UNIX_SOCKET_ADDRESS_ANONYMOUS
	 * indicates a socket not bound to any name (eg, a client-side socket,
	 * or a socket created with socketpair()).
	 * 
	 * For abstract sockets, there are two incompatible ways of naming
	 * them; the man pages suggest using the entire `struct sockaddr_un`
	 * as the name, padding the unused parts of the %sun_path field with
	 * zeroes; this corresponds to %G_UNIX_SOCKET_ADDRESS_ABSTRACT_PADDED.
	 * However, many programs instead just use a portion of %sun_path, and
	 * pass an appropriate smaller length to bind() or connect(). This is
	 * %G_UNIX_SOCKET_ADDRESS_ABSTRACT.
	 */
	enum UnixSocketAddressType {
		/**
		 * invalid
		 */
		INVALID = 0,
		/**
		 * anonymous
		 */
		ANONYMOUS = 1,
		/**
		 * a filesystem path
		 */
		PATH = 2,
		/**
		 * an abstract name
		 */
		ABSTRACT = 3,
		/**
		 * an abstract name, 0-padded
		 *   to the full length of a unix socket name
		 */
		ABSTRACT_PADDED = 4
	}

	/**
	 * Used to select the type of data format to use for #GZlibDecompressor
	 * and #GZlibCompressor.
	 */
	enum ZlibCompressorFormat {
		/**
		 * deflate compression with zlib header
		 */
		ZLIB = 0,
		/**
		 * gzip file format
		 */
		GZIP = 1,
		/**
		 * deflate compression with no header
		 */
		RAW = 2
	}

	/**
	 * Flags used when creating a #GAppInfo.
	 */
	enum AppInfoCreateFlags {
		/**
		 * No flags.
		 */
		NONE = 0,
		/**
		 * Application opens in a terminal window.
		 */
		NEEDS_TERMINAL = 1,
		/**
		 * Application supports URI arguments.
		 */
		SUPPORTS_URIS = 2,
		/**
		 * Application supports startup notification. Since 2.26
		 */
		SUPPORTS_STARTUP_NOTIFICATION = 4
	}

	/**
	 * Flags used to define the behaviour of a #GApplication.
	 */
	enum ApplicationFlags {
		/**
		 * Default
		 */
		FLAGS_NONE = 0,
		/**
		 * Run as a service. In this mode, registration
		 *      fails if the service is already running, and the application
		 *      will initially wait up to 10 seconds for an initial activation
		 *      message to arrive.
		 */
		IS_SERVICE = 1,
		/**
		 * Don't try to become the primary instance.
		 */
		IS_LAUNCHER = 2,
		/**
		 * This application handles opening files (in
		 *     the primary instance). Note that this flag only affects the default
		 *     implementation of {@link Local.command_line}, and has no effect if
		 *     %G_APPLICATION_HANDLES_COMMAND_LINE is given.
		 *     See g_application_run() for details.
		 */
		HANDLES_OPEN = 4,
		/**
		 * This application handles command line
		 *     arguments (in the primary instance). Note that this flag only affect
		 *     the default implementation of {@link Local.command_line}.
		 *     See g_application_run() for details.
		 */
		HANDLES_COMMAND_LINE = 8,
		/**
		 * Send the environment of the
		 *     launching process to the primary instance. Set this flag if your
		 *     application is expected to behave differently depending on certain
		 *     environment variables. For instance, an editor might be expected
		 *     to use the `GIT_COMMITTER_NAME` environment variable
		 *     when editing a git commit message. The environment is available
		 *     to the #GApplication::command-line signal handler, via
		 *     {@link G.application_command_line_getenv}.
		 */
		SEND_ENVIRONMENT = 16,
		/**
		 * Make no attempts to do any of the typical
		 *     single-instance application negotiation, even if the application
		 *     ID is given.  The application neither attempts to become the
		 *     owner of the application ID nor does it check if an existing
		 *     owner already exists.  Everything occurs in the local process.
		 *     Since: 2.30.
		 */
		NON_UNIQUE = 32,
		/**
		 * Allow users to override the
		 *     application ID from the command line with `--gapplication-app-id`.
		 *     Since: 2.48
		 */
		CAN_OVERRIDE_APP_ID = 64,
		/**
		 * Allow another instance to take over
		 *     the bus name. Since: 2.60
		 */
		ALLOW_REPLACEMENT = 128,
		/**
		 * Take over from another instance. This flag is
		 *     usually set by passing `--gapplication-replace` on the commandline.
		 *     Since: 2.60
		 */
		REPLACE = 256
	}

	/**
	 * #GAskPasswordFlags are used to request specific information from the
	 * user, or to notify the user of their choices in an authentication
	 * situation.
	 */
	enum AskPasswordFlags {
		/**
		 * operation requires a password.
		 */
		NEED_PASSWORD = 1,
		/**
		 * operation requires a username.
		 */
		NEED_USERNAME = 2,
		/**
		 * operation requires a domain.
		 */
		NEED_DOMAIN = 4,
		/**
		 * operation supports saving settings.
		 */
		SAVING_SUPPORTED = 8,
		/**
		 * operation supports anonymous users.
		 */
		ANONYMOUS_SUPPORTED = 16,
		/**
		 * operation takes TCRYPT parameters (Since: 2.58)
		 */
		TCRYPT = 32
	}

	/**
	 * Flags used in {@link G.bus_own_name}.
	 */
	enum BusNameOwnerFlags {
		/**
		 * No flags set.
		 */
		NONE = 0,
		/**
		 * Allow another message bus connection to claim the name.
		 */
		ALLOW_REPLACEMENT = 1,
		/**
		 * If another message bus connection owns the name and have
		 * specified #G_BUS_NAME_OWNER_FLAGS_ALLOW_REPLACEMENT, then take the name from the other connection.
		 */
		REPLACE = 2,
		/**
		 * If another message bus connection owns the name, immediately
		 * return an error from {@link G.bus_own_name} rather than entering the waiting queue for that name. (Since 2.54)
		 */
		DO_NOT_QUEUE = 4
	}

	/**
	 * Flags used in {@link G.bus_watch_name}.
	 */
	enum BusNameWatcherFlags {
		/**
		 * No flags set.
		 */
		NONE = 0,
		/**
		 * If no-one owns the name when
		 * beginning to watch the name, ask the bus to launch an owner for the
		 * name.
		 */
		AUTO_START = 1
	}

	/**
	 * Flags used when calling a {@link G.converter_convert}.
	 */
	enum ConverterFlags {
		/**
		 * No flags.
		 */
		NONE = 0,
		/**
		 * At end of input data
		 */
		INPUT_AT_END = 1,
		/**
		 * Flush data
		 */
		FLUSH = 2
	}

	/**
	 * Flags used in {@link G.dbus_connection_call} and similar APIs.
	 */
	enum DBusCallFlags {
		/**
		 * No flags set.
		 */
		NONE = 0,
		/**
		 * The bus must not launch
		 * an owner for the destination name in response to this method
		 * invocation.
		 */
		NO_AUTO_START = 1,
		/**
		 * the caller is prepared to
		 * wait for interactive authorization. Since 2.46.
		 */
		ALLOW_INTERACTIVE_AUTHORIZATION = 2
	}

	/**
	 * Capabilities negotiated with the remote peer.
	 */
	enum DBusCapabilityFlags {
		/**
		 * No flags set.
		 */
		NONE = 0,
		/**
		 * The connection
		 * supports exchanging UNIX file descriptors with the remote peer.
		 */
		UNIX_FD_PASSING = 1
	}

	/**
	 * Flags used when creating a new #GDBusConnection.
	 */
	enum DBusConnectionFlags {
		/**
		 * No flags set.
		 */
		NONE = 0,
		/**
		 * Perform authentication against server.
		 */
		AUTHENTICATION_CLIENT = 1,
		/**
		 * Perform authentication against client.
		 */
		AUTHENTICATION_SERVER = 2,
		/**
		 * When
		 * authenticating as a server, allow the anonymous authentication
		 * method.
		 */
		AUTHENTICATION_ALLOW_ANONYMOUS = 4,
		/**
		 * Pass this flag if connecting to a peer that is a
		 * message bus. This means that the Hello() method will be invoked as part of the connection setup.
		 */
		MESSAGE_BUS_CONNECTION = 8,
		/**
		 * If set, processing of D-Bus messages is
		 * delayed until {@link G.dbus_connection_start_message_processing} is called.
		 */
		DELAY_MESSAGE_PROCESSING = 16,
		/**
		 * When authenticating
		 * as a server, require the UID of the peer to be the same as the UID of the server. (Since: 2.68)
		 */
		AUTHENTICATION_REQUIRE_SAME_USER = 32
	}

	/**
	 * Flags describing the behavior of a #GDBusInterfaceSkeleton instance.
	 */
	enum DBusInterfaceSkeletonFlags {
		/**
		 * No flags set.
		 */
		NONE = 0,
		/**
		 * Each method invocation is handled in
		 *   a thread dedicated to the invocation. This means that the method implementation can use blocking IO
		 *   without blocking any other part of the process. It also means that the method implementation must
		 *   use locking to access data structures used by other threads.
		 */
		HANDLE_METHOD_INVOCATIONS_IN_THREAD = 1
	}

	/**
	 * Message flags used in #GDBusMessage.
	 */
	enum DBusMessageFlags {
		/**
		 * No flags set.
		 */
		NONE = 0,
		/**
		 * A reply is not expected.
		 */
		NO_REPLY_EXPECTED = 1,
		/**
		 * The bus must not launch an
		 * owner for the destination name in response to this message.
		 */
		NO_AUTO_START = 2,
		/**
		 * If set on a method
		 * call, this flag means that the caller is prepared to wait for interactive
		 * authorization. Since 2.46.
		 */
		ALLOW_INTERACTIVE_AUTHORIZATION = 4
	}

	/**
	 * Flags used when constructing a #GDBusObjectManagerClient.
	 */
	enum DBusObjectManagerClientFlags {
		/**
		 * No flags set.
		 */
		NONE = 0,
		/**
		 * If not set and the
		 *   manager is for a well-known name, then request the bus to launch
		 *   an owner for the name if no-one owns the name. This flag can only
		 *   be used in managers for well-known names.
		 */
		DO_NOT_AUTO_START = 1
	}

	/**
	 * Flags describing the access control of a D-Bus property.
	 */
	enum DBusPropertyInfoFlags {
		/**
		 * No flags set.
		 */
		NONE = 0,
		/**
		 * Property is readable.
		 */
		READABLE = 1,
		/**
		 * Property is writable.
		 */
		WRITABLE = 2
	}

	/**
	 * Flags used when constructing an instance of a #GDBusProxy derived class.
	 */
	enum DBusProxyFlags {
		/**
		 * No flags set.
		 */
		NONE = 0,
		/**
		 * Don't load properties.
		 */
		DO_NOT_LOAD_PROPERTIES = 1,
		/**
		 * Don't connect to signals on the remote object.
		 */
		DO_NOT_CONNECT_SIGNALS = 2,
		/**
		 * If the proxy is for a well-known name,
		 * do not ask the bus to launch an owner during proxy initialization or a method call.
		 * This flag is only meaningful in proxies for well-known names.
		 */
		DO_NOT_AUTO_START = 4,
		/**
		 * If set, the property value for any __invalidated property__ will be (asynchronously) retrieved upon receiving the [`PropertiesChanged`](http://dbus.freedesktop.org/doc/dbus-specification.html#standard-interfaces-properties) D-Bus signal and the property will not cause emission of the #GDBusProxy::g-properties-changed signal. When the value is received the #GDBusProxy::g-properties-changed signal is emitted for the property along with the retrieved value. Since 2.32.
		 */
		GET_INVALIDATED_PROPERTIES = 8,
		/**
		 * If the proxy is for a well-known name,
		 * do not ask the bus to launch an owner during proxy initialization, but allow it to be
		 * autostarted by a method call. This flag is only meaningful in proxies for well-known names,
		 * and only if %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START is not also specified.
		 */
		DO_NOT_AUTO_START_AT_CONSTRUCTION = 16
	}

	/**
	 * Flags used when sending #GDBusMessages on a #GDBusConnection.
	 */
	enum DBusSendMessageFlags {
		/**
		 * No flags set.
		 */
		NONE = 0,
		/**
		 * Do not automatically
		 * assign a serial number from the #GDBusConnection object when
		 * sending a message.
		 */
		PRESERVE_SERIAL = 1
	}

	/**
	 * Flags used when creating a #GDBusServer.
	 */
	enum DBusServerFlags {
		/**
		 * No flags set.
		 */
		NONE = 0,
		/**
		 * All #GDBusServer::new-connection
		 * signals will run in separated dedicated threads (see signal for
		 * details).
		 */
		RUN_IN_THREAD = 1,
		/**
		 * Allow the anonymous
		 * authentication method.
		 */
		AUTHENTICATION_ALLOW_ANONYMOUS = 2,
		/**
		 * Require the UID of the
		 * peer to be the same as the UID of the server when authenticating. (Since: 2.68)
		 */
		AUTHENTICATION_REQUIRE_SAME_USER = 4
	}

	/**
	 * Flags used when subscribing to signals via {@link G.dbus_connection_signal_subscribe}.
	 */
	enum DBusSignalFlags {
		/**
		 * No flags set.
		 */
		NONE = 0,
		/**
		 * Don't actually send the AddMatch
		 * D-Bus call for this signal subscription.  This gives you more control
		 * over which match rules you add (but you must add them manually).
		 */
		NO_MATCH_RULE = 1,
		/**
		 * Match first arguments that
		 * contain a bus or interface name with the given namespace.
		 */
		MATCH_ARG0_NAMESPACE = 2,
		/**
		 * Match first arguments that
		 * contain an object path that is either equivalent to the given path,
		 * or one of the paths is a subpath of the other.
		 */
		MATCH_ARG0_PATH = 4
	}

	/**
	 * Flags passed to {@link G.dbus_connection_register_subtree}.
	 */
	enum DBusSubtreeFlags {
		/**
		 * No flags set.
		 */
		NONE = 0,
		/**
		 * Method calls to objects not in the enumerated range
		 *                                                       will still be dispatched. This is useful if you want
		 *                                                       to dynamically spawn objects in the subtree.
		 */
		DISPATCH_TO_UNENUMERATED_NODES = 1
	}

	/**
	 * Flags used when starting a drive.
	 */
	enum DriveStartFlags {
		/**
		 * No flags set.
		 */
		NONE = 0
	}

	/**
	 * Flags specifying the behaviour of an attribute.
	 */
	enum FileAttributeInfoFlags {
		/**
		 * no flags set.
		 */
		NONE = 0,
		/**
		 * copy the attribute values when the file is copied.
		 */
		COPY_WITH_FILE = 1,
		/**
		 * copy the attribute values when the file is moved.
		 */
		COPY_WHEN_MOVED = 2
	}

	/**
	 * Flags used when copying or moving files.
	 */
	enum FileCopyFlags {
		/**
		 * No flags set.
		 */
		NONE = 0,
		/**
		 * Overwrite any existing files
		 */
		OVERWRITE = 1,
		/**
		 * Make a backup of any existing files.
		 */
		BACKUP = 2,
		/**
		 * Don't follow symlinks.
		 */
		NOFOLLOW_SYMLINKS = 4,
		/**
		 * Copy all file metadata instead of just default set used for copy (see #GFileInfo).
		 */
		ALL_METADATA = 8,
		/**
		 * Don't use copy and delete fallback if native move not supported.
		 */
		NO_FALLBACK_FOR_MOVE = 16,
		/**
		 * Leaves target file with default perms, instead of setting the source file perms.
		 */
		TARGET_DEFAULT_PERMS = 32
	}

	/**
	 * Flags used when an operation may create a file.
	 */
	enum FileCreateFlags {
		/**
		 * No flags set.
		 */
		NONE = 0,
		/**
		 * Create a file that can only be
		 *    accessed by the current user.
		 */
		PRIVATE = 1,
		/**
		 * Replace the destination
		 *    as if it didn't exist before. Don't try to keep any old
		 *    permissions, replace instead of following links. This
		 *    is generally useful if you're doing a "copy over"
		 *    rather than a "save new version of" replace operation.
		 *    You can think of it as "unlink destination" before
		 *    writing to it, although the implementation may not
		 *    be exactly like that. This flag can only be used with
		 *    {@link G.file_replace} and its variants, including g_file_replace_contents().
		 *    Since 2.20
		 */
		REPLACE_DESTINATION = 2
	}

	/**
	 * Flags that can be used with {@link G.file_measure_disk_usage}.
	 */
	enum FileMeasureFlags {
		/**
		 * No flags set.
		 */
		NONE = 0,
		/**
		 * Report any error encountered
		 *   while traversing the directory tree.  Normally errors are only
		 *   reported for the toplevel file.
		 */
		REPORT_ANY_ERROR = 2,
		/**
		 * Tally usage based on apparent file
		 *   sizes.  Normally, the block-size is used, if available, as this is a
		 *   more accurate representation of disk space used.
		 *   Compare with `du --apparent-size`.
		 */
		APPARENT_SIZE = 4,
		/**
		 * Do not cross mount point boundaries.
		 *   Compare with `du -x`.
		 */
		NO_XDEV = 8
	}

	/**
	 * Flags used to set what a #GFileMonitor will watch for.
	 */
	enum FileMonitorFlags {
		/**
		 * No flags set.
		 */
		NONE = 0,
		/**
		 * Watch for mount events.
		 */
		WATCH_MOUNTS = 1,
		/**
		 * Pair DELETED and CREATED events caused
		 *   by file renames (moves) and send a single G_FILE_MONITOR_EVENT_MOVED
		 *   event instead (NB: not supported on all backends; the default
		 *   behaviour -without specifying this flag- is to send single DELETED
		 *   and CREATED events).  Deprecated since 2.46: use
		 *   %G_FILE_MONITOR_WATCH_MOVES instead.
		 */
		SEND_MOVED = 2,
		/**
		 * Watch for changes to the file made
		 *   via another hard link. Since 2.36.
		 */
		WATCH_HARD_LINKS = 4,
		/**
		 * Watch for rename operations on a
		 *   monitored directory.  This causes %G_FILE_MONITOR_EVENT_RENAMED,
		 *   %G_FILE_MONITOR_EVENT_MOVED_IN and %G_FILE_MONITOR_EVENT_MOVED_OUT
		 *   events to be emitted when possible.  Since: 2.46.
		 */
		WATCH_MOVES = 8
	}

	/**
	 * Flags used when querying a #GFileInfo.
	 */
	enum FileQueryInfoFlags {
		/**
		 * No flags set.
		 */
		NONE = 0,
		/**
		 * Don't follow symlinks.
		 */
		NOFOLLOW_SYMLINKS = 1
	}

	/**
	 * GIOStreamSpliceFlags determine how streams should be spliced.
	 */
	enum IOStreamSpliceFlags {
		/**
		 * Do not close either stream.
		 */
		NONE = 0,
		/**
		 * Close the first stream after
		 *     the splice.
		 */
		CLOSE_STREAM1 = 1,
		/**
		 * Close the second stream after
		 *     the splice.
		 */
		CLOSE_STREAM2 = 2,
		/**
		 * Wait for both splice operations to finish
		 *     before calling the callback.
		 */
		WAIT_FOR_BOTH = 4
	}

	/**
	 * Flags used when mounting a mount.
	 */
	enum MountMountFlags {
		/**
		 * No flags set.
		 */
		NONE = 0
	}

	/**
	 * Flags used when an unmounting a mount.
	 */
	enum MountUnmountFlags {
		/**
		 * No flags set.
		 */
		NONE = 0,
		/**
		 * Unmount even if there are outstanding
		 *  file operations on the mount.
		 */
		FORCE = 1
	}

	/**
	 * GOutputStreamSpliceFlags determine how streams should be spliced.
	 */
	enum OutputStreamSpliceFlags {
		/**
		 * Do not close either stream.
		 */
		NONE = 0,
		/**
		 * Close the source stream after
		 *     the splice.
		 */
		CLOSE_SOURCE = 1,
		/**
		 * Close the target stream after
		 *     the splice.
		 */
		CLOSE_TARGET = 2
	}

	/**
	 * Flags to modify lookup behavior.
	 */
	enum ResolverNameLookupFlags {
		/**
		 * default behavior (same as {@link G.resolver_lookup_by_name})
		 */
		DEFAULT = 0,
		/**
		 * only resolve ipv4 addresses
		 */
		IPV4_ONLY = 1,
		/**
		 * only resolve ipv6 addresses
		 */
		IPV6_ONLY = 2
	}

	/**
	 * GResourceFlags give information about a particular file inside a resource
	 * bundle.
	 */
	enum ResourceFlags {
		/**
		 * No flags set.
		 */
		NONE = 0,
		/**
		 * The file is compressed.
		 */
		COMPRESSED = 1
	}

	/**
	 * GResourceLookupFlags determine how resource path lookups are handled.
	 */
	enum ResourceLookupFlags {
		/**
		 * No flags set.
		 */
		NONE = 0
	}

	/**
	 * Flags used when creating a binding. These flags determine in which
	 * direction the binding works. The default is to synchronize in both
	 * directions.
	 */
	enum SettingsBindFlags {
		/**
		 * Equivalent to `G_SETTINGS_BIND_GET|G_SETTINGS_BIND_SET`
		 */
		DEFAULT = 0,
		/**
		 * Update the #GObject property when the setting changes.
		 *     It is an error to use this flag if the property is not writable.
		 */
		GET = 1,
		/**
		 * Update the setting when the #GObject property changes.
		 *     It is an error to use this flag if the property is not readable.
		 */
		SET = 2,
		/**
		 * Do not try to bind a "sensitivity" property to the writability of the setting
		 */
		NO_SENSITIVITY = 4,
		/**
		 * When set in addition to #G_SETTINGS_BIND_GET, set the #GObject property
		 *     value initially from the setting, but do not listen for changes of the setting
		 */
		GET_NO_CHANGES = 8,
		/**
		 * When passed to {@link G.settings_bind}, uses a pair of mapping functions that invert
		 *     the boolean value when mapping between the setting and the property.  The setting and property must both
		 *     be booleans.  You cannot pass this flag to g_settings_bind_with_mapping().
		 */
		INVERT_BOOLEAN = 16
	}

	/**
	 * Flags used in {@link G.socket_receive_message} and g_socket_send_message().
	 * The flags listed in the enum are some commonly available flags, but the
	 * values used for them are the same as on the platform, and any other flags
	 * are passed in/out as is. So to use a platform specific flag, just include
	 * the right system header and pass in the flag.
	 */
	enum SocketMsgFlags {
		/**
		 * No flags.
		 */
		NONE = 0,
		/**
		 * Request to send/receive out of band data.
		 */
		OOB = 1,
		/**
		 * Read data from the socket without removing it from
		 *     the queue.
		 */
		PEEK = 2,
		/**
		 * Don't use a gateway to send out the packet,
		 *     only send to hosts on directly connected networks.
		 */
		DONTROUTE = 4
	}

	/**
	 * Flags to define the behaviour of a #GSubprocess.
	 * 
	 * Note that the default for stdin is to redirect from `/dev/null`.  For
	 * stdout and stderr the default are for them to inherit the
	 * corresponding descriptor from the calling process.
	 * 
	 * Note that it is a programmer error to mix 'incompatible' flags.  For
	 * example, you may not request both %G_SUBPROCESS_FLAGS_STDOUT_PIPE and
	 * %G_SUBPROCESS_FLAGS_STDOUT_SILENCE.
	 */
	enum SubprocessFlags {
		/**
		 * No flags.
		 */
		NONE = 0,
		/**
		 * create a pipe for the stdin of the
		 *   spawned process that can be accessed with
		 *   {@link G.subprocess_get_stdin_pipe}.
		 */
		STDIN_PIPE = 1,
		/**
		 * stdin is inherited from the
		 *   calling process.
		 */
		STDIN_INHERIT = 2,
		/**
		 * create a pipe for the stdout of the
		 *   spawned process that can be accessed with
		 *   {@link G.subprocess_get_stdout_pipe}.
		 */
		STDOUT_PIPE = 4,
		/**
		 * silence the stdout of the spawned
		 *   process (ie: redirect to `/dev/null`).
		 */
		STDOUT_SILENCE = 8,
		/**
		 * create a pipe for the stderr of the
		 *   spawned process that can be accessed with
		 *   {@link G.subprocess_get_stderr_pipe}.
		 */
		STDERR_PIPE = 16,
		/**
		 * silence the stderr of the spawned
		 *   process (ie: redirect to `/dev/null`).
		 */
		STDERR_SILENCE = 32,
		/**
		 * merge the stderr of the spawned
		 *   process with whatever the stdout happens to be.  This is a good way
		 *   of directing both streams to a common log file, for example.
		 */
		STDERR_MERGE = 64,
		/**
		 * spawned processes will inherit the
		 *   file descriptors of their parent, unless those descriptors have
		 *   been explicitly marked as close-on-exec.  This flag has no effect
		 *   over the "standard" file descriptors (stdin, stdout, stderr).
		 */
		INHERIT_FDS = 128
	}

	/**
	 * Flags to define future #GTestDBus behaviour.
	 */
	enum TestDBusFlags {
		/**
		 * No flags.
		 */
		NONE = 0
	}

	/**
	 * A set of flags describing TLS certification validation. This can be
	 * used to set which validation steps to perform (eg, with
	 * {@link G.tls_client_connection_set_validation_flags}), or to describe why
	 * a particular certificate was rejected (eg, in
	 * #GTlsConnection::accept-certificate).
	 */
	enum TlsCertificateFlags {
		/**
		 * The signing certificate authority is
		 *   not known.
		 */
		UNKNOWN_CA = 1,
		/**
		 * The certificate does not match the
		 *   expected identity of the site that it was retrieved from.
		 */
		BAD_IDENTITY = 2,
		/**
		 * The certificate's activation time
		 *   is still in the future
		 */
		NOT_ACTIVATED = 4,
		/**
		 * The certificate has expired
		 */
		EXPIRED = 8,
		/**
		 * The certificate has been revoked
		 *   according to the #GTlsConnection's certificate revocation list.
		 */
		REVOKED = 16,
		/**
		 * The certificate's algorithm is
		 *   considered insecure.
		 */
		INSECURE = 32,
		/**
		 * Some other error occurred validating
		 *   the certificate
		 */
		GENERIC_ERROR = 64,
		/**
		 * the combination of all of the above
		 *   flags
		 */
		VALIDATE_ALL = 127
	}

	/**
	 * Flags for {@link G.tls_database_verify_chain}.
	 */
	enum TlsDatabaseVerifyFlags {
		/**
		 * No verification flags
		 */
		NONE = 0
	}

	/**
	 * Various flags for the password.
	 */
	enum TlsPasswordFlags {
		/**
		 * No flags
		 */
		NONE = 0,
		/**
		 * The password was wrong, and the user should retry.
		 */
		RETRY = 2,
		/**
		 * Hint to the user that the password has been
		 *    wrong many times, and the user may not have many chances left.
		 */
		MANY_TRIES = 4,
		/**
		 * Hint to the user that this is the last try to get
		 *    this password right.
		 */
		FINAL_TRY = 8,
		/**
		 * For PKCS #11, the user PIN is required.
		 *    Since: 2.70.
		 */
		PKCS11_USER = 16,
		/**
		 * For PKCS #11, the security officer
		 *    PIN is required. Since: 2.70.
		 */
		PKCS11_SECURITY_OFFICER = 32,
		/**
		 * For PKCS #11, the context-specific
		 *    PIN is required. Since: 2.70.
		 */
		PKCS11_CONTEXT_SPECIFIC = 64
	}

	/**
	 * Type definition for a function that will be called back when an asynchronous
	 * operation within GIO has been completed. #GAsyncReadyCallback
	 * callbacks from #GTask are guaranteed to be invoked in a later
	 * iteration of the
	 * [thread-default main context][g-main-context-push-thread-default]
	 * where the #GTask was created. All other users of
	 * #GAsyncReadyCallback must likewise call it asynchronously in a
	 * later iteration of the main context.
	 * 
	 * The asynchronous operation is guaranteed to have held a reference to
	 * #source_object from the time when the {@link `*.async}` function was called, until
	 * after this callback returns.
	 */
	interface AsyncReadyCallback {
		/**
		 * Type definition for a function that will be called back when an asynchronous
		 * operation within GIO has been completed. #GAsyncReadyCallback
		 * callbacks from #GTask are guaranteed to be invoked in a later
		 * iteration of the
		 * [thread-default main context][g-main-context-push-thread-default]
		 * where the #GTask was created. All other users of
		 * #GAsyncReadyCallback must likewise call it asynchronously in a
		 * later iteration of the main context.
		 * 
		 * The asynchronous operation is guaranteed to have held a reference to
		 * #source_object from the time when the {@link `*.async}` function was called, until
		 * after this callback returns.
		 * @param source_object the object the asynchronous operation was started with.
		 * @param res a #GAsyncResult.
		 */
		(source_object: GObject.Object | null, res: AsyncResult): void;
	}

	/**
	 * Invoked when a connection to a message bus has been obtained.
	 */
	interface BusAcquiredCallback {
		/**
		 * Invoked when a connection to a message bus has been obtained.
		 * @param connection The #GDBusConnection to a message bus.
		 * @param name The name that is requested to be owned.
		 */
		(connection: DBusConnection, name: string): void;
	}

	/**
	 * Invoked when the name is acquired.
	 */
	interface BusNameAcquiredCallback {
		/**
		 * Invoked when the name is acquired.
		 * @param connection The #GDBusConnection on which to acquired the name.
		 * @param name The name being owned.
		 */
		(connection: DBusConnection, name: string): void;
	}

	/**
	 * Invoked when the name being watched is known to have to have an owner.
	 */
	interface BusNameAppearedCallback {
		/**
		 * Invoked when the name being watched is known to have to have an owner.
		 * @param connection The #GDBusConnection the name is being watched on.
		 * @param name The name being watched.
		 * @param name_owner Unique name of the owner of the name being watched.
		 */
		(connection: DBusConnection, name: string, name_owner: string): void;
	}

	/**
	 * Invoked when the name is lost or #connection has been closed.
	 */
	interface BusNameLostCallback {
		/**
		 * Invoked when the name is lost or #connection has been closed.
		 * @param connection The #GDBusConnection on which to acquire the name or %NULL if
		 * the connection was disconnected.
		 * @param name The name being owned.
		 */
		(connection: DBusConnection, name: string): void;
	}

	/**
	 * Invoked when the name being watched is known not to have to have an owner.
	 * 
	 * This is also invoked when the #GDBusConnection on which the watch was
	 * established has been closed.  In that case, #connection will be
	 * %NULL.
	 */
	interface BusNameVanishedCallback {
		/**
		 * Invoked when the name being watched is known not to have to have an owner.
		 * 
		 * This is also invoked when the #GDBusConnection on which the watch was
		 * established has been closed.  In that case, #connection will be
		 * %NULL.
		 * @param connection The #GDBusConnection the name is being watched on, or
		 *     %NULL.
		 * @param name The name being watched.
		 */
		(connection: DBusConnection, name: string): void;
	}

	/**
	 * This is the function type of the callback used for the #GSource
	 * returned by {@link G.cancellable_source_new}.
	 */
	interface CancellableSourceFunc {
		/**
		 * This is the function type of the callback used for the #GSource
		 * returned by {@link G.cancellable_source_new}.
		 * @param cancellable the #GCancellable
		 * @returns it should return %FALSE if the source should be removed.
		 */
		(cancellable?: Cancellable | null): boolean;
	}

	/**
	 * The type of the #get_property function in #GDBusInterfaceVTable.
	 */
	interface DBusInterfaceGetPropertyFunc {
		/**
		 * The type of the #get_property function in #GDBusInterfaceVTable.
		 * @param connection A #GDBusConnection.
		 * @param sender The unique bus name of the remote caller.
		 * @param object_path The object path that the method was invoked on.
		 * @param interface_name The D-Bus interface name for the property.
		 * @param property_name The name of the property to get the value of.
		 * @param error Return location for error.
		 * @returns A #GVariant with the value for #property_name or %NULL if
		 *     #error is set. If the returned #GVariant is floating, it is
		 *     consumed - otherwise its reference count is decreased by one.
		 */
		(connection: DBusConnection, sender: string, object_path: string, interface_name: string, property_name: string, error: GLib.Error): GLib.Variant;
	}

	/**
	 * The type of the #method_call function in #GDBusInterfaceVTable.
	 */
	interface DBusInterfaceMethodCallFunc {
		/**
		 * The type of the #method_call function in #GDBusInterfaceVTable.
		 * @param connection A #GDBusConnection.
		 * @param sender The unique bus name of the remote caller.
		 * @param object_path The object path that the method was invoked on.
		 * @param interface_name The D-Bus interface name the method was invoked on.
		 * @param method_name The name of the method that was invoked.
		 * @param parameters A #GVariant tuple with parameters.
		 * @param invocation A #GDBusMethodInvocation object that must be used to return a value or error.
		 */
		(connection: DBusConnection, sender: string, object_path: string, interface_name: string, method_name: string, parameters: GLib.Variant, invocation: DBusMethodInvocation): void;
	}

	/**
	 * The type of the #set_property function in #GDBusInterfaceVTable.
	 */
	interface DBusInterfaceSetPropertyFunc {
		/**
		 * The type of the #set_property function in #GDBusInterfaceVTable.
		 * @param connection A #GDBusConnection.
		 * @param sender The unique bus name of the remote caller.
		 * @param object_path The object path that the method was invoked on.
		 * @param interface_name The D-Bus interface name for the property.
		 * @param property_name The name of the property to get the value of.
		 * @param value The value to set the property to.
		 * @param error Return location for error.
		 * @returns %TRUE if the property was set to #value, %FALSE if #error is set.
		 */
		(connection: DBusConnection, sender: string, object_path: string, interface_name: string, property_name: string, value: GLib.Variant, error: GLib.Error): boolean;
	}

	/**
	 * Signature for function used in {@link G.dbus_connection_add_filter}.
	 * 
	 * A filter function is passed a #GDBusMessage and expected to return
	 * a #GDBusMessage too. Passive filter functions that don't modify the
	 * message can simply return the #message object:
	 * |[
	 * static GDBusMessage *
	 * passive_filter (GDBusConnection *connection
	 *                 GDBusMessage    *message,
	 *                 gboolean         incoming,
	 *                 gpointer         user_data)
	 * {
	 *   // inspect #message
	 *   return message;
	 * }
	 * ]|
	 * Filter functions that wants to drop a message can simply return %NULL:
	 * |[
	 * static GDBusMessage *
	 * drop_filter (GDBusConnection *connection
	 *              GDBusMessage    *message,
	 *              gboolean         incoming,
	 *              gpointer         user_data)
	 * {
	 *   if (should_drop_message)
	 *     {
	 *       g_object_unref (message);
	 *       message = NULL;
	 *     }
	 *   return message;
	 * }
	 * ]|
	 * Finally, a filter function may modify a message by copying it:
	 * |[
	 * static GDBusMessage *
	 * modifying_filter (GDBusConnection *connection
	 *                   GDBusMessage    *message,
	 *                   gboolean         incoming,
	 *                   gpointer         user_data)
	 * {
	 *   GDBusMessage *copy;
	 *   GError *error;
	 * 
	 *   error = NULL;
	 *   copy = g_dbus_message_copy (message, &error);
	 *   // handle #error being set
	 *   g_object_unref (message);
	 * 
	 *   // modify #copy
	 * 
	 *   return copy;
	 * }
	 * ]|
	 * If the returned #GDBusMessage is different from #message and cannot
	 * be sent on #connection (it could use features, such as file
	 * descriptors, not compatible with #connection), then a warning is
	 * logged to standard error. Applications can
	 * check this ahead of time using g_dbus_message_to_blob() passing a
	 * #GDBusCapabilityFlags value obtained from #connection.
	 */
	interface DBusMessageFilterFunction {
		/**
		 * Signature for function used in {@link G.dbus_connection_add_filter}.
		 * 
		 * A filter function is passed a #GDBusMessage and expected to return
		 * a #GDBusMessage too. Passive filter functions that don't modify the
		 * message can simply return the #message object:
		 * |[
		 * static GDBusMessage *
		 * passive_filter (GDBusConnection *connection
		 *                 GDBusMessage    *message,
		 *                 gboolean         incoming,
		 *                 gpointer         user_data)
		 * {
		 *   // inspect #message
		 *   return message;
		 * }
		 * ]|
		 * Filter functions that wants to drop a message can simply return %NULL:
		 * |[
		 * static GDBusMessage *
		 * drop_filter (GDBusConnection *connection
		 *              GDBusMessage    *message,
		 *              gboolean         incoming,
		 *              gpointer         user_data)
		 * {
		 *   if (should_drop_message)
		 *     {
		 *       g_object_unref (message);
		 *       message = NULL;
		 *     }
		 *   return message;
		 * }
		 * ]|
		 * Finally, a filter function may modify a message by copying it:
		 * |[
		 * static GDBusMessage *
		 * modifying_filter (GDBusConnection *connection
		 *                   GDBusMessage    *message,
		 *                   gboolean         incoming,
		 *                   gpointer         user_data)
		 * {
		 *   GDBusMessage *copy;
		 *   GError *error;
		 * 
		 *   error = NULL;
		 *   copy = g_dbus_message_copy (message, &error);
		 *   // handle #error being set
		 *   g_object_unref (message);
		 * 
		 *   // modify #copy
		 * 
		 *   return copy;
		 * }
		 * ]|
		 * If the returned #GDBusMessage is different from #message and cannot
		 * be sent on #connection (it could use features, such as file
		 * descriptors, not compatible with #connection), then a warning is
		 * logged to standard error. Applications can
		 * check this ahead of time using g_dbus_message_to_blob() passing a
		 * #GDBusCapabilityFlags value obtained from #connection.
		 * @param connection A #GDBusConnection.
		 * @param message A locked #GDBusMessage that the filter function takes ownership of.
		 * @param incoming %TRUE if it is a message received from the other peer, %FALSE if it is
		 * a message to be sent to the other peer.
		 * @returns A #GDBusMessage that will be freed with
		 * {@link GObject.unref} or %NULL to drop the message. Passive filter
		 * functions can simply return the passed #message object.
		 */
		(connection: DBusConnection, message: DBusMessage, incoming: boolean): DBusMessage | null;
	}

	/**
	 * Function signature for a function used to determine the #GType to
	 * use for an interface proxy (if #interface_name is not %NULL) or
	 * object proxy (if #interface_name is %NULL).
	 * 
	 * This function is called in the
	 * [thread-default main loop][g-main-context-push-thread-default]
	 * that #manager was constructed in.
	 */
	interface DBusProxyTypeFunc {
		/**
		 * Function signature for a function used to determine the #GType to
		 * use for an interface proxy (if #interface_name is not %NULL) or
		 * object proxy (if #interface_name is %NULL).
		 * 
		 * This function is called in the
		 * [thread-default main loop][g-main-context-push-thread-default]
		 * that #manager was constructed in.
		 * @param manager A #GDBusObjectManagerClient.
		 * @param object_path The object path of the remote object.
		 * @param interface_name The interface name of the remote object or %NULL if a #GDBusObjectProxy #GType is requested.
		 * @returns A #GType to use for the remote object. The returned type
		 *   must be a #GDBusProxy or #GDBusObjectProxy -derived
		 *   type.
		 */
		(manager: DBusObjectManagerClient, object_path: string, interface_name?: string | null): GObject.Type;
	}

	/**
	 * Signature for callback function used in {@link G.dbus_connection_signal_subscribe}.
	 */
	interface DBusSignalCallback {
		/**
		 * Signature for callback function used in {@link G.dbus_connection_signal_subscribe}.
		 * @param connection A #GDBusConnection.
		 * @param sender_name The unique bus name of the sender of the signal,
		 *    or %NULL on a peer-to-peer D-Bus connection.
		 * @param object_path The object path that the signal was emitted on.
		 * @param interface_name The name of the interface.
		 * @param signal_name The name of the signal.
		 * @param parameters A #GVariant tuple with parameters for the signal.
		 */
		(connection: DBusConnection, sender_name: string | null, object_path: string, interface_name: string, signal_name: string, parameters: GLib.Variant): void;
	}

	/**
	 * The type of the #dispatch function in #GDBusSubtreeVTable.
	 * 
	 * Subtrees are flat.  #node, if non-%NULL, is always exactly one
	 * segment of the object path (ie: it never contains a slash).
	 */
	interface DBusSubtreeDispatchFunc {
		/**
		 * The type of the #dispatch function in #GDBusSubtreeVTable.
		 * 
		 * Subtrees are flat.  #node, if non-%NULL, is always exactly one
		 * segment of the object path (ie: it never contains a slash).
		 * @param connection A #GDBusConnection.
		 * @param sender The unique bus name of the remote caller.
		 * @param object_path The object path that was registered with {@link G.dbus_connection_register_subtree}.
		 * @param interface_name The D-Bus interface name that the method call or property access is for.
		 * @param node A node that is a child of #object_path (relative to #object_path) or %NULL for the root of the subtree.
		 * @param out_user_data Return location for user data to pass to functions in the returned #GDBusInterfaceVTable.
		 * @returns A #GDBusInterfaceVTable or %NULL if you don't want to handle the methods.
		 */
		(connection: DBusConnection, sender: string, object_path: string, interface_name: string, node: string, out_user_data: any): DBusInterfaceVTable | null;
	}

	/**
	 * The type of the #enumerate function in #GDBusSubtreeVTable.
	 * 
	 * This function is called when generating introspection data and also
	 * when preparing to dispatch incoming messages in the event that the
	 * %G_DBUS_SUBTREE_FLAGS_DISPATCH_TO_UNENUMERATED_NODES flag is not
	 * specified (ie: to verify that the object path is valid).
	 * 
	 * Hierarchies are not supported; the items that you return should not
	 * contain the `/` character.
	 * 
	 * The return value will be freed with {@link G.strfreev}.
	 */
	interface DBusSubtreeEnumerateFunc {
		/**
		 * The type of the #enumerate function in #GDBusSubtreeVTable.
		 * 
		 * This function is called when generating introspection data and also
		 * when preparing to dispatch incoming messages in the event that the
		 * %G_DBUS_SUBTREE_FLAGS_DISPATCH_TO_UNENUMERATED_NODES flag is not
		 * specified (ie: to verify that the object path is valid).
		 * 
		 * Hierarchies are not supported; the items that you return should not
		 * contain the `/` character.
		 * 
		 * The return value will be freed with {@link G.strfreev}.
		 * @param connection A #GDBusConnection.
		 * @param sender The unique bus name of the remote caller.
		 * @param object_path The object path that was registered with {@link G.dbus_connection_register_subtree}.
		 * @returns A newly allocated array of strings for node names that are children of #object_path.
		 */
		(connection: DBusConnection, sender: string, object_path: string): string[];
	}

	/**
	 * The type of the #introspect function in #GDBusSubtreeVTable.
	 * 
	 * Subtrees are flat.  #node, if non-%NULL, is always exactly one
	 * segment of the object path (ie: it never contains a slash).
	 * 
	 * This function should return %NULL to indicate that there is no object
	 * at this node.
	 * 
	 * If this function returns non-%NULL, the return value is expected to
	 * be a %NULL-terminated array of pointers to #GDBusInterfaceInfo
	 * structures describing the interfaces implemented by #node.  This
	 * array will have {@link G.dbus_interface_info_unref} called on each item
	 * before being freed with g_free().
	 * 
	 * The difference between returning %NULL and an array containing zero
	 * items is that the standard DBus interfaces will returned to the
	 * remote introspector in the empty array case, but not in the %NULL
	 * case.
	 */
	interface DBusSubtreeIntrospectFunc {
		/**
		 * The type of the #introspect function in #GDBusSubtreeVTable.
		 * 
		 * Subtrees are flat.  #node, if non-%NULL, is always exactly one
		 * segment of the object path (ie: it never contains a slash).
		 * 
		 * This function should return %NULL to indicate that there is no object
		 * at this node.
		 * 
		 * If this function returns non-%NULL, the return value is expected to
		 * be a %NULL-terminated array of pointers to #GDBusInterfaceInfo
		 * structures describing the interfaces implemented by #node.  This
		 * array will have {@link G.dbus_interface_info_unref} called on each item
		 * before being freed with g_free().
		 * 
		 * The difference between returning %NULL and an array containing zero
		 * items is that the standard DBus interfaces will returned to the
		 * remote introspector in the empty array case, but not in the %NULL
		 * case.
		 * @param connection A #GDBusConnection.
		 * @param sender The unique bus name of the remote caller.
		 * @param object_path The object path that was registered with {@link G.dbus_connection_register_subtree}.
		 * @param node A node that is a child of #object_path (relative to #object_path) or %NULL for the root of the subtree.
		 * @returns A %NULL-terminated array of pointers to #GDBusInterfaceInfo, or %NULL.
		 */
		(connection: DBusConnection, sender: string, object_path: string, node: string): DBusInterfaceInfo[] | null;
	}

	/**
	 * This is the function type of the callback used for the #GSource
	 * returned by {@link G.datagram_based_create_source}.
	 */
	interface DatagramBasedSourceFunc {
		/**
		 * This is the function type of the callback used for the #GSource
		 * returned by {@link G.datagram_based_create_source}.
		 * @param datagram_based the #GDatagramBased
		 * @param condition the current condition at the source fired
		 * @returns %G_SOURCE_REMOVE if the source should be removed,
		 *   %G_SOURCE_CONTINUE otherwise
		 */
		(datagram_based: DatagramBased, condition: GLib.IOCondition): boolean;
	}

	/**
	 * During invocation, {@link G.desktop_app_info_launch_uris_as_manager} may
	 * create one or more child processes.  This callback is invoked once
	 * for each, providing the process ID.
	 */
	interface DesktopAppLaunchCallback {
		/**
		 * During invocation, {@link G.desktop_app_info_launch_uris_as_manager} may
		 * create one or more child processes.  This callback is invoked once
		 * for each, providing the process ID.
		 * @param appinfo a #GDesktopAppInfo
		 * @param pid Process identifier
		 */
		(appinfo: DesktopAppInfo, pid: GLib.Pid): void;
	}

	/**
	 * This callback type is used by {@link G.file_measure_disk_usage} to make
	 * periodic progress reports when measuring the amount of disk spaced
	 * used by a directory.
	 * 
	 * These calls are made on a best-effort basis and not all types of
	 * #GFile will support them.  At the minimum, however, one call will
	 * always be made immediately.
	 * 
	 * In the case that there is no support, #reporting will be set to
	 * %FALSE (and the other values undefined) and no further calls will be
	 * made.  Otherwise, the #reporting will be %TRUE and the other values
	 * all-zeros during the first (immediate) call.  In this way, you can
	 * know which type of progress UI to show without a delay.
	 * 
	 * For g_file_measure_disk_usage() the callback is made directly.  For
	 * g_file_measure_disk_usage_async() the callback is made via the
	 * default main context of the calling thread (ie: the same way that the
	 * final async result would be reported).
	 * 
	 * #current_size is in the same units as requested by the operation (see
	 * %G_FILE_MEASURE_APPARENT_SIZE).
	 * 
	 * The frequency of the updates is implementation defined, but is
	 * ideally about once every 200ms.
	 * 
	 * The last progress callback may or may not be equal to the final
	 * result.  Always check the async result to get the final value.
	 */
	interface FileMeasureProgressCallback {
		/**
		 * This callback type is used by {@link G.file_measure_disk_usage} to make
		 * periodic progress reports when measuring the amount of disk spaced
		 * used by a directory.
		 * 
		 * These calls are made on a best-effort basis and not all types of
		 * #GFile will support them.  At the minimum, however, one call will
		 * always be made immediately.
		 * 
		 * In the case that there is no support, #reporting will be set to
		 * %FALSE (and the other values undefined) and no further calls will be
		 * made.  Otherwise, the #reporting will be %TRUE and the other values
		 * all-zeros during the first (immediate) call.  In this way, you can
		 * know which type of progress UI to show without a delay.
		 * 
		 * For g_file_measure_disk_usage() the callback is made directly.  For
		 * g_file_measure_disk_usage_async() the callback is made via the
		 * default main context of the calling thread (ie: the same way that the
		 * final async result would be reported).
		 * 
		 * #current_size is in the same units as requested by the operation (see
		 * %G_FILE_MEASURE_APPARENT_SIZE).
		 * 
		 * The frequency of the updates is implementation defined, but is
		 * ideally about once every 200ms.
		 * 
		 * The last progress callback may or may not be equal to the final
		 * result.  Always check the async result to get the final value.
		 * @param reporting %TRUE if more reports will come
		 * @param current_size the current cumulative size measurement
		 * @param num_dirs the number of directories visited so far
		 * @param num_files the number of non-directory files encountered
		 */
		(reporting: boolean, current_size: number, num_dirs: number, num_files: number): void;
	}

	/**
	 * When doing file operations that may take a while, such as moving
	 * a file or copying a file, a progress callback is used to pass how
	 * far along that operation is to the application.
	 */
	interface FileProgressCallback {
		/**
		 * When doing file operations that may take a while, such as moving
		 * a file or copying a file, a progress callback is used to pass how
		 * far along that operation is to the application.
		 * @param current_num_bytes the current number of bytes in the operation.
		 * @param total_num_bytes the total number of bytes in the operation.
		 */
		(current_num_bytes: number, total_num_bytes: number): void;
	}

	/**
	 * When loading the partial contents of a file with {@link G.file_load_partial_contents_async},
	 * it may become necessary to determine if any more data from the file should be loaded.
	 * A #GFileReadMoreCallback function facilitates this by returning %TRUE if more data
	 * should be read, or %FALSE otherwise.
	 */
	interface FileReadMoreCallback {
		/**
		 * When loading the partial contents of a file with {@link G.file_load_partial_contents_async},
		 * it may become necessary to determine if any more data from the file should be loaded.
		 * A #GFileReadMoreCallback function facilitates this by returning %TRUE if more data
		 * should be read, or %FALSE otherwise.
		 * @param file_contents the data as currently read.
		 * @param file_size the size of the data currently read.
		 * @returns %TRUE if more data should be read back. %FALSE otherwise.
		 */
		(file_contents: string, file_size: number): boolean;
	}

	/**
	 * I/O Job function.
	 * 
	 * Long-running jobs should periodically check the #cancellable
	 * to see if they have been cancelled.
	 */
	interface IOSchedulerJobFunc {
		/**
		 * I/O Job function.
		 * 
		 * Long-running jobs should periodically check the #cancellable
		 * to see if they have been cancelled.
		 * @param job a #GIOSchedulerJob.
		 * @param cancellable optional #GCancellable object, %NULL to ignore.
		 * @returns %TRUE if this function should be called again to
		 *    complete the job, %FALSE if the job is complete (or cancelled)
		 */
		(job: IOSchedulerJob, cancellable?: Cancellable | null): boolean;
	}

	/**
	 * This is the function type of the callback used for the #GSource
	 * returned by {@link G.pollable_input_stream_create_source} and
	 * g_pollable_output_stream_create_source().
	 */
	interface PollableSourceFunc {
		/**
		 * This is the function type of the callback used for the #GSource
		 * returned by {@link G.pollable_input_stream_create_source} and
		 * g_pollable_output_stream_create_source().
		 * @param pollable_stream the #GPollableInputStream or #GPollableOutputStream
		 * @returns it should return %FALSE if the source should be removed.
		 */
		(pollable_stream: GObject.Object): boolean;
	}

	/**
	 * Changes the size of the memory block pointed to by #data to
	 * #size bytes.
	 * 
	 * The function should have the same semantics as realloc().
	 */
	interface ReallocFunc {
		/**
		 * Changes the size of the memory block pointed to by #data to
		 * #size bytes.
		 * 
		 * The function should have the same semantics as realloc().
		 * @param data memory block to reallocate
		 * @param size size to reallocate #data to
		 * @returns a pointer to the reallocated memory
		 */
		(data: any | null, size: number): any | null;
	}

	/**
	 * The type for the function that is used to convert from #GSettings to
	 * an object property. The #value is already initialized to hold values
	 * of the appropriate type.
	 */
	interface SettingsBindGetMapping {
		/**
		 * The type for the function that is used to convert from #GSettings to
		 * an object property. The #value is already initialized to hold values
		 * of the appropriate type.
		 * @param value return location for the property value
		 * @param variant the #GVariant
		 * @returns %TRUE if the conversion succeeded, %FALSE in case of an error
		 */
		(value: GObject.Value, variant: GLib.Variant): boolean;
	}

	/**
	 * The type for the function that is used to convert an object property
	 * value to a #GVariant for storing it in #GSettings.
	 */
	interface SettingsBindSetMapping {
		/**
		 * The type for the function that is used to convert an object property
		 * value to a #GVariant for storing it in #GSettings.
		 * @param value a #GValue containing the property value to map
		 * @param expected_type the #GVariantType to create
		 * @returns a new #GVariant holding the data from #value,
		 *     or %NULL in case of an error
		 */
		(value: GObject.Value, expected_type: GLib.VariantType): GLib.Variant;
	}

	/**
	 * The type of the function that is used to convert from a value stored
	 * in a #GSettings to a value that is useful to the application.
	 * 
	 * If the value is successfully mapped, the result should be stored at
	 * #result and %TRUE returned.  If mapping fails (for example, if #value
	 * is not in the right format) then %FALSE should be returned.
	 * 
	 * If #value is %NULL then it means that the mapping function is being
	 * given a "last chance" to successfully return a valid value.  %TRUE
	 * must be returned in this case.
	 */
	interface SettingsGetMapping {
		/**
		 * The type of the function that is used to convert from a value stored
		 * in a #GSettings to a value that is useful to the application.
		 * 
		 * If the value is successfully mapped, the result should be stored at
		 * #result and %TRUE returned.  If mapping fails (for example, if #value
		 * is not in the right format) then %FALSE should be returned.
		 * 
		 * If #value is %NULL then it means that the mapping function is being
		 * given a "last chance" to successfully return a valid value.  %TRUE
		 * must be returned in this case.
		 * @param value the #GVariant to map, or %NULL
		 * @returns %TRUE if the conversion succeeded, %FALSE in case of an error
		 * 
		 * the result of the mapping
		 */
		(value: GLib.Variant): [ boolean, any | null ];
	}

	/**
	 * Simple thread function that runs an asynchronous operation and
	 * checks for cancellation.
	 */
	interface SimpleAsyncThreadFunc {
		/**
		 * Simple thread function that runs an asynchronous operation and
		 * checks for cancellation.
		 * @param res a #GSimpleAsyncResult.
		 * @param object a #GObject.
		 * @param cancellable optional #GCancellable object, %NULL to ignore.
		 */
		(res: SimpleAsyncResult, object: GObject.Object, cancellable?: Cancellable | null): void;
	}

	/**
	 * This is the function type of the callback used for the #GSource
	 * returned by {@link G.socket_create_source}.
	 */
	interface SocketSourceFunc {
		/**
		 * This is the function type of the callback used for the #GSource
		 * returned by {@link G.socket_create_source}.
		 * @param socket the #GSocket
		 * @param condition the current condition at the source fired.
		 * @returns it should return %FALSE if the source should be removed.
		 */
		(socket: Socket, condition: GLib.IOCondition): boolean;
	}

	/**
	 * The prototype for a task function to be run in a thread via
	 * {@link G.task_run_in_thread} or g_task_run_in_thread_sync().
	 * 
	 * If the return-on-cancel flag is set on #task, and #cancellable gets
	 * cancelled, then the #GTask will be completed immediately (as though
	 * g_task_return_error_if_cancelled() had been called), without
	 * waiting for the task function to complete. However, the task
	 * function will continue running in its thread in the background. The
	 * function therefore needs to be careful about how it uses
	 * externally-visible state in this case. See
	 * g_task_set_return_on_cancel() for more details.
	 * 
	 * Other than in that case, #task will be completed when the
	 * #GTaskThreadFunc returns, not when it calls a
	 * `g_task_return_` function.
	 */
	interface TaskThreadFunc {
		/**
		 * The prototype for a task function to be run in a thread via
		 * {@link G.task_run_in_thread} or g_task_run_in_thread_sync().
		 * 
		 * If the return-on-cancel flag is set on #task, and #cancellable gets
		 * cancelled, then the #GTask will be completed immediately (as though
		 * g_task_return_error_if_cancelled() had been called), without
		 * waiting for the task function to complete. However, the task
		 * function will continue running in its thread in the background. The
		 * function therefore needs to be careful about how it uses
		 * externally-visible state in this case. See
		 * g_task_set_return_on_cancel() for more details.
		 * 
		 * Other than in that case, #task will be completed when the
		 * #GTaskThreadFunc returns, not when it calls a
		 * `g_task_return_` function.
		 * @param task the #GTask
		 * @param source_object #task's source object
		 * @param task_data #task's task data
		 * @param cancellable #task's #GCancellable, or %NULL
		 */
		(task: Task, source_object: GObject.Object, task_data?: any | null, cancellable?: Cancellable | null): void;
	}

	/**
	 * This function type is used by {@link G.vfs_register_uri_scheme} to make it
	 * possible for a client to associate an URI scheme to a different #GFile
	 * implementation.
	 * 
	 * The client should return a reference to the new file that has been
	 * created for #uri, or %NULL to continue with the default implementation.
	 */
	interface VfsFileLookupFunc {
		/**
		 * This function type is used by {@link G.vfs_register_uri_scheme} to make it
		 * possible for a client to associate an URI scheme to a different #GFile
		 * implementation.
		 * 
		 * The client should return a reference to the new file that has been
		 * created for #uri, or %NULL to continue with the default implementation.
		 * @param vfs a #GVfs
		 * @param identifier the identifier to look up a #GFile for. This can either
		 *     be an URI or a parse name as returned by {@link G.file_get_parse_name}
		 * @returns a #GFile for #identifier.
		 */
		(vfs: Vfs, identifier: string): File;
	}

	/**
	 * Checks if #action_name is valid.
	 * 
	 * #action_name is valid if it consists only of alphanumeric characters,
	 * plus '-' and '.'.  The empty string is not a valid action name.
	 * 
	 * It is an error to call this function with a non-utf8 #action_name.
	 * #action_name must not be %NULL.
	 * @param action_name a potential action name
	 * @returns %TRUE if #action_name is valid
	 */
	function action_name_is_valid(action_name: string): boolean;
	/**
	 * Parses a detailed action name into its separate name and target
	 * components.
	 * 
	 * Detailed action names can have three formats.
	 * 
	 * The first format is used to represent an action name with no target
	 * value and consists of just an action name containing no whitespace
	 * nor the characters ':', '(' or ')'.  For example: "app.action".
	 * 
	 * The second format is used to represent an action with a target value
	 * that is a non-empty string consisting only of alphanumerics, plus '-'
	 * and '.'.  In that case, the action name and target value are
	 * separated by a double colon ("::").  For example:
	 * "app.action::target".
	 * 
	 * The third format is used to represent an action with any type of
	 * target value, including strings.  The target value follows the action
	 * name, surrounded in parens.  For example: "app.action(42)".  The
	 * target value is parsed using {@link G.variant_parse}.  If a tuple-typed
	 * value is desired, it must be specified in the same way, resulting in
	 * two sets of parens, for example: "app.action((1,2,3))".  A string
	 * target can be specified this way as well: "app.action('target')".
	 * For strings, this third format must be used if * target value is
	 * empty or contains characters other than alphanumerics, '-' and '.'.
	 * @param detailed_name a detailed action name
	 * @returns %TRUE if successful, else %FALSE with #error set
	 * 
	 * the action name
	 * 
	 * the target value, or %NULL for no target
	 */
	function action_parse_detailed_name(detailed_name: string): [ boolean, string, GLib.Variant ];
	/**
	 * Formats a detailed action name from #action_name and #target_value.
	 * 
	 * It is an error to call this function with an invalid action name.
	 * 
	 * This function is the opposite of {@link G.action_parse_detailed_name}.
	 * It will produce a string that can be parsed back to the #action_name
	 * and #target_value by that function.
	 * 
	 * See that function for the types of strings that will be printed by
	 * this function.
	 * @param action_name a valid action name
	 * @param target_value a #GVariant target value, or %NULL
	 * @returns a detailed format string
	 */
	function action_print_detailed_name(action_name: string, target_value: GLib.Variant | null): string;
	/**
	 * Creates a new #GAppInfo from the given information.
	 * 
	 * Note that for #commandline, the quoting rules of the Exec key of the
	 * [freedesktop.org Desktop Entry Specification](http://freedesktop.org/Standards/desktop-entry-spec)
	 * are applied. For example, if the #commandline contains
	 * percent-encoded URIs, the percent-character must be doubled in order to prevent it from
	 * being swallowed by Exec key unquoting. See the specification for exact quoting rules.
	 * @param commandline the commandline to use
	 * @param application_name the application name, or %NULL to use #commandline
	 * @param flags flags that can specify details of the created #GAppInfo
	 * @returns new #GAppInfo for given command.
	 */
	function app_info_create_from_commandline(commandline: string, application_name: string | null, flags: AppInfoCreateFlags): AppInfo;
	/**
	 * Gets a list of all of the applications currently registered
	 * on this system.
	 * 
	 * For desktop files, this includes applications that have
	 * `NoDisplay=true` set or are excluded from display by means
	 * of `OnlyShowIn` or `NotShowIn`. See {@link G.app_info_should_show}.
	 * The returned list does not include applications which have
	 * the `Hidden` key set.
	 * @returns a newly allocated #GList of references to #GAppInfos.
	 */
	function app_info_get_all(): AppInfo[];
	/**
	 * Gets a list of all #GAppInfos for a given content type,
	 * including the recommended and fallback #GAppInfos. See
	 * {@link G.app_info_get_recommended_for_type} and
	 * g_app_info_get_fallback_for_type().
	 * @param content_type the content type to find a #GAppInfo for
	 * @returns #GList of #GAppInfos
	 *     for given #content_type or %NULL on error.
	 */
	function app_info_get_all_for_type(content_type: string): AppInfo[];
	/**
	 * Gets the default #GAppInfo for a given content type.
	 * @param content_type the content type to find a #GAppInfo for
	 * @param must_support_uris if %TRUE, the #GAppInfo is expected to
	 *     support URIs
	 * @returns #GAppInfo for given #content_type or
	 *     %NULL on error.
	 */
	function app_info_get_default_for_type(content_type: string, must_support_uris: boolean): AppInfo | null;
	/**
	 * Gets the default application for handling URIs with
	 * the given URI scheme. A URI scheme is the initial part
	 * of the URI, up to but not including the ':', e.g. "http",
	 * "ftp" or "sip".
	 * @param uri_scheme a string containing a URI scheme.
	 * @returns #GAppInfo for given #uri_scheme or
	 *     %NULL on error.
	 */
	function app_info_get_default_for_uri_scheme(uri_scheme: string): AppInfo | null;
	/**
	 * Gets a list of fallback #GAppInfos for a given content type, i.e.
	 * those applications which claim to support the given content type
	 * by MIME type subclassing and not directly.
	 * @param content_type the content type to find a #GAppInfo for
	 * @returns #GList of #GAppInfos
	 *     for given #content_type or %NULL on error.
	 */
	function app_info_get_fallback_for_type(content_type: string): AppInfo[];
	/**
	 * Gets a list of recommended #GAppInfos for a given content type, i.e.
	 * those applications which claim to support the given content type exactly,
	 * and not by MIME type subclassing.
	 * Note that the first application of the list is the last used one, i.e.
	 * the last one for which {@link G.app_info_set_as_last_used_for_type} has been
	 * called.
	 * @param content_type the content type to find a #GAppInfo for
	 * @returns #GList of #GAppInfos
	 *     for given #content_type or %NULL on error.
	 */
	function app_info_get_recommended_for_type(content_type: string): AppInfo[];
	/**
	 * Utility function that launches the default application
	 * registered to handle the specified uri. Synchronous I/O
	 * is done on the uri to detect the type of the file if
	 * required.
	 * 
	 * The D-Bus–activated applications don't have to be started if your application
	 * terminates too soon after this function. To prevent this, use
	 * {@link G.app_info_launch_default_for_uri_async} instead.
	 * @param uri the uri to show
	 * @param context an optional #GAppLaunchContext
	 * @returns %TRUE on success, %FALSE on error.
	 */
	function app_info_launch_default_for_uri(uri: string, context: AppLaunchContext | null): boolean;
	/**
	 * Async version of {@link G.app_info_launch_default_for_uri}.
	 * 
	 * This version is useful if you are interested in receiving
	 * error information in the case where the application is
	 * sandboxed and the portal may present an application chooser
	 * dialog to the user.
	 * 
	 * This is also useful if you want to be sure that the D-Bus–activated
	 * applications are really started before termination and if you are interested
	 * in receiving error information from their activation.
	 * @param uri the uri to show
	 * @param context an optional #GAppLaunchContext
	 * @param cancellable a #GCancellable
	 * @param callback a #GAsyncReadyCallback to call when the request is done
	 */
	function app_info_launch_default_for_uri_async(uri: string, context: AppLaunchContext | null, cancellable: Cancellable | null, callback: AsyncReadyCallback | null): void;
	/**
	 * Finishes an asynchronous launch-default-for-uri operation.
	 * @param result a #GAsyncResult
	 * @returns %TRUE if the launch was successful, %FALSE if #error is set
	 */
	function app_info_launch_default_for_uri_finish(result: AsyncResult): boolean;
	/**
	 * Removes all changes to the type associations done by
	 * {@link G.app_info_set_as_default_for_type},
	 * g_app_info_set_as_default_for_extension(),
	 * g_app_info_add_supports_type() or
	 * g_app_info_remove_supports_type().
	 * @param content_type a content type
	 */
	function app_info_reset_type_associations(content_type: string): void;
	/**
	 * Helper function for constructing #GAsyncInitable object. This is
	 * similar to {@link GObject.newv} but also initializes the object asynchronously.
	 * 
	 * When the initialization is finished, #callback will be called. You can
	 * then call g_async_initable_new_finish() to get the new object and check
	 * for any errors.
	 * @param object_type a #GType supporting #GAsyncInitable.
	 * @param n_parameters the number of parameters in #parameters
	 * @param parameters the parameters to use to construct the object
	 * @param io_priority the [I/O priority][io-priority] of the operation
	 * @param cancellable optional #GCancellable object, %NULL to ignore.
	 * @param callback a #GAsyncReadyCallback to call when the initialization is
	 *     finished
	 */
	function async_initable_newv_async(object_type: GObject.Type, n_parameters: number, parameters: GObject.Parameter, io_priority: number, cancellable: Cancellable | null, callback: AsyncReadyCallback | null): void;
	/**
	 * Asynchronously connects to the message bus specified by #bus_type.
	 * 
	 * When the operation is finished, #callback will be invoked. You can
	 * then call {@link G.bus_get_finish} to get the result of the operation.
	 * 
	 * This is an asynchronous failable function. See g_bus_get_sync() for
	 * the synchronous version.
	 * @param bus_type a #GBusType
	 * @param cancellable a #GCancellable or %NULL
	 * @param callback a #GAsyncReadyCallback to call when the request is satisfied
	 */
	function bus_get(bus_type: BusType, cancellable: Cancellable | null, callback: AsyncReadyCallback | null): void;
	/**
	 * Finishes an operation started with {@link G.bus_get}.
	 * 
	 * The returned object is a singleton, that is, shared with other
	 * callers of g_bus_get() and g_bus_get_sync() for #bus_type. In the
	 * event that you need a private message bus connection, use
	 * g_dbus_address_get_for_bus_sync() and
	 * g_dbus_connection_new_for_address().
	 * 
	 * Note that the returned #GDBusConnection object will (usually) have
	 * the #GDBusConnection:exit-on-close property set to %TRUE.
	 * @param res a #GAsyncResult obtained from the #GAsyncReadyCallback passed
	 *     to {@link G.bus_get}
	 * @returns a #GDBusConnection or %NULL if #error is set.
	 *     Free with {@link GObject.unref}.
	 */
	function bus_get_finish(res: AsyncResult): DBusConnection;
	/**
	 * Synchronously connects to the message bus specified by #bus_type.
	 * Note that the returned object may shared with other callers,
	 * e.g. if two separate parts of a process calls this function with
	 * the same #bus_type, they will share the same object.
	 * 
	 * This is a synchronous failable function. See {@link G.bus_get} and
	 * g_bus_get_finish() for the asynchronous version.
	 * 
	 * The returned object is a singleton, that is, shared with other
	 * callers of g_bus_get() and g_bus_get_sync() for #bus_type. In the
	 * event that you need a private message bus connection, use
	 * g_dbus_address_get_for_bus_sync() and
	 * g_dbus_connection_new_for_address().
	 * 
	 * Note that the returned #GDBusConnection object will (usually) have
	 * the #GDBusConnection:exit-on-close property set to %TRUE.
	 * @param bus_type a #GBusType
	 * @param cancellable a #GCancellable or %NULL
	 * @returns a #GDBusConnection or %NULL if #error is set.
	 *     Free with {@link GObject.unref}.
	 */
	function bus_get_sync(bus_type: BusType, cancellable: Cancellable | null): DBusConnection;
	/**
	 * Version of {@link G.bus_own_name} using closures instead of callbacks for
	 * easier binding in other languages.
	 * @param bus_type the type of bus to own a name on
	 * @param name the well-known name to own
	 * @param flags a set of flags from the #GBusNameOwnerFlags enumeration
	 * @param bus_acquired_closure #GClosure to invoke when connected to
	 *     the bus of type #bus_type or %NULL
	 * @param name_acquired_closure #GClosure to invoke when #name is
	 *     acquired or %NULL
	 * @param name_lost_closure #GClosure to invoke when #name is lost or
	 *     %NULL
	 * @returns an identifier (never 0) that can be used with
	 *     {@link G.bus_unown_name} to stop owning the name.
	 */
	function bus_own_name(bus_type: BusType, name: string, flags: BusNameOwnerFlags, bus_acquired_closure: GObject.Closure | null, name_acquired_closure: GObject.Closure | null, name_lost_closure: GObject.Closure | null): number;
	/**
	 * Version of {@link G.bus_own_name_on_connection} using closures instead of
	 * callbacks for easier binding in other languages.
	 * @param connection a #GDBusConnection
	 * @param name the well-known name to own
	 * @param flags a set of flags from the #GBusNameOwnerFlags enumeration
	 * @param name_acquired_closure #GClosure to invoke when #name is
	 *     acquired or %NULL
	 * @param name_lost_closure #GClosure to invoke when #name is lost
	 *     or %NULL
	 * @returns an identifier (never 0) that can be used with
	 *     {@link G.bus_unown_name} to stop owning the name.
	 */
	function bus_own_name_on_connection(connection: DBusConnection, name: string, flags: BusNameOwnerFlags, name_acquired_closure: GObject.Closure | null, name_lost_closure: GObject.Closure | null): number;
	/**
	 * Stops owning a name.
	 * 
	 * Note that there may still be D-Bus traffic to process (relating to owning
	 * and unowning the name) in the current thread-default #GMainContext after
	 * this function has returned. You should continue to iterate the #GMainContext
	 * until the #GDestroyNotify function passed to {@link G.bus_own_name} is called, in
	 * order to avoid memory leaks through callbacks queued on the #GMainContext
	 * after it’s stopped being iterated.
	 * @param owner_id an identifier obtained from {@link G.bus_own_name}
	 */
	function bus_unown_name(owner_id: number): void;
	/**
	 * Stops watching a name.
	 * 
	 * Note that there may still be D-Bus traffic to process (relating to watching
	 * and unwatching the name) in the current thread-default #GMainContext after
	 * this function has returned. You should continue to iterate the #GMainContext
	 * until the #GDestroyNotify function passed to {@link G.bus_watch_name} is called, in
	 * order to avoid memory leaks through callbacks queued on the #GMainContext
	 * after it’s stopped being iterated.
	 * @param watcher_id An identifier obtained from {@link G.bus_watch_name}
	 */
	function bus_unwatch_name(watcher_id: number): void;
	/**
	 * Version of {@link G.bus_watch_name} using closures instead of callbacks for
	 * easier binding in other languages.
	 * @param bus_type The type of bus to watch a name on.
	 * @param name The name (well-known or unique) to watch.
	 * @param flags Flags from the #GBusNameWatcherFlags enumeration.
	 * @param name_appeared_closure #GClosure to invoke when #name is known
	 * to exist or %NULL.
	 * @param name_vanished_closure #GClosure to invoke when #name is known
	 * to not exist or %NULL.
	 * @returns An identifier (never 0) that can be used with
	 * {@link G.bus_unwatch_name} to stop watching the name.
	 */
	function bus_watch_name(bus_type: BusType, name: string, flags: BusNameWatcherFlags, name_appeared_closure: GObject.Closure | null, name_vanished_closure: GObject.Closure | null): number;
	/**
	 * Version of {@link G.bus_watch_name_on_connection} using closures instead of callbacks for
	 * easier binding in other languages.
	 * @param connection A #GDBusConnection.
	 * @param name The name (well-known or unique) to watch.
	 * @param flags Flags from the #GBusNameWatcherFlags enumeration.
	 * @param name_appeared_closure #GClosure to invoke when #name is known
	 * to exist or %NULL.
	 * @param name_vanished_closure #GClosure to invoke when #name is known
	 * to not exist or %NULL.
	 * @returns An identifier (never 0) that can be used with
	 * {@link G.bus_unwatch_name} to stop watching the name.
	 */
	function bus_watch_name_on_connection(connection: DBusConnection, name: string, flags: BusNameWatcherFlags, name_appeared_closure: GObject.Closure | null, name_vanished_closure: GObject.Closure | null): number;
	/**
	 * Checks if a content type can be executable. Note that for instance
	 * things like text files can be executables (i.e. scripts and batch files).
	 * @param type a content type string
	 * @returns %TRUE if the file type corresponds to a type that
	 *     can be executable, %FALSE otherwise.
	 */
	function content_type_can_be_executable(type: string): boolean;
	/**
	 * Compares two content types for equality.
	 * @param type1 a content type string
	 * @param type2 a content type string
	 * @returns %TRUE if the two strings are identical or equivalent,
	 *     %FALSE otherwise.
	 */
	function content_type_equals(type1: string, type2: string): boolean;
	/**
	 * Tries to find a content type based on the mime type name.
	 * @param mime_type a mime type string
	 * @returns Newly allocated string with content type or
	 *     %NULL. Free with {@link G.free}
	 */
	function content_type_from_mime_type(mime_type: string): string | null;
	/**
	 * Gets the human readable description of the content type.
	 * @param type a content type string
	 * @returns a short description of the content type #type. Free the
	 *     returned string with {@link G.free}
	 */
	function content_type_get_description(type: string): string;
	/**
	 * Gets the generic icon name for a content type.
	 * 
	 * See the
	 * [shared-mime-info](http://www.freedesktop.org/wiki/Specifications/shared-mime-info-spec)
	 * specification for more on the generic icon name.
	 * @param type a content type string
	 * @returns the registered generic icon name for the given #type,
	 *     or %NULL if unknown. Free with {@link G.free}
	 */
	function content_type_get_generic_icon_name(type: string): string | null;
	/**
	 * Gets the icon for a content type.
	 * @param type a content type string
	 * @returns #GIcon corresponding to the content type. Free the returned
	 *     object with {@link GObject.unref}
	 */
	function content_type_get_icon(type: string): Icon;
	/**
	 * Get the list of directories which MIME data is loaded from. See
	 * {@link G.content_type_set_mime_dirs} for details.
	 * @returns %NULL-terminated list of
	 *    directories to load MIME data from, including any `mime/` subdirectory,
	 *    and with the first directory to try listed first
	 */
	function content_type_get_mime_dirs(): string[];
	/**
	 * Gets the mime type for the content type, if one is registered.
	 * @param type a content type string
	 * @returns the registered mime type for the
	 *     given #type, or %NULL if unknown; free with {@link G.free}.
	 */
	function content_type_get_mime_type(type: string): string | null;
	/**
	 * Gets the symbolic icon for a content type.
	 * @param type a content type string
	 * @returns symbolic #GIcon corresponding to the content type.
	 *     Free the returned object with {@link GObject.unref}
	 */
	function content_type_get_symbolic_icon(type: string): Icon;
	/**
	 * Guesses the content type based on example data. If the function is
	 * uncertain, #result_uncertain will be set to %TRUE. Either #filename
	 * or #data may be %NULL, in which case the guess will be based solely
	 * on the other argument.
	 * @param filename a string, or %NULL
	 * @param data a stream of data, or %NULL
	 * @returns a string indicating a guessed content type for the
	 *     given data. Free with {@link G.free}
	 * 
	 * return location for the certainty
	 *     of the result, or %NULL
	 */
	function content_type_guess(filename: string | null, data: number[] | null): [ string, boolean | null ];
	/**
	 * Tries to guess the type of the tree with root #root, by
	 * looking at the files it contains. The result is an array
	 * of content types, with the best guess coming first.
	 * 
	 * The types returned all have the form x-content/foo, e.g.
	 * x-content/audio-cdda (for audio CDs) or x-content/image-dcf
	 * (for a camera memory card). See the
	 * [shared-mime-info](http://www.freedesktop.org/wiki/Specifications/shared-mime-info-spec)
	 * specification for more on x-content types.
	 * 
	 * This function is useful in the implementation of
	 * {@link G.mount_guess_content_type}.
	 * @param root the root of the tree to guess a type for
	 * @returns an %NULL-terminated
	 *     array of zero or more content types. Free with {@link G.strfreev}
	 */
	function content_type_guess_for_tree(root: File): string[];
	/**
	 * Determines if #type is a subset of #supertype.
	 * @param type a content type string
	 * @param supertype a content type string
	 * @returns %TRUE if #type is a kind of #supertype,
	 *     %FALSE otherwise.
	 */
	function content_type_is_a(type: string, supertype: string): boolean;
	/**
	 * Determines if #type is a subset of #mime_type.
	 * Convenience wrapper around {@link G.content_type_is_a}.
	 * @param type a content type string
	 * @param mime_type a mime type string
	 * @returns %TRUE if #type is a kind of #mime_type,
	 *     %FALSE otherwise.
	 */
	function content_type_is_mime_type(type: string, mime_type: string): boolean;
	/**
	 * Checks if the content type is the generic "unknown" type.
	 * On UNIX this is the "application/octet-stream" mimetype,
	 * while on win32 it is "*" and on OSX it is a dynamic type
	 * or octet-stream.
	 * @param type a content type string
	 * @returns %TRUE if the type is the unknown type.
	 */
	function content_type_is_unknown(type: string): boolean;
	/**
	 * Set the list of directories used by GIO to load the MIME database.
	 * If #dirs is %NULL, the directories used are the default:
	 * 
	 *  - the `mime` subdirectory of the directory in `$XDG_DATA_HOME`
	 *  - the `mime` subdirectory of every directory in `$XDG_DATA_DIRS`
	 * 
	 * This function is intended to be used when writing tests that depend on
	 * information stored in the MIME database, in order to control the data.
	 * 
	 * Typically, in case your tests use %G_TEST_OPTION_ISOLATE_DIRS, but they
	 * depend on the system’s MIME database, you should call this function
	 * with #dirs set to %NULL before calling {@link G.test_init}, for instance:
	 * 
	 * |[<!-- language="C" -->
	 *   // Load MIME data from the system
	 *   g_content_type_set_mime_dirs (NULL);
	 *   // Isolate the environment
	 *   g_test_init (&argc, &argv, G_TEST_OPTION_ISOLATE_DIRS, NULL);
	 * 
	 *   …
	 * 
	 *   return g_test_run ();
	 * ]|
	 * @param dirs %NULL-terminated list of
	 *    directories to load MIME data from, including any `mime/` subdirectory,
	 *    and with the first directory to try listed first
	 */
	function content_type_set_mime_dirs(dirs: string[] | null): void;
	/**
	 * Gets a list of strings containing all the registered content types
	 * known to the system. The list and its data should be freed using
	 * `g_list_free_full (list, g_free)`.
	 * @returns list of the registered
	 *     content types
	 */
	function content_types_get_registered(): string[];
	/**
	 * Escape #string so it can appear in a D-Bus address as the value
	 * part of a key-value pair.
	 * 
	 * For instance, if #string is `/run/bus-for-:0`,
	 * this function would return `/run/bus-for-%3A0`,
	 * which could be used in a D-Bus address like
	 * `unix:nonce-tcp:host=127.0.0.1,port=42,noncefile=/run/bus-for-%3A0`.
	 * @param string an unescaped string to be included in a D-Bus address
	 *     as the value in a key-value pair
	 * @returns a copy of #string with all
	 *     non-optionally-escaped bytes escaped
	 */
	function dbus_address_escape_value(string: string): string;
	/**
	 * Synchronously looks up the D-Bus address for the well-known message
	 * bus instance specified by #bus_type. This may involve using various
	 * platform specific mechanisms.
	 * 
	 * The returned address will be in the
	 * [D-Bus address format](https://dbus.freedesktop.org/doc/dbus-specification.html#addresses).
	 * @param bus_type a #GBusType
	 * @param cancellable a #GCancellable or %NULL
	 * @returns a valid D-Bus address string for #bus_type or
	 *     %NULL if #error is set
	 */
	function dbus_address_get_for_bus_sync(bus_type: BusType, cancellable: Cancellable | null): string;
	/**
	 * Asynchronously connects to an endpoint specified by #address and
	 * sets up the connection so it is in a state to run the client-side
	 * of the D-Bus authentication conversation. #address must be in the
	 * [D-Bus address format](https://dbus.freedesktop.org/doc/dbus-specification.html#addresses).
	 * 
	 * When the operation is finished, #callback will be invoked. You can
	 * then call {@link G.dbus_address_get_stream_finish} to get the result of
	 * the operation.
	 * 
	 * This is an asynchronous failable function. See
	 * g_dbus_address_get_stream_sync() for the synchronous version.
	 * @param address A valid D-Bus address.
	 * @param cancellable A #GCancellable or %NULL.
	 * @param callback A #GAsyncReadyCallback to call when the request is satisfied.
	 */
	function dbus_address_get_stream(address: string, cancellable: Cancellable | null, callback: AsyncReadyCallback | null): void;
	/**
	 * Finishes an operation started with {@link G.dbus_address_get_stream}.
	 * 
	 * A server is not required to set a GUID, so #out_guid may be set to %NULL
	 * even on success.
	 * @param res A #GAsyncResult obtained from the GAsyncReadyCallback passed to {@link G.dbus_address_get_stream}.
	 * @returns A #GIOStream or %NULL if #error is set.
	 * 
	 * %NULL or return location to store the GUID extracted from #address, if any.
	 */
	function dbus_address_get_stream_finish(res: AsyncResult): [ IOStream, string | null ];
	/**
	 * Synchronously connects to an endpoint specified by #address and
	 * sets up the connection so it is in a state to run the client-side
	 * of the D-Bus authentication conversation. #address must be in the
	 * [D-Bus address format](https://dbus.freedesktop.org/doc/dbus-specification.html#addresses).
	 * 
	 * A server is not required to set a GUID, so #out_guid may be set to %NULL
	 * even on success.
	 * 
	 * This is a synchronous failable function. See
	 * {@link G.dbus_address_get_stream} for the asynchronous version.
	 * @param address A valid D-Bus address.
	 * @param cancellable A #GCancellable or %NULL.
	 * @returns A #GIOStream or %NULL if #error is set.
	 * 
	 * %NULL or return location to store the GUID extracted from #address, if any.
	 */
	function dbus_address_get_stream_sync(address: string, cancellable: Cancellable | null): [ IOStream, string | null ];
	/**
	 * Looks up the value of an annotation.
	 * 
	 * The cost of this function is O(n) in number of annotations.
	 * @param annotations A %NULL-terminated array of annotations or %NULL.
	 * @param name The name of the annotation to look up.
	 * @returns The value or %NULL if not found. Do not free, it is owned by #annotations.
	 */
	function dbus_annotation_info_lookup(annotations: DBusAnnotationInfo[] | null, name: string): string | null;
	/**
	 * Creates a D-Bus error name to use for #error. If #error matches
	 * a registered error (cf. {@link G.dbus_error_register_error}), the corresponding
	 * D-Bus error name will be returned.
	 * 
	 * Otherwise the a name of the form
	 * `org.gtk.GDBus.UnmappedGError.Quark._ESCAPED_QUARK_NAME.Code_ERROR_CODE`
	 * will be used. This allows other GDBus applications to map the error
	 * on the wire back to a #GError using g_dbus_error_new_for_dbus_error().
	 * 
	 * This function is typically only used in object mappings to put a
	 * #GError on the wire. Regular applications should not use it.
	 * @param error A #GError.
	 * @returns A D-Bus error name (never %NULL).
	 *     Free with {@link G.free}.
	 */
	function dbus_error_encode_gerror(error: GLib.Error): string;
	/**
	 * Gets the D-Bus error name used for #error, if any.
	 * 
	 * This function is guaranteed to return a D-Bus error name for all
	 * #GErrors returned from functions handling remote method calls
	 * (e.g. {@link G.dbus_connection_call_finish}) unless
	 * g_dbus_error_strip_remote_error() has been used on #error.
	 * @param error a #GError
	 * @returns an allocated string or %NULL if the
	 *     D-Bus error name could not be found. Free with {@link G.free}.
	 */
	function dbus_error_get_remote_error(error: GLib.Error): string | null;
	/**
	 * Checks if #error represents an error received via D-Bus from a remote peer. If so,
	 * use {@link G.dbus_error_get_remote_error} to get the name of the error.
	 * @param error A #GError.
	 * @returns %TRUE if #error represents an error from a remote peer,
	 * %FALSE otherwise.
	 */
	function dbus_error_is_remote_error(error: GLib.Error): boolean;
	/**
	 * Creates a #GError based on the contents of #dbus_error_name and
	 * #dbus_error_message.
	 * 
	 * Errors registered with {@link G.dbus_error_register_error} will be looked
	 * up using #dbus_error_name and if a match is found, the error domain
	 * and code is used. Applications can use g_dbus_error_get_remote_error()
	 * to recover #dbus_error_name.
	 * 
	 * If a match against a registered error is not found and the D-Bus
	 * error name is in a form as returned by g_dbus_error_encode_gerror()
	 * the error domain and code encoded in the name is used to
	 * create the #GError. Also, #dbus_error_name is added to the error message
	 * such that it can be recovered with g_dbus_error_get_remote_error().
	 * 
	 * Otherwise, a #GError with the error code %G_IO_ERROR_DBUS_ERROR
	 * in the #G_IO_ERROR error domain is returned. Also, #dbus_error_name is
	 * added to the error message such that it can be recovered with
	 * g_dbus_error_get_remote_error().
	 * 
	 * In all three cases, #dbus_error_name can always be recovered from the
	 * returned #GError using the g_dbus_error_get_remote_error() function
	 * (unless g_dbus_error_strip_remote_error() hasn't been used on the returned error).
	 * 
	 * This function is typically only used in object mappings to prepare
	 * #GError instances for applications. Regular applications should not use
	 * it.
	 * @param dbus_error_name D-Bus error name.
	 * @param dbus_error_message D-Bus error message.
	 * @returns An allocated #GError. Free with {@link G.error_free}.
	 */
	function dbus_error_new_for_dbus_error(dbus_error_name: string, dbus_error_message: string): GLib.Error;
	function dbus_error_quark(): GLib.Quark;
	/**
	 * Creates an association to map between #dbus_error_name and
	 * #GErrors specified by #error_domain and #error_code.
	 * 
	 * This is typically done in the routine that returns the #GQuark for
	 * an error domain.
	 * @param error_domain A #GQuark for an error domain.
	 * @param error_code An error code.
	 * @param dbus_error_name A D-Bus error name.
	 * @returns %TRUE if the association was created, %FALSE if it already
	 * exists.
	 */
	function dbus_error_register_error(error_domain: GLib.Quark, error_code: number, dbus_error_name: string): boolean;
	/**
	 * Helper function for associating a #GError error domain with D-Bus error names.
	 * 
	 * While #quark_volatile has a `volatile` qualifier, this is a historical
	 * artifact and the argument passed to it should not be `volatile`.
	 * @param error_domain_quark_name The error domain name.
	 * @param quark_volatile A pointer where to store the #GQuark.
	 * @param entries A pointer to #num_entries #GDBusErrorEntry struct items.
	 */
	function dbus_error_register_error_domain(error_domain_quark_name: string, quark_volatile: number, entries: DBusErrorEntry[]): void;
	/**
	 * Looks for extra information in the error message used to recover
	 * the D-Bus error name and strips it if found. If stripped, the
	 * message field in #error will correspond exactly to what was
	 * received on the wire.
	 * 
	 * This is typically used when presenting errors to the end user.
	 * @param error A #GError.
	 * @returns %TRUE if information was stripped, %FALSE otherwise.
	 */
	function dbus_error_strip_remote_error(error: GLib.Error): boolean;
	/**
	 * Destroys an association previously set up with {@link G.dbus_error_register_error}.
	 * @param error_domain A #GQuark for an error domain.
	 * @param error_code An error code.
	 * @param dbus_error_name A D-Bus error name.
	 * @returns %TRUE if the association was destroyed, %FALSE if it wasn't found.
	 */
	function dbus_error_unregister_error(error_domain: GLib.Quark, error_code: number, dbus_error_name: string): boolean;
	/**
	 * This is a language binding friendly version of {@link G.dbus_escape_object_path_bytestring}.
	 * @param s the string to escape
	 * @returns an escaped version of #s. Free with {@link G.free}.
	 */
	function dbus_escape_object_path(s: string): string;
	/**
	 * Escapes #bytes for use in a D-Bus object path component.
	 * #bytes is an array of zero or more nonzero bytes in an
	 * unspecified encoding, followed by a single zero byte.
	 * 
	 * The escaping method consists of replacing all non-alphanumeric
	 * characters (see {@link G.ascii_isalnum}) with their hexadecimal value
	 * preceded by an underscore (`_`). For example:
	 * `foo.bar.baz` will become `foo_2ebar_2ebaz`.
	 * 
	 * This method is appropriate to use when the input is nearly
	 * a valid object path component but is not when your input
	 * is far from being a valid object path component.
	 * Other escaping algorithms are also valid to use with
	 * D-Bus object paths.
	 * 
	 * This can be reversed with g_dbus_unescape_object_path().
	 * @param bytes the string of bytes to escape
	 * @returns an escaped version of #bytes. Free with {@link G.free}.
	 */
	function dbus_escape_object_path_bytestring(bytes: number[]): string;
	/**
	 * Generate a D-Bus GUID that can be used with
	 * e.g. {@link G.dbus_connection_new}.
	 * 
	 * See the
	 * [D-Bus specification](https://dbus.freedesktop.org/doc/dbus-specification.html#uuids)
	 * regarding what strings are valid D-Bus GUIDs. The specification refers to
	 * these as ‘UUIDs’ whereas GLib (for historical reasons) refers to them as
	 * ‘GUIDs’. The terms are interchangeable.
	 * 
	 * Note that D-Bus GUIDs do not follow
	 * [RFC 4122](https://datatracker.ietf.org/doc/html/rfc4122).
	 * @returns A valid D-Bus GUID. Free with {@link G.free}.
	 */
	function dbus_generate_guid(): string;
	/**
	 * Converts a #GValue to a #GVariant of the type indicated by the #type
	 * parameter.
	 * 
	 * The conversion is using the following rules:
	 * 
	 * - #G_TYPE_STRING: 's', 'o', 'g' or 'ay'
	 * - #G_TYPE_STRV: 'as', 'ao' or 'aay'
	 * - #G_TYPE_BOOLEAN: 'b'
	 * - #G_TYPE_UCHAR: 'y'
	 * - #G_TYPE_INT: 'i', 'n'
	 * - #G_TYPE_UINT: 'u', 'q'
	 * - #G_TYPE_INT64 'x'
	 * - #G_TYPE_UINT64: 't'
	 * - #G_TYPE_DOUBLE: 'd'
	 * - #G_TYPE_VARIANT: Any #GVariantType
	 * 
	 * This can fail if e.g. #gvalue is of type #G_TYPE_STRING and #type
	 * is ['i'][G-VARIANT-TYPE-INT32:CAPS]. It will also fail for any #GType
	 * (including e.g. #G_TYPE_OBJECT and #G_TYPE_BOXED derived-types) not
	 * in the table above.
	 * 
	 * Note that if #gvalue is of type #G_TYPE_VARIANT and its value is
	 * %NULL, the empty #GVariant instance (never %NULL) for #type is
	 * returned (e.g. 0 for scalar types, the empty string for string types,
	 * '/' for object path types, the empty array for any array type and so on).
	 * 
	 * See the {@link G.dbus_gvariant_to_gvalue} function for how to convert a
	 * #GVariant to a #GValue.
	 * @param gvalue A #GValue to convert to a #GVariant
	 * @param type A #GVariantType
	 * @returns A #GVariant (never floating) of
	 *     #GVariantType #type holding the data from #gvalue or an empty #GVariant
	 *     in case of failure. Free with {@link G.variant_unref}.
	 */
	function dbus_gvalue_to_gvariant(gvalue: GObject.Value, type: GLib.VariantType): GLib.Variant;
	/**
	 * Converts a #GVariant to a #GValue. If #value is floating, it is consumed.
	 * 
	 * The rules specified in the {@link G.dbus_gvalue_to_gvariant} function are
	 * used - this function is essentially its reverse form. So, a #GVariant
	 * containing any basic or string array type will be converted to a #GValue
	 * containing a basic value or string array. Any other #GVariant (handle,
	 * variant, tuple, dict entry) will be converted to a #GValue containing that
	 * #GVariant.
	 * 
	 * The conversion never fails - a valid #GValue is always returned in
	 * #out_gvalue.
	 * @param value A #GVariant.
	 * @returns Return location pointing to a zero-filled (uninitialized) #GValue.
	 */
	function dbus_gvariant_to_gvalue(value: GLib.Variant): GObject.Value;
	/**
	 * Checks if #string is a
	 * [D-Bus address](https://dbus.freedesktop.org/doc/dbus-specification.html#addresses).
	 * 
	 * This doesn't check if #string is actually supported by #GDBusServer
	 * or #GDBusConnection - use {@link G.dbus_is_supported_address} to do more
	 * checks.
	 * @param string A string.
	 * @returns %TRUE if #string is a valid D-Bus address, %FALSE otherwise.
	 */
	function dbus_is_address(string: string): boolean;
	/**
	 * Check whether #string is a valid D-Bus error name.
	 * 
	 * This function returns the same result as {@link G.dbus_is_interface_name},
	 * because D-Bus error names are defined to have exactly the
	 * same syntax as interface names.
	 * @param string The string to check.
	 * @returns %TRUE if valid, %FALSE otherwise.
	 */
	function dbus_is_error_name(string: string): boolean;
	/**
	 * Checks if #string is a D-Bus GUID.
	 * 
	 * See the documentation for {@link G.dbus_generate_guid} for more information about
	 * the format of a GUID.
	 * @param string The string to check.
	 * @returns %TRUE if #string is a GUID, %FALSE otherwise.
	 */
	function dbus_is_guid(string: string): boolean;
	/**
	 * Checks if #string is a valid D-Bus interface name.
	 * @param string The string to check.
	 * @returns %TRUE if valid, %FALSE otherwise.
	 */
	function dbus_is_interface_name(string: string): boolean;
	/**
	 * Checks if #string is a valid D-Bus member (e.g. signal or method) name.
	 * @param string The string to check.
	 * @returns %TRUE if valid, %FALSE otherwise.
	 */
	function dbus_is_member_name(string: string): boolean;
	/**
	 * Checks if #string is a valid D-Bus bus name (either unique or well-known).
	 * @param string The string to check.
	 * @returns %TRUE if valid, %FALSE otherwise.
	 */
	function dbus_is_name(string: string): boolean;
	/**
	 * Like {@link G.dbus_is_address} but also checks if the library supports the
	 * transports in #string and that key/value pairs for each transport
	 * are valid. See the specification of the
	 * [D-Bus address format](https://dbus.freedesktop.org/doc/dbus-specification.html#addresses).
	 * @param string A string.
	 * @returns %TRUE if #string is a valid D-Bus address that is
	 * supported by this library, %FALSE if #error is set.
	 */
	function dbus_is_supported_address(string: string): boolean;
	/**
	 * Checks if #string is a valid D-Bus unique bus name.
	 * @param string The string to check.
	 * @returns %TRUE if valid, %FALSE otherwise.
	 */
	function dbus_is_unique_name(string: string): boolean;
	/**
	 * Unescapes an string that was previously escaped with
	 * {@link G.dbus_escape_object_path}. If the string is in a format that could
	 * not have been returned by g_dbus_escape_object_path(), this function
	 * returns %NULL.
	 * 
	 * Encoding alphanumeric characters which do not need to be
	 * encoded is not allowed (e.g `_63` is not valid, the string
	 * should contain `c` instead).
	 * @param s the string to unescape
	 * @returns an
	 *   unescaped version of #s, or %NULL if #s is not a string returned
	 *   from {@link G.dbus_escape_object_path}. Free with g_free().
	 */
	function dbus_unescape_object_path(s: string): number[] | null;
	/**
	 * Creates a new #GDtlsClientConnection wrapping #base_socket which is
	 * assumed to communicate with the server identified by #server_identity.
	 * @param base_socket the #GDatagramBased to wrap
	 * @param server_identity the expected identity of the server
	 * @returns the new
	 *   #GDtlsClientConnection, or %NULL on error
	 */
	function dtls_client_connection_new(base_socket: DatagramBased, server_identity: SocketConnectable | null): DtlsClientConnection;
	/**
	 * Creates a new #GDtlsServerConnection wrapping #base_socket.
	 * @param base_socket the #GDatagramBased to wrap
	 * @param certificate the default server certificate, or %NULL
	 * @returns the new
	 *   #GDtlsServerConnection, or %NULL on error
	 */
	function dtls_server_connection_new(base_socket: DatagramBased, certificate: TlsCertificate | null): DtlsServerConnection;
	/**
	 * Creates a #GFile with the given argument from the command line.
	 * The value of #arg can be either a URI, an absolute path or a
	 * relative path resolved relative to the current working directory.
	 * This operation never fails, but the returned object might not
	 * support any I/O operation if #arg points to a malformed path.
	 * 
	 * Note that on Windows, this function expects its argument to be in
	 * UTF-8 -- not the system code page.  This means that you
	 * should not use this function with string from argv as it is passed
	 * to main().  g_win32_get_command_line() will return a UTF-8 version of
	 * the commandline.  #GApplication also uses UTF-8 but
	 * g_application_command_line_create_file_for_arg() may be more useful
	 * for you there.  It is also always possible to use this function with
	 * #GOptionContext arguments of type %G_OPTION_ARG_FILENAME.
	 * @param arg a command line string
	 * @returns a new #GFile.
	 *    Free the returned object with {@link GObject.unref}.
	 */
	function file_new_for_commandline_arg(arg: string): File;
	/**
	 * Creates a #GFile with the given argument from the command line.
	 * 
	 * This function is similar to {@link G.file_new_for_commandline_arg} except
	 * that it allows for passing the current working directory as an
	 * argument instead of using the current working directory of the
	 * process.
	 * 
	 * This is useful if the commandline argument was given in a context
	 * other than the invocation of the current process.
	 * 
	 * See also g_application_command_line_create_file_for_arg().
	 * @param arg a command line string
	 * @param cwd the current working directory of the commandline
	 * @returns a new #GFile
	 */
	function file_new_for_commandline_arg_and_cwd(arg: string, cwd: string): File;
	/**
	 * Constructs a #GFile for a given path. This operation never
	 * fails, but the returned object might not support any I/O
	 * operation if #path is malformed.
	 * @param path a string containing a relative or absolute path.
	 *     The string must be encoded in the glib filename encoding.
	 * @returns a new #GFile for the given #path.
	 *   Free the returned object with {@link GObject.unref}.
	 */
	function file_new_for_path(path: string): File;
	/**
	 * Constructs a #GFile for a given URI. This operation never
	 * fails, but the returned object might not support any I/O
	 * operation if #uri is malformed or if the uri type is
	 * not supported.
	 * @param uri a UTF-8 string containing a URI
	 * @returns a new #GFile for the given #uri.
	 *     Free the returned object with {@link GObject.unref}.
	 */
	function file_new_for_uri(uri: string): File;
	/**
	 * Opens a file in the preferred directory for temporary files (as
	 * returned by {@link G.get_tmp_dir}) and returns a #GFile and
	 * #GFileIOStream pointing to it.
	 * 
	 * #tmpl should be a string in the GLib file name encoding
	 * containing a sequence of six 'X' characters, and containing no
	 * directory components. If it is %NULL, a default template is used.
	 * 
	 * Unlike the other #GFile constructors, this will return %NULL if
	 * a temporary file could not be created.
	 * @param tmpl Template for the file
	 *   name, as in {@link G.file_open_tmp}, or %NULL for a default template
	 * @returns a new #GFile.
	 *     Free the returned object with {@link GObject.unref}.
	 * 
	 * on return, a #GFileIOStream for the created file
	 */
	function file_new_tmp(tmpl: string | null): [ File, FileIOStream ];
	/**
	 * Constructs a #GFile with the given #parse_name (i.e. something
	 * given by {@link G.file_get_parse_name}). This operation never fails,
	 * but the returned object might not support any I/O operation if
	 * the #parse_name cannot be parsed.
	 * @param parse_name a file name or path to be parsed
	 * @returns a new #GFile.
	 */
	function file_parse_name(parse_name: string): File;
	/**
	 * Deserializes a #GIcon previously serialized using {@link G.icon_serialize}.
	 * @param value a #GVariant created with {@link G.icon_serialize}
	 * @returns a #GIcon, or %NULL when deserialization fails.
	 */
	function icon_deserialize(value: GLib.Variant): Icon | null;
	/**
	 * Gets a hash for an icon.
	 * @param icon #gconstpointer to an icon object.
	 * @returns a #guint containing a hash for the #icon, suitable for
	 * use in a #GHashTable or similar data structure.
	 */
	function icon_hash(icon: any): number;
	/**
	 * Generate a #GIcon instance from #str. This function can fail if
	 * #str is not valid - see {@link G.icon_to_string} for discussion.
	 * 
	 * If your application or library provides one or more #GIcon
	 * implementations you need to ensure that each #GType is registered
	 * with the type system prior to calling g_icon_new_for_string().
	 * @param str A string obtained via {@link G.icon_to_string}.
	 * @returns An object implementing the #GIcon
	 *          interface or %NULL if #error is set.
	 */
	function icon_new_for_string(str: string): Icon;
	/**
	 * Helper function for constructing #GInitable object. This is
	 * similar to {@link GObject.newv} but also initializes the object
	 * and returns %NULL, setting an error on failure.
	 * @param object_type a #GType supporting #GInitable.
	 * @param parameters the parameters to use to construct the object
	 * @param cancellable optional #GCancellable object, %NULL to ignore.
	 * @returns a newly allocated
	 *      #GObject, or %NULL on error
	 */
	function initable_newv(object_type: GObject.Type, parameters: GObject.Parameter[], cancellable: Cancellable | null): GObject.Object;
	/**
	 * Converts errno.h error codes into GIO error codes. The fallback
	 * value %G_IO_ERROR_FAILED is returned for error codes not currently
	 * handled (but note that future GLib releases may return a more
	 * specific value instead).
	 * 
	 * As %errno is global and may be modified by intermediate function
	 * calls, you should save its value as soon as the call which sets it
	 * @param err_no Error number as defined in errno.h.
	 * @returns #GIOErrorEnum value for the given errno.h error number.
	 */
	function io_error_from_errno(err_no: number): IOErrorEnum;
	/**
	 * Gets the GIO Error Quark.
	 * @returns a #GQuark.
	 */
	function io_error_quark(): GLib.Quark;
	/**
	 * Registers #type as extension for the extension point with name
	 * #extension_point_name.
	 * 
	 * If #type has already been registered as an extension for this
	 * extension point, the existing #GIOExtension object is returned.
	 * @param extension_point_name the name of the extension point
	 * @param type the #GType to register as extension
	 * @param extension_name the name for the extension
	 * @param priority the priority for the extension
	 * @returns a #GIOExtension object for #GType
	 */
	function io_extension_point_implement(extension_point_name: string, type: GObject.Type, extension_name: string, priority: number): IOExtension;
	/**
	 * Looks up an existing extension point.
	 * @param name the name of the extension point
	 * @returns the #GIOExtensionPoint, or %NULL if there
	 *    is no registered extension point with the given name.
	 */
	function io_extension_point_lookup(name: string): IOExtensionPoint;
	/**
	 * Registers an extension point.
	 * @param name The name of the extension point
	 * @returns the new #GIOExtensionPoint. This object is
	 *    owned by GIO and should not be freed.
	 */
	function io_extension_point_register(name: string): IOExtensionPoint;
	/**
	 * Loads all the modules in the specified directory.
	 * 
	 * If don't require all modules to be initialized (and thus registering
	 * all gtypes) then you can use {@link G.io_modules_scan_all_in_directory}
	 * which allows delayed/lazy loading of modules.
	 * @param dirname pathname for a directory containing modules
	 *     to load.
	 * @returns a list of #GIOModules loaded
	 *      from the directory,
	 *      All the modules are loaded into memory, if you want to
	 *      unload them (enabling on-demand loading) you must call
	 *      {@link G.type_module_unuse} on all the modules. Free the list
	 *      with g_list_free().
	 */
	function io_modules_load_all_in_directory(dirname: string): IOModule[];
	/**
	 * Loads all the modules in the specified directory.
	 * 
	 * If don't require all modules to be initialized (and thus registering
	 * all gtypes) then you can use {@link G.io_modules_scan_all_in_directory}
	 * which allows delayed/lazy loading of modules.
	 * @param dirname pathname for a directory containing modules
	 *     to load.
	 * @param scope a scope to use when scanning the modules.
	 * @returns a list of #GIOModules loaded
	 *      from the directory,
	 *      All the modules are loaded into memory, if you want to
	 *      unload them (enabling on-demand loading) you must call
	 *      {@link G.type_module_unuse} on all the modules. Free the list
	 *      with g_list_free().
	 */
	function io_modules_load_all_in_directory_with_scope(dirname: string, scope: IOModuleScope): IOModule[];
	/**
	 * Scans all the modules in the specified directory, ensuring that
	 * any extension point implemented by a module is registered.
	 * 
	 * This may not actually load and initialize all the types in each
	 * module, some modules may be lazily loaded and initialized when
	 * an extension point it implements is used with e.g.
	 * {@link G.io_extension_point_get_extensions} or
	 * g_io_extension_point_get_extension_by_name().
	 * 
	 * If you need to guarantee that all types are loaded in all the modules,
	 * use g_io_modules_load_all_in_directory().
	 * @param dirname pathname for a directory containing modules
	 *     to scan.
	 */
	function io_modules_scan_all_in_directory(dirname: string): void;
	/**
	 * Scans all the modules in the specified directory, ensuring that
	 * any extension point implemented by a module is registered.
	 * 
	 * This may not actually load and initialize all the types in each
	 * module, some modules may be lazily loaded and initialized when
	 * an extension point it implements is used with e.g.
	 * {@link G.io_extension_point_get_extensions} or
	 * g_io_extension_point_get_extension_by_name().
	 * 
	 * If you need to guarantee that all types are loaded in all the modules,
	 * use g_io_modules_load_all_in_directory().
	 * @param dirname pathname for a directory containing modules
	 *     to scan.
	 * @param scope a scope to use when scanning the modules
	 */
	function io_modules_scan_all_in_directory_with_scope(dirname: string, scope: IOModuleScope): void;
	/**
	 * Cancels all cancellable I/O jobs.
	 * 
	 * A job is cancellable if a #GCancellable was passed into
	 * {@link G.io_scheduler_push_job}.
	 */
	function io_scheduler_cancel_all_jobs(): void;
	/**
	 * Schedules the I/O job to run in another thread.
	 * 
	 * #notify will be called on #user_data after #job_func has returned,
	 * regardless whether the job was cancelled or has run to completion.
	 * 
	 * If #cancellable is not %NULL, it can be used to cancel the I/O job
	 * by calling {@link G.cancellable_cancel} or by calling
	 * g_io_scheduler_cancel_all_jobs().
	 * @param job_func a #GIOSchedulerJobFunc.
	 * @param io_priority the [I/O priority][io-priority]
	 * of the request.
	 * @param cancellable optional #GCancellable object, %NULL to ignore.
	 */
	function io_scheduler_push_job(job_func: IOSchedulerJobFunc, io_priority: number, cancellable: Cancellable | null): void;
	/**
	 * Creates a keyfile-backed #GSettingsBackend.
	 * 
	 * The filename of the keyfile to use is given by #filename.
	 * 
	 * All settings read to or written from the backend must fall under the
	 * path given in #root_path (which must start and end with a slash and
	 * not contain two consecutive slashes).  #root_path may be "/".
	 * 
	 * If #root_group is non-%NULL then it specifies the name of the keyfile
	 * group used for keys that are written directly below #root_path.  For
	 * example, if #root_path is "/apps/example/" and #root_group is
	 * "toplevel", then settings the key "/apps/example/enabled" to a value
	 * of %TRUE will cause the following to appear in the keyfile:
	 * 
	 * |[
	 *   [toplevel]
	 *   enabled=true
	 * ]|
	 * 
	 * If #root_group is %NULL then it is not permitted to store keys
	 * directly below the #root_path.
	 * 
	 * For keys not stored directly below #root_path (ie: in a sub-path),
	 * the name of the subpath (with the final slash stripped) is used as
	 * the name of the keyfile group.  To continue the example, if
	 * "/apps/example/profiles/default/font-size" were set to
	 * 12 then the following would appear in the keyfile:
	 * 
	 * |[
	 *   [profiles/default]
	 *   font-size=12
	 * ]|
	 * 
	 * The backend will refuse writes (and return writability as being
	 * %FALSE) for keys outside of #root_path and, in the event that
	 * #root_group is %NULL, also for keys directly under #root_path.
	 * Writes will also be refused if the backend detects that it has the
	 * inability to rewrite the keyfile (ie: the containing directory is not
	 * writable).
	 * 
	 * There is no checking done for your key namespace clashing with the
	 * syntax of the key file format.  For example, if you have '[' or ']'
	 * characters in your path names or '=' in your key names you may be in
	 * trouble.
	 * 
	 * The backend reads default values from a keyfile called `defaults` in
	 * the directory specified by the #GKeyfileSettingsBackend:defaults-dir property,
	 * and a list of locked keys from a text file with the name `locks` in
	 * the same location.
	 * @param filename the filename of the keyfile
	 * @param root_path the path under which all settings keys appear
	 * @param root_group the group name corresponding to
	 *              #root_path, or %NULL
	 * @returns a keyfile-backed #GSettingsBackend
	 */
	function keyfile_settings_backend_new(filename: string, root_path: string, root_group: string | null): SettingsBackend;
	/**
	 * Gets a reference to the default #GMemoryMonitor for the system.
	 * @returns a new reference to the default #GMemoryMonitor
	 */
	function memory_monitor_dup_default(): MemoryMonitor;
	/**
	 * Creates a memory-backed #GSettingsBackend.
	 * 
	 * This backend allows changes to settings, but does not write them
	 * to any backing storage, so the next time you run your application,
	 * the memory backend will start out with the default values again.
	 * @returns a newly created #GSettingsBackend
	 */
	function memory_settings_backend_new(): SettingsBackend;
	/**
	 * Gets the default #GNetworkMonitor for the system.
	 * @returns a #GNetworkMonitor, which will be
	 *     a dummy object if no network monitor is available
	 */
	function network_monitor_get_default(): NetworkMonitor;
	/**
	 * Initializes the platform networking libraries (eg, on Windows, this
	 * calls WSAStartup()). GLib will call this itself if it is needed, so
	 * you only need to call it if you directly call system networking
	 * functions (without calling any GLib networking functions first).
	 */
	function networking_init(): void;
	/**
	 * Creates a readonly #GSettingsBackend.
	 * 
	 * This backend does not allow changes to settings, so all settings
	 * will always have their default values.
	 * @returns a newly created #GSettingsBackend
	 */
	function null_settings_backend_new(): SettingsBackend;
	/**
	 * Utility method for #GPollableInputStream and #GPollableOutputStream
	 * implementations. Creates a new #GSource that expects a callback of
	 * type #GPollableSourceFunc. The new source does not actually do
	 * anything on its own; use {@link G.source_add_child_source} to add other
	 * sources to it to cause it to trigger.
	 * @param pollable_stream the stream associated with the new source
	 * @returns the new #GSource.
	 */
	function pollable_source_new(pollable_stream: GObject.Object): GLib.Source;
	/**
	 * Utility method for #GPollableInputStream and #GPollableOutputStream
	 * implementations. Creates a new #GSource, as with
	 * {@link G.pollable_source_new}, but also attaching #child_source (with a
	 * dummy callback), and #cancellable, if they are non-%NULL.
	 * @param pollable_stream the stream associated with the
	 *   new source
	 * @param child_source optional child source to attach
	 * @param cancellable optional #GCancellable to attach
	 * @returns the new #GSource.
	 */
	function pollable_source_new_full(pollable_stream: GObject.Object, child_source: GLib.Source | null, cancellable: Cancellable | null): GLib.Source;
	/**
	 * Tries to read from #stream, as with {@link G.input_stream_read} (if
	 * #blocking is %TRUE) or g_pollable_input_stream_read_nonblocking()
	 * (if #blocking is %FALSE). This can be used to more easily share
	 * code between blocking and non-blocking implementations of a method.
	 * 
	 * If #blocking is %FALSE, then #stream must be a
	 * #GPollableInputStream for which g_pollable_input_stream_can_poll()
	 * returns %TRUE, or else the behavior is undefined. If #blocking is
	 * %TRUE, then #stream does not need to be a #GPollableInputStream.
	 * @param stream a #GInputStream
	 * @param buffer a buffer to
	 *   read data into
	 * @param blocking whether to do blocking I/O
	 * @param cancellable optional #GCancellable object, %NULL to ignore.
	 * @returns the number of bytes read, or -1 on error.
	 */
	function pollable_stream_read(stream: InputStream, buffer: number[], blocking: boolean, cancellable: Cancellable | null): number;
	/**
	 * Tries to write to #stream, as with {@link G.output_stream_write} (if
	 * #blocking is %TRUE) or g_pollable_output_stream_write_nonblocking()
	 * (if #blocking is %FALSE). This can be used to more easily share
	 * code between blocking and non-blocking implementations of a method.
	 * 
	 * If #blocking is %FALSE, then #stream must be a
	 * #GPollableOutputStream for which
	 * g_pollable_output_stream_can_poll() returns %TRUE or else the
	 * behavior is undefined. If #blocking is %TRUE, then #stream does not
	 * need to be a #GPollableOutputStream.
	 * @param stream a #GOutputStream.
	 * @param buffer the buffer
	 *   containing the data to write.
	 * @param blocking whether to do blocking I/O
	 * @param cancellable optional #GCancellable object, %NULL to ignore.
	 * @returns the number of bytes written, or -1 on error.
	 */
	function pollable_stream_write(stream: OutputStream, buffer: number[], blocking: boolean, cancellable: Cancellable | null): number;
	/**
	 * Tries to write #count bytes to #stream, as with
	 * {@link G.output_stream_write_all}, but using g_pollable_stream_write()
	 * rather than g_output_stream_write().
	 * 
	 * On a successful write of #count bytes, %TRUE is returned, and
	 * #bytes_written is set to #count.
	 * 
	 * If there is an error during the operation (including
	 * %G_IO_ERROR_WOULD_BLOCK in the non-blocking case), %FALSE is
	 * returned and #error is set to indicate the error status,
	 * #bytes_written is updated to contain the number of bytes written
	 * into the stream before the error occurred.
	 * 
	 * As with g_pollable_stream_write(), if #blocking is %FALSE, then
	 * #stream must be a #GPollableOutputStream for which
	 * g_pollable_output_stream_can_poll() returns %TRUE or else the
	 * behavior is undefined. If #blocking is %TRUE, then #stream does not
	 * need to be a #GPollableOutputStream.
	 * @param stream a #GOutputStream.
	 * @param buffer the buffer
	 *   containing the data to write.
	 * @param blocking whether to do blocking I/O
	 * @param cancellable optional #GCancellable object, %NULL to ignore.
	 * @returns %TRUE on success, %FALSE if there was an error
	 * 
	 * location to store the number of bytes that was
	 *   written to the stream
	 */
	function pollable_stream_write_all(stream: OutputStream, buffer: number[], blocking: boolean, cancellable: Cancellable | null): [ boolean, number ];
	/**
	 * Gets a reference to the default #GPowerProfileMonitor for the system.
	 * @returns a new reference to the default #GPowerProfileMonitor
	 */
	function power_profile_monitor_dup_default(): PowerProfileMonitor;
	/**
	 * Find the `gio-proxy` extension point for a proxy implementation that supports
	 * the specified protocol.
	 * @param protocol the proxy protocol name (e.g. http, socks, etc)
	 * @returns return a #GProxy or NULL if protocol
	 *               is not supported.
	 */
	function proxy_get_default_for_protocol(protocol: string): Proxy | null;
	/**
	 * Gets the default #GProxyResolver for the system.
	 * @returns the default #GProxyResolver, which
	 *     will be a dummy object if no proxy resolver is available
	 */
	function proxy_resolver_get_default(): ProxyResolver;
	/**
	 * Gets the #GResolver Error Quark.
	 * @returns a #GQuark.
	 */
	function resolver_error_quark(): GLib.Quark;
	/**
	 * Gets the #GResource Error Quark.
	 * @returns a #GQuark
	 */
	function resource_error_quark(): GLib.Quark;
	/**
	 * Loads a binary resource bundle and creates a #GResource representation of it, allowing
	 * you to query it for data.
	 * 
	 * If you want to use this resource in the global resource namespace you need
	 * to register it with {@link G.resources_register}.
	 * 
	 * If #filename is empty or the data in it is corrupt,
	 * %G_RESOURCE_ERROR_INTERNAL will be returned. If #filename doesn’t exist, or
	 * there is an error in reading it, an error from g_mapped_file_new() will be
	 * returned.
	 * @param filename the path of a filename to load, in the GLib filename encoding
	 * @returns a new #GResource, or %NULL on error
	 */
	function resource_load(filename: string): Resource;
	/**
	 * Returns all the names of children at the specified #path in the set of
	 * globally registered resources.
	 * The return result is a %NULL terminated list of strings which should
	 * be released with {@link G.strfreev}.
	 * 
	 * #lookup_flags controls the behaviour of the lookup.
	 * @param path A pathname inside the resource
	 * @param lookup_flags A #GResourceLookupFlags
	 * @returns an array of constant strings
	 */
	function resources_enumerate_children(path: string, lookup_flags: ResourceLookupFlags): string[];
	/**
	 * Looks for a file at the specified #path in the set of
	 * globally registered resources and if found returns information about it.
	 * 
	 * #lookup_flags controls the behaviour of the lookup.
	 * @param path A pathname inside the resource
	 * @param lookup_flags A #GResourceLookupFlags
	 * @returns %TRUE if the file was found. %FALSE if there were errors
	 * 
	 * a location to place the length of the contents of the file,
	 *    or %NULL if the length is not needed
	 * 
	 * a location to place the #GResourceFlags about the file,
	 *    or %NULL if the flags are not needed
	 */
	function resources_get_info(path: string, lookup_flags: ResourceLookupFlags): [ boolean, number | null, number | null ];
	/**
	 * Looks for a file at the specified #path in the set of
	 * globally registered resources and returns a #GBytes that
	 * lets you directly access the data in memory.
	 * 
	 * The data is always followed by a zero byte, so you
	 * can safely use the data as a C string. However, that byte
	 * is not included in the size of the GBytes.
	 * 
	 * For uncompressed resource files this is a pointer directly into
	 * the resource bundle, which is typically in some readonly data section
	 * in the program binary. For compressed files we allocate memory on
	 * the heap and automatically uncompress the data.
	 * 
	 * #lookup_flags controls the behaviour of the lookup.
	 * @param path A pathname inside the resource
	 * @param lookup_flags A #GResourceLookupFlags
	 * @returns #GBytes or %NULL on error.
	 *     Free the returned object with {@link G.bytes_unref}
	 */
	function resources_lookup_data(path: string, lookup_flags: ResourceLookupFlags): GLib.Bytes;
	/**
	 * Looks for a file at the specified #path in the set of
	 * globally registered resources and returns a #GInputStream
	 * that lets you read the data.
	 * 
	 * #lookup_flags controls the behaviour of the lookup.
	 * @param path A pathname inside the resource
	 * @param lookup_flags A #GResourceLookupFlags
	 * @returns #GInputStream or %NULL on error.
	 *     Free the returned object with {@link GObject.unref}
	 */
	function resources_open_stream(path: string, lookup_flags: ResourceLookupFlags): InputStream;
	/**
	 * Registers the resource with the process-global set of resources.
	 * Once a resource is registered the files in it can be accessed
	 * with the global resource lookup functions like {@link G.resources_lookup_data}.
	 * @param resource A #GResource
	 */
	function resources_register(resource: Resource): void;
	/**
	 * Unregisters the resource from the process-global set of resources.
	 * @param resource A #GResource
	 */
	function resources_unregister(resource: Resource): void;
	/**
	 * Gets the default system schema source.
	 * 
	 * This function is not required for normal uses of #GSettings but it
	 * may be useful to authors of plugin management systems or to those who
	 * want to introspect the content of schemas.
	 * 
	 * If no schemas are installed, %NULL will be returned.
	 * 
	 * The returned source may actually consist of multiple schema sources
	 * from different directories, depending on which directories were given
	 * in `XDG_DATA_DIRS` and `GSETTINGS_SCHEMA_DIR`. For this reason, all
	 * lookups performed against the default source should probably be done
	 * recursively.
	 * @returns the default schema source
	 */
	function settings_schema_source_get_default(): SettingsSchemaSource | null;
	/**
	 * Reports an error in an asynchronous function in an idle function by
	 * directly setting the contents of the #GAsyncResult with the given error
	 * information.
	 * @param object a #GObject, or %NULL.
	 * @param callback a #GAsyncReadyCallback.
	 * @param domain a #GQuark containing the error domain (usually #G_IO_ERROR).
	 * @param code a specific error code.
	 * @param format a formatted error reporting string.
	 */
	function simple_async_report_error_in_idle(object: GObject.Object | null, callback: AsyncReadyCallback | null, domain: GLib.Quark, code: number, format: string): void;
	/**
	 * Reports an error in an idle function. Similar to
	 * {@link G.simple_async_report_error_in_idle}, but takes a #GError rather
	 * than building a new one.
	 * @param object a #GObject, or %NULL
	 * @param callback a #GAsyncReadyCallback.
	 * @param error the #GError to report
	 */
	function simple_async_report_gerror_in_idle(object: GObject.Object | null, callback: AsyncReadyCallback | null, error: GLib.Error): void;
	/**
	 * Reports an error in an idle function. Similar to
	 * {@link G.simple_async_report_gerror_in_idle}, but takes over the caller's
	 * ownership of #error, so the caller does not have to free it any more.
	 * @param object a #GObject, or %NULL
	 * @param callback a #GAsyncReadyCallback.
	 * @param error the #GError to report
	 */
	function simple_async_report_take_gerror_in_idle(object: GObject.Object | null, callback: AsyncReadyCallback | null, error: GLib.Error): void;
	/**
	 * Sorts #targets in place according to the algorithm in RFC 2782.
	 * @param targets a #GList of #GSrvTarget
	 * @returns the head of the sorted list.
	 */
	function srv_target_list_sort(targets: any[]): any[];
	/**
	 * Gets the default #GTlsBackend for the system.
	 * @returns a #GTlsBackend, which will be a
	 *     dummy object if no TLS backend is available
	 */
	function tls_backend_get_default(): TlsBackend;
	/**
	 * Gets the TLS channel binding error quark.
	 * @returns a #GQuark.
	 */
	function tls_channel_binding_error_quark(): GLib.Quark;
	/**
	 * Creates a new #GTlsClientConnection wrapping #base_io_stream (which
	 * must have pollable input and output streams) which is assumed to
	 * communicate with the server identified by #server_identity.
	 * 
	 * See the documentation for #GTlsConnection:base-io-stream for restrictions
	 * on when application code can run operations on the #base_io_stream after
	 * this function has returned.
	 * @param base_io_stream the #GIOStream to wrap
	 * @param server_identity the expected identity of the server
	 * @returns the new
	 * #GTlsClientConnection, or %NULL on error
	 */
	function tls_client_connection_new(base_io_stream: IOStream, server_identity: SocketConnectable | null): TlsClientConnection;
	/**
	 * Gets the TLS error quark.
	 * @returns a #GQuark.
	 */
	function tls_error_quark(): GLib.Quark;
	/**
	 * Creates a new #GTlsFileDatabase which uses anchor certificate authorities
	 * in #anchors to verify certificate chains.
	 * 
	 * The certificates in #anchors must be PEM encoded.
	 * @param anchors filename of anchor certificate authorities.
	 * @returns the new
	 * #GTlsFileDatabase, or %NULL on error
	 */
	function tls_file_database_new(anchors: string): TlsFileDatabase;
	/**
	 * Creates a new #GTlsServerConnection wrapping #base_io_stream (which
	 * must have pollable input and output streams).
	 * 
	 * See the documentation for #GTlsConnection:base-io-stream for restrictions
	 * on when application code can run operations on the #base_io_stream after
	 * this function has returned.
	 * @param base_io_stream the #GIOStream to wrap
	 * @param certificate the default server certificate, or %NULL
	 * @returns the new
	 * #GTlsServerConnection, or %NULL on error
	 */
	function tls_server_connection_new(base_io_stream: IOStream, certificate: TlsCertificate | null): TlsServerConnection;
	/**
	 * Determines if #mount_path is considered an implementation of the
	 * OS. This is primarily used for hiding mountable and mounted volumes
	 * that only are used in the OS and has little to no relevance to the
	 * casual user.
	 * @param mount_path a mount path, e.g. `/media/disk` or `/usr`
	 * @returns %TRUE if #mount_path is considered an implementation detail
	 *     of the OS.
	 */
	function unix_is_mount_path_system_internal(mount_path: string): boolean;
	/**
	 * Determines if #device_path is considered a block device path which is only
	 * used in implementation of the OS. This is primarily used for hiding
	 * mounted volumes that are intended as APIs for programs to read, and system
	 * administrators at a shell; rather than something that should, for example,
	 * appear in a GUI. For example, the Linux `/proc` filesystem.
	 * 
	 * The list of device paths considered ‘system’ ones may change over time.
	 * @param device_path a device path, e.g. `/dev/loop0` or `nfsd`
	 * @returns %TRUE if #device_path is considered an implementation detail of
	 *    the OS.
	 */
	function unix_is_system_device_path(device_path: string): boolean;
	/**
	 * Determines if #fs_type is considered a type of file system which is only
	 * used in implementation of the OS. This is primarily used for hiding
	 * mounted volumes that are intended as APIs for programs to read, and system
	 * administrators at a shell; rather than something that should, for example,
	 * appear in a GUI. For example, the Linux `/proc` filesystem.
	 * 
	 * The list of file system types considered ‘system’ ones may change over time.
	 * @param fs_type a file system type, e.g. `procfs` or `tmpfs`
	 * @returns %TRUE if #fs_type is considered an implementation detail of the OS.
	 */
	function unix_is_system_fs_type(fs_type: string): boolean;
	/**
	 * Gets a #GUnixMountEntry for a given mount path. If #time_read
	 * is set, it will be filled with a unix timestamp for checking
	 * if the mounts have changed since with {@link G.unix_mounts_changed_since}.
	 * 
	 * If more mounts have the same mount path, the last matching mount
	 * is returned.
	 * 
	 * This will return %NULL if there is no mount point at #mount_path.
	 * @param mount_path path for a possible unix mount.
	 * @returns a #GUnixMountEntry.
	 * 
	 * guint64 to contain a timestamp.
	 */
	function unix_mount_at(mount_path: string): [ UnixMountEntry | null, number | null ];
	/**
	 * Compares two unix mounts.
	 * @param mount1 first #GUnixMountEntry to compare.
	 * @param mount2 second #GUnixMountEntry to compare.
	 * @returns 1, 0 or -1 if #mount1 is greater than, equal to,
	 * or less than #mount2, respectively.
	 */
	function unix_mount_compare(mount1: UnixMountEntry, mount2: UnixMountEntry): number;
	/**
	 * Makes a copy of #mount_entry.
	 * @param mount_entry a #GUnixMountEntry.
	 * @returns a new #GUnixMountEntry
	 */
	function unix_mount_copy(mount_entry: UnixMountEntry): UnixMountEntry;
	/**
	 * Gets a #GUnixMountEntry for a given file path. If #time_read
	 * is set, it will be filled with a unix timestamp for checking
	 * if the mounts have changed since with {@link G.unix_mounts_changed_since}.
	 * 
	 * If more mounts have the same mount path, the last matching mount
	 * is returned.
	 * 
	 * This will return %NULL if looking up the mount entry fails, if
	 * #file_path doesn’t exist or there is an I/O error.
	 * @param file_path file path on some unix mount.
	 * @returns a #GUnixMountEntry.
	 * 
	 * guint64 to contain a timestamp.
	 */
	function unix_mount_for(file_path: string): [ UnixMountEntry | null, number | null ];
	/**
	 * Frees a unix mount.
	 * @param mount_entry a #GUnixMountEntry.
	 */
	function unix_mount_free(mount_entry: UnixMountEntry): void;
	/**
	 * Gets the device path for a unix mount.
	 * @param mount_entry a #GUnixMount.
	 * @returns a string containing the device path.
	 */
	function unix_mount_get_device_path(mount_entry: UnixMountEntry): string;
	/**
	 * Gets the filesystem type for the unix mount.
	 * @param mount_entry a #GUnixMount.
	 * @returns a string containing the file system type.
	 */
	function unix_mount_get_fs_type(mount_entry: UnixMountEntry): string;
	/**
	 * Gets the mount path for a unix mount.
	 * @param mount_entry input #GUnixMountEntry to get the mount path for.
	 * @returns the mount path for #mount_entry.
	 */
	function unix_mount_get_mount_path(mount_entry: UnixMountEntry): string;
	/**
	 * Gets a comma-separated list of mount options for the unix mount. For example,
	 * `rw,relatime,seclabel,data=ordered`.
	 * 
	 * This is similar to {@link G.unix_mount_point_get_options}, but it takes
	 * a #GUnixMountEntry as an argument.
	 * @param mount_entry a #GUnixMountEntry.
	 * @returns a string containing the options, or %NULL if not
	 * available.
	 */
	function unix_mount_get_options(mount_entry: UnixMountEntry): string | null;
	/**
	 * Gets the root of the mount within the filesystem. This is useful e.g. for
	 * mounts created by bind operation, or btrfs subvolumes.
	 * 
	 * For example, the root path is equal to "/" for mount created by
	 * "mount /dev/sda1 /mnt/foo" and "/bar" for
	 * "mount --bind /mnt/foo/bar /mnt/bar".
	 * @param mount_entry a #GUnixMountEntry.
	 * @returns a string containing the root, or %NULL if not supported.
	 */
	function unix_mount_get_root_path(mount_entry: UnixMountEntry): string | null;
	/**
	 * Guesses whether a Unix mount can be ejected.
	 * @param mount_entry a #GUnixMountEntry
	 * @returns %TRUE if #mount_entry is deemed to be ejectable.
	 */
	function unix_mount_guess_can_eject(mount_entry: UnixMountEntry): boolean;
	/**
	 * Guesses the icon of a Unix mount.
	 * @param mount_entry a #GUnixMountEntry
	 * @returns a #GIcon
	 */
	function unix_mount_guess_icon(mount_entry: UnixMountEntry): Icon;
	/**
	 * Guesses the name of a Unix mount.
	 * The result is a translated string.
	 * @param mount_entry a #GUnixMountEntry
	 * @returns A newly allocated string that must
	 *     be freed with {@link G.free}
	 */
	function unix_mount_guess_name(mount_entry: UnixMountEntry): string;
	/**
	 * Guesses whether a Unix mount should be displayed in the UI.
	 * @param mount_entry a #GUnixMountEntry
	 * @returns %TRUE if #mount_entry is deemed to be displayable.
	 */
	function unix_mount_guess_should_display(mount_entry: UnixMountEntry): boolean;
	/**
	 * Guesses the symbolic icon of a Unix mount.
	 * @param mount_entry a #GUnixMountEntry
	 * @returns a #GIcon
	 */
	function unix_mount_guess_symbolic_icon(mount_entry: UnixMountEntry): Icon;
	/**
	 * Checks if a unix mount is mounted read only.
	 * @param mount_entry a #GUnixMount.
	 * @returns %TRUE if #mount_entry is read only.
	 */
	function unix_mount_is_readonly(mount_entry: UnixMountEntry): boolean;
	/**
	 * Checks if a Unix mount is a system mount. This is the Boolean OR of
	 * {@link G.unix_is_system_fs_type}, g_unix_is_system_device_path() and
	 * g_unix_is_mount_path_system_internal() on #mount_entry’s properties.
	 * 
	 * The definition of what a ‘system’ mount entry is may change over time as new
	 * file system types and device paths are ignored.
	 * @param mount_entry a #GUnixMount.
	 * @returns %TRUE if the unix mount is for a system path.
	 */
	function unix_mount_is_system_internal(mount_entry: UnixMountEntry): boolean;
	/**
	 * Gets a #GUnixMountPoint for a given mount path. If #time_read is set, it
	 * will be filled with a unix timestamp for checking if the mount points have
	 * changed since with {@link G.unix_mount_points_changed_since}.
	 * 
	 * If more mount points have the same mount path, the last matching mount point
	 * is returned.
	 * @param mount_path path for a possible unix mount point.
	 * @returns a #GUnixMountPoint, or %NULL if no match
	 * is found.
	 * 
	 * guint64 to contain a timestamp.
	 */
	function unix_mount_point_at(mount_path: string): [ UnixMountPoint | null, number | null ];
	/**
	 * Checks if the unix mount points have changed since a given unix time.
	 * @param time guint64 to contain a timestamp.
	 * @returns %TRUE if the mount points have changed since #time.
	 */
	function unix_mount_points_changed_since(time: number): boolean;
	/**
	 * Gets a #GList of #GUnixMountPoint containing the unix mount points.
	 * If #time_read is set, it will be filled with the mount timestamp,
	 * allowing for checking if the mounts have changed with
	 * {@link G.unix_mount_points_changed_since}.
	 * @returns 
	 *     a #GList of the UNIX mountpoints.
	 * 
	 * guint64 to contain a timestamp.
	 */
	function unix_mount_points_get(): [ UnixMountPoint[], number | null ];
	/**
	 * Checks if the unix mounts have changed since a given unix time.
	 * @param time guint64 to contain a timestamp.
	 * @returns %TRUE if the mounts have changed since #time.
	 */
	function unix_mounts_changed_since(time: number): boolean;
	/**
	 * Gets a #GList of #GUnixMountEntry containing the unix mounts.
	 * If #time_read is set, it will be filled with the mount
	 * timestamp, allowing for checking if the mounts have changed
	 * with {@link G.unix_mounts_changed_since}.
	 * @returns 
	 *     a #GList of the UNIX mounts.
	 * 
	 * guint64 to contain a timestamp, or %NULL
	 */
	function unix_mounts_get(): [ UnixMountEntry[], number | null ];
	/**
	 * The value returned by handlers of the signals generated by
	 * the `gdbus-codegen` tool to indicate that a method call has been
	 * handled by an implementation. It is equal to %TRUE, but using
	 * this macro is sometimes more readable.
	 * 
	 * In code that needs to be backwards-compatible with older GLib,
	 * use %TRUE instead, often written like this:
	 * 
	 * |[
	 *   g_dbus_method_invocation_return_error (invocation, ...);
	 *   return TRUE;    // handled
	 * ]|
	 * @returns The value returned by handlers of the signals generated by
	 * the `gdbus-codegen` tool to indicate that a method call has been
	 * handled by an implementation. It is equal to %TRUE, but using
	 * this macro is sometimes more readable.
	 * 
	 * In code that needs to be backwards-compatible with older GLib,
	 * use %TRUE instead, often written like this:
	 * 
	 * |[
	 *   g_dbus_method_invocation_return_error (invocation, ...);
	 *   return TRUE;    // handled
	 * ]|
	 */
	const DBUS_METHOD_INVOCATION_HANDLED: boolean;

	/**
	 * The value returned by handlers of the signals generated by
	 * the `gdbus-codegen` tool to indicate that a method call has not been
	 * handled by an implementation. It is equal to %FALSE, but using
	 * this macro is sometimes more readable.
	 * 
	 * In code that needs to be backwards-compatible with older GLib,
	 * use %FALSE instead.
	 * @returns The value returned by handlers of the signals generated by
	 * the `gdbus-codegen` tool to indicate that a method call has not been
	 * handled by an implementation. It is equal to %FALSE, but using
	 * this macro is sometimes more readable.
	 * 
	 * In code that needs to be backwards-compatible with older GLib,
	 * use %FALSE instead.
	 */
	const DBUS_METHOD_INVOCATION_UNHANDLED: boolean;

	/**
	 * Extension point for default handler to URI association. See
	 * [Extending GIO][extending-gio].
	 * @returns Extension point for default handler to URI association. See
	 * [Extending GIO][extending-gio].
	 */
	const DESKTOP_APP_INFO_LOOKUP_EXTENSION_POINT_NAME: string;

	/**
	 * The string used to obtain a Unix device path with {@link G.drive_get_identifier}.
	 * @returns The string used to obtain a Unix device path with {@link G.drive_get_identifier}.
	 */
	const DRIVE_IDENTIFIER_KIND_UNIX_DEVICE: string;

	/**
	 * A key in the "access" namespace for checking deletion privileges.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
	 * 
	 * This attribute will be %TRUE if the user is able to delete the file.
	 * @returns A key in the "access" namespace for checking deletion privileges.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
	 * 
	 * This attribute will be %TRUE if the user is able to delete the file.
	 */
	const FILE_ATTRIBUTE_ACCESS_CAN_DELETE: string;

	/**
	 * A key in the "access" namespace for getting execution privileges.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
	 * 
	 * This attribute will be %TRUE if the user is able to execute the file.
	 * @returns A key in the "access" namespace for getting execution privileges.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
	 * 
	 * This attribute will be %TRUE if the user is able to execute the file.
	 */
	const FILE_ATTRIBUTE_ACCESS_CAN_EXECUTE: string;

	/**
	 * A key in the "access" namespace for getting read privileges.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
	 * 
	 * This attribute will be %TRUE if the user is able to read the file.
	 * @returns A key in the "access" namespace for getting read privileges.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
	 * 
	 * This attribute will be %TRUE if the user is able to read the file.
	 */
	const FILE_ATTRIBUTE_ACCESS_CAN_READ: string;

	/**
	 * A key in the "access" namespace for checking renaming privileges.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
	 * 
	 * This attribute will be %TRUE if the user is able to rename the file.
	 * @returns A key in the "access" namespace for checking renaming privileges.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
	 * 
	 * This attribute will be %TRUE if the user is able to rename the file.
	 */
	const FILE_ATTRIBUTE_ACCESS_CAN_RENAME: string;

	/**
	 * A key in the "access" namespace for checking trashing privileges.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
	 * 
	 * This attribute will be %TRUE if the user is able to move the file to
	 * the trash.
	 * @returns A key in the "access" namespace for checking trashing privileges.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
	 * 
	 * This attribute will be %TRUE if the user is able to move the file to
	 * the trash.
	 */
	const FILE_ATTRIBUTE_ACCESS_CAN_TRASH: string;

	/**
	 * A key in the "access" namespace for getting write privileges.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
	 * 
	 * This attribute will be %TRUE if the user is able to write to the file.
	 * @returns A key in the "access" namespace for getting write privileges.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
	 * 
	 * This attribute will be %TRUE if the user is able to write to the file.
	 */
	const FILE_ATTRIBUTE_ACCESS_CAN_WRITE: string;

	/**
	 * A key in the "dos" namespace for checking if the file's archive flag
	 * is set.
	 * 
	 * This attribute is %TRUE if the archive flag is set.
	 * 
	 * This attribute is only available for DOS file systems.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
	 * @returns A key in the "dos" namespace for checking if the file's archive flag
	 * is set.
	 * 
	 * This attribute is %TRUE if the archive flag is set.
	 * 
	 * This attribute is only available for DOS file systems.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
	 */
	const FILE_ATTRIBUTE_DOS_IS_ARCHIVE: string;

	/**
	 * A key in the "dos" namespace for checking if the file is a NTFS mount point
	 * (a volume mount or a junction point).
	 * 
	 * This attribute is %TRUE if file is a reparse point of type
	 * [IO_REPARSE_TAG_MOUNT_POINT](https://msdn.microsoft.com/en-us/library/dd541667.aspx).
	 * 
	 * This attribute is only available for DOS file systems.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
	 * @returns A key in the "dos" namespace for checking if the file is a NTFS mount point
	 * (a volume mount or a junction point).
	 * 
	 * This attribute is %TRUE if file is a reparse point of type
	 * [IO_REPARSE_TAG_MOUNT_POINT](https://msdn.microsoft.com/en-us/library/dd541667.aspx).
	 * 
	 * This attribute is only available for DOS file systems.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
	 */
	const FILE_ATTRIBUTE_DOS_IS_MOUNTPOINT: string;

	/**
	 * A key in the "dos" namespace for checking if the file's backup flag
	 * is set.
	 * 
	 * This attribute is %TRUE if the backup flag is set.
	 * 
	 * This attribute is only available for DOS file systems.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
	 * @returns A key in the "dos" namespace for checking if the file's backup flag
	 * is set.
	 * 
	 * This attribute is %TRUE if the backup flag is set.
	 * 
	 * This attribute is only available for DOS file systems.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
	 */
	const FILE_ATTRIBUTE_DOS_IS_SYSTEM: string;

	/**
	 * A key in the "dos" namespace for getting the file NTFS reparse tag.
	 * 
	 * This value is 0 for files that are not reparse points.
	 * 
	 * See the [Reparse Tags](https://msdn.microsoft.com/en-us/library/dd541667.aspx)
	 * page for possible reparse tag values.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT32.
	 * @returns A key in the "dos" namespace for getting the file NTFS reparse tag.
	 * 
	 * This value is 0 for files that are not reparse points.
	 * 
	 * See the [Reparse Tags](https://msdn.microsoft.com/en-us/library/dd541667.aspx)
	 * page for possible reparse tag values.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT32.
	 */
	const FILE_ATTRIBUTE_DOS_REPARSE_POINT_TAG: string;

	/**
	 * A key in the "etag" namespace for getting the value of the file's
	 * entity tag.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.
	 * @returns A key in the "etag" namespace for getting the value of the file's
	 * entity tag.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.
	 */
	const FILE_ATTRIBUTE_ETAG_VALUE: string;

	/**
	 * A key in the "filesystem" namespace for getting the number of bytes
	 * of free space left on the file system.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT64.
	 * @returns A key in the "filesystem" namespace for getting the number of bytes
	 * of free space left on the file system.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT64.
	 */
	const FILE_ATTRIBUTE_FILESYSTEM_FREE: string;

	/**
	 * A key in the "filesystem" namespace for checking if the file system
	 * is read only.
	 * 
	 * Is set to %TRUE if the file system is read only.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
	 * @returns A key in the "filesystem" namespace for checking if the file system
	 * is read only.
	 * 
	 * Is set to %TRUE if the file system is read only.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
	 */
	const FILE_ATTRIBUTE_FILESYSTEM_READONLY: string;

	/**
	 * A key in the "filesystem" namespace for checking if the file system
	 * is remote.
	 * 
	 * Is set to %TRUE if the file system is remote.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
	 * @returns A key in the "filesystem" namespace for checking if the file system
	 * is remote.
	 * 
	 * Is set to %TRUE if the file system is remote.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
	 */
	const FILE_ATTRIBUTE_FILESYSTEM_REMOTE: string;

	/**
	 * A key in the "filesystem" namespace for getting the total size (in
	 * bytes) of the file system, used in {@link G.file_query_filesystem_info}.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT64.
	 * @returns A key in the "filesystem" namespace for getting the total size (in
	 * bytes) of the file system, used in {@link G.file_query_filesystem_info}.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT64.
	 */
	const FILE_ATTRIBUTE_FILESYSTEM_SIZE: string;

	/**
	 * A key in the "filesystem" namespace for getting the file system's type.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.
	 * @returns A key in the "filesystem" namespace for getting the file system's type.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.
	 */
	const FILE_ATTRIBUTE_FILESYSTEM_TYPE: string;

	/**
	 * A key in the "filesystem" namespace for getting the number of bytes
	 * used by data on the file system.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT64.
	 * @returns A key in the "filesystem" namespace for getting the number of bytes
	 * used by data on the file system.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT64.
	 */
	const FILE_ATTRIBUTE_FILESYSTEM_USED: string;

	/**
	 * A key in the "filesystem" namespace for hinting a file manager
	 * application whether it should preview (e.g. thumbnail) files on the
	 * file system.
	 * 
	 * The value for this key contain a #GFilesystemPreviewType.
	 * @returns A key in the "filesystem" namespace for hinting a file manager
	 * application whether it should preview (e.g. thumbnail) files on the
	 * file system.
	 * 
	 * The value for this key contain a #GFilesystemPreviewType.
	 */
	const FILE_ATTRIBUTE_FILESYSTEM_USE_PREVIEW: string;

	/**
	 * A key in the "gvfs" namespace that gets the name of the current
	 * GVFS backend in use.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.
	 * @returns A key in the "gvfs" namespace that gets the name of the current
	 * GVFS backend in use.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.
	 */
	const FILE_ATTRIBUTE_GVFS_BACKEND: string;

	/**
	 * A key in the "id" namespace for getting a file identifier.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.
	 * 
	 * An example use would be during listing files, to avoid recursive
	 * directory scanning.
	 * @returns A key in the "id" namespace for getting a file identifier.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.
	 * 
	 * An example use would be during listing files, to avoid recursive
	 * directory scanning.
	 */
	const FILE_ATTRIBUTE_ID_FILE: string;

	/**
	 * A key in the "id" namespace for getting the file system identifier.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.
	 * 
	 * An example use would be during drag and drop to see if the source
	 * and target are on the same filesystem (default to move) or not (default
	 * to copy).
	 * @returns A key in the "id" namespace for getting the file system identifier.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.
	 * 
	 * An example use would be during drag and drop to see if the source
	 * and target are on the same filesystem (default to move) or not (default
	 * to copy).
	 */
	const FILE_ATTRIBUTE_ID_FILESYSTEM: string;

	/**
	 * A key in the "mountable" namespace for checking if a file (of
	 * type G_FILE_TYPE_MOUNTABLE) can be ejected.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
	 * @returns A key in the "mountable" namespace for checking if a file (of
	 * type G_FILE_TYPE_MOUNTABLE) can be ejected.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
	 */
	const FILE_ATTRIBUTE_MOUNTABLE_CAN_EJECT: string;

	/**
	 * A key in the "mountable" namespace for checking if a file (of
	 * type G_FILE_TYPE_MOUNTABLE) is mountable.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
	 * @returns A key in the "mountable" namespace for checking if a file (of
	 * type G_FILE_TYPE_MOUNTABLE) is mountable.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
	 */
	const FILE_ATTRIBUTE_MOUNTABLE_CAN_MOUNT: string;

	/**
	 * A key in the "mountable" namespace for checking if a file (of
	 * type G_FILE_TYPE_MOUNTABLE) can be polled.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
	 * @returns A key in the "mountable" namespace for checking if a file (of
	 * type G_FILE_TYPE_MOUNTABLE) can be polled.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
	 */
	const FILE_ATTRIBUTE_MOUNTABLE_CAN_POLL: string;

	/**
	 * A key in the "mountable" namespace for checking if a file (of
	 * type G_FILE_TYPE_MOUNTABLE) can be started.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
	 * @returns A key in the "mountable" namespace for checking if a file (of
	 * type G_FILE_TYPE_MOUNTABLE) can be started.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
	 */
	const FILE_ATTRIBUTE_MOUNTABLE_CAN_START: string;

	/**
	 * A key in the "mountable" namespace for checking if a file (of
	 * type G_FILE_TYPE_MOUNTABLE) can be started degraded.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
	 * @returns A key in the "mountable" namespace for checking if a file (of
	 * type G_FILE_TYPE_MOUNTABLE) can be started degraded.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
	 */
	const FILE_ATTRIBUTE_MOUNTABLE_CAN_START_DEGRADED: string;

	/**
	 * A key in the "mountable" namespace for checking if a file (of
	 * type G_FILE_TYPE_MOUNTABLE) can be stopped.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
	 * @returns A key in the "mountable" namespace for checking if a file (of
	 * type G_FILE_TYPE_MOUNTABLE) can be stopped.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
	 */
	const FILE_ATTRIBUTE_MOUNTABLE_CAN_STOP: string;

	/**
	 * A key in the "mountable" namespace for checking if a file (of
	 * type G_FILE_TYPE_MOUNTABLE)  is unmountable.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
	 * @returns A key in the "mountable" namespace for checking if a file (of
	 * type G_FILE_TYPE_MOUNTABLE)  is unmountable.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
	 */
	const FILE_ATTRIBUTE_MOUNTABLE_CAN_UNMOUNT: string;

	/**
	 * A key in the "mountable" namespace for getting the HAL UDI for the mountable
	 * file.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.
	 * @returns A key in the "mountable" namespace for getting the HAL UDI for the mountable
	 * file.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.
	 */
	const FILE_ATTRIBUTE_MOUNTABLE_HAL_UDI: string;

	/**
	 * A key in the "mountable" namespace for checking if a file (of
	 * type G_FILE_TYPE_MOUNTABLE) is automatically polled for media.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
	 * @returns A key in the "mountable" namespace for checking if a file (of
	 * type G_FILE_TYPE_MOUNTABLE) is automatically polled for media.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
	 */
	const FILE_ATTRIBUTE_MOUNTABLE_IS_MEDIA_CHECK_AUTOMATIC: string;

	/**
	 * A key in the "mountable" namespace for getting the #GDriveStartStopType.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT32.
	 * @returns A key in the "mountable" namespace for getting the #GDriveStartStopType.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT32.
	 */
	const FILE_ATTRIBUTE_MOUNTABLE_START_STOP_TYPE: string;

	/**
	 * A key in the "mountable" namespace for getting the unix device.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT32.
	 * @returns A key in the "mountable" namespace for getting the unix device.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT32.
	 */
	const FILE_ATTRIBUTE_MOUNTABLE_UNIX_DEVICE: string;

	/**
	 * A key in the "mountable" namespace for getting the unix device file.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.
	 * @returns A key in the "mountable" namespace for getting the unix device file.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.
	 */
	const FILE_ATTRIBUTE_MOUNTABLE_UNIX_DEVICE_FILE: string;

	/**
	 * A key in the "owner" namespace for getting the file owner's group.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.
	 * @returns A key in the "owner" namespace for getting the file owner's group.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.
	 */
	const FILE_ATTRIBUTE_OWNER_GROUP: string;

	/**
	 * A key in the "owner" namespace for getting the user name of the
	 * file's owner.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.
	 * @returns A key in the "owner" namespace for getting the user name of the
	 * file's owner.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.
	 */
	const FILE_ATTRIBUTE_OWNER_USER: string;

	/**
	 * A key in the "owner" namespace for getting the real name of the
	 * user that owns the file.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.
	 * @returns A key in the "owner" namespace for getting the real name of the
	 * user that owns the file.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.
	 */
	const FILE_ATTRIBUTE_OWNER_USER_REAL: string;

	/**
	 * A key in the "preview" namespace for getting a #GIcon that can be
	 * used to get preview of the file.
	 * 
	 * For example, it may be a low resolution thumbnail without metadata.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_OBJECT.
	 * 
	 * The value for this key should contain a #GIcon.
	 * @returns A key in the "preview" namespace for getting a #GIcon that can be
	 * used to get preview of the file.
	 * 
	 * For example, it may be a low resolution thumbnail without metadata.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_OBJECT.
	 * 
	 * The value for this key should contain a #GIcon.
	 */
	const FILE_ATTRIBUTE_PREVIEW_ICON: string;

	/**
	 * A key in the "recent" namespace for getting time, when the metadata for the
	 * file in `recent:///` was last changed.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_INT64.
	 * @returns A key in the "recent" namespace for getting time, when the metadata for the
	 * file in `recent:///` was last changed.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_INT64.
	 */
	const FILE_ATTRIBUTE_RECENT_MODIFIED: string;

	/**
	 * A key in the "selinux" namespace for getting the file's SELinux
	 * context.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.
	 * 
	 * Note that this attribute is only available if GLib has been built
	 * with SELinux support.
	 * @returns A key in the "selinux" namespace for getting the file's SELinux
	 * context.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.
	 * 
	 * Note that this attribute is only available if GLib has been built
	 * with SELinux support.
	 */
	const FILE_ATTRIBUTE_SELINUX_CONTEXT: string;

	/**
	 * A key in the "standard" namespace for getting the amount of disk space
	 * that is consumed by the file (in bytes).
	 * 
	 * This will generally be larger than the file size (due to block size
	 * overhead) but can occasionally be smaller (for example, for sparse files).
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT64.
	 * @returns A key in the "standard" namespace for getting the amount of disk space
	 * that is consumed by the file (in bytes).
	 * 
	 * This will generally be larger than the file size (due to block size
	 * overhead) but can occasionally be smaller (for example, for sparse files).
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT64.
	 */
	const FILE_ATTRIBUTE_STANDARD_ALLOCATED_SIZE: string;

	/**
	 * A key in the "standard" namespace for getting the content type of the file.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.
	 * 
	 * The value for this key should contain a valid content type.
	 * @returns A key in the "standard" namespace for getting the content type of the file.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.
	 * 
	 * The value for this key should contain a valid content type.
	 */
	const FILE_ATTRIBUTE_STANDARD_CONTENT_TYPE: string;

	/**
	 * A key in the "standard" namespace for getting the copy name of the file.
	 * 
	 * The copy name is an optional version of the name. If available it's always
	 * in UTF8, and corresponds directly to the original filename (only transcoded to
	 * UTF8). This is useful if you want to copy the file to another filesystem that
	 * might have a different encoding. If the filename is not a valid string in the
	 * encoding selected for the filesystem it is in then the copy name will not be set.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.
	 * @returns A key in the "standard" namespace for getting the copy name of the file.
	 * 
	 * The copy name is an optional version of the name. If available it's always
	 * in UTF8, and corresponds directly to the original filename (only transcoded to
	 * UTF8). This is useful if you want to copy the file to another filesystem that
	 * might have a different encoding. If the filename is not a valid string in the
	 * encoding selected for the filesystem it is in then the copy name will not be set.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.
	 */
	const FILE_ATTRIBUTE_STANDARD_COPY_NAME: string;

	/**
	 * A key in the "standard" namespace for getting the description of the file.
	 * 
	 * The description is a utf8 string that describes the file, generally containing
	 * the filename, but can also contain further information. Example descriptions
	 * could be "filename (on hostname)" for a remote file or "filename (in trash)"
	 * for a file in the trash. This is useful for instance as the window title
	 * when displaying a directory or for a bookmarks menu.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.
	 * @returns A key in the "standard" namespace for getting the description of the file.
	 * 
	 * The description is a utf8 string that describes the file, generally containing
	 * the filename, but can also contain further information. Example descriptions
	 * could be "filename (on hostname)" for a remote file or "filename (in trash)"
	 * for a file in the trash. This is useful for instance as the window title
	 * when displaying a directory or for a bookmarks menu.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.
	 */
	const FILE_ATTRIBUTE_STANDARD_DESCRIPTION: string;

	/**
	 * A key in the "standard" namespace for getting the display name of the file.
	 * 
	 * A display name is guaranteed to be in UTF-8 and can thus be displayed in
	 * the UI. It is guaranteed to be set on every file.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.
	 * @returns A key in the "standard" namespace for getting the display name of the file.
	 * 
	 * A display name is guaranteed to be in UTF-8 and can thus be displayed in
	 * the UI. It is guaranteed to be set on every file.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.
	 */
	const FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME: string;

	/**
	 * A key in the "standard" namespace for edit name of the file.
	 * 
	 * An edit name is similar to the display name, but it is meant to be
	 * used when you want to rename the file in the UI. The display name
	 * might contain information you don't want in the new filename (such as
	 * "(invalid unicode)" if the filename was in an invalid encoding).
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.
	 * @returns A key in the "standard" namespace for edit name of the file.
	 * 
	 * An edit name is similar to the display name, but it is meant to be
	 * used when you want to rename the file in the UI. The display name
	 * might contain information you don't want in the new filename (such as
	 * "(invalid unicode)" if the filename was in an invalid encoding).
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.
	 */
	const FILE_ATTRIBUTE_STANDARD_EDIT_NAME: string;

	/**
	 * A key in the "standard" namespace for getting the fast content type.
	 * 
	 * The fast content type isn't as reliable as the regular one, as it
	 * only uses the filename to guess it, but it is faster to calculate than the
	 * regular content type.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.
	 * @returns A key in the "standard" namespace for getting the fast content type.
	 * 
	 * The fast content type isn't as reliable as the regular one, as it
	 * only uses the filename to guess it, but it is faster to calculate than the
	 * regular content type.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.
	 */
	const FILE_ATTRIBUTE_STANDARD_FAST_CONTENT_TYPE: string;

	/**
	 * A key in the "standard" namespace for getting the icon for the file.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_OBJECT.
	 * 
	 * The value for this key should contain a #GIcon.
	 * @returns A key in the "standard" namespace for getting the icon for the file.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_OBJECT.
	 * 
	 * The value for this key should contain a #GIcon.
	 */
	const FILE_ATTRIBUTE_STANDARD_ICON: string;

	/**
	 * A key in the "standard" namespace for checking if a file is a backup file.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
	 * @returns A key in the "standard" namespace for checking if a file is a backup file.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
	 */
	const FILE_ATTRIBUTE_STANDARD_IS_BACKUP: string;

	/**
	 * A key in the "standard" namespace for checking if a file is hidden.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
	 * @returns A key in the "standard" namespace for checking if a file is hidden.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
	 */
	const FILE_ATTRIBUTE_STANDARD_IS_HIDDEN: string;

	/**
	 * A key in the "standard" namespace for checking if the file is a symlink.
	 * Typically the actual type is something else, if we followed the symlink
	 * to get the type.
	 * 
	 * On Windows NTFS mountpoints are considered to be symlinks as well.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
	 * @returns A key in the "standard" namespace for checking if the file is a symlink.
	 * Typically the actual type is something else, if we followed the symlink
	 * to get the type.
	 * 
	 * On Windows NTFS mountpoints are considered to be symlinks as well.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
	 */
	const FILE_ATTRIBUTE_STANDARD_IS_SYMLINK: string;

	/**
	 * A key in the "standard" namespace for checking if a file is virtual.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
	 * @returns A key in the "standard" namespace for checking if a file is virtual.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
	 */
	const FILE_ATTRIBUTE_STANDARD_IS_VIRTUAL: string;

	/**
	 * A key in the "standard" namespace for checking if a file is
	 * volatile. This is meant for opaque, non-POSIX-like backends to
	 * indicate that the URI is not persistent. Applications should look
	 * at %G_FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET for the persistent URI.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
	 * @returns A key in the "standard" namespace for checking if a file is
	 * volatile. This is meant for opaque, non-POSIX-like backends to
	 * indicate that the URI is not persistent. Applications should look
	 * at %G_FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET for the persistent URI.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
	 */
	const FILE_ATTRIBUTE_STANDARD_IS_VOLATILE: string;

	/**
	 * A key in the "standard" namespace for getting the name of the file.
	 * 
	 * The name is the on-disk filename which may not be in any known encoding,
	 * and can thus not be generally displayed as is. It is guaranteed to be set on
	 * every file.
	 * 
	 * Use %G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME if you need to display the
	 * name in a user interface.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BYTE_STRING.
	 * @returns A key in the "standard" namespace for getting the name of the file.
	 * 
	 * The name is the on-disk filename which may not be in any known encoding,
	 * and can thus not be generally displayed as is. It is guaranteed to be set on
	 * every file.
	 * 
	 * Use %G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME if you need to display the
	 * name in a user interface.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BYTE_STRING.
	 */
	const FILE_ATTRIBUTE_STANDARD_NAME: string;

	/**
	 * A key in the "standard" namespace for getting the file's size (in bytes).
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT64.
	 * @returns A key in the "standard" namespace for getting the file's size (in bytes).
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT64.
	 */
	const FILE_ATTRIBUTE_STANDARD_SIZE: string;

	/**
	 * A key in the "standard" namespace for setting the sort order of a file.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_INT32.
	 * 
	 * An example use would be in file managers, which would use this key
	 * to set the order files are displayed. Files with smaller sort order
	 * should be sorted first, and files without sort order as if sort order
	 * was zero.
	 * @returns A key in the "standard" namespace for setting the sort order of a file.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_INT32.
	 * 
	 * An example use would be in file managers, which would use this key
	 * to set the order files are displayed. Files with smaller sort order
	 * should be sorted first, and files without sort order as if sort order
	 * was zero.
	 */
	const FILE_ATTRIBUTE_STANDARD_SORT_ORDER: string;

	/**
	 * A key in the "standard" namespace for getting the symbolic icon for the file.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_OBJECT.
	 * 
	 * The value for this key should contain a #GIcon.
	 * @returns A key in the "standard" namespace for getting the symbolic icon for the file.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_OBJECT.
	 * 
	 * The value for this key should contain a #GIcon.
	 */
	const FILE_ATTRIBUTE_STANDARD_SYMBOLIC_ICON: string;

	/**
	 * A key in the "standard" namespace for getting the symlink target, if the file
	 * is a symlink.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BYTE_STRING.
	 * @returns A key in the "standard" namespace for getting the symlink target, if the file
	 * is a symlink.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BYTE_STRING.
	 */
	const FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET: string;

	/**
	 * A key in the "standard" namespace for getting the target URI for the file, in
	 * the case of %G_FILE_TYPE_SHORTCUT or %G_FILE_TYPE_MOUNTABLE files.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.
	 * @returns A key in the "standard" namespace for getting the target URI for the file, in
	 * the case of %G_FILE_TYPE_SHORTCUT or %G_FILE_TYPE_MOUNTABLE files.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.
	 */
	const FILE_ATTRIBUTE_STANDARD_TARGET_URI: string;

	/**
	 * A key in the "standard" namespace for storing file types.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT32.
	 * 
	 * The value for this key should contain a #GFileType.
	 * @returns A key in the "standard" namespace for storing file types.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT32.
	 * 
	 * The value for this key should contain a #GFileType.
	 */
	const FILE_ATTRIBUTE_STANDARD_TYPE: string;

	/**
	 * A key in the "thumbnail" namespace for checking if thumbnailing failed.
	 * 
	 * This attribute is %TRUE if thumbnailing failed.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
	 * @returns A key in the "thumbnail" namespace for checking if thumbnailing failed.
	 * 
	 * This attribute is %TRUE if thumbnailing failed.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
	 */
	const FILE_ATTRIBUTE_THUMBNAILING_FAILED: string;

	/**
	 * A key in the "thumbnail" namespace for checking whether the thumbnail is outdated.
	 * 
	 * This attribute is %TRUE if the thumbnail is up-to-date with the file it represents,
	 * and %FALSE if the file has been modified since the thumbnail was generated.
	 * 
	 * If %G_FILE_ATTRIBUTE_THUMBNAILING_FAILED is %TRUE and this attribute is %FALSE,
	 * it indicates that thumbnailing may be attempted again and may succeed.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
	 * @returns A key in the "thumbnail" namespace for checking whether the thumbnail is outdated.
	 * 
	 * This attribute is %TRUE if the thumbnail is up-to-date with the file it represents,
	 * and %FALSE if the file has been modified since the thumbnail was generated.
	 * 
	 * If %G_FILE_ATTRIBUTE_THUMBNAILING_FAILED is %TRUE and this attribute is %FALSE,
	 * it indicates that thumbnailing may be attempted again and may succeed.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
	 */
	const FILE_ATTRIBUTE_THUMBNAIL_IS_VALID: string;

	/**
	 * A key in the "thumbnail" namespace for getting the path to the thumbnail
	 * image.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BYTE_STRING.
	 * @returns A key in the "thumbnail" namespace for getting the path to the thumbnail
	 * image.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BYTE_STRING.
	 */
	const FILE_ATTRIBUTE_THUMBNAIL_PATH: string;

	/**
	 * A key in the "time" namespace for getting the time the file was last
	 * accessed.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT64, and
	 * contains the time since the file was last accessed, in seconds since the
	 * UNIX epoch.
	 * @returns A key in the "time" namespace for getting the time the file was last
	 * accessed.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT64, and
	 * contains the time since the file was last accessed, in seconds since the
	 * UNIX epoch.
	 */
	const FILE_ATTRIBUTE_TIME_ACCESS: string;

	/**
	 * A key in the "time" namespace for getting the microseconds of the time
	 * the file was last accessed.
	 * 
	 * This should be used in conjunction with %G_FILE_ATTRIBUTE_TIME_ACCESS.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT32.
	 * @returns A key in the "time" namespace for getting the microseconds of the time
	 * the file was last accessed.
	 * 
	 * This should be used in conjunction with %G_FILE_ATTRIBUTE_TIME_ACCESS.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT32.
	 */
	const FILE_ATTRIBUTE_TIME_ACCESS_USEC: string;

	/**
	 * A key in the "time" namespace for getting the time the file was last
	 * changed.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT64,
	 * and contains the time since the file was last changed, in seconds since
	 * the UNIX epoch.
	 * 
	 * This corresponds to the traditional UNIX ctime.
	 * @returns A key in the "time" namespace for getting the time the file was last
	 * changed.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT64,
	 * and contains the time since the file was last changed, in seconds since
	 * the UNIX epoch.
	 * 
	 * This corresponds to the traditional UNIX ctime.
	 */
	const FILE_ATTRIBUTE_TIME_CHANGED: string;

	/**
	 * A key in the "time" namespace for getting the microseconds of the time
	 * the file was last changed.
	 * 
	 * This should be used in conjunction with %G_FILE_ATTRIBUTE_TIME_CHANGED.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT32.
	 * @returns A key in the "time" namespace for getting the microseconds of the time
	 * the file was last changed.
	 * 
	 * This should be used in conjunction with %G_FILE_ATTRIBUTE_TIME_CHANGED.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT32.
	 */
	const FILE_ATTRIBUTE_TIME_CHANGED_USEC: string;

	/**
	 * A key in the "time" namespace for getting the time the file was created.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT64,
	 * and contains the time since the file was created, in seconds since the UNIX
	 * epoch.
	 * 
	 * This may correspond to Linux `stx_btime`, FreeBSD `st_birthtim`, NetBSD
	 * `st_birthtime` or NTFS `ctime`.
	 * @returns A key in the "time" namespace for getting the time the file was created.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT64,
	 * and contains the time since the file was created, in seconds since the UNIX
	 * epoch.
	 * 
	 * This may correspond to Linux `stx_btime`, FreeBSD `st_birthtim`, NetBSD
	 * `st_birthtime` or NTFS `ctime`.
	 */
	const FILE_ATTRIBUTE_TIME_CREATED: string;

	/**
	 * A key in the "time" namespace for getting the microseconds of the time
	 * the file was created.
	 * 
	 * This should be used in conjunction with %G_FILE_ATTRIBUTE_TIME_CREATED.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT32.
	 * @returns A key in the "time" namespace for getting the microseconds of the time
	 * the file was created.
	 * 
	 * This should be used in conjunction with %G_FILE_ATTRIBUTE_TIME_CREATED.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT32.
	 */
	const FILE_ATTRIBUTE_TIME_CREATED_USEC: string;

	/**
	 * A key in the "time" namespace for getting the time the file was last
	 * modified.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT64, and
	 * contains the time since the file was modified, in seconds since the UNIX
	 * epoch.
	 * @returns A key in the "time" namespace for getting the time the file was last
	 * modified.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT64, and
	 * contains the time since the file was modified, in seconds since the UNIX
	 * epoch.
	 */
	const FILE_ATTRIBUTE_TIME_MODIFIED: string;

	/**
	 * A key in the "time" namespace for getting the microseconds of the time
	 * the file was last modified.
	 * 
	 * This should be used in conjunction with %G_FILE_ATTRIBUTE_TIME_MODIFIED.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT32.
	 * @returns A key in the "time" namespace for getting the microseconds of the time
	 * the file was last modified.
	 * 
	 * This should be used in conjunction with %G_FILE_ATTRIBUTE_TIME_MODIFIED.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT32.
	 */
	const FILE_ATTRIBUTE_TIME_MODIFIED_USEC: string;

	/**
	 * A key in the "trash" namespace for getting the deletion date and time
	 * of a file inside the `trash:///` folder.
	 * 
	 * The format of the returned string is `YYYY-MM-DDThh:mm:ss`.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.
	 * @returns A key in the "trash" namespace for getting the deletion date and time
	 * of a file inside the `trash:///` folder.
	 * 
	 * The format of the returned string is `YYYY-MM-DDThh:mm:ss`.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.
	 */
	const FILE_ATTRIBUTE_TRASH_DELETION_DATE: string;

	/**
	 * A key in the "trash" namespace for getting the number of (toplevel) items
	 * that are present in the `trash:///` folder.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT32.
	 * @returns A key in the "trash" namespace for getting the number of (toplevel) items
	 * that are present in the `trash:///` folder.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT32.
	 */
	const FILE_ATTRIBUTE_TRASH_ITEM_COUNT: string;

	/**
	 * A key in the "trash" namespace for getting the original path of a file
	 * inside the `trash:///` folder before it was trashed.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BYTE_STRING.
	 * @returns A key in the "trash" namespace for getting the original path of a file
	 * inside the `trash:///` folder before it was trashed.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BYTE_STRING.
	 */
	const FILE_ATTRIBUTE_TRASH_ORIG_PATH: string;

	/**
	 * A key in the "unix" namespace for getting the number of blocks allocated
	 * for the file.
	 * 
	 * This attribute is only available for UNIX file systems.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT64.
	 * @returns A key in the "unix" namespace for getting the number of blocks allocated
	 * for the file.
	 * 
	 * This attribute is only available for UNIX file systems.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT64.
	 */
	const FILE_ATTRIBUTE_UNIX_BLOCKS: string;

	/**
	 * A key in the "unix" namespace for getting the block size for the file
	 * system.
	 * 
	 * This attribute is only available for UNIX file systems.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT32.
	 * @returns A key in the "unix" namespace for getting the block size for the file
	 * system.
	 * 
	 * This attribute is only available for UNIX file systems.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT32.
	 */
	const FILE_ATTRIBUTE_UNIX_BLOCK_SIZE: string;

	/**
	 * A key in the "unix" namespace for getting the device id of the device the
	 * file is located on (see stat() documentation).
	 * 
	 * This attribute is only available for UNIX file systems.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT32.
	 * @returns A key in the "unix" namespace for getting the device id of the device the
	 * file is located on (see stat() documentation).
	 * 
	 * This attribute is only available for UNIX file systems.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT32.
	 */
	const FILE_ATTRIBUTE_UNIX_DEVICE: string;

	/**
	 * A key in the "unix" namespace for getting the group ID for the file.
	 * 
	 * This attribute is only available for UNIX file systems.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT32.
	 * @returns A key in the "unix" namespace for getting the group ID for the file.
	 * 
	 * This attribute is only available for UNIX file systems.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT32.
	 */
	const FILE_ATTRIBUTE_UNIX_GID: string;

	/**
	 * A key in the "unix" namespace for getting the inode of the file.
	 * 
	 * This attribute is only available for UNIX file systems.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT64.
	 * @returns A key in the "unix" namespace for getting the inode of the file.
	 * 
	 * This attribute is only available for UNIX file systems.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT64.
	 */
	const FILE_ATTRIBUTE_UNIX_INODE: string;

	/**
	 * A key in the "unix" namespace for checking if the file represents a
	 * UNIX mount point.
	 * 
	 * This attribute is %TRUE if the file is a UNIX mount point.
	 * 
	 * Since 2.58, `/` is considered to be a mount point.
	 * 
	 * This attribute is only available for UNIX file systems.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
	 * @returns A key in the "unix" namespace for checking if the file represents a
	 * UNIX mount point.
	 * 
	 * This attribute is %TRUE if the file is a UNIX mount point.
	 * 
	 * Since 2.58, `/` is considered to be a mount point.
	 * 
	 * This attribute is only available for UNIX file systems.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
	 */
	const FILE_ATTRIBUTE_UNIX_IS_MOUNTPOINT: string;

	/**
	 * A key in the "unix" namespace for getting the mode of the file
	 * (e.g. whether the file is a regular file, symlink, etc).
	 * 
	 * See the documentation for `lstat()`: this attribute is equivalent to
	 * the `st_mode` member of `struct stat`, and includes both the file type
	 * and permissions.
	 * 
	 * This attribute is only available for UNIX file systems.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT32.
	 * @returns A key in the "unix" namespace for getting the mode of the file
	 * (e.g. whether the file is a regular file, symlink, etc).
	 * 
	 * See the documentation for `lstat()`: this attribute is equivalent to
	 * the `st_mode` member of `struct stat`, and includes both the file type
	 * and permissions.
	 * 
	 * This attribute is only available for UNIX file systems.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT32.
	 */
	const FILE_ATTRIBUTE_UNIX_MODE: string;

	/**
	 * A key in the "unix" namespace for getting the number of hard links
	 * for a file.
	 * 
	 * See the documentation for `lstat()`.
	 * 
	 * This attribute is only available for UNIX file systems.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT32.
	 * @returns A key in the "unix" namespace for getting the number of hard links
	 * for a file.
	 * 
	 * See the documentation for `lstat()`.
	 * 
	 * This attribute is only available for UNIX file systems.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT32.
	 */
	const FILE_ATTRIBUTE_UNIX_NLINK: string;

	/**
	 * A key in the "unix" namespace for getting the device ID for the file
	 * (if it is a special file).
	 * 
	 * See the documentation for `lstat()`.
	 * 
	 * This attribute is only available for UNIX file systems.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT32.
	 * @returns A key in the "unix" namespace for getting the device ID for the file
	 * (if it is a special file).
	 * 
	 * See the documentation for `lstat()`.
	 * 
	 * This attribute is only available for UNIX file systems.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT32.
	 */
	const FILE_ATTRIBUTE_UNIX_RDEV: string;

	/**
	 * A key in the "unix" namespace for getting the user ID for the file.
	 * 
	 * This attribute is only available for UNIX file systems.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT32.
	 * @returns A key in the "unix" namespace for getting the user ID for the file.
	 * 
	 * This attribute is only available for UNIX file systems.
	 * 
	 * Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT32.
	 */
	const FILE_ATTRIBUTE_UNIX_UID: string;

	/**
	 * Extension point for memory usage monitoring functionality.
	 * See [Extending GIO][extending-gio].
	 * @returns Extension point for memory usage monitoring functionality.
	 * See [Extending GIO][extending-gio].
	 */
	const MEMORY_MONITOR_EXTENSION_POINT_NAME: string;

	/**
	 * The menu item attribute which holds the action name of the item.  Action
	 * names are namespaced with an identifier for the action group in which the
	 * action resides. For example, "win." for window-specific actions and "app."
	 * for application-wide actions.
	 * 
	 * See also {@link G.menu_model_get_item_attribute} and g_menu_item_set_attribute().
	 * @returns The menu item attribute which holds the action name of the item.  Action
	 * names are namespaced with an identifier for the action group in which the
	 * action resides. For example, "win." for window-specific actions and "app."
	 * for application-wide actions.
	 * 
	 * See also {@link G.menu_model_get_item_attribute} and g_menu_item_set_attribute().
	 */
	const MENU_ATTRIBUTE_ACTION: string;

	/**
	 * The menu item attribute that holds the namespace for all action names in
	 * menus that are linked from this item.
	 * @returns The menu item attribute that holds the namespace for all action names in
	 * menus that are linked from this item.
	 */
	const MENU_ATTRIBUTE_ACTION_NAMESPACE: string;

	/**
	 * The menu item attribute which holds the icon of the item.
	 * 
	 * The icon is stored in the format returned by {@link G.icon_serialize}.
	 * 
	 * This attribute is intended only to represent 'noun' icons such as
	 * favicons for a webpage, or application icons.  It should not be used
	 * for 'verbs' (ie: stock icons).
	 * @returns The menu item attribute which holds the icon of the item.
	 * 
	 * The icon is stored in the format returned by {@link G.icon_serialize}.
	 * 
	 * This attribute is intended only to represent 'noun' icons such as
	 * favicons for a webpage, or application icons.  It should not be used
	 * for 'verbs' (ie: stock icons).
	 */
	const MENU_ATTRIBUTE_ICON: string;

	/**
	 * The menu item attribute which holds the label of the item.
	 * @returns The menu item attribute which holds the label of the item.
	 */
	const MENU_ATTRIBUTE_LABEL: string;

	/**
	 * The menu item attribute which holds the target with which the item's action
	 * will be activated.
	 * 
	 * See also {@link G.menu_item_set_action_and_target}
	 * @returns The menu item attribute which holds the target with which the item's action
	 * will be activated.
	 * 
	 * See also {@link G.menu_item_set_action_and_target}
	 */
	const MENU_ATTRIBUTE_TARGET: string;

	/**
	 * The name of the link that associates a menu item with a section.  The linked
	 * menu will usually be shown in place of the menu item, using the item's label
	 * as a header.
	 * 
	 * See also {@link G.menu_item_set_link}.
	 * @returns The name of the link that associates a menu item with a section.  The linked
	 * menu will usually be shown in place of the menu item, using the item's label
	 * as a header.
	 * 
	 * See also {@link G.menu_item_set_link}.
	 */
	const MENU_LINK_SECTION: string;

	/**
	 * The name of the link that associates a menu item with a submenu.
	 * 
	 * See also {@link G.menu_item_set_link}.
	 * @returns The name of the link that associates a menu item with a submenu.
	 * 
	 * See also {@link G.menu_item_set_link}.
	 */
	const MENU_LINK_SUBMENU: string;

	const NATIVE_VOLUME_MONITOR_EXTENSION_POINT_NAME: string;

	/**
	 * Extension point for network status monitoring functionality.
	 * See [Extending GIO][extending-gio].
	 * @returns Extension point for network status monitoring functionality.
	 * See [Extending GIO][extending-gio].
	 */
	const NETWORK_MONITOR_EXTENSION_POINT_NAME: string;

	/**
	 * Extension point for power profile usage monitoring functionality.
	 * See [Extending GIO][extending-gio].
	 * @returns Extension point for power profile usage monitoring functionality.
	 * See [Extending GIO][extending-gio].
	 */
	const POWER_PROFILE_MONITOR_EXTENSION_POINT_NAME: string;

	/**
	 * Extension point for proxy functionality.
	 * See [Extending GIO][extending-gio].
	 * @returns Extension point for proxy functionality.
	 * See [Extending GIO][extending-gio].
	 */
	const PROXY_EXTENSION_POINT_NAME: string;

	/**
	 * Extension point for proxy resolving functionality.
	 * See [Extending GIO][extending-gio].
	 * @returns Extension point for proxy resolving functionality.
	 * See [Extending GIO][extending-gio].
	 */
	const PROXY_RESOLVER_EXTENSION_POINT_NAME: string;

	/**
	 * Extension point for #GSettingsBackend functionality.
	 * @returns Extension point for #GSettingsBackend functionality.
	 */
	const SETTINGS_BACKEND_EXTENSION_POINT_NAME: string;

	/**
	 * Extension point for TLS functionality via #GTlsBackend.
	 * See [Extending GIO][extending-gio].
	 * @returns Extension point for TLS functionality via #GTlsBackend.
	 * See [Extending GIO][extending-gio].
	 */
	const TLS_BACKEND_EXTENSION_POINT_NAME: string;

	/**
	 * The purpose used to verify the client certificate in a TLS connection.
	 * Used by TLS servers.
	 * @returns The purpose used to verify the client certificate in a TLS connection.
	 * Used by TLS servers.
	 */
	const TLS_DATABASE_PURPOSE_AUTHENTICATE_CLIENT: string;

	/**
	 * The purpose used to verify the server certificate in a TLS connection. This
	 * is the most common purpose in use. Used by TLS clients.
	 * @returns The purpose used to verify the server certificate in a TLS connection. This
	 * is the most common purpose in use. Used by TLS clients.
	 */
	const TLS_DATABASE_PURPOSE_AUTHENTICATE_SERVER: string;

	/**
	 * Extension point for #GVfs functionality.
	 * See [Extending GIO][extending-gio].
	 * @returns Extension point for #GVfs functionality.
	 * See [Extending GIO][extending-gio].
	 */
	const VFS_EXTENSION_POINT_NAME: string;

	/**
	 * The string used to obtain the volume class with {@link G.volume_get_identifier}.
	 * 
	 * Known volume classes include `device`, `network`, and `loop`. Other
	 * classes may be added in the future.
	 * 
	 * This is intended to be used by applications to classify #GVolume
	 * instances into different sections - for example a file manager or
	 * file chooser can use this information to show `network` volumes under
	 * a "Network" heading and `device` volumes under a "Devices" heading.
	 * @returns The string used to obtain the volume class with {@link G.volume_get_identifier}.
	 * 
	 * Known volume classes include `device`, `network`, and `loop`. Other
	 * classes may be added in the future.
	 * 
	 * This is intended to be used by applications to classify #GVolume
	 * instances into different sections - for example a file manager or
	 * file chooser can use this information to show `network` volumes under
	 * a "Network" heading and `device` volumes under a "Devices" heading.
	 */
	const VOLUME_IDENTIFIER_KIND_CLASS: string;

	/**
	 * The string used to obtain a Hal UDI with {@link G.volume_get_identifier}.
	 * @returns The string used to obtain a Hal UDI with {@link G.volume_get_identifier}.
	 */
	const VOLUME_IDENTIFIER_KIND_HAL_UDI: string;

	/**
	 * The string used to obtain a filesystem label with {@link G.volume_get_identifier}.
	 * @returns The string used to obtain a filesystem label with {@link G.volume_get_identifier}.
	 */
	const VOLUME_IDENTIFIER_KIND_LABEL: string;

	/**
	 * The string used to obtain a NFS mount with {@link G.volume_get_identifier}.
	 * @returns The string used to obtain a NFS mount with {@link G.volume_get_identifier}.
	 */
	const VOLUME_IDENTIFIER_KIND_NFS_MOUNT: string;

	/**
	 * The string used to obtain a Unix device path with {@link G.volume_get_identifier}.
	 * @returns The string used to obtain a Unix device path with {@link G.volume_get_identifier}.
	 */
	const VOLUME_IDENTIFIER_KIND_UNIX_DEVICE: string;

	/**
	 * The string used to obtain a UUID with {@link G.volume_get_identifier}.
	 * @returns The string used to obtain a UUID with {@link G.volume_get_identifier}.
	 */
	const VOLUME_IDENTIFIER_KIND_UUID: string;

	/**
	 * Extension point for volume monitor functionality.
	 * See [Extending GIO][extending-gio].
	 * @returns Extension point for volume monitor functionality.
	 * See [Extending GIO][extending-gio].
	 */
	const VOLUME_MONITOR_EXTENSION_POINT_NAME: string;

}